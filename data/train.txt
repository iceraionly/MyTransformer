{"code": "protected void tearDown(){\n}\n", "nl": "Tears down the fixture, for example, close a network connection. This method is called after a test is executed."}
{"code": "@KnownFailure(\"Fixed on DonutBurger, Wrong Exception thrown\") public void test_unwrap_ByteBuffer$ByteBuffer_02(){\n  String host=\"new host\";\n  int port=8080;\n  ByteBuffer bbs=ByteBuffer.allocate(10);\n  ByteBuffer bbR=ByteBuffer.allocate(100).asReadOnlyBuffer();\n  ByteBuffer[] bbA={bbR,ByteBuffer.allocate(10),ByteBuffer.allocate(100)};\n  SSLEngine sse=getEngine(host,port);\n  sse.setUseClientMode(true);\n  try {\n    sse.unwrap(bbs,bbA);\n    fail(\"ReadOnlyBufferException wasn't thrown\");\n  }\n catch (  ReadOnlyBufferException iobe) {\n  }\ncatch (  Exception e) {\n    fail(e + \" was thrown instead of ReadOnlyBufferException\");\n  }\n}\n", "nl": "javax.net.ssl.SSLEngine#unwrap(ByteBuffer src, ByteBuffer[] dsts) ReadOnlyBufferException should be thrown."}
{"code": "public static CstFloat make(int bits){\n  return new CstFloat(bits);\n}\n", "nl": "Makes an instance for the given value. This may (but does not necessarily) return an already-allocated instance."}
{"code": "public long size(){\n  long size=0;\n  if (parsedGeneExpressions == null)   parseGenes();\n  for (int i=0; i < parsedGeneExpressions.length; i++)   size+=parsedGeneExpressions[i].numberOfNodes();\n  return size;\n}\n", "nl": "Returns the \"size\" of the chromosome, namely, the number of nodes in all of its parsed genes -- does not include the linking functions. "}
{"code": "public void increment(View view){\n  if (quantity == 100) {\n    return;\n  }\n  quantity=quantity + 1;\n  displayQuantity(quantity);\n}\n", "nl": "This method is called when the plus button is clicked."}
{"code": "public void trimToSize(){\n  ++modCount;\n  if (size < elementData.length) {\n    elementData=Arrays.copyOf(elementData,size);\n  }\n}\n", "nl": "Trims the capacity of this <tt>ArrayHashList</tt> instance to be the list's current size. An application can use this operation to minimize the storage of an <tt>ArrayHashList</tt> instance."}
{"code": "public SyncValueResponseMessage(SyncValueResponseMessage other){\n  __isset_bitfield=other.__isset_bitfield;\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n  this.count=other.count;\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "public void clearParsers(){\n  if (parserManager != null) {\n    parserManager.clearParsers();\n  }\n}\n", "nl": "Removes all parsers from this text area."}
{"code": "@Override public void run(){\n  while (doWork) {\n    deliverLock();\n    while (tomLayer.isRetrievingState()) {\n      System.out.println(\"-- Retrieving State\");\n      canDeliver.awaitUninterruptibly();\n      if (tomLayer.getLastExec() == -1)       System.out.println(\"-- Ready to process operations\");\n    }\n    try {\n      ArrayList<Decision> decisions=new ArrayList<Decision>();\n      decidedLock.lock();\n      if (decided.isEmpty()) {\n        notEmptyQueue.await();\n      }\n      decided.drainTo(decisions);\n      decidedLock.unlock();\n      if (!doWork)       break;\n      if (decisions.size() > 0) {\n        TOMMessage[][] requests=new TOMMessage[decisions.size()][];\n        int[] consensusIds=new int[requests.length];\n        int[] leadersIds=new int[requests.length];\n        int[] regenciesIds=new int[requests.length];\n        CertifiedDecision[] cDecs;\n        cDecs=new CertifiedDecision[requests.length];\n        int count=0;\n        for (        Decision d : decisions) {\n          requests[count]=extractMessagesFromDecision(d);\n          consensusIds[count]=d.getConsensusId();\n          leadersIds[count]=d.getLeader();\n          regenciesIds[count]=d.getRegency();\n          CertifiedDecision cDec=new CertifiedDecision(this.controller.getStaticConf().getProcessId(),d.getConsensusId(),d.getValue(),d.getDecisionEpoch().proof);\n          cDecs[count]=cDec;\n          if (requests[count][0].equals(d.firstMessageProposed)) {\n            long time=requests[count][0].timestamp;\n            long seed=requests[count][0].seed;\n            int numOfNonces=requests[count][0].numOfNonces;\n            requests[count][0]=d.firstMessageProposed;\n            requests[count][0].timestamp=time;\n            requests[count][0].seed=seed;\n            requests[count][0].numOfNonces=numOfNonces;\n          }\n          count++;\n        }\n        Decision lastDecision=decisions.get(decisions.size() - 1);\n        if (requests != null && requests.length > 0) {\n          deliverMessages(consensusIds,regenciesIds,leadersIds,cDecs,requests);\n          if (controller.hasUpdates()) {\n            processReconfigMessages(lastDecision.getConsensusId());\n            tomLayer.setLastExec(lastDecision.getConsensusId());\n            tomLayer.setInExec(-1);\n          }\n        }\n        int cid=lastDecision.getConsensusId();\n        if (cid > 2) {\n          int stableConsensus=cid - 3;\n          tomLayer.execManager.removeConsensus(stableConsensus);\n        }\n      }\n    }\n catch (    Exception e) {\n      e.printStackTrace(System.err);\n    }\n    deliverUnlock();\n  }\n  java.util.logging.Logger.getLogger(DeliveryThread.class.getName()).log(Level.INFO,\"DeliveryThread stopped.\");\n}\n", "nl": "This is the code for the thread. It delivers decisions to the TOM request receiver object (which is the application)"}
{"code": "private byte[] calculateUValue(byte[] generalKey,byte[] firstDocIdValue,int revision) throws GeneralSecurityException, EncryptionUnsupportedByProductException {\n  if (revision == 2) {\n    Cipher rc4=createRC4Cipher();\n    SecretKey key=createRC4Key(generalKey);\n    initEncryption(rc4,key);\n    return crypt(rc4,PW_PADDING);\n  }\n else   if (revision >= 3) {\n    MessageDigest md5=createMD5Digest();\n    md5.update(PW_PADDING);\n    if (firstDocIdValue != null) {\n      md5.update(firstDocIdValue);\n    }\n    final byte[] hash=md5.digest();\n    Cipher rc4=createRC4Cipher();\n    SecretKey key=createRC4Key(generalKey);\n    initEncryption(rc4,key);\n    final byte[] v=crypt(rc4,hash);\n    rc4shuffle(v,generalKey,rc4);\n    assert v.length == 16;\n    final byte[] entryValue=new byte[32];\n    System.arraycopy(v,0,entryValue,0,v.length);\n    System.arraycopy(v,0,entryValue,16,v.length);\n    return entryValue;\n  }\n else {\n    throw new EncryptionUnsupportedByProductException(\"Unsupported standard security handler revision \" + revision);\n  }\n}\n", "nl": "Calculate what the U value should consist of given a particular key and document configuration. Correponds to Algorithms 3.4 and 3.5 of the PDF Reference version 1.7"}
{"code": "private void assign(HashMap<String,DBIDs> labelMap,String label,DBIDRef id){\n  if (labelMap.containsKey(label)) {\n    DBIDs exist=labelMap.get(label);\n    if (exist instanceof DBID) {\n      ModifiableDBIDs n=DBIDUtil.newHashSet();\n      n.add((DBID)exist);\n      n.add(id);\n      labelMap.put(label,n);\n    }\n else {\n      assert (exist instanceof HashSetModifiableDBIDs);\n      assert (exist.size() > 1);\n      ((ModifiableDBIDs)exist).add(id);\n    }\n  }\n else {\n    labelMap.put(label,DBIDUtil.deref(id));\n  }\n}\n", "nl": "Assigns the specified id to the labelMap according to its label"}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public CDeleteAction(final BackEndDebuggerProvider debuggerProvider,final int[] rows){\n  super(rows.length == 1 ? \"Remove Breakpoint\" : \"Remove Breakpoints\");\n  m_debuggerProvider=Preconditions.checkNotNull(debuggerProvider,\"IE01344: Debugger provider argument can not be null\");\n  m_rows=rows.clone();\n}\n", "nl": "Creates a new action object."}
{"code": "public Yaml(BaseConstructor constructor,Representer representer,DumperOptions dumperOptions,Resolver resolver){\n  if (!constructor.isExplicitPropertyUtils()) {\n    constructor.setPropertyUtils(representer.getPropertyUtils());\n  }\n else   if (!representer.isExplicitPropertyUtils()) {\n    representer.setPropertyUtils(constructor.getPropertyUtils());\n  }\n  this.constructor=constructor;\n  representer.setDefaultFlowStyle(dumperOptions.getDefaultFlowStyle());\n  representer.setDefaultScalarStyle(dumperOptions.getDefaultScalarStyle());\n  representer.getPropertyUtils().setAllowReadOnlyProperties(dumperOptions.isAllowReadOnlyProperties());\n  representer.setTimeZone(dumperOptions.getTimeZone());\n  this.representer=representer;\n  this.dumperOptions=dumperOptions;\n  this.resolver=resolver;\n  this.name=\"Yaml:\" + System.identityHashCode(this);\n}\n", "nl": "Create Yaml instance. It is safe to create a few instances and use them in different Threads."}
{"code": "public void testHitEndAfterFind(){\n  hitEndTest(true,\"#01.0\",\"r((ege)|(geg))x\",\"regexx\",false);\n  hitEndTest(true,\"#01.1\",\"r((ege)|(geg))x\",\"regex\",false);\n  hitEndTest(true,\"#01.2\",\"r((ege)|(geg))x\",\"rege\",true);\n  hitEndTest(true,\"#01.2\",\"r((ege)|(geg))x\",\"xregexx\",false);\n  hitEndTest(true,\"#02.0\",\"regex\",\"rexreger\",true);\n  hitEndTest(true,\"#02.1\",\"regex\",\"raxregexr\",false);\n  String floatRegex=getHexFloatRegex();\n  hitEndTest(true,\"#03.0\",floatRegex,Double.toHexString(-1.234d),true);\n  hitEndTest(true,\"#03.1\",floatRegex,\"1 ABC\" + Double.toHexString(Double.NaN) + \"buhuhu\",false);\n  hitEndTest(true,\"#03.2\",floatRegex,Double.toHexString(-0.0) + \"--\",false);\n  hitEndTest(true,\"#03.3\",floatRegex,\"--\" + Double.toHexString(Double.MIN_VALUE) + \"--\",false);\n  hitEndTest(true,\"#04.0\",\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\d+)\",\"1 fish 2 fish red fish 5\",true);\n  hitEndTest(true,\"#04.1\",\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\d+)\",\"----1 fish 2 fish red fish 5----\",false);\n}\n", "nl": "Regression test for HARMONY-4396"}
{"code": "public void add(Individual individual){\n  individuals.add(individual);\n}\n", "nl": "Adds a single individual."}
{"code": "public boolean removeSession(IgniteUuid sesId){\n  GridTaskSessionImpl ses=sesMap.get(sesId);\n  assert ses == null || ses.isFullSupport();\n  if (ses != null && ses.release()) {\n    sesMap.remove(sesId,ses);\n    return true;\n  }\n  return false;\n}\n", "nl": "Removes session for a given session ID."}
{"code": "public static Bitmap loadBitmapOptimized(Uri uri,Context context,int limit) throws ImageLoadException {\n  return loadBitmapOptimized(new UriSource(uri,context){\n  }\n,limit);\n}\n", "nl": "Loading bitmap with optimized loaded size less than specific pixels count"}
{"code": "protected BasePeriod(long duration){\n  super();\n  iType=PeriodType.standard();\n  int[] values=ISOChronology.getInstanceUTC().get(DUMMY_PERIOD,duration);\n  iValues=new int[8];\n  System.arraycopy(values,0,iValues,4,4);\n}\n", "nl": "Creates a period from the given millisecond duration with the standard period type and ISO rules, ensuring that the calculation is performed with the time-only period type. <p> The calculation uses the hour, minute, second and millisecond fields."}
{"code": "public FlatBufferBuilder(){\n  this(1024);\n}\n", "nl": "Start with a buffer of 1KiB, then grow as required."}
{"code": "public PbrpcConnectionException(String arg0,Throwable arg1){\n  super(arg0,arg1);\n}\n", "nl": "Creates a new instance of PbrpcConnectionException."}
{"code": "public void uninstallUI(JComponent a){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).uninstallUI(a);\n  }\n}\n", "nl": "Invokes the <code>uninstallUI</code> method on each UI handled by this object."}
{"code": "public static void shutdown(){\n  if (instance != null) {\n    instance.save();\n  }\n}\n", "nl": "Saves the configuration file."}
{"code": "public boolean GE(Word w2){\n  return value.GE(w2.value);\n}\n", "nl": "Greater-than or equal comparison"}
{"code": "public static UnionCoder of(List<Coder<?>> elementCoders){\n  return new UnionCoder(elementCoders);\n}\n", "nl": "Builds a union coder with the given list of element coders.  This list corresponds to a mapping of union tag to Coder.  Union tags start at 0."}
{"code": "public void testFileDeletion() throws Exception {\n  File testDir=createTestDir(\"testFileDeletion\");\n  String prefix1=\"testFileDeletion1\";\n  File[] files1=createFiles(testDir,prefix1,5);\n  String prefix2=\"testFileDeletion2\";\n  File[] files2=createFiles(testDir,prefix2,5);\n  FileCommands.deleteFiles(files1,true);\n  assertNotExists(files1);\n  FileCommands.deleteFiles(files2,false);\n  Thread.sleep(1000);\n  assertNotExists(files2);\n}\n", "nl": "Verify ability to delete a list of files."}
{"code": "public boolean isOnClasspath(String classpath){\n  return this.classpath.equals(classpath);\n}\n", "nl": "Evaluates if the Dependency is targeted for a classpath type."}
{"code": "protected void source(String ceylon){\n  String providerPreSrc=\"provider/\" + ceylon + \"_pre.ceylon\";\n  String providerPostSrc=\"provider/\" + ceylon + \"_post.ceylon\";\n  String clientSrc=\"client/\" + ceylon + \"_client.ceylon\";\n  compile(providerPreSrc,providerModuleSrc,providerPackageSrc);\n  compile(clientSrc,clientModuleSrc);\n  compile(providerPostSrc,providerModuleSrc,providerPackageSrc);\n  compile(clientSrc,clientModuleSrc);\n}\n", "nl": "Checks that we can still compile a client after a change"}
{"code": "public PerformanceMonitor(){\n  initComponents();\n  if (Display.getInstance().getCurrent() != null) {\n    refreshFrameActionPerformed(null);\n  }\n  resultData.setModel(new Model());\n  performanceLog.setLineWrap(true);\n  resultData.setRowSorter(new TableRowSorter<Model>((Model)resultData.getModel()));\n}\n", "nl": "Creates new form PerformanceMonitor"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:15.190 -0400\",hash_original_method=\"F262A3A18BABECF7EC492736953EAF6E\",hash_generated_method=\"94A4545C167C029CC38AACEACF2087E9\") private void unparkSuccessor(Node node){\n  int ws=node.waitStatus;\n  if (ws < 0)   compareAndSetWaitStatus(node,ws,0);\n  Node s=node.next;\n  if (s == null || s.waitStatus > 0) {\n    s=null;\n    for (Node t=tail; t != null && t != node; t=t.prev)     if (t.waitStatus <= 0)     s=t;\n  }\n  if (s != null)   LockSupport.unpark(s.thread);\n}\n", "nl": "Wakes up node's successor, if one exists."}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:44.364 -0500\",hash_original_method=\"EA3734ADDEB20313C9CAB09B48812C54\",hash_generated_method=\"4858AFE909DDE63867ACB561D5449C13\") static public void assertFalse(String message,boolean condition){\n  assertTrue(message,!condition);\n}\n", "nl": "Asserts that a condition is false. If it isn't it throws an AssertionFailedError with the given message."}
{"code": "@Override protected void initData(){\n  Intent intent=new Intent(this,PushMessageService.class);\n  this.startService(intent);\n  this.bindService(intent,this.connection,Context.BIND_AUTO_CREATE);\n}\n", "nl": "Initialize the Activity data"}
{"code": "public static Date parseDateDay(String dateString) throws ParseException {\n  return getSimplDateFormat(DF_DEF).parse(dateString);\n}\n", "nl": "Returns date parsed from string in format: yyyy.MM.dd."}
{"code": "private boolean doesStoragePortExistsInVArray(StoragePort umfsStoragePort,VirtualArray virtualArray){\n  List<URI> virtualArrayPorts=returnAllPortsInVArray(virtualArray.getId());\n  if (virtualArrayPorts.contains(umfsStoragePort.getId())) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks if the given storage port is part of VArray"}
{"code": "public SpringVaadinServletService(VaadinServlet servlet,DeploymentConfiguration deploymentConfiguration,String serviceUrl) throws ServiceException {\n  super(servlet,deploymentConfiguration);\n  this.serviceUrl=serviceUrl;\n}\n", "nl": "Create a servlet service instance that allows the use of a custom service URL."}
{"code": "private static List<TranslationResult> translateChildrenOfNode(final ITranslationEnvironment environment,final IOperandTreeNode expression,OperandSize size,final boolean loadOperand,Long baseOffset) throws InternalTranslationException {\n  final List<TranslationResult> partialResults=new ArrayList<>();\n  final List<? extends IOperandTreeNode> children=expression.getChildren();\n  Collections.sort(children,comparator);\n  for (  final IOperandTreeNode child : children) {\n    final TranslationResult nextResult=loadOperand(environment,baseOffset,child,isSegmentExpression(expression.getValue()) ? expression : null,size,loadOperand);\n    partialResults.add(nextResult);\n    baseOffset+=nextResult.getInstructions().size();\n  }\n  return partialResults;\n}\n", "nl": "Iterates over the children of a node in the operand tree and generates translations for them."}
{"code": "public void removeShutdownLatch(final CountDownLatch latch){\n  removeShutdownLatch(latch,false);\n}\n", "nl": "Releases the latch and removes it from the latches being handled by this handler."}
{"code": "public Version(){\n  this(CommonReflection.getVersionTag());\n}\n", "nl": "Constructs a new Version from the current server version running"}
{"code": "public static void startActivity(Context context,String chatId){\n  Intent intent=new Intent(context,SendGroupFile.class);\n  intent.putExtra(EXTRA_CHAT_ID,chatId);\n  context.startActivity(intent);\n}\n", "nl": "Start SendGroupFile activity"}
{"code": "public Index excludedDataCenters(String excludedDataCenters){\n  this.excludedDataCenters=excludedDataCenters;\n  return this;\n}\n", "nl": "Sets the list of excluded data centers."}
{"code": "public final int read() throws IOException {\n  int result=src.read();\n  if (result != -1) {\n    ++pointer;\n  }\n  return result;\n}\n", "nl": "Forwards the request to the real <code>InputStream</code>."}
{"code": "public static boolean compareAndSwapInt(Object obj,long off,int exp,int upd){\n  return UNSAFE.compareAndSwapInt(obj,off,exp,upd);\n}\n", "nl": "Integer CAS."}
{"code": "public static String dec2Bin(int value){\n  String result=\"\";\n  return dec2Bin(value,result);\n}\n", "nl": "Methods converts a decimal number into a binary number as a string"}
{"code": "public void apply(RecyclerView recyclerView,Iterable<Item> items){\n  if (items != null) {\n    HashMap<Integer,Stack<RecyclerView.ViewHolder>> cache=new HashMap<>();\n    for (    Item d : items) {\n      if (!cache.containsKey(d.getType())) {\n        cache.put(d.getType(),new Stack<RecyclerView.ViewHolder>());\n      }\n      if (mCacheSize == -1 || cache.get(d.getType()).size() <= mCacheSize) {\n        cache.get(d.getType()).push(d.getViewHolder(recyclerView));\n      }\n      RecyclerView.RecycledViewPool recyclerViewPool=new RecyclerView.RecycledViewPool();\n      for (      Map.Entry<Integer,Stack<RecyclerView.ViewHolder>> entry : cache.entrySet()) {\n        recyclerViewPool.setMaxRecycledViews(entry.getKey(),mCacheSize);\n        for (        RecyclerView.ViewHolder holder : entry.getValue()) {\n          recyclerViewPool.putRecycledView(holder);\n        }\n        entry.getValue().clear();\n      }\n      cache.clear();\n      recyclerView.setRecycledViewPool(recyclerViewPool);\n    }\n  }\n}\n", "nl": "init the cache on your own."}
{"code": "public void incNumOverflowOnDisk(long delta){\n  this.stats.incLong(numOverflowOnDiskId,delta);\n}\n", "nl": "Increments the current number of entries whose value has been overflowed to disk by a given amount."}
{"code": "public void paint(Graphics a,JComponent b){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).paint(a,b);\n  }\n}\n", "nl": "Invokes the <code>paint</code> method on each UI handled by this object."}
{"code": "public void updateUI(){\n  setUI((TableHeaderUI)UIManager.getUI(this));\n  TableCellRenderer renderer=getDefaultRenderer();\n  if (renderer instanceof Component) {\n    SwingUtilities.updateComponentTreeUI((Component)renderer);\n  }\n}\n", "nl": "Notification from the <code>UIManager</code> that the look and feel (L&amp;F) has changed. Replaces the current UI object with the latest version from the <code>UIManager</code>."}
{"code": "public static RefactoringStatus create(IStatus status){\n  if (status.isOK())   return new RefactoringStatus();\n  if (!status.isMultiStatus()) {\nswitch (status.getSeverity()) {\ncase IStatus.OK:\n      return new RefactoringStatus();\ncase IStatus.INFO:\n    return RefactoringStatus.createWarningStatus(status.getMessage());\ncase IStatus.WARNING:\n  return RefactoringStatus.createErrorStatus(status.getMessage());\ncase IStatus.ERROR:\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\ncase IStatus.CANCEL:\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\ndefault :\nreturn RefactoringStatus.createFatalErrorStatus(status.getMessage());\n}\n}\n else {\nIStatus[] children=status.getChildren();\nRefactoringStatus result=new RefactoringStatus();\nfor (int i=0; i < children.length; i++) {\nresult.merge(RefactoringStatus.create(children[i]));\n}\nreturn result;\n}\n}\n", "nl": "Creates a new <code>RefactoringStatus</code> from the given <code>IStatus</code>. An OK status is mapped to an OK refactoring status, an information status is mapped to a warning refactoring status, a warning status is mapped to an error refactoring status and an error or cancel status is mapped to a fatal refactoring status. An unknown status is converted into a fatal error status as well. If the status is a <code>MultiStatus </code> then the first level of children of the status will be added as refactoring status entries to the created refactoring status."}
{"code": "public void debug(String msg){\n  debugLogger.debug(msg);\n}\n", "nl": "Log a Setup and/or administrative log message for log4jdbc."}
{"code": "public int size(){\n  return codon.length;\n}\n", "nl": "Returns the length of the integer codon representation of this grammar."}
{"code": "public Diff decode() throws UnsupportedEncodingException, DecodingException {\n  int header=r.read(3);\n  if (DiffAction.parse(header) != DiffAction.DECODER_DATA) {\n    throw new DecodingException(\"Invalid codecData code: \" + header);\n  }\n  int blockSize_C=3;\n  int blockSize_S=r.read(5);\n  int blockSize_E=r.read(5);\n  int blockSize_B=r.read(5);\n  int blockSize_L=r.read(5);\n  r.read(1);\n  if (blockSize_S < 0 || blockSize_S > 31) {\n    throw new DecodingException(\"blockSize_S out of range: \" + blockSize_S);\n  }\n  if (blockSize_E < 0 || blockSize_E > 31) {\n    throw new DecodingException(\"blockSize_E out of range: \" + blockSize_E);\n  }\n  if (blockSize_B < 0 || blockSize_B > 31) {\n    throw new DecodingException(\"blockSize_B out of range: \" + blockSize_B);\n  }\n  if (blockSize_L < 0 || blockSize_L > 31) {\n    throw new DecodingException(\"blockSize_L out of range: \" + blockSize_L);\n  }\n  return decode(blockSize_C,blockSize_S,blockSize_E,blockSize_B,blockSize_L);\n}\n", "nl": "Decodes the information and returns the Diff."}
{"code": "public FontSizeLocator(){\n}\n", "nl": "Creates a new instance."}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) static <E extends Comparable<E>>AutoSortedCollection<E> createAutoSortedCollection(Collection<? extends E> values){\n  return createAutoSortedCollection(null,values);\n}\n", "nl": "Construct new auto sorted collection using natural order."}
{"code": "@Override public String toString(){\n  return super.toString();\n}\n", "nl": "Returns the super class implementation of toString()."}
{"code": "public boolean useLayoutEditor(SignalMast destination){\n  if (!destList.containsKey(destination)) {\n    return false;\n  }\n  return destList.get(destination).useLayoutEditor();\n}\n", "nl": "Query if we are using the layout editor panels to build the signal mast logic, blocks, turnouts ."}
{"code": "private static String unescapePathComponent(String name){\n  return name.replaceAll(\"\\\\\\\\(.)\",\"$1\");\n}\n", "nl": "Convert a path component that contains backslash escape sequences to a literal string. This is necessary when you want to explicitly refer to a path that contains globber metacharacters."}
{"code": "public AbstractExampleTable(List<Attribute> attributes){\n  addAttributes(attributes);\n}\n", "nl": "Creates a new ExampleTable."}
{"code": "public void zoomOut(){\n  Matrix save=mViewPortHandler.zoomOut(getWidth() / 2f,-(getHeight() / 2f));\n  mViewPortHandler.refresh(save,this,true);\n}\n", "nl": "Zooms out by 0.7f, from the charts center. center."}
{"code": "public Media createBackgroundMedia(String uri) throws IOException {\n  return impl.createBackgroundMedia(uri);\n}\n", "nl": "Creates an audio media that can be played in the background."}
{"code": "private boolean hasNextTlsMode(){\n  return nextTlsMode != TLS_MODE_NULL;\n}\n", "nl": "Returns true if there's another TLS mode to try."}
{"code": "protected void copyToOpsw(){\n  opsw[1]=fullmode.isSelected();\n  opsw[2]=twoaspects.isSelected();\n  opsw[11]=semaphore.isSelected();\n  opsw[12]=pulsed.isSelected();\n  opsw[13]=disableDS.isSelected();\n  opsw[14]=fromloconet.isSelected();\n  opsw[15]=disablelocal.isSelected();\n  opsw[17]=sigaddress.isSelected();\n  opsw[18]=bcastaddress.isSelected();\n  opsw[19]=semaddress.isSelected();\n  opsw[20]=setdefault.isSelected();\n  opsw[21]=exercise.isSelected();\n  int value=section1to4mode.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[5]=true;\n  }\n else {\n    opsw[5]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[4]=true;\n  }\n else {\n    opsw[4]=false;\n  }\n  if ((value & 0x04) != 0) {\n    opsw[3]=true;\n  }\n else {\n    opsw[3]=false;\n  }\n  value=section5to8mode.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[8]=true;\n  }\n else {\n    opsw[8]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[7]=true;\n  }\n else {\n    opsw[7]=false;\n  }\n  if ((value & 0x04) != 0) {\n    opsw[6]=true;\n  }\n else {\n    opsw[6]=false;\n  }\n  value=fourthAspect.getSelectedIndex();\n  if ((value & 0x01) != 0) {\n    opsw[10]=true;\n  }\n else {\n    opsw[10]=false;\n  }\n  if ((value & 0x02) != 0) {\n    opsw[9]=true;\n  }\n else {\n    opsw[9]=false;\n  }\n}\n", "nl": "Copy from the GUI to the opsw array. <p> Used before write operations start"}
{"code": "@Override public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){\n  if (requestCode == ALLOW_PERMISSIONS && grantResults.length > 0) {\n    List<String> permissionsNotAllowed=new ArrayList<>();\n    for (int i=0; i < permissions.length; i++) {\n      if (grantResults[i] == PackageManager.PERMISSION_DENIED) {\n        permissionsNotAllowed.add(permissions[i]);\n      }\n    }\n    if (permissionsNotAllowed.isEmpty()) {\n      initEvent();\n    }\n else {\n      permissionNotEnabled();\n    }\n  }\n else {\n    permissionNotEnabled();\n  }\n}\n", "nl": "This method is a callback. Check the user's answer after requesting permission."}
{"code": "public String rowGet(String key){\n  String resolvedKey=resolveRowKey(key);\n  String cachedValue=rowMapCache.get(resolvedKey);\n  if (cachedValue != null) {\n    return cachedValue;\n  }\n  String value=rowMap.get(resolvedKey);\n  if (value == null && parent != null) {\n    value=parent.rowGet(resolvedKey);\n  }\n  if (value == null) {\n    return null;\n  }\n  String expandedString=expand(value,false);\n  rowMapCache.put(resolvedKey,expandedString);\n  return expandedString;\n}\n", "nl": "Looks up and returns the RowSpec associated with the given key. First looks for an association in this LayoutMap. If there's no association, the lookup continues with the parent map - if any."}
{"code": "public void postEvaluationStatistics(final EvolutionState state){\n  super.postEvaluationStatistics(state);\n  state.output.println(\"\\nGeneration: \" + state.generation,Output.V_NO_GENERAL,statisticslog);\n  for (int x=0; x < state.population.subpops.length; x++)   for (int y=1; y < state.population.subpops[x].individuals.length; y++)   state.population.subpops[x].individuals[y].printIndividualForHumans(state,statisticslog,Output.V_NO_GENERAL);\n}\n", "nl": "Logs the best individual of the generation."}
{"code": "private void checkUserExists(String entidad) throws Exception {\n  int count;\n  UsersTable table=new UsersTable();\n  DbConnection dbConn=new DbConnection();\n  try {\n    dbConn.open(DBSessionManager.getSession());\n    if (_id == ISicresAdminDefsKeys.NULL_ID)     count=DbSelectFns.selectCount(dbConn,table.getBaseTableName(),table.getCountNameQual(_name));\n else     count=DbSelectFns.selectCount(dbConn,table.getBaseTableName(),table.getCountNameIdQual(_id,_name));\n    if (count > 0)     ISicresAdminBasicException.throwException(ISicresAdminUserKeys.EC_USER_EXISTS_NAME);\n  }\n catch (  Exception e) {\n    _logger.error(e);\n    throw e;\n  }\n finally {\n    dbConn.close();\n  }\n}\n", "nl": "Comprueba que el usuario tiene distinto nombre a los que ya existen."}
{"code": "@Transactional public Role createRoleWithPermissions(Role role,Set<Long> permissionIds){\n  Role current=findRoleByRoleName(role.getRoleName());\n  Preconditions.checkState(current == null,\"Role %s already exists!\",role.getRoleName());\n  Role createdRole=roleRepository.save(role);\n  if (!CollectionUtils.isEmpty(permissionIds)) {\n    Iterable<RolePermission> rolePermissions=FluentIterable.from(permissionIds).transform(null);\n    rolePermissionRepository.save(rolePermissions);\n  }\n  return createdRole;\n}\n", "nl": "Create role with permissions, note that role name should be unique"}
{"code": "protected void generateNewCursorBox(){\n  if ((old_m_x2 != -1) || (old_m_y2 != -1) || (Math.abs(commonValues.m_x2 - old_m_x2) > 5)|| (Math.abs(commonValues.m_y2 - old_m_y2) > 5)) {\n    int top_x=commonValues.m_x1;\n    if (commonValues.m_x1 > commonValues.m_x2) {\n      top_x=commonValues.m_x2;\n    }\n    int top_y=commonValues.m_y1;\n    if (commonValues.m_y1 > commonValues.m_y2) {\n      top_y=commonValues.m_y2;\n    }\n    final int w=Math.abs(commonValues.m_x2 - commonValues.m_x1);\n    final int h=Math.abs(commonValues.m_y2 - commonValues.m_y1);\n    final int[] currentRectangle={top_x,top_y,w,h};\n    decode_pdf.updateCursorBoxOnScreen(currentRectangle,DecoderOptions.highlightColor.getRGB());\n    if (!currentCommands.extractingAsImage) {\n      final int[] r={commonValues.m_x1,commonValues.m_y1,commonValues.m_x2 - commonValues.m_x1,commonValues.m_y2 - commonValues.m_y1};\n      decode_pdf.getTextLines().addHighlights(new int[][]{r},false,commonValues.getCurrentPage());\n    }\n    old_m_x2=commonValues.m_x2;\n    old_m_y2=commonValues.m_y2;\n  }\n  decode_pdf.repaintPane(commonValues.getCurrentPage());\n}\n", "nl": "generate new  cursorBox and highlight extractable text, if hardware acceleration off and extraction on<br> and update current cursor box displayed on screen"}
{"code": "public OMGraphicList(int initialCapacity){\n  graphics=Collections.synchronizedList(new ArrayList<OMGraphic>(initialCapacity));\n}\n", "nl": "Construct an OMGraphicList with an initial capacity."}
{"code": "private void saveToSettings(){\n  List<String> dataToSave=new LinkedList<>();\n  for (  UsercolorItem item : data) {\n    dataToSave.add(item.getId() + \",\" + HtmlColors.getColorString(item.getColor()));\n  }\n  settings.putList(\"usercolors\",dataToSave);\n}\n", "nl": "Copy the current data to the settings."}
{"code": "public static boolean isArrayForName(String value){\n  return ARRAY_FOR_NAME_PATTERN.matcher(value).matches();\n}\n", "nl": "Returns true if the given string looks like a Java array name."}
{"code": "public double length(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n", "nl": "Calculates the length of the vector."}
{"code": "public String toString(){\n  return schema;\n}\n", "nl": "Returns this' media-type (a MIME content-type category) (previously returned a description key)"}
{"code": "public void restoreStarting(int numPackages){\n}\n", "nl": "The restore operation has begun."}
{"code": "private boolean resourceIsGwtXmlAndInGwt(IResource resource) throws CoreException {\n  return GWTNature.isGWTProject(resource.getProject()) && resource.getName().endsWith(\".gwt.xml\");\n}\n", "nl": "If the resource is a .gwt.xml file and we're in a gwt-enabled project, return true."}
{"code": "public GlowCreature(Location location,EntityType type,double maxHealth){\n  super(location,maxHealth);\n  this.type=type;\n}\n", "nl": "Creates a new monster."}
{"code": "public CacheLayer(){\n}\n", "nl": "Construct a default CacheLayer."}
{"code": "protected Address buildAndroidAddress(JSONObject jResult) throws JSONException {\n  Address gAddress=new Address(mLocale);\n  gAddress.setLatitude(jResult.getDouble(\"lat\"));\n  gAddress.setLongitude(jResult.getDouble(\"lng\"));\n  int addressIndex=0;\n  if (jResult.has(\"streetName\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"streetName\"));\n    gAddress.setThoroughfare(jResult.getString(\"streetName\"));\n  }\n  if (jResult.has(\"zipCode\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"zipCode\"));\n    gAddress.setPostalCode(jResult.getString(\"zipCode\"));\n  }\n  if (jResult.has(\"city\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"city\"));\n    gAddress.setLocality(jResult.getString(\"city\"));\n  }\n  if (jResult.has(\"state\")) {\n    gAddress.setAdminArea(jResult.getString(\"state\"));\n  }\n  if (jResult.has(\"country\")) {\n    gAddress.setAddressLine(addressIndex++,jResult.getString(\"country\"));\n    gAddress.setCountryName(jResult.getString(\"country\"));\n  }\n  if (jResult.has(\"countrycode\"))   gAddress.setCountryCode(jResult.getString(\"countrycode\"));\n  return gAddress;\n}\n", "nl": "Build an Android Address object from the Gisgraphy address in JSON format."}
{"code": "public JDBCCategoryDataset(Connection connection,String query) throws SQLException {\n  this(connection);\n  executeQuery(query);\n}\n", "nl": "Creates a new dataset with the given database connection, and executes the supplied query to populate the dataset."}
{"code": "public static Map<String,Object> generateReqsFromCancelledPOItems(DispatchContext dctx,Map<String,? extends Object> context){\n  Delegator delegator=dctx.getDelegator();\n  LocalDispatcher dispatcher=dctx.getDispatcher();\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  Locale locale=(Locale)context.get(\"locale\");\n  String orderId=(String)context.get(\"orderId\");\n  String facilityId=(String)context.get(\"facilityId\");\n  try {\n    GenericValue orderHeader=EntityQuery.use(delegator).from(\"OrderHeader\").where(\"orderId\",orderId).queryOne();\n    if (UtilValidate.isEmpty(orderHeader)) {\n      String errorMessage=UtilProperties.getMessage(resource_error,\"OrderErrorOrderIdNotFound\",UtilMisc.toMap(\"orderId\",orderId),locale);\n      Debug.logError(errorMessage,module);\n      return ServiceUtil.returnError(errorMessage);\n    }\n    if (!\"PURCHASE_ORDER\".equals(orderHeader.getString(\"orderTypeId\"))) {\n      String errorMessage=UtilProperties.getMessage(resource_error,\"ProductErrorOrderNotPurchaseOrder\",UtilMisc.toMap(\"orderId\",orderId),locale);\n      Debug.logError(errorMessage,module);\n      return ServiceUtil.returnError(errorMessage);\n    }\n    Map<String,Object> productRequirementQuantities=new HashMap<String,Object>();\n    List<GenericValue> orderItems=orderHeader.getRelated(\"OrderItem\",null,null,false);\n    for (    GenericValue orderItem : orderItems) {\n      if (!\"PRODUCT_ORDER_ITEM\".equals(orderItem.getString(\"orderItemTypeId\")))       continue;\n      BigDecimal orderItemCancelQuantity=BigDecimal.ZERO;\n      if (!UtilValidate.isEmpty(orderItem.get(\"cancelQuantity\"))) {\n        orderItemCancelQuantity=orderItem.getBigDecimal(\"cancelQuantity\");\n      }\n      if (orderItemCancelQuantity.compareTo(BigDecimal.ZERO) <= 0)       continue;\n      String productId=orderItem.getString(\"productId\");\n      if (productRequirementQuantities.containsKey(productId)) {\n        orderItemCancelQuantity=orderItemCancelQuantity.add((BigDecimal)productRequirementQuantities.get(productId));\n      }\n      productRequirementQuantities.put(productId,orderItemCancelQuantity);\n    }\n    for (    String productId : productRequirementQuantities.keySet()) {\n      BigDecimal requiredQuantity=(BigDecimal)productRequirementQuantities.get(productId);\n      Map<String,Object> createRequirementResult=dispatcher.runSync(\"createRequirement\",UtilMisc.<String,Object>toMap(\"requirementTypeId\",\"PRODUCT_REQUIREMENT\",\"facilityId\",facilityId,\"productId\",productId,\"quantity\",requiredQuantity,\"userLogin\",userLogin));\n      if (ServiceUtil.isError(createRequirementResult))       return createRequirementResult;\n    }\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(e.getMessage());\n  }\ncatch (  GenericServiceException se) {\n    Debug.logError(se,module);\n    return ServiceUtil.returnError(se.getMessage());\n  }\n  return ServiceUtil.returnSuccess();\n}\n", "nl": "Generates a product requirement for the total cancelled quantity over all order items for each product"}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  if (bayesIm == null) {\n    throw new NullPointerException();\n  }\n  if (variables == null) {\n    throw new NullPointerException();\n  }\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "boolean contains(ProtocolVersion protocolVersion){\n  if (protocolVersion == ProtocolVersion.SSL20Hello) {\n    return false;\n  }\n  return protocols.contains(protocolVersion);\n}\n", "nl": "Return whether this list contains the specified protocol version. SSLv2Hello is not a real protocol version we support, we always return false for it."}
{"code": "@Override protected EClass eStaticClass(){\n  return DatatypePackage.Literals.OBJECT_PROPERTY_TYPE;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:34:35.806 -0500\",hash_original_method=\"E14DF72F5869874CC38AD67447F5264E\",hash_generated_method=\"127365361841BB38033FE96228DFD635\") public final Iterator<String> typesIterator(){\n  return mDataTypes != null ? mDataTypes.iterator() : null;\n}\n", "nl": "Return an iterator over the filter's data types."}
{"code": "public void registerGUI(final ConfigGUI gui){\n  this.gui=gui;\n}\n", "nl": "Sets the reference of the GUI."}
{"code": "public IntersectionMatrix(IntersectionMatrix other){\n  this();\n  matrix[Location.INTERIOR][Location.INTERIOR]=other.matrix[Location.INTERIOR][Location.INTERIOR];\n  matrix[Location.INTERIOR][Location.BOUNDARY]=other.matrix[Location.INTERIOR][Location.BOUNDARY];\n  matrix[Location.INTERIOR][Location.EXTERIOR]=other.matrix[Location.INTERIOR][Location.EXTERIOR];\n  matrix[Location.BOUNDARY][Location.INTERIOR]=other.matrix[Location.BOUNDARY][Location.INTERIOR];\n  matrix[Location.BOUNDARY][Location.BOUNDARY]=other.matrix[Location.BOUNDARY][Location.BOUNDARY];\n  matrix[Location.BOUNDARY][Location.EXTERIOR]=other.matrix[Location.BOUNDARY][Location.EXTERIOR];\n  matrix[Location.EXTERIOR][Location.INTERIOR]=other.matrix[Location.EXTERIOR][Location.INTERIOR];\n  matrix[Location.EXTERIOR][Location.BOUNDARY]=other.matrix[Location.EXTERIOR][Location.BOUNDARY];\n  matrix[Location.EXTERIOR][Location.EXTERIOR]=other.matrix[Location.EXTERIOR][Location.EXTERIOR];\n}\n", "nl": "Creates an <code>IntersectionMatrix</code> with the same elements as <code>other</code>."}
{"code": "public long readUnsignedInt(){\n  long result=shiftIntoLong(data,position,4);\n  position+=4;\n  return result;\n}\n", "nl": "Reads the next four bytes as an unsigned value."}
{"code": "public void emit(final SpannableStringBuilder out,final Block root){\n  root.removeSurroundingEmptyLines();\nswitch (root.type) {\ncase NONE:\n    break;\ncase PARAGRAPH:\n  this.config.decorator.openParagraph(out);\nbreak;\ncase BLOCKQUOTE:\nthis.config.decorator.openBlockquote(out);\nbreak;\ncase UNORDERED_LIST:\nthis.config.decorator.openUnorderedList(out);\nbreak;\ncase ORDERED_LIST:\nthis.config.decorator.openOrderedList(out);\nbreak;\ncase UNORDERED_LIST_ITEM:\nthis.config.decorator.openUnOrderedListItem(out);\nbreak;\ncase ORDERED_LIST_ITEM:\nthis.config.decorator.openOrderedListItem(out);\nbreak;\n}\nif (root.hasLines()) {\nthis.emitLines(out,root);\n}\n else {\nBlock block=root.blocks;\nwhile (block != null) {\nthis.emit(out,block);\nblock=block.next;\n}\n}\nswitch (root.type) {\ncase NONE:\nbreak;\ncase PARAGRAPH:\nthis.config.decorator.closeParagraph(out);\nbreak;\ncase BLOCKQUOTE:\nthis.config.decorator.closeBlockquote(out);\nbreak;\ncase UNORDERED_LIST:\nthis.config.decorator.closeUnorderedList(out);\nbreak;\ncase ORDERED_LIST:\nthis.config.decorator.closeOrderedList(out);\nbreak;\ncase UNORDERED_LIST_ITEM:\nthis.config.decorator.closeUnOrderedListItem(out);\nbreak;\ncase ORDERED_LIST_ITEM:\nthis.config.decorator.closeOrderedListItem(out);\nbreak;\n}\n}\n", "nl": "Transforms the given block recursively into HTML."}
{"code": "public boolean isInternable(){\n  return (classAnnotations != null) && (fieldAnnotations == null) && (methodAnnotations == null)&& (parameterAnnotations == null);\n}\n", "nl": "Returns whether this item is a candidate for interning. The only interning candidates are ones that <i>only</i> have a non-null set of class annotations, with no other lists."}
{"code": "public URI(final String scheme,final String userinfo,final String host,final int port,final String path,final String query,final String fragment) throws URIException {\n  this(scheme,(host == null) ? null : ((userinfo != null) ? userinfo + '@' : \"\") + host + ((port != -1) ? \":\" + port : \"\"),path,query,fragment);\n}\n", "nl": "Construct a general URI from the given components."}
{"code": "public void addUser(User user){\n  users.addElement(user);\n}\n", "nl": "Add a user"}
{"code": "protected void engineUpdate(byte b) throws SignatureException {\n  msgDigest.update(b);\n}\n", "nl": "Updates data to sign or to verify."}
{"code": "public RqMtFake(final Request req,final Request... dispositions) throws IOException {\n  this.fake=new RqMtBase(new RqMtFake.FakeMultipartRequest(req,dispositions));\n}\n", "nl": "Fake ctor."}
{"code": "public static Video randomVideo(){\n  String id=UUID.randomUUID().toString();\n  String title=\"Video-\" + id;\n  String url=\"http://coursera.org/some/video-\" + id;\n  long duration=60 * (int)Math.rint(Math.random() * 60) * 1000;\n  return new Video(title,url,duration);\n}\n", "nl": "Construct and return a Video object with a rnadom name, url, and duration."}
{"code": "public void addHeader(String header,String value){\n  clientHeaderMap.put(header,value);\n}\n", "nl": "Sets headers that will be added to all requests this client makes (before sending)."}
{"code": "public void addPostalAddress(PostalAddress postalAddress){\n  getPostalAddresses().add(postalAddress);\n}\n", "nl": "Adds a new contact postal address."}
{"code": "public CaughtExceptionRef newCaughtExceptionRef(){\n  return new JCaughtExceptionRef();\n}\n", "nl": "Constructs a CaughtExceptionRef() grammar chunk."}
{"code": "public void actionPerformed(ActionEvent e){\n  if (e.getSource() instanceof PerformanceIndicator) {\n    PerformanceIndicator pi=(PerformanceIndicator)e.getSource();\n    log.info(pi.getName());\n    MGoal goal=pi.getGoal();\n    if (goal.getMeasure() != null)     new PerformanceDetail(goal);\n  }\n}\n", "nl": "Action Listener for Drill Down"}
{"code": "public Iterator<AbstractNode> childIterator(final boolean dirtyNodesOnly){\n  if (dirtyNodesOnly) {\n    return new DirtyChildIterator(this);\n  }\n else {\n    return new ChildIterator(this);\n  }\n}\n", "nl": "Iterator visits the direct child nodes in the external key ordering."}
{"code": "public static int maxIndex(double[] doubles){\n  double maximum=0;\n  int maxIndex=0;\n  for (int i=0; i < doubles.length; i++) {\n    if ((i == 0) || (doubles[i] > maximum)) {\n      maxIndex=i;\n      maximum=doubles[i];\n    }\n  }\n  return maxIndex;\n}\n", "nl": "Returns index of maximum element in a given array of doubles. First maximum is returned."}
{"code": "private List<PreferenceIndex> crawlSingleIndexableResource(IndexableFragment indexableFragment){\n  List<PreferenceIndex> indexablePreferences=new ArrayList<>();\n  XmlPullParser parser=mContext.getResources().getXml(indexableFragment.xmlRes);\n  int type;\n  try {\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {\n    }\n    String nodeName=parser.getName();\n    if (!NODE_NAME_PREFERENCE_SCREEN.equals(nodeName)) {\n      throw new RuntimeException(\"XML document must start with <PreferenceScreen> tag; found\" + nodeName + \" at \"+ parser.getPositionDescription());\n    }\n    final int outerDepth=parser.getDepth();\n    final AttributeSet attrs=Xml.asAttributeSet(parser);\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n        continue;\n      }\n      nodeName=parser.getName();\n      String key=PreferenceXmlUtil.getDataKey(mContext,attrs);\n      String title=PreferenceXmlUtil.getDataTitle(mContext,attrs);\n      if (NODE_NAME_PREFERENCE_CATEGORY.equals(nodeName) || TextUtils.isEmpty(key) || TextUtils.isEmpty(title)) {\n        continue;\n      }\n      PreferenceIndex indexablePreference=new PreferenceIndex(key,title,indexableFragment.fragmentName);\n      indexablePreferences.add(indexablePreference);\n    }\n  }\n catch (  XmlPullParserException|IOException|ReflectiveOperationException ex) {\n    Log.e(TAG,\"Error in parsing a preference xml file, skip it\",ex);\n  }\n  return indexablePreferences;\n}\n", "nl": "Skim through the xml preference file."}
{"code": "@Inline private static void genNullCheck(Assembler asm,GPR objRefReg){\n  asm.emitTEST_Reg_Reg(objRefReg,objRefReg);\n  asm.emitBranchLikelyNextInstruction();\n  ForwardReference fr=asm.forwardJcc(NE);\n  asm.emitINT_Imm(RuntimeEntrypoints.TRAP_NULL_POINTER + RVM_TRAP_BASE);\n  fr.resolve(asm);\n}\n", "nl": "Generate an explicit null check (compare to zero)."}
{"code": "public Location(String provider){\n  mProvider=provider;\n}\n", "nl": "Construct a new Location with a named provider. <p>By default time, latitude and longitude are 0, and the location has no bearing, altitude, speed, accuracy or extras."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String demHeader=null;\n  String creekHeader=null;\n  String ttControlHeader=null;\n  String eacOutputHeader=null;\n  String dfcOutputHeader=null;\n  String gtcOutputHeader=null;\n  String ttpOutputHeader=null;\n  WhiteboxRaster dem;\n  WhiteboxRaster creek;\n  WhiteboxRaster ttControl=null;\n  WhiteboxRaster eacOutput;\n  WhiteboxRaster dfcOutput;\n  WhiteboxRaster gtcOutput;\n  WhiteboxRaster ttpOutput;\n  int numCols, numRows;\n  double gridRes;\n  boolean blnTTControl=true;\n  int flowIndex;\n  List<FlowCell> flowPath=new ArrayList<>();\n  int c;\n  int x, y;\n  int xn, yn;\n  double p;\n  int maxDirection;\n  double grad, maxGrad;\n  double deltaElev;\n  double deltaXY;\n  int radius;\n  float maxRadius=200;\n  int maxX=0, maxY=0;\n  double ttControlMean;\n  int[] xd=new int[]{0,-1,-1,-1,0,1,1,1};\n  int[] yd=new int[]{-1,-1,0,1,1,1,0,-1};\n  double[] dd=new double[]{1,Math.sqrt(2),1,Math.sqrt(2),1,Math.sqrt(2),1,Math.sqrt(2)};\n  double noData;\n  float progress=0;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      demHeader=args[i];\n    }\n else     if (i == 1) {\n      creekHeader=args[i];\n    }\n else     if (i == 2) {\n      ttControlHeader=args[i];\n      if (ttControlHeader.toLowerCase().contains(\"not specified\")) {\n        blnTTControl=false;\n      }\n    }\n else     if (i == 3) {\n      eacOutputHeader=args[i];\n    }\n else     if (i == 4) {\n      dfcOutputHeader=args[i];\n    }\n else     if (i == 5) {\n      gtcOutputHeader=args[i];\n    }\n else     if (i == 6) {\n      ttpOutputHeader=args[i];\n    }\n  }\n  if ((demHeader == null) || (creekHeader == null) || (eacOutputHeader == null)|| (dfcOutputHeader == null)|| (gtcOutputHeader == null)|| (ttpOutputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    dem=new WhiteboxRaster(demHeader,\"r\");\n    creek=new WhiteboxRaster(creekHeader,\"r\");\n    if (blnTTControl == true) {\n      ttControl=new WhiteboxRaster(ttControlHeader,\"r\");\n    }\n    numRows=dem.getNumberRows();\n    numCols=dem.getNumberColumns();\n    noData=dem.getNoDataValue();\n    gridRes=dem.getCellSizeX();\n    eacOutput=new WhiteboxRaster(eacOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    eacOutput.setPreferredPalette(\"blueyellow.pal\");\n    eacOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    eacOutput.setZUnits(\"dimensionless\");\n    dfcOutput=new WhiteboxRaster(dfcOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    dfcOutput.setPreferredPalette(\"blueyellow.pal\");\n    dfcOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    dfcOutput.setZUnits(\"dimensionless\");\n    gtcOutput=new WhiteboxRaster(gtcOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    gtcOutput.setPreferredPalette(\"blueyellow.pal\");\n    gtcOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    gtcOutput.setZUnits(\"dimensionless\");\n    ttpOutput=new WhiteboxRaster(ttpOutputHeader,\"rw\",demHeader,WhiteboxRaster.DataType.FLOAT,0);\n    ttpOutput.setPreferredPalette(\"blueyellow.pal\");\n    ttpOutput.setDataScale(WhiteboxRasterBase.DataScale.CONTINUOUS);\n    ttpOutput.setZUnits(\"dimensionless\");\n    updateProgress(\"Loop 1 of 2:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (dem.getValue(row,col) != noData) {\n          if (creek.getValue(row,col) <= 0) {\n            eacOutput.setValue(row,col,-1048);\n          }\n        }\n else {\n          eacOutput.setValue(row,col,noData);\n          dfcOutput.setValue(row,col,noData);\n          gtcOutput.setValue(row,col,noData);\n          ttpOutput.setValue(row,col,noData);\n        }\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 1 of 2:\",(int)progress);\n    }\n    updateProgress(\"Loop 2 of 2:\",0);\n    for (int row=0; row < numRows; row++) {\n      for (int col=0; col < numCols; col++) {\n        if (eacOutput.getValue(row,col) == -1048) {\n          flowIndex=-1;\n          flowPath=new ArrayList<>();\n          x=col;\n          y=row;\n          while (eacOutput.getValue(y,x) == -1048) {\n            flowIndex=flowIndex + 1;\n            flowPath.add(new FlowCell(y,x));\n            p=dem.getValue(y,x);\n            maxDirection=-1;\n            maxGrad=0;\n            for (c=0; c < 8; c++) {\n              xn=x + xd[c];\n              yn=y + yd[c];\n              if (dem.getValue(yn,xn) != noData) {\n                grad=(p - dem.getValue(yn,xn)) / (dd[c] * gridRes);\n                if (grad > maxGrad) {\n                  maxGrad=grad;\n                  maxDirection=c;\n                }\n              }\n            }\n            if (maxDirection > -1) {\n              x=x + xd[maxDirection];\n              y=y + yd[maxDirection];\n            }\n else {\n              radius=1;\n              do {\n                for (int i=-radius; i <= radius; i++) {\n                  for (int j=-radius; j <= radius; j++) {\n                    if (Math.abs(i) > radius - 1 || Math.abs(j) > radius - 1) {\n                      xn=x + i;\n                      yn=y + j;\n                      if (dem.getValue(yn,xn) != noData && dem.getValue(yn,xn) < p) {\n                        grad=(p - dem.getValue(yn,xn)) / (Math.sqrt(i * i + j * j) * gridRes);\n                        if (grad > maxGrad) {\n                          maxGrad=grad;\n                          maxX=xn;\n                          maxY=yn;\n                        }\n                      }\n                    }\n                  }\n                }\n                radius=radius + 1;\n              }\n while (maxGrad == 0 & radius <= maxRadius);\n              if (maxGrad > 0) {\n                x=maxX;\n                y=maxY;\n              }\n else {\n                eacOutput.setValue(y,x,noData);\n                dfcOutput.setValue(y,x,noData);\n                gtcOutput.setValue(y,x,noData);\n                ttpOutput.setValue(y,x,noData);\n              }\n            }\n          }\n          if (eacOutput.getValue(y,x) == noData) {\n            eacOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n            dfcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n            gtcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n            ttpOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,noData);\n          }\n else {\n            deltaElev=dem.getValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex) - dem.getValue(y,x);\n            deltaXY=Math.sqrt(Math.pow(flowPath.get(flowIndex).rowIndex - y,2) + Math.pow(flowPath.get(flowIndex).columnIndex - x,2)) * gridRes;\n            eacOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,eacOutput.getValue(y,x) + deltaElev);\n            dfcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,dfcOutput.getValue(y,x) + deltaXY);\n            gtcOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,(gtcOutput.getValue(y,x) * dfcOutput.getValue(y,x) + deltaElev) / dfcOutput.getValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex));\n            if (blnTTControl == false) {\n              ttpOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,ttpOutput.getValue(y,x) + Math.pow(deltaXY,2) / deltaElev);\n            }\n else {\n              ttControlMean=(ttControl.getValue(y,x) + ttControl.getValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex)) / 2;\n              ttpOutput.setValue(flowPath.get(flowIndex).rowIndex,flowPath.get(flowIndex).columnIndex,ttpOutput.getValue(y,x) + Math.pow(deltaXY,2) / (deltaElev * ttControlMean));\n            }\n          }\n          for (int i=flowIndex - 1; i >= 0; i--) {\n            if (eacOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) == noData) {\n              eacOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n              dfcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n              gtcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n              ttpOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,noData);\n            }\n else {\n              deltaElev=dem.getValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex) - dem.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex);\n              deltaXY=Math.sqrt(Math.pow(flowPath.get(i).rowIndex - flowPath.get(i + 1).rowIndex,2) + Math.pow(flowPath.get(i).columnIndex - flowPath.get(i + 1).columnIndex,2)) * gridRes;\n              eacOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,eacOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + deltaElev);\n              dfcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,dfcOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + deltaXY);\n              gtcOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,(gtcOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) * dfcOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + deltaElev) / dfcOutput.getValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex));\n              if (blnTTControl == false) {\n                ttpOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,ttpOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + Math.pow(deltaXY,2) / deltaElev);\n              }\n else {\n                ttControlMean=(ttControl.getValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex) + ttControl.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex)) / 2;\n                ttpOutput.setValue(flowPath.get(i).rowIndex,flowPath.get(i).columnIndex,ttpOutput.getValue(flowPath.get(i + 1).rowIndex,flowPath.get(i + 1).columnIndex) + Math.pow(deltaXY,2) / (deltaElev * ttControlMean));\n              }\n            }\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 2 of 2:\",(int)progress);\n    }\n    eacOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    eacOutput.addMetadataEntry(\"Created on \" + new Date());\n    dfcOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    dfcOutput.addMetadataEntry(\"Created on \" + new Date());\n    gtcOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    gtcOutput.addMetadataEntry(\"Created on \" + new Date());\n    ttpOutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    ttpOutput.addMetadataEntry(\"Created on \" + new Date());\n    dem.close();\n    creek.close();\n    if (blnTTControl == true) {\n      ttControl.close();\n    }\n    eacOutput.close();\n    dfcOutput.close();\n    gtcOutput.close();\n    ttpOutput.close();\n    returnData(eacOutputHeader);\n  }\n catch (  Exception e) {\n    showFeedback(e.getMessage());\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public NodesInfoRequest(String... nodesIds){\n  super(nodesIds);\n}\n", "nl": "Get information from nodes based on the nodes ids specified. If none are passed, information for all nodes will be returned."}
{"code": "public static double norm(double[] a){\n  double squaredSum=0;\n  for (int i=0; i < a.length; i++) {\n    squaredSum+=a[i] * a[i];\n  }\n  return Math.sqrt(squaredSum);\n}\n", "nl": "Computes 2-norm of vector"}
{"code": "private static double[] toDoubleAray(Integer[] intArray,HashSet<Integer> skipIndex){\n  double[] res=new double[intArray.length - skipIndex.size()];\n  int skip=0;\n  for (int i=0; i < intArray.length; i++) {\n    if (skipIndex.contains(i)) {\n      skip++;\n      continue;\n    }\n    res[i - skip]=intArray[i].doubleValue();\n  }\n  return res;\n}\n", "nl": "Converts an array into array of doubles skipping specified indeces."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public CompositeValidationIssueProcessor(final IValidationIssueProcessor first,final IValidationIssueProcessor... others){\n  processors=Lists.asList(first,others);\n}\n", "nl": "Creates a new composite issue processor with the given sub processor arguments."}
{"code": "public OptionSet removeMaxAge(){\n  max_age=null;\n  return this;\n}\n", "nl": "Removes the Max-Age option. Returns the current OptionSet object for a fluent API."}
{"code": "public Request(){\n  locality=\"\";\n  state=\"\";\n  organization=\"\";\n  orgunit=\"\";\n  dnsname=\"\";\n  uri=\"\";\n  email=\"\";\n  ipaddress=\"\";\n  keyusage=0;\n}\n", "nl": "Ctor for the Request Object"}
{"code": "@Override protected Position determineMainLabelPosition(DrawContext dc){\n  return this.getReferencePosition();\n}\n", "nl": "Compute the position for the area's main label. This position indicates the position of the first line of the label. If there are more lines, they will be arranged South of the first line."}
{"code": "@Override Map<String,Object> extractFields(String line){\n  if (!initialized) {\n    init();\n    initialized=true;\n  }\n  String[] values=fixedWidthParser.parseLine(line);\n  if (hasHeader && Arrays.deepEquals(values,header)) {\n    return null;\n  }\n  Map<String,Object> map=Maps.newHashMap();\n  int i=0;\n  for (  FixedWidthField field : fields) {\n    map.put(field.getName(),getValue(field,values[i++]));\n  }\n  return map;\n}\n", "nl": "Extracts the fields from a fixed width record and returns a map containing field names and values"}
{"code": "@Override public boolean contains(Value subvalue){\n  return toString().contains(subvalue.toString());\n}\n", "nl": "Returns true if the value is contained in the relation structure. (this is done"}
{"code": "private void applyTo(ClassVisitor v,Field f){\n  if (Log.isLoggingOn()) {\n    Log.logLine(String.format(\"Visiting field %s\",f.toGenericString()));\n  }\n  v.visit(f);\n}\n", "nl": "Apply a visitor to a field."}
{"code": "@Override protected EClass eStaticClass(){\n  return ExpressionsPackage.Literals.BITWISE_AND_EXPRESSION;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public final void closePath(){\n  shape_primitives.addElement(H);\n  shape_primitive_x.addElement(0);\n  shape_primitive_y.addElement(0);\n  shape_primitive_x2.addElement(0);\n  shape_primitive_y2.addElement(0);\n  shape_primitive_x3.addElement(0);\n  shape_primitive_y3.addElement(0);\n}\n", "nl": "end a shape, storing info for later"}
{"code": "public DefaultBoundValueOperations(K key,RedisOperations<K,V> operations){\n  super(key,operations);\n  this.ops=operations.opsForValue();\n}\n", "nl": "Constructs a new <code>DefaultBoundValueOperations</code> instance."}
{"code": "@Override public void writeBatch() throws IOException {\n  if (getInstances() == null) {\n    throw new IOException(\"No instances to save\");\n  }\n  if (getRetrieval() == INCREMENTAL) {\n    throw new IOException(\"Batch and incremental saving cannot be mixed.\");\n  }\n  setRetrieval(BATCH);\n  setWriteMode(WRITE);\n  if ((retrieveFile() == null) && (getWriter() == null)) {\n    for (int i=0; i < getInstances().numInstances(); i++) {\n      System.out.println(instanceToLibsvm(getInstances().instance(i)));\n    }\n    setWriteMode(WAIT);\n  }\n else {\n    PrintWriter outW=new PrintWriter(getWriter());\n    for (int i=0; i < getInstances().numInstances(); i++) {\n      outW.println(instanceToLibsvm(getInstances().instance(i)));\n    }\n    outW.flush();\n    outW.close();\n    setWriteMode(WAIT);\n    outW=null;\n    resetWriter();\n    setWriteMode(CANCEL);\n  }\n}\n", "nl": "Writes a Batch of instances"}
{"code": "public FloatMatrix truthi(){\n  for (int i=0; i < length; i++) {\n    put(i,get(i) == 0.0f ? 0.0f : 1.0f);\n  }\n  return this;\n}\n", "nl": "Maps zero to 0.0 and all non-zero values to 1.0 (in-place)."}
{"code": "public void testCallProcEscapeSequenceWithWhitespaces() throws Exception {\n  check(\"CALL func1()\",\"{ call func1()}\");\n  check(\"CALL func1()\",\"{    call  func1()}\");\n  check(\"CALL func1()\",\"{ \\n call\\nfunc1()}\");\n  checkFail(\"{ \\n func1()}\");\n}\n", "nl": "Test escape sequences with additional whitespace characters"}
{"code": "public EnumRowStatus(Long valueIndex) throws IllegalArgumentException {\n  this(valueIndex.longValue());\n}\n", "nl": "Build an <code>EnumRowStatus</code> from a <code>Long</code>."}
{"code": "private void generateOps708(char[][] screenData,long[][] screenCellData,java.awt.geom.Rectangle2D.Float clipRect,float alphaFactor,float xoff,float yoff,float rowHeight,float currY,float charWidth,float currX){\n  if (reality.isIntegerPixels())   currY=(float)Math.floor(currY);\n  StringBuffer sb=new StringBuffer();\n  printCCBuffer(\"708 CCData to render\",screenData,sb,screenCellData,new StringBuffer());\n  sb.setLength(0);\n  for (int row=0; row < sage.media.sub.CCSubtitleHandler.CC_ROWS && screenData != null; row++) {\n    long lastCellFormat=screenCellData[row][0];\n    if (CellFormat.getBackgroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT && screenData[row][0] == 0) {\n      lastCellFormat=CellFormat.setForeground(lastCellFormat,(byte)CellFormat.getForeground(lastCellFormat),DTVCCOpacity.TRANSPARENT);\n    }\n    rowOffsets[row]=-1;\n    float rowStartY=rowHeight * row;\n    float textOffset=charWidth;\n    int maxCols=screenCellData[row].length - 1;\n    int lastRenderedCol=-1;\n    for (int col=0; col < maxCols; col++) {\n      if (lastCellFormat != screenCellData[row][col]) {\n        int windowID=CellFormat.getWindowID(lastCellFormat);\n        if ((CellFormat.getForegroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT || CellFormat.getBackgroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT)) {\n          textOffset+=render708ops(screenData,screenCellData,clipRect,alphaFactor,xoff,yoff,rowHeight,currY,charWidth,currX,sb,lastCellFormat,rowStartY,textOffset,lastRenderedCol,row,col);\n          lastRenderedCol=col - 1;\n        }\n else {\n          addTo708WindowRect(windowID,xoff + currX + textOffset,yoff + rowStartY,sb.length() * charWidth,rowHeight);\n          textOffset+=sb.length() * charWidth;\n        }\n        sb.setLength(0);\n      }\n      lastCellFormat=screenCellData[row][col];\n      if (CellFormat.getBackgroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT && screenData[row][col] == 0) {\n        lastCellFormat=CellFormat.setForeground(lastCellFormat,(byte)CellFormat.getForeground(lastCellFormat),DTVCCOpacity.TRANSPARENT);\n      }\n      if (CellFormat.getBackgroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT && (CellFormat.getForegroundOpacity(lastCellFormat) == DTVCCOpacity.TRANSPARENT || screenData[row][col] == 0)) {\n        textOffset+=charWidth;\n      }\n else       if (screenData[row][col] != 0) {\n        if (rowOffsets[row] == -1) {\n          rowOffsets[row]=col;\n        }\n        sb.append(screenData[row][col]);\n      }\n else {\n        sb.append(' ');\n      }\n    }\n    if (sb.length() > 0) {\n      if (CellFormat.getForegroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT || CellFormat.getBackgroundOpacity(lastCellFormat) != DTVCCOpacity.TRANSPARENT) {\n        render708ops(screenData,screenCellData,clipRect,alphaFactor,xoff,yoff,rowHeight,currY,charWidth,currX,sb,lastCellFormat,rowStartY,textOffset,lastRenderedCol,row,maxCols);\n      }\n    }\n    sb.setLength(0);\n  }\n  for (  List<RenderingOp> ops : cached708WindowOps) {\n    cachedRenderOps.addAll(ops);\n  }\n}\n", "nl": "Render the 708 caption text to the screen. BIG NOTE(codefu): This wont draw perfectly square boxes with text on it. e.g.: back-filled with black, 2 rows, 32 columns.  Text on second row \"testing\" will produce and image that is stepped.  If we want to draw squares, we need to track the widest character from any font/size that is used."}
{"code": "public static void putbytes2Uint8s(char[] destUint8s,byte[] srcBytes,int destOffset,int srcOffset,int count){\n  for (int i=0; i < count; i++) {\n    destUint8s[destOffset + i]=convertByte2Uint8(srcBytes[srcOffset + i]);\n  }\n}\n", "nl": "Put byte[] into char[]( we treat char[] as uint8[])"}
{"code": "public static void superposeWithAngle(ComplexVector vec1,ComplexVector vec2,float weight,int[] permutation){\n  int positionToAdd;\n  int dim=vec1.getDimension();\n  short c[]=vec2.getPhaseAngles();\n  float[] coordinates=vec1.getCoordinates();\n  if (permutation != null) {\n    for (int i=0; i < dim; i++) {\n      positionToAdd=permutation[i] << 1;\n      coordinates[positionToAdd]+=CircleLookupTable.getRealEntry(c[i]) * weight;\n      coordinates[positionToAdd + 1]+=CircleLookupTable.getImagEntry(c[i]) * weight;\n    }\n  }\n else {\n    for (int i=0; i < dim; i++) {\n      positionToAdd=i << 1;\n      coordinates[positionToAdd]+=CircleLookupTable.getRealEntry(c[i]) * weight;\n      coordinates[positionToAdd + 1]+=CircleLookupTable.getImagEntry(c[i]) * weight;\n    }\n  }\n}\n", "nl": "Superposes vec2 with vec1 with weight and permutation. vec1 is in CARTESIAN mode. vec2 is in POLAR mode."}
{"code": "protected void _addFieldMixIns(Class<?> targetClass,Class<?> mixInCls,Map<String,AnnotatedField> fields){\n  List<Class<?>> parents=new ArrayList<Class<?>>();\n  parents.add(mixInCls);\n  ClassUtil.findSuperTypes(mixInCls,targetClass,parents);\n  for (  Class<?> mixin : parents) {\n    for (    Field mixinField : mixin.getDeclaredFields()) {\n      if (!_isIncludableField(mixinField)) {\n        continue;\n      }\n      String name=mixinField.getName();\n      AnnotatedField maskedField=fields.get(name);\n      if (maskedField != null) {\n        for (        Annotation a : mixinField.getDeclaredAnnotations()) {\n          if (_annotationIntrospector.isHandled(a)) {\n            maskedField.addOrOverride(a);\n          }\n        }\n      }\n    }\n  }\n}\n", "nl": "Method called to add field mix-ins from given mix-in class (and its fields) into already collected actual fields (from introspected classes and their super-classes)"}
{"code": "@Override public boolean input(Instance instance) throws Exception {\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  if (m_NewBatch) {\n    resetQueue();\n    m_NewBatch=false;\n  }\n  double[] vals=new double[instance.numAttributes() + 1];\n  for (int i=0; i < instance.numAttributes(); i++) {\n    if (instance.isMissing(i)) {\n      vals[i]=Utils.missingValue();\n    }\n else {\n      vals[i]=instance.value(i);\n    }\n  }\n  m_attributeExpression.evaluateExpression(vals);\n  Instance inst=null;\n  if (instance instanceof SparseInstance) {\n    inst=new SparseInstance(instance.weight(),vals);\n  }\n else {\n    inst=new DenseInstance(instance.weight(),vals);\n  }\n  inst.setDataset(getOutputFormat());\n  copyValues(inst,false,instance.dataset(),getOutputFormat());\n  inst.setDataset(getOutputFormat());\n  push(inst);\n  return true;\n}\n", "nl": "Input an instance for filtering. Ordinarily the instance is processed and made available for output immediately. Some filters require all instances be read before producing output."}
{"code": "public String lookup(String data){\n  Iterator<String> it=map.getPrefixedBy(data);\n  if (!it.hasNext())   return null;\n  return it.next();\n}\n", "nl": "Return the last String in the set that can be prefixed by this String (Trie's are stored in alphabetical order). Return null if no such String exist in the current set."}
{"code": "public boolean attempt(LiveAnalysis live,Register r1,Register r2){\n  if (isLiveAtDef(r2,r1,live))   return false;\n  if (isLiveAtDef(r1,r2,live))   return false;\n  if (split(r1,r2))   return false;\n  if (r1 == r2)   return false;\n  live.merge(r1,r2);\n  for (Enumeration<RegisterOperand> e=DefUse.defs(r2); e.hasMoreElements(); ) {\n    RegisterOperand def=e.nextElement();\n    DefUse.removeDef(def);\n    def.setRegister(r1);\n    DefUse.recordDef(def);\n  }\n  for (Enumeration<RegisterOperand> e=DefUse.uses(r2); e.hasMoreElements(); ) {\n    RegisterOperand use=e.nextElement();\n    DefUse.removeUse(use);\n    use.setRegister(r1);\n    DefUse.recordUse(use);\n  }\n  return true;\n}\n", "nl": "Attempt to coalesce register r2 into register r1.  If this is legal, <ul> <li> rewrite all defs and uses of r2 as defs and uses of r1 <li> update the liveness information <li> update the def-use chains </ul> <strong>PRECONDITION </strong> def-use chains must be computed and valid."}
{"code": "private void registerTarget(final Message message,final String virtualHost){\n  final String thingId=getStringHeaderKey(message,MessageHeaderKey.THING_ID,\"ThingId is null\");\n  final String replyTo=message.getMessageProperties().getReplyTo();\n  if (StringUtils.isEmpty(replyTo)) {\n    logAndThrowMessageError(message,\"No ReplyTo was set for the createThing Event.\");\n  }\n  final URI amqpUri=IpUtil.createAmqpUri(virtualHost,replyTo);\n  final Target target=controllerManagement.findOrRegisterTargetIfItDoesNotexist(thingId,amqpUri);\n  LOG.debug(\"Target {} reported online state.\",thingId);\n  lookIfUpdateAvailable(target);\n}\n", "nl": "Method to create a new target or to find the target if it already exists."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public long term(){\n  return term;\n}\n", "nl": "Returns the responding node's current term."}
{"code": "public void purgePlayer(Player player){\n  zombies.remove(player.getUniqueId());\n  humans.remove(player.getUniqueId());\n}\n", "nl": "Removes the player from the current ADTs."}
{"code": "public RestClient(String target,String username,String password,CloseableHttpAsyncClient asyncClient){\n  checkNotNull(target,\"target cannot be null\");\n  checkNotNull(username,\"username cannot be null\");\n  checkNotNull(password,\"password cannot be null\");\n  this.target=target;\n  this.clientContext=getHttpClientContext(target,username,password);\n  this.asyncClient=asyncClient == null ? getHttpClient() : asyncClient;\n}\n", "nl": "Constructs a RestClient."}
{"code": "private String createPatternHash(int baseColorIndex){\n  String hashSource=\"\" + baseColorIndex + \"\";\n  int count=0;\nsynchronized (PatternList) {\n    for (    BannerPattern bp : PatternList) {\n      if (count++ != 0) {\n        hashSource+=\"-\";\n      }\n      hashSource+=bp.toString();\n    }\n  }\n  return hashSource;\n}\n", "nl": "Creates a uniq string for combination of patterns"}
{"code": "public void close() throws IOException {\n  super.close();\n  disposerRecord.dispose();\n  stream=null;\n  cache=null;\n  cacheFile=null;\n  StreamCloser.removeFromQueue(closeAction);\n}\n", "nl": "Closes this <code>FileCacheImageInputStream</code>, closing and removing the cache file.  The source <code>InputStream</code> is not closed."}
{"code": "public static Uri importContent(String sessionId,String sourcePath) throws IOException {\n  File sourceFile=new File(sourcePath);\n  String targetPath=\"/\" + sessionId + \"/upload/\"+ sourceFile.getName();\n  targetPath=createUniqueFilename(targetPath);\n  copyToVfs(sourcePath,targetPath);\n  return vfsUri(targetPath);\n}\n", "nl": "Copy device content into vfs. All imported content is stored under /SESSION_NAME/ The original full path is retained to facilitate browsing The session content can be deleted when the session is over"}
{"code": "public static ProjectActionEvent createProjectClosedEvent(ProjectDescriptor project,boolean closingBeforeOpening){\n  return new ProjectActionEvent(project,ProjectAction.CLOSED,closingBeforeOpening);\n}\n", "nl": "Creates a Project Closed Event."}
{"code": "public static void initiateItemEvent(EntityPlayer player,ItemStack itemStack,int event,boolean limitRange){\n  try {\n    if (NetworkManager_initiateItemEvent == null)     NetworkManager_initiateItemEvent=Class.forName(getPackage() + \".core.network.NetworkManager\").getMethod(\"initiateItemEvent\",EntityPlayer.class,ItemStack.class,Integer.TYPE,Boolean.TYPE);\n    if (instance == null)     instance=getInstance();\n    NetworkManager_initiateItemEvent.invoke(instance,player,itemStack,event,limitRange);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Immediately send an event for the specified Item to the clients in range. The item should implement INetworkItemEventListener to receive the event. If this method is being executed on the client (i.e. Singleplayer), it'll just call INetworkItemEventListener.onNetworkEvent (if implemented by the item)."}
{"code": "public Enumeration<V> elements(){\n  return new ValueIterator();\n}\n", "nl": "Returns an enumeration of the values in this table."}
{"code": "private boolean trackerAt(StendhalRPZone zone,int x,int y){\n  final List<Entity> list=zone.getEntitiesAt(x,y);\n  for (  Entity entity : list) {\n    if (entity instanceof ExpirationTracker) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks to see if an ExpirationTracker is already at a given coordinate to prevent multiple one from accumulating in the database"}
{"code": "public Segment segment(long index){\n  assertOpen();\n  if (currentSegment != null && currentSegment.validIndex(index))   return currentSegment;\n  Map.Entry<Long,Segment> segment=segments.floorEntry(index);\n  return segment != null ? segment.getValue() : null;\n}\n", "nl": "Returns the segment for the given index."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:20.138 -0400\",hash_original_method=\"5CC57CD7C5B9408E54C315A9BE16050C\",hash_generated_method=\"E0C143C4A578FB33A41B66D46278449D\") public int nextInt(int least,int bound){\n  if (least >= bound)   throw new IllegalArgumentException();\n  return nextInt(bound - least) + least;\n}\n", "nl": "Returns a pseudorandom, uniformly distributed value between the given least value (inclusive) and bound (exclusive)."}
{"code": "protected ECPoint multiplyPositive(ECPoint p,BigInteger k){\n  ECPoint[] R=new ECPoint[]{p.getCurve().getInfinity(),p};\n  int n=k.bitLength();\n  for (int i=0; i < n; ++i) {\n    int b=k.testBit(i) ? 1 : 0;\n    int bp=1 - b;\n    R[bp]=R[bp].twicePlus(R[b]);\n  }\n  return R[0];\n}\n", "nl": "Joye's double-add algorithm."}
{"code": "void listItemsSortedSecure() throws Exception {\n  System.out.println(\"Secure Systems Inc. - list items\");\n  String order=input(\"order (id, name)?\");\n  if (!order.matches(\"[a-zA-Z0-9_]*\")) {\n    order=\"id\";\n  }\n  try {\n    ResultSet rs=stat.executeQuery(\"SELECT ID, NAME FROM ITEMS ORDER BY \" + order);\n    while (rs.next()) {\n      System.out.println(rs.getString(1) + \": \" + rs.getString(2));\n    }\n  }\n catch (  SQLException e) {\n    System.out.println(e);\n  }\n}\n", "nl": "List items using a specified sort order. The method is secure as the user input is validated before use. However the database has no chance to verify this."}
{"code": "private int readInt(InputStream is) throws IOException {\n  return ((is.read() << 24) | (is.read() << 16) | (is.read() << 8)| (is.read()));\n}\n", "nl": "Parses a 32-bit int."}
{"code": "void enableConfirmButtons(){\n  confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipConfirmChangesSheet\"));\n  confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipConfirmAllSheet\"));\n  if (_cvModel.getProgrammer() != null && !_cvModel.getProgrammer().getCanRead()) {\n    confirmChangesButton.setEnabled(false);\n    confirmAllButton.setEnabled(false);\n    confirmChangesButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipNoRead\"));\n    confirmAllButton.setToolTipText(SymbolicProgBundle.getMessage(\"TipNoRead\"));\n  }\n else {\n    confirmChangesButton.setEnabled(true);\n    confirmAllButton.setEnabled(true);\n  }\n}\n", "nl": "Enable the compare all and compare changes button if possible. This checks to make sure this is appropriate, given the attached programmer's capability."}
{"code": "private String eventName(String taskType,int taskNum,String evtType){\n  assert nodeId != null;\n  return taskType + \" \" + taskNum+ \" \"+ evtType+ \" \"+ nodeId;\n}\n", "nl": "Generate name that consists of some event information."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.ACTION___ANONYMOUS_ACTION_11:\n    return ((InternalEList<?>)getAnonymous_action_1_1()).basicRemove(otherEnd,msgs);\ncase UmplePackage.ACTION___ANONYMOUS_ACTION_21:\n  return ((InternalEList<?>)getAnonymous_action_2_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void showPathInFileBrowser(final Path path){\n  try {\n    final boolean isFolder=Files.isDirectory(path);\n    final boolean isFile=!isFolder;\n    if (isFile && LEnv.OS == OpSys.WINDOWS) {\n      new ProcessBuilder(\"explorer.exe\",\"/select,\",path.toAbsolutePath().toString()).start();\n    }\n else     Desktop.getDesktop().open(isFolder ? path.toFile() : path.getParent().toFile());\n  }\n catch (  final IOException ie) {\n    LEnv.LOGGER.warning(\"Failed to open file browser!\",ie);\n  }\n}\n", "nl": "Opens the specified file or folder in the default file browser application of the user's OS. <p> If a file is specified, on Windows it will also be selected. </p>"}
{"code": "private <T>T processExtremes(Stamp forX,Stamp forY,BiFunction<Long,Long,T> op){\n  IntegerStamp xStamp=(IntegerStamp)forX;\n  IntegerStamp yStamp=(IntegerStamp)forY;\n  JavaKind kind=getStackKind();\n  assert kind == JavaKind.Int || kind == JavaKind.Long;\n  long[] xExtremes=getUnsignedExtremes(xStamp);\n  long[] yExtremes=getUnsignedExtremes(yStamp);\n  long min=Long.MAX_VALUE;\n  long max=Long.MIN_VALUE;\n  for (  long a : xExtremes) {\n    for (    long b : yExtremes) {\n      long result=kind == JavaKind.Int ? multiplyHighUnsigned((int)a,(int)b) : multiplyHighUnsigned(a,b);\n      min=Math.min(min,result);\n      max=Math.max(max,result);\n    }\n  }\n  return op.apply(min,max);\n}\n", "nl": "Determines the minimum and maximum result of this node for the given inputs and returns the result of the given BiFunction on the minimum and maximum values. Note that the minima and maxima are calculated using signed min/max functions, while the values themselves are unsigned."}
{"code": "public String toSignatureString(){\n  StringBuilder sb=new StringBuilder();\n  String accessLevel=convertModifiersToAccessLevel(mModifier);\n  if (!\"\".equals(accessLevel)) {\n    sb.append(accessLevel).append(\" \");\n  }\n  if (!JDiffType.INTERFACE.equals(mClassType)) {\n    String modifierString=convertModifersToModifierString(mModifier);\n    if (!\"\".equals(modifierString)) {\n      sb.append(modifierString).append(\" \");\n    }\n    sb.append(\"class \");\n  }\n else {\n    sb.append(\"interface \");\n  }\n  sb.append(mShortClassName);\n  if (mExtendedClass != null) {\n    sb.append(\" extends \").append(mExtendedClass).append(\" \");\n  }\n  if (implInterfaces.size() > 0) {\n    sb.append(\" implements \");\n    for (int x=0; x < implInterfaces.size(); x++) {\n      String interf=implInterfaces.get(x);\n      sb.append(interf);\n      if (x + 1 != implInterfaces.size()) {\n        sb.append(\", \");\n      }\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Convert the class into a printable signature string."}
{"code": "public void showPopup(){\n  if (getPopup() != null) {\n    getPopup().setVisible(true);\n  }\n}\n", "nl": "if a JPopupMenu is set, it is displayed again. Displaying this dialog closes any JPopupMenu automatically."}
{"code": "public boolean isGame(){\n  return true;\n}\n", "nl": "Determines if this marker is a game. Default is true, so override is only necessary if implementation is not a game."}
{"code": "private FigureLayerComparator(){\n}\n", "nl": "Creates a new instance."}
{"code": "public TDoubleDoubleHashMap normalizedDistribution(){\n  return normalizedDistribution(absoluteDistribution());\n}\n", "nl": "Returns a histogram of all samples where the values are normalized so that the sum of all samples equals one."}
{"code": "private void waitForUsers(URI hostUri,String authToken) throws Throwable {\n  URI usersLink=UriUtils.buildUri(hostUri,UserService.FACTORY_LINK);\n  Integer[] numberUsers=new Integer[1];\n  for (int i=0; i < 20; i++) {\n    Operation get=Operation.createGet(usersLink).forceRemote().addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER,authToken).setCompletion(null);\n    this.host.testStart(1);\n    this.host.send(get);\n    this.host.testWait();\n    if (numberUsers[0] == 2) {\n      break;\n    }\n    Thread.sleep(250);\n  }\n  assertTrue(numberUsers[0] == 2);\n}\n", "nl": "Supports createUsers() by waiting for two users to be created. They aren't created immediately, so this polls."}
{"code": "public synchronized int send(byte[] buffer,int offset,int len) throws IOException {\n  if (m_state != PseudoTcpState.TCP_ESTABLISHED) {\n    throw new IOException(\"Socket not connected\");\n  }\n  long available_space;\n  available_space=m_sbuf.getWriteRemaining();\n  if (available_space == 0) {\n    m_bWriteEnable=true;\n    return 0;\n  }\n  int written=queue(buffer,offset,len,false);\n  attemptSend(SendFlags.sfNone);\n  return written;\n}\n", "nl": "Enqueues data in the send buffer"}
{"code": "public SampleAxioms(){\n  super();\n}\n", "nl": "De-serialization ctor."}
{"code": "public void validateTagTypeKey(TagTypeKey tagTypeKey) throws IllegalArgumentException {\n  Assert.notNull(tagTypeKey,\"A tag type key must be specified.\");\n  tagTypeKey.setTagTypeCode(alternateKeyHelper.validateStringParameter(\"tag type code\",tagTypeKey.getTagTypeCode()));\n}\n", "nl": "Validates a tag type key. This method also trims the key parameters."}
{"code": "public static BigInteger nextPrime(long n){\n  long i;\n  boolean found=false;\n  long result=0;\n  if (n <= 1) {\n    return BigInteger.valueOf(2);\n  }\n  if (n == 2) {\n    return BigInteger.valueOf(3);\n  }\n  for (i=n + 1 + (n & 1); (i <= n << 1) && !found; i+=2) {\n    for (long j=3; (j <= i >> 1) && !found; j+=2) {\n      if (i % j == 0) {\n        found=true;\n      }\n    }\n    if (found) {\n      found=false;\n    }\n else {\n      result=i;\n      found=true;\n    }\n  }\n  return BigInteger.valueOf(result);\n}\n", "nl": "Computes the next prime greater than n."}
{"code": "@Override public void addCharacterToOutput(final Entry<Character,GrayscaleMatrix> characterEntry,final int[] sourceImagePixels,final int tileX,final int tileY,final int imageWidth){\n  this.output.append(characterEntry.getKey());\n  if ((tileX + 1) * this.characterCache.getCharacterImageSize().getWidth() == imageWidth) {\n    this.output.append(System.lineSeparator());\n  }\n}\n", "nl": "Append choosen character to StringBuffer."}
{"code": "@VisibleForTesting static int chooseTableSize(int setSize){\n  if (setSize == 1) {\n    return 2;\n  }\n  int tableSize=Integer.highestOneBit(setSize - 1) << 1;\n  while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\n    tableSize<<=1;\n  }\n  return tableSize;\n}\n", "nl": "Returns an array size suitable for the backing array of a hash table that uses open addressing with linear probing in its implementation. The returned size is the smallest power of two that can hold setSize elements with the desired load factor."}
{"code": "public void validateMinimum(){\n  double newMin;\n  try {\n    newMin=Double.parseDouble(this.minimumRangeValue.getText());\n    if (newMin >= this.maximumValue) {\n      newMin=this.minimumValue;\n    }\n  }\n catch (  NumberFormatException e) {\n    newMin=this.minimumValue;\n  }\n  this.minimumValue=newMin;\n  this.minimumRangeValue.setText(Double.toString(this.minimumValue));\n}\n", "nl": "Revalidate the range minimum."}
{"code": "public static void init(ActorSystem actorSystem){\n  if (instance == null) {\n    instance=actorSystem.actorOf(Props.create(BatchSigner.class));\n  }\n}\n", "nl": "Initializes the batch signer with the given actor system."}
{"code": "private static void dump(PrintData pd){\n  dumpHeader(pd);\n  for (int i=0; i < pd.getRowCount(); i++)   dumpRow(pd,i);\n}\n", "nl": "Dump all PrintData - header and rows"}
{"code": "public boolean isHIGHER(){\n  return value == HIGHER;\n}\n", "nl": "Is the condition code HIGHER?"}
{"code": "public Matrix4x3d rotateZ(double ang){\n  return rotateZ(ang,this);\n}\n", "nl": "Apply rotation about the Z axis to this matrix by rotating the given amount of radians. <p> When used with a right-handed coordinate system, the produced rotation will rotate a vector  counter-clockwise around the rotation axis, when viewing along the negative axis direction towards the origin. When used with a left-handed coordinate system, the rotation is clockwise. <p> If <code>M</code> is <code>this</code> matrix and <code>R</code> the rotation matrix, then the new matrix will be <code>M * R</code>. So when transforming a vector <code>v</code> with the new matrix by using <code>M * R * v</code>, the rotation will be applied first! <p> Reference: <a href=\"http://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations\">http://en.wikipedia.org</a>"}
{"code": "@Override protected URLConnection openConnection(URL url,Proxy proxy) throws IOException {\n  if (url == null || proxy == null) {\n    throw new IllegalArgumentException(\"url == null || proxy == null\");\n  }\n  return new FtpURLConnection(url,proxy);\n}\n", "nl": "Returns a connection, which is established via the <code>proxy</code>, to the FTP server specified by this <code>URL</code>. If <code>proxy</code> is DIRECT type, the connection is made in normal way."}
{"code": "private boolean saveMacro(){\n  if (firstTime) {\n    try {\n      Thread.sleep(firstTimeSleep);\n    }\n catch (    InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n  firstTime=false;\n  byte[] macroAccy=new byte[macroSize];\n  int index=0;\n  int accyNum=0;\n  accyNum=getAccyRow(macroAccy,index,textAccy1,accyTextField1,cmdButton1);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy2,accyTextField2,cmdButton2);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy3,accyTextField3,cmdButton3);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy4,accyTextField4,cmdButton4);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy5,accyTextField5,cmdButton5);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy6,accyTextField6,cmdButton6);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy7,accyTextField7,cmdButton7);\n  if (accyNum < 0) {\n    return false;\n  }\n  if (accyNum > 0) {\n    index+=2;\n  }\n  if (!isUsb) {\n    accyNum=getAccyRow(macroAccy,index,textAccy8,accyTextField8,cmdButton8);\n    if (accyNum < 0) {\n      return false;\n    }\n    if (accyNum > 0) {\n      index+=2;\n    }\n    accyNum=getAccyRow(macroAccy,index,textAccy9,accyTextField9,cmdButton9);\n    if (accyNum < 0) {\n      return false;\n    }\n    if (accyNum > 0) {\n      index+=2;\n    }\n  }\n  accyNum=getAccyRow(macroAccy,index,textAccy10,accyTextField10,cmdButton10);\n  if (accyNum < 0) {\n    JOptionPane.showMessageDialog(this,rb.getString(\"EnterMacroNumberLine10\"),rb.getString(\"NceMacro\"),JOptionPane.ERROR_MESSAGE);\n    return false;\n  }\n  processMemory(false,true,macroNum,macroAccy);\n  return true;\n}\n", "nl": "Writes all bytes to NCE CS memory as long as there are no user input errors"}
{"code": "private boolean matchesMobile4g(NetworkIdentity ident){\n  ensureSubtypeAvailable();\n  if (ident.mType == TYPE_WIMAX) {\n    return true;\n  }\n else   if (matchesMobile(ident)) {\nswitch (getNetworkClass(ident.mSubType)) {\ncase NETWORK_CLASS_4_G:\n      return true;\n  }\n}\nreturn false;\n}\n", "nl": "Check if mobile network classified 4G with matching IMSI."}
{"code": "public void writeToBuffer(ByteBuf buffer) throws Exception {\n  if (id != -1) {\n    Type.VAR_INT.write(buffer,id);\n  }\n  if (readableObjects.size() > 0) {\n    packetValues.addAll(readableObjects);\n    readableObjects.clear();\n  }\n  int index=0;\n  for (  Pair<Type,Object> packetValue : packetValues) {\n    try {\n      Object value=packetValue.getValue();\n      if (value != null) {\n        if (!packetValue.getKey().getOutputClass().isAssignableFrom(value.getClass())) {\n          if (packetValue.getKey() instanceof TypeConverter) {\n            value=((TypeConverter)packetValue.getKey()).from(value);\n          }\n else {\n            System.out.println(\"Possible type mismatch: \" + value.getClass().getName() + \" -> \"+ packetValue.getKey().getOutputClass());\n          }\n        }\n      }\n      packetValue.getKey().write(buffer,value);\n    }\n catch (    Exception e) {\n      throw new InformativeException(e).set(\"Index\",index).set(\"Type\",packetValue.getKey().getTypeName()).set(\"Packet ID\",getId()).set(\"Data\",packetValues);\n    }\n    index++;\n  }\n  writeRemaining(buffer);\n}\n", "nl": "Write the current output to a buffer."}
{"code": "public RandomDecisionTree(int numFeatures,int maxDepth,int minSamples,TreePruner.PruningMethod pruningMethod,double testProportion){\n  super(maxDepth,minSamples,pruningMethod,testProportion);\n  setRandomFeatureCount(numFeatures);\n}\n", "nl": "Creates a new Random Decision Tree"}
{"code": "protected void fireCommentEvent(char[] chars,int start,int length) throws org.xml.sax.SAXException {\n  if (m_tracer != null) {\n    flushMyWriter();\n    m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_COMMENT,new String(chars,start,length));\n  }\n}\n", "nl": "Report the comment trace event"}
{"code": "private void init(Context context,AttributeSet attrs,RuqusTheme theme){\n  inflate(context,R.layout.rqv_card,this);\n  outlineView=(FrameLayout)findViewById(R.id.outline);\n  outlineTextView=(TextView)findViewById(R.id.outline_text);\n  cardView=(CardView)findViewById(R.id.card);\n  cardTextView=(TextView)findViewById(R.id.card_text);\n  setTheme(theme);\n  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.RQVCard);\n  mode=typedArray.getInt(R.styleable.RQVCard_rqv_card_mode,0) == 0 ? Mode.OUTLINE : Mode.CARD;\n  outlineTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_outline_text));\n  cardTextView.setText(typedArray.getString(R.styleable.RQVCard_rqv_card_text));\n  typedArray.recycle();\n}\n", "nl": "Initialize our view."}
{"code": "public void onUndeploy(ClassLoader ldr){\n  for (  Class<?> cls : descByCls.keySet()) {\n    if (ldr.equals(cls.getClassLoader()))     descByCls.remove(cls);\n  }\n  U.clearClassCache(ldr);\n}\n", "nl": "Undeployment callback invoked when class loader is being undeployed. Some marshallers may want to clean their internal state that uses the undeployed class loader somehow."}
{"code": "@Override public int compare(final Long o1,final Long o2){\n  if (o1.longValue() < o2.longValue())   return 1;\n  if (o1.longValue() > o2.longValue())   return -1;\n  return 0;\n}\n", "nl": "Comparator puts the entries into descending order by the query execution time (longest running queries are first)."}
{"code": "public void testResourceParameterOfListType(){\n  doTest();\n}\n", "nl": "Tests that a ResourceParameterInspection error is generated for a resource parameter of List type."}
{"code": "public TeXFormula add(String s) throws ParseException {\n  if (s != null && s.length() != 0) {\n    textStyle=null;\n    add(new TeXFormula(s));\n  }\n  return this;\n}\n", "nl": "Parses the given string and inserts the resulting formula at the end of the current TeXFormula."}
{"code": "public ResponseEntity<List<Recommendation>> defaultRecommendations(int productId){\n  LOG.warn(\"Using fallback method for recommendation-service\");\n  return util.createResponse(Arrays.asList(new Recommendation(productId,1,\"Fallback Author 1\",1,\"Fallback Content 1\")),HttpStatus.OK);\n}\n", "nl": "Fallback method for getRecommendations()"}
{"code": "private void cmd_annotateDifference(){\n  BigDecimal previousValue, actualValue, difference;\n  previousValue=(BigDecimal)v_previousBalance.getValue();\n  actualValue=(BigDecimal)v_ActualBalance.getValue();\n  difference=actualValue.subtract(previousValue);\n  MCashBook cashBook=new MCashBook(p_ctx,p_pos.getC_CashBook_ID(),null);\n  Timestamp today=TimeUtil.getDay(System.currentTimeMillis());\n  MCash cash=MCash.get(p_ctx,cashBook.getC_CashBook_ID(),today,null);\n  if (cash != null && cash.get_ID() != 0 && difference.compareTo(cash.getStatementDifference()) != 0) {\n    MCashLine cl=new MCashLine(cash);\n    cl.setCashType(MCashLine.CASHTYPE_Difference);\n    cl.setAmount(difference);\n    cl.setDescription(Msg.translate(p_pos.getCtx(),\"Cash Scrutiny -> Before: \") + previousValue + \" Now: \"+ actualValue);\n    cl.saveEx();\n  }\n  cash=MCash.get(p_pos.getCtx(),p_pos.getC_CashBook_ID(),today,null);\n  v_previousBalance.setValue(cash.getEndingBalance());\n  v_ActualBalance.setValue(Env.ZERO);\n  v_difference.setValue(Env.ZERO);\n}\n", "nl": "Annotate the difference between previous balance and actual from cash scrutiny in the cash book"}
{"code": "public boolean hasJpgThumbnail(){\n  if (getThumbnailType() != ExifDirectory.COMPRESSION_JPEG)   return false;\n  byte[] thumbData;\n  try {\n    ExifDirectory exif=(ExifDirectory)metadata.getDirectory(ExifDirectory.class);\n    thumbData=exif.getThumbnailData();\n  }\n catch (  MetadataException e) {\n    return false;\n  }\n  if (thumbData.length > 2) {\n    int magicNumber;\n    magicNumber=(thumbData[0] & 0xFF) << 8;\n    magicNumber|=(thumbData[1] & 0xFF);\n    if (magicNumber == ImageMetadataReader.JPEG_FILE_MAGIC_NUMBER)     return true;\n  }\n  return false;\n}\n", "nl": "Performs checks to determine if the image has a JPG thumbnail in the EXIF data. <p> The EXIF TAG_COMPRESION , and the magic number at the beginning of the thumbnail bytes are used to verify that the thumb is in JPG format"}
{"code": "private void waitForRScriptInitialized() throws InterpreterException {\nsynchronized (rScriptInitializeNotifier) {\n    long startTime=System.nanoTime();\n    while (rScriptInitialized == false && rScriptRunning && System.nanoTime() - startTime < 10L * 1000 * 1000000) {\n      try {\n        rScriptInitializeNotifier.wait(1000);\n      }\n catch (      InterruptedException e) {\n        logger.error(e.getMessage(),e);\n      }\n    }\n  }\n  String errorMessage=\"\";\n  try {\n    initialOutput.flush();\n    errorMessage=new String(initialOutput.toByteArray());\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n  if (rScriptInitialized == false) {\n    throw new InterpreterException(\"sparkr is not responding \" + errorMessage);\n  }\n}\n", "nl": "Wait until src/main/resources/R/zeppelin_sparkr.R is initialized and call onScriptInitialized()"}
{"code": "private DefaultUnitConverter(){\n}\n", "nl": "Constructs a DefaultUnitConverter and registers a listener that handles changes in the look&amp;feel."}
{"code": "public static String morpha(String text,boolean tags){\n  if (text.isEmpty()) {\n    return \"\";\n  }\n  String[] textParts=whitespace.split(text);\n  StringBuilder result=new StringBuilder();\n  try {\n    for (    String textPart : textParts) {\n      Morpha morpha=new Morpha(new StringReader(textPart),tags);\n      if (result.length() != 0) {\n        result.append(\" \");\n      }\n      result.append(morpha.next());\n    }\n  }\n catch (  Error e) {\n    return text;\n  }\ncatch (  java.io.IOException e) {\n    return text;\n  }\n  return result.toString();\n}\n", "nl": "Run the morpha algorithm on the specified string."}
{"code": "protected void readUnzipedResponse(InputStream input) throws IOException {\n  super.readResponse(input);\n}\n", "nl": "This method can be overridden instead of readResponse"}
{"code": "public EventStream<S> events() throws Exception {\n  return EventStream.empty();\n}\n", "nl": "Returns a stream of events that should be recorded. By default, an empty stream returned."}
{"code": "public Object invoke(Remote obj,java.lang.reflect.Method method,Object[] params,long opnum) throws Exception {\n  boolean force=false;\n  RemoteRef localRef;\n  Exception exception=null;\nsynchronized (this) {\n    if (ref == null) {\n      localRef=activate(force);\n      force=true;\n    }\n else {\n      localRef=ref;\n    }\n  }\n  for (int retries=MAX_RETRIES; retries > 0; retries--) {\n    try {\n      return localRef.invoke(obj,method,params,opnum);\n    }\n catch (    NoSuchObjectException e) {\n      exception=e;\n    }\ncatch (    ConnectException e) {\n      exception=e;\n    }\ncatch (    UnknownHostException e) {\n      exception=e;\n    }\ncatch (    ConnectIOException e) {\n      exception=e;\n    }\ncatch (    MarshalException e) {\n      throw e;\n    }\ncatch (    ServerError e) {\n      throw e;\n    }\ncatch (    ServerException e) {\n      throw e;\n    }\ncatch (    RemoteException e) {\nsynchronized (this) {\n        if (localRef == ref) {\n          ref=null;\n        }\n      }\n      throw e;\n    }\n    if (retries > 1) {\nsynchronized (this) {\n        if (localRef.remoteEquals(ref) || ref == null) {\n          RemoteRef newRef=activate(force);\n          if (newRef.remoteEquals(localRef) && exception instanceof NoSuchObjectException && force == false) {\n            newRef=activate(true);\n          }\n          localRef=newRef;\n          force=true;\n        }\n else {\n          localRef=ref;\n          force=false;\n        }\n      }\n    }\n  }\n  throw exception;\n}\n", "nl": "Invoke method on remote object. This method delegates remote method invocation to the underlying ref type.  If the underlying reference is not known (is null), then the object must be activated first.  If an attempt at method invocation fails, the object should force reactivation.  Method invocation must preserve \"at most once\" call semantics.  In RMI, \"at most once\" applies to parameter deserialization at the remote site and the remote object's method execution.  \"At most once\" does not apply to parameter serialization at the client so the parameters of a call don't need to be buffered in anticipation of call retry. Thus, a method call is only be retried if the initial method invocation does not execute at all at the server (including parameter deserialization)."}
{"code": "public String lookupCacheSizeTipText(){\n  return \"Set the maximum size of the lookup cache of evaluated subsets. This is \" + \"expressed as a multiplier of the number of attributes in the data set. \" + \"(default = 1).\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "private SimpleObject providerToJson(Provider provider){\n  SimpleObject jsonForm=new SimpleObject();\n  if (provider != null) {\n    jsonForm.add(USER_ID,provider.getUuid());\n    jsonForm.add(FULL_NAME,provider.getName());\n    Person person=provider.getPerson();\n    if (person != null) {\n      jsonForm.add(GIVEN_NAME,person.getGivenName());\n      jsonForm.add(FAMILY_NAME,person.getFamilyName());\n    }\n  }\n  return jsonForm;\n}\n", "nl": "Builds a SimpleObject describing the given Provider."}
{"code": "@Override public int next() throws XMLStreamException {\n  log.fine(\"next()\");\n  if (event == START_DOCUMENT) {\n    event=START_ELEMENT;\n    elementIndex.currentElement=parser.getDocument().getBody().getElement();\n  }\n else   if (event == START_ELEMENT) {\n    elementIndex.index=0;\n    event=nextInElement(false);\n  }\n else   if (event == ATTRIBUTE) {\n    elementIndex.index=0;\n    event=nextInElement(false);\n  }\n else   if (event == CHARACTERS) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == SPACE) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == ENTITY_REFERENCE) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == PROCESSING_INSTRUCTION) {\n    elementIndex.index++;\n    event=nextInElement(false);\n  }\n else   if (event == END_ELEMENT) {\n    if (parents.isEmpty()) {\n      event=END_DOCUMENT;\n    }\n else {\n      elementIndex=parents.pop();\n      elementIndex.index++;\n      event=nextInElement(false);\n    }\n  }\n else   if (event == END_DOCUMENT) {\n    throw new XMLStreamException(\"End of coument reached!\");\n  }\n else {\n    throw new XMLStreamException(\"Invalid event state!\");\n  }\n  log.log(Level.FINE,\"next(): {0}\",event);\n  return event;\n}\n", "nl": "Get next parsing event - a processor may return all contiguous character  data in a single chunk, or it may split it into several chunks. If the  property javax.xml.stream.isCoalescing is set to true element content  must be coalesced and only one CHARACTERS event must be returned for  contiguous element content or CDATA Sections. By default entity  references must be expanded and reported transparently to the application.  An exception will be thrown if an entity reference cannot be expanded.  If element content is empty (i.e. content is \"\") then no CHARACTERS  event will be reported. <p>This method marks the current element and index using the elementIndex structure. Besides a queue of parents element index is maintained to cross over all element hierarchy.</p> <p>The WbXMLStreamReader only manages the following states:</p> <ul> <li>START_DOCUMENT</li> <li>PROCESSING_INSTRUCTION</li> <li>START_ELEMENT</li> <li>ATTRIBUTE</li> <lI>CHARACTERS</li> <li>END_ELEMENT</li> <li>SPACE</li> <li>END_DOCUMENT</li> <li>ENTITY_REFERENCE</li> </ul> <p>Therefore the following element does no matter in this stream reader:</p> <ul> <li>CDATA (CHARACTERS are used always).</li> <li>COMMENT (no comments in WBXML).</li> <li>DTD (no DTD section)</li> <li>ENTITY_DECLARATION</li> <li>NAMESPACE</li> <li>NOTATION DECLARATION</li> </ul>"}
{"code": "@SuppressWarnings(\"unchecked\") public synchronized List<Relationship> findAllRelationshipsTo(Vertex vertex){\n  Query query=this.entityManager.createQuery(\"Select r from Relationship r where r.target = :vertex or r.type = :vertex\");\n  setHints(query);\n  query.setParameter(\"vertex\",vertex);\n  return query.getResultList();\n}\n", "nl": "Find all relationships related to the vertex or of the vertex relationship type."}
{"code": "public static String convertMethodSignature(InvokeInstruction inv,ConstantPoolGen cpg){\n  return convertMethodSignature(inv.getClassName(cpg),inv.getName(cpg),inv.getSignature(cpg));\n}\n", "nl": "Convenience method for generating a method signature in human readable form."}
{"code": "@Override public int count(Selector obj){\n  if ((obj.getMask() & Selector.MASK_INSTANCE) > 0) {\n    if (device.findObject(obj.toUiSelector()).exists())     return 1;\n else     return 0;\n  }\n else {\n    UiSelector sel=obj.toUiSelector();\n    if (!device.findObject(sel).exists())     return 0;\n    int low=1;\n    int high=2;\n    sel=sel.instance(high - 1);\n    while (device.findObject(sel).exists()) {\n      low=high;\n      high=high * 2;\n      sel=sel.instance(high - 1);\n    }\n    while (high > low + 1) {\n      int mid=(low + high) / 2;\n      sel=sel.instance(mid - 1);\n      if (device.findObject(sel).exists())       low=mid;\n else       high=mid;\n    }\n    return low;\n  }\n}\n", "nl": "Get the count of the UiObject instances by the selector"}
{"code": "private boolean isComputeHost(ComputeDescription computeDescription){\n  List<String> supportedChildren=computeDescription.supportedChildren;\n  return supportedChildren != null && supportedChildren.contains(ComputeType.VM_GUEST.name());\n}\n", "nl": "Returns if the given compute description is a compute host or not."}
{"code": "public File prepareTestDir(String logDirName) throws Exception {\n  File logDir=new File(logDirName);\n  FilePath path=new FilePath(logDir.getAbsolutePath());\n  fileIO.delete(path,true);\n  fileIO.mkdir(path);\n  return logDir;\n}\n", "nl": "Create an empty test directory or if the directory exists remove any files within it."}
{"code": "public void receiveErrorqueryAssociatedPortsForProcessor(java.lang.Exception e){\n}\n", "nl": "auto generated Axis2 Error handler override this method for handling error response from queryAssociatedPortsForProcessor operation"}
{"code": "@Override public Object clone() throws CloneNotSupportedException {\n  return super.clone();\n}\n", "nl": "Returns a clone of this instance."}
{"code": "private void dump(File from,OutputStream out) throws IOException {\n  writeHeader(from,out);\n  FileInputStream in=null;\n  try {\n    in=new FileInputStream(from);\n    int count;\n    while ((count=in.read(buffer)) != -1) {\n      out.write(buffer,0,count);\n    }\n  }\n  finally {\n    closeQuietly(in);\n  }\n}\n", "nl": "Copies from a file to an output stream."}
{"code": "public static long lastLocalId(){\n  return cntGen.get();\n}\n", "nl": "Gets last generated local ID."}
{"code": "RoleEventImpl(Region region,Operation op,Object callbackArgument,boolean originRemote,DistributedMember distributedMember,Set requiredRoles){\n  super(region,op,callbackArgument,originRemote,distributedMember);\n  this.requiredRoles=Collections.unmodifiableSet(requiredRoles);\n}\n", "nl": "Constructs new RoleEventImpl."}
{"code": "public QLFFilesCollection(File directory,String extension,Class<F> featureClass,String pathRegexFind,String pathRegexRep){\n  this(featureClass,pathRegexFind,pathRegexRep);\n  processDirs(directory,extension);\n}\n", "nl": "Construct the collection from the files in the given directory that have the given file extension. All the files are expected to contain features of the given feature class. The file search is recursive, and will also look in sub-directories of the specified directory. The final two parameters allow a regular-expression find and replace operation for be performed on the found filenames in order to create the document identifier for each QLFDocument. This is useful to ensure only the document name is stored in the index, rather than the absolute path."}
{"code": "public static void main(String[] args) throws IOException {\n  boolean enableOutput=true;\n  boolean outputToFile=false;\n  String inputFolder=LrMc.class.getClassLoader().getResource(\"workload/planetlab\").getPath();\n  String outputFolder=\"output\";\n  String workload=\"20110303\";\n  String vmAllocationPolicy=\"lr\";\n  String vmSelectionPolicy=\"mc\";\n  String parameter=\"1.2\";\n  new PlanetLabRunner(enableOutput,outputToFile,inputFolder,outputFolder,workload,vmAllocationPolicy,vmSelectionPolicy,parameter);\n}\n", "nl": "The main method."}
{"code": "void make(BulkTest bulk){\n  Class c=bulk.getClass();\n  Method[] all=c.getMethods();\n  for (int i=0; i < all.length; i++) {\n    if (isTest(all[i]))     addTest(bulk,all[i]);\n    if (isBulk(all[i]))     addBulk(bulk,all[i]);\n  }\n}\n", "nl": "Appends all the simple tests and bulk tests defined by the given instance's class to the current TestSuite."}
{"code": "private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n  String inName=(String)in.readObject();\n  String inDescription=(String)in.readObject();\n  Object inValue=in.readObject();\n  Class inClass=(Class)in.readObject();\n  boolean inUserModifiable=in.readBoolean();\n  Assert.assertTrue(inName != null);\n  Assert.assertTrue(inDescription != null);\n  Assert.assertTrue(inValue != null);\n  Assert.assertTrue(inClass != null);\n  this.deserialized=true;\n  this.name=inName;\n  setInternalState(inDescription,inValue,inClass,inUserModifiable);\n}\n", "nl": "Override readObject which is used in serialization. Customize serialization of this exception to avoid escape of InternalRole which is not Serializable."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static String escape(String s){\n  if (s == null)   return null;\n  StringBuffer sb=new StringBuffer();\n  escape(s,sb);\n  return sb.toString();\n}\n", "nl": "Escape quotes, \\, /, \\r, \\n, \\b, \\f, \\t and other control characters (U+0000 through U+001F)."}
{"code": "public ArrayDeque<E> clone(){\n  try {\n    @SuppressWarnings(\"unchecked\") ArrayDeque<E> result=(ArrayDeque<E>)super.clone();\n    result.elements=Arrays.copyOf(elements,elements.length);\n    return result;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new AssertionError();\n  }\n}\n", "nl": "Returns a copy of this deque."}
{"code": "public void generateCode(BlockScope currentScope){\n  if ((this.bits & IsReachable) == 0) {\n    return;\n  }\n  generateInit: {\n    if (this.initialization == null)     break generateInit;\n    if (this.binding.resolvedPosition < 0) {\n      if (this.initialization.constant != Constant.NotAConstant)       break generateInit;\n      this.initialization.generateCode(currentScope,false);\n      break generateInit;\n    }\n    this.initialization.generateCode(currentScope,true);\n  }\n}\n", "nl": "Code generation for a local declaration: i.e.&nbsp;normal assignment to a local variable + unused variable handling"}
{"code": "public static boolean isPotentialValidLink(File file) throws IOException {\n  boolean isPotentiallyValid;\n  try (InputStream fis=new FileInputStream(file)){\n    final int minimumLength=0x64;\n    isPotentiallyValid=file.isFile() && file.getName().toLowerCase().endsWith(\".lnk\") && fis.available() >= minimumLength && isMagicPresent(getBytes(fis,32));\n  }\n   return isPotentiallyValid;\n}\n", "nl": "Provides a quick test to see if this could be a valid link ! If you try to instantiate a new WindowShortcut and the link is not valid, Exceptions may be thrown and Exceptions are extremely slow to generate, therefore any code needing to loop through several files should first check this."}
{"code": "public IGameMove decideMove(IGameState state){\n  if (state.isDraw())   return null;\n  if (state.isWin())   return null;\n  Collection<IGameMove> moves=logic.validMoves(this,state);\n  if (moves.size() == 0) {\n    return null;\n  }\n else {\n    IGameMove[] mvs=moves.toArray(new IGameMove[]{});\n    int idx=(int)(Math.random() * moves.size());\n    return mvs[idx];\n  }\n}\n", "nl": "Randomly make a move based upon the available logic of the game. Make sure you check that the game is not already won, lost or drawn before calling  this method, because you "}
{"code": "public static int nextPowerOf2(int x){\n  long i=1;\n  while (i < x && i < (Integer.MAX_VALUE / 2)) {\n    i+=i;\n  }\n  return (int)i;\n}\n", "nl": "Get the value that is equal or higher than this value, and that is a power of two."}
{"code": "public Point2D inverseTransform(Point2D viewPoint){\n  Point2D viewCenter=getViewCenter();\n  double viewRadius=getViewRadius();\n  double ratio=getRatio();\n  double dx=viewPoint.getX() - viewCenter.getX();\n  double dy=viewPoint.getY() - viewCenter.getY();\n  dx*=ratio;\n  Point2D pointFromCenter=new Point2D.Double(dx,dy);\n  PolarPoint polar=PolarPoint.cartesianToPolar(pointFromCenter);\n  double radius=polar.getRadius();\n  if (radius > viewRadius)   return delegate.inverseTransform(viewPoint);\n  radius/=viewRadius;\n  radius=Math.abs(Math.tan(radius));\n  radius/=Math.PI / 2;\n  radius*=viewRadius;\n  double mag=Math.tan(Math.PI / 2 * magnification);\n  radius/=mag;\n  polar.setRadius(radius);\n  Point2D projectedPoint=PolarPoint.polarToCartesian(polar);\n  projectedPoint.setLocation(projectedPoint.getX() / ratio,projectedPoint.getY());\n  Point2D translatedBack=new Point2D.Double(projectedPoint.getX() + viewCenter.getX(),projectedPoint.getY() + viewCenter.getY());\n  return delegate.inverseTransform(translatedBack);\n}\n", "nl": "override base class to un-project the fisheye effect"}
{"code": "private boolean iconBoundsIntersectBar(RectF barBounds,Rect icon,double scaleFactor){\n  int iconL=icon.left + scale(icon.width(),scaleFactor);\n  int iconT=icon.top + scale(icon.height(),scaleFactor);\n  int iconR=icon.right - scale(icon.width(),scaleFactor);\n  int iconB=icon.bottom - scale(icon.height(),scaleFactor);\n  return barBounds.intersects(iconL,iconT,iconR,iconB);\n}\n", "nl": "Helper method for calculating intersections for control icons and bars."}
{"code": "public void closeRegistration(){\n  flushDeferrables();\n  for (  Map.Entry<String,ClassPlugins> e : registrations.entrySet()) {\n    e.getValue().initializeMap();\n  }\n}\n", "nl": "Disallows new registrations of new plugins, and creates the internal tables for method lookup."}
{"code": "public static String toGml(final IDirectedGraph<?,? extends IGraphEdge<?>> graph){\n  Preconditions.checkNotNull(graph,\"Graph argument can not be null\");\n  final StringBuilder sb=new StringBuilder();\n  sb.append(\"graph\\n\" + \"[\\n\");\n  int currentId=0;\n  final Map<Object,Integer> nodeMap=new HashMap<>();\n  for (  final Object node : graph.getNodes()) {\n    sb.append(\"\\tnode\\n\" + \"\\t[\\n\" + \"\\tid \"+ \"\\n\");\n    sb.append(currentId);\n    sb.append(\"\\tlabel \\\"\");\n    sb.append(node);\n    sb.append(\"\\\"\\n\" + \"\\t]\\n\");\n    nodeMap.put(node,currentId);\n    ++currentId;\n  }\n  for (  final IGraphEdge<?> edge : graph.getEdges()) {\n    sb.append(\"\\tedge\\n\" + \"\\t[\\n\" + \"\\tsource \");\n    sb.append(nodeMap.get(edge.getSource()));\n    sb.append(\"\\n\" + \"\\ttarget \");\n    sb.append(nodeMap.get(edge.getTarget()));\n    sb.append(\"\\n\" + \"\\tgraphics\\n\" + \"\\t[\\n\"+ \"\\t\\tfill \\\"#000000\\\"\\n\"+ \"\\t\\ttargetArrow \\\"standard\\\"\\n\"+ \"\\t]\\n\"+ \"\\t]\\n\");\n  }\n  sb.append(\"]\\n\");\n  return sb.toString();\n}\n", "nl": "Creates GML code that represents a given directed graph."}
{"code": "void cachePage(long pos,Page page,int memory){\n  if (cache != null) {\n    cache.put(pos,page,memory);\n  }\n}\n", "nl": "Put the page in the cache."}
{"code": "public static Class<?> typeToClass(int type){\n  Class<?> result;\nswitch (type) {\ncase Types.BIGINT:\n    result=Long.class;\n  break;\ncase Types.BINARY:\nresult=String.class;\nbreak;\ncase Types.BIT:\nresult=Boolean.class;\nbreak;\ncase Types.CHAR:\nresult=Character.class;\nbreak;\ncase Types.DATE:\nresult=java.sql.Date.class;\nbreak;\ncase Types.DECIMAL:\nresult=Double.class;\nbreak;\ncase Types.DOUBLE:\nresult=Double.class;\nbreak;\ncase Types.FLOAT:\nresult=Float.class;\nbreak;\ncase Types.INTEGER:\nresult=Integer.class;\nbreak;\ncase Types.LONGVARBINARY:\nresult=String.class;\nbreak;\ncase Types.LONGVARCHAR:\nresult=String.class;\nbreak;\ncase Types.NULL:\nresult=String.class;\nbreak;\ncase Types.NUMERIC:\nresult=Double.class;\nbreak;\ncase Types.OTHER:\nresult=String.class;\nbreak;\ncase Types.REAL:\nresult=Double.class;\nbreak;\ncase Types.SMALLINT:\nresult=Short.class;\nbreak;\ncase Types.TIME:\nresult=java.sql.Time.class;\nbreak;\ncase Types.TIMESTAMP:\nresult=java.sql.Timestamp.class;\nbreak;\ncase Types.TINYINT:\nresult=Short.class;\nbreak;\ncase Types.VARBINARY:\nresult=String.class;\nbreak;\ncase Types.VARCHAR:\nresult=String.class;\nbreak;\ndefault :\nresult=null;\n}\nreturn result;\n}\n", "nl": "Returns the class associated with a SQL type."}
{"code": "private String noteToString(Repository repo,Note note) throws MissingObjectException, IOException, UnsupportedEncodingException {\n  ObjectLoader loader=repo.open(note.getData());\n  ByteArrayOutputStream baos=new ByteArrayOutputStream();\n  loader.copyTo(baos);\n  return new String(baos.toByteArray(),\"UTF-8\");\n}\n", "nl": "Utility method that converts a note to a string (assuming it's UTF-8)."}
{"code": "@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) public void initTimers() throws ValidationException {\n  initAllTimers();\n}\n", "nl": "Reads the configuration settings for the timer intervals to be used and creates the timers accordingly."}
{"code": "public static String tbiIndexToUniqueString(InputStream is) throws IOException {\n  final StringBuilder ret=new StringBuilder();\n  final byte[] buf=new byte[4096];\n  readIOFully(is,buf,4);\n  final String header=new String(buf,0,4);\n  ret.append(\"Header correct: \").append(header.equals(\"TBI\\u0001\")).append(StringUtils.LS);\n  readIOFully(is,buf,4);\n  final int numRefs=ByteArrayIOUtils.bytesToIntLittleEndian(buf,0);\n  ret.append(\"numRefs: \").append(numRefs).append(StringUtils.LS);\n  readIOFully(is,buf,28);\n  final int format=ByteArrayIOUtils.bytesToIntLittleEndian(buf,0);\n  final int colSeq=ByteArrayIOUtils.bytesToIntLittleEndian(buf,4);\n  final int colBeg=ByteArrayIOUtils.bytesToIntLittleEndian(buf,8);\n  final int colEnd=ByteArrayIOUtils.bytesToIntLittleEndian(buf,12);\n  final int meta=ByteArrayIOUtils.bytesToIntLittleEndian(buf,16);\n  final int skip=ByteArrayIOUtils.bytesToIntLittleEndian(buf,20);\n  final int refNameLength=ByteArrayIOUtils.bytesToIntLittleEndian(buf,24);\n  final String formatStr;\n  formatStr=TbiFormat.values()[format & 0xffff].name();\n  ret.append(\"Format: \").append(formatStr).append(\" 0-based: \").append((format & 0x10000) != 0).append(StringUtils.LS);\n  ret.append(\"Columns: (refName:Start-End) \").append(colSeq).append(\":\").append(colBeg).append(\"-\").append(colEnd).append(StringUtils.LS);\n  ret.append(\"Meta: \").append((char)meta).append(StringUtils.LS);\n  ret.append(\"Skip: \").append(skip).append(StringUtils.LS);\n  final byte[] names=new byte[refNameLength];\n  readIOFully(is,names,names.length);\n  ret.append(\"Sequence names: \");\n  boolean first=true;\n  int off=0;\n  for (int i=0; i < numRefs; i++) {\n    int newOff=off;\n    while (newOff < names.length && names[newOff] != 0) {\n      newOff++;\n    }\n    if (!first) {\n      ret.append(\", \");\n    }\n    ret.append(new String(names,off,newOff - off));\n    off=newOff + 1;\n    first=false;\n  }\n  ret.append(StringUtils.LS);\n  ret.append(indicesToUniqueString(is,numRefs)).append(StringUtils.LS);\n  return ret.toString();\n}\n", "nl": "Creates a string representation of the TABIX index"}
{"code": "public void addFeatureChangeListener(final FeatureChangeListener l){\n  featureListeners.add(l);\n}\n", "nl": "Add a feature change listener."}
{"code": "protected UserPassword(){\n  super();\n}\n", "nl": "Dear JPA..."}
{"code": "public void firePropertyChange(String propertyName,float oldValue,float newValue){\n}\n", "nl": "Overridden for performance reasons. See the <a href=\"#override\">Implementation Note</a> for more information."}
{"code": "public void testUpdate5(){\n  int factor=3;\n  String updateQuery=\"UPDATE \" + DatabaseCreator.TEST_TABLE1 + \" SET field2=field2 *\"+ factor;\n  try {\n    String selectQuery=\"SELECT field2 FROM \" + DatabaseCreator.TEST_TABLE1;\n    ResultSet result=statement.executeQuery(selectQuery);\n    HashSet<BigDecimal> values=new HashSet<BigDecimal>();\n    int num=statement.executeUpdate(updateQuery);\n    assertEquals(\"Not all records in the database were updated\",numberOfRecords,num);\n    result=statement.executeQuery(selectQuery);\n    assertTrue(\"Not all records were updated\",values.isEmpty());\n    result.close();\n  }\n catch (  SQLException e) {\n    fail(\"Unexpected exception\" + e.getMessage());\n  }\n}\n", "nl": "UpdateFunctionalityTest#testUpdate5(). Updates values in one columns in the table using condition"}
{"code": "public final boolean isCaretBlinkEnabled(){\n  return caretBlinks;\n}\n", "nl": "Returns true if the caret is blinking, false otherwise."}
{"code": "public void testBug73663() throws Exception {\n  this.rs=this.stmt.executeQuery(\"show variables like 'collation_server'\");\n  this.rs.next();\n  String collation=this.rs.getString(2);\n  if (collation != null && collation.startsWith(\"utf8mb4\") && \"utf8mb4\".equals(((MySQLConnection)this.conn).getServerVariable(\"character_set_server\"))) {\n    Properties p=new Properties();\n    p.setProperty(\"characterEncoding\",\"UTF-8\");\n    p.setProperty(\"statementInterceptors\",Bug73663StatementInterceptor.class.getName());\n    getConnectionWithProps(p);\n  }\n else {\n    System.out.println(\"testBug73663 was skipped: This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations.\");\n  }\n}\n", "nl": "Tests fix for Bug#73663 (19479242), utf8mb4 does not work for connector/j >=5.1.13 This test is only run when character_set_server=utf8mb4 and collation-server set to one of utf8mb4 collations (it's better to test two configurations: with default utf8mb4_general_ci and one of non-default, say utf8mb4_bin)"}
{"code": "@Override public void removeEdge(final InstructionGraphEdge edge){\n  super.removeEdge(edge);\n}\n", "nl": "Removes an instruction edge from the instruction graph."}
{"code": "public void addApps(List<AppInfo> apps){\n  mApps.addApps(apps);\n}\n", "nl": "Adds new apps to the list."}
{"code": "public void stop(){\n  final String methodName=\"stop\";\nsynchronized (lifecycle) {\n    log.fine(CLASS_NAME,methodName,\"850\");\n    if (running) {\n      running=false;\n      receiving=false;\n      if (!Thread.currentThread().equals(recThread)) {\n        try {\n          recThread.join();\n        }\n catch (        InterruptedException ex) {\n        }\n      }\n    }\n  }\n  recThread=null;\n  log.fine(CLASS_NAME,methodName,\"851\");\n}\n", "nl": "Stops the Receiver's thread.  This call will block."}
{"code": "First(){\n}\n", "nl": "CONSTRUCTOR <init>"}
{"code": "@Override public String toString(){\n  String temp=\"\";\n  for (int i=0; i < variables.length; i++) {\n    temp+=variables[i].toString();\n    temp+=\"\\n\";\n  }\n  return structName + \"\\n\" + temp;\n}\n", "nl": "Override ToString()."}
{"code": "public void addActionListener(ActionListener l){\n  dispatcher.addListener(l);\n}\n", "nl": "Adds a listener to the switch which will cause an event to dispatch on click"}
{"code": "@Override protected SystemMemberCache createSystemMemberCache(GemFireVM vm) throws org.apache.geode.admin.AdminException {\n  if (managedSystemMemberCache == null) {\n    managedSystemMemberCache=new SystemMemberCacheJmxImpl(vm);\n  }\n  return managedSystemMemberCache;\n}\n", "nl": "Override createSystemMemberCache by instantiating SystemMemberCacheJmxImpl if it was not created earlier."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile=args[0];\n  if (inputFile.toLowerCase().contains(\".dep\")) {\n    calculateRaster();\n  }\n else   if (inputFile.toLowerCase().contains(\".shp\")) {\n    calculateVector();\n  }\n else {\n    showFeedback(\"There was a problem reading the input file.\");\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public void test_compressed_timestamp_01b() throws Exception {\n  new TestHelper(\"compressed-timestamp-01b\",\"compressed-timestamp-01b.rq\",\"compressed-timestamp.ttl\",\"compressed-timestamp-01.srx\").runTest();\n}\n", "nl": "Simple SELECT query returning data typed with the given timestamp, where we have several FILTERs that should evaluate to true."}
{"code": "private void writeAttribute(java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "private void addTag(String newTag){\n  if (StringUtils.isBlank(newTag)) {\n    return;\n  }\nsynchronized (tagsObservable) {\n    if (tagsObservable.contains(newTag)) {\n      return;\n    }\n    tagsObservable.add(newTag);\n  }\n  firePropertyChange(\"tag\",null,tagsObservable);\n}\n", "nl": "Adds the tag."}
{"code": "public EObject basicGetAstElement(){\n  return astElement;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void detach(){\n  if (systemOverlay) {\n    getWindowManager().removeView(this);\n  }\n else {\n    ((ViewGroup)getActivityContentView()).removeView(this);\n  }\n}\n", "nl": "Detaches it from the container view."}
{"code": "private static void patternCompile(){\n  try {\n    ptnNumber=Pattern.compile(strNumberPattern);\n    ptnShortDate=Pattern.compile(strShortDatePattern);\n    ptnLongDate=Pattern.compile(strLongDatePattern);\n    ptnPercentage=Pattern.compile(strPercentagePattern);\n    ptnCurrency=Pattern.compile(strCurrencyPattern);\n    ptnViCurrency=Pattern.compile(strViCurrencyPattern);\n  }\n catch (  PatternSyntaxException ex) {\n    System.err.println(ex.getMessage());\n    System.exit(1);\n  }\n}\n", "nl": "Pattern compile."}
{"code": "public NotificationChain basicSetParams(ExpressionList newParams,NotificationChain msgs){\n  ExpressionList oldParams=params;\n  params=newParams;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,GamlPackage.PARAMETERS__PARAMS,oldParams,newParams);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "static public int unpackInt(DataInput is) throws IOException {\n  int ret=0;\n  byte v;\n  do {\n    v=is.readByte();\n    ret=(ret << 7) | (v & 0x7F);\n  }\n while ((v & 0x80) == 0);\n  return ret;\n}\n", "nl": "Unpack int value from the input stream."}
{"code": "public Object loadWorkflowData(String stepId,String key){\n  Object data=null;\n  String workflowUri=getMainWorkflowUri(stepId);\n  try {\n    if (workflowUri != null) {\n      String dataPath=String.format(_zkStepDataPath,workflowUri) + String.format(_zkWorkflowData,key);\n      if (_dataManager.checkExists(dataPath) != null) {\n        data=_dataManager.getData(dataPath,false);\n      }\n    }\n  }\n catch (  Exception ex) {\n    String exMsg=\"Exception adding global data to workflow from stepId: \" + stepId + \": \"+ ex.getMessage();\n    _log.error(exMsg);\n    data=null;\n  }\n  return data;\n}\n", "nl": "Gets the step workflow data stored under /workflow/stepdata/{workflowURI}/data/{key} where workflowURI is the URI of the main workflow regardless of whether the step belongs in the main workflow or one of its nested workflows."}
{"code": "public static void fillByte(byte[] array,byte x){\n  for (int i=0; i < array.length; i++) {\n    array[i]=x;\n  }\n}\n", "nl": "Fill an array with the given value."}
{"code": "@Override public void addDictionaryChunk(List<byte[]> dictionaryChunk){\n  dictionaryChunks.add(dictionaryChunk);\n  if (null == dictionaryByteArrayToSurrogateKeyMap) {\n    createDictionaryByteArrayToSurrogateKeyMap(dictionaryChunk.size());\n  }\n  addDataToDictionaryMap();\n}\n", "nl": "This method will add a new dictionary chunk to existing list of dictionary chunks"}
{"code": "public OMWarpingImage(BufferedImage bi){\n  setWarp(bi,LatLonGCT.INSTANCE,new DataBounds(-180,-90,180,90));\n}\n", "nl": "Takes an image, assumed to be a world image in the LLXY projection (equal arc) covering -180, 180 longitude to -90, 90 latitude."}
{"code": "private void acquirePrecachingWakeLock(){\n  if (mPrecachingWakeLock == null) {\n    PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE);\n    mPrecachingWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);\n  }\n  mPrecachingWakeLock.acquire();\n}\n", "nl": "Acquire the precaching WakeLock."}
{"code": "public static List<Long> entropyHybridTest(GeoTimeSerie gts,int buckets_per_period,int periods_per_piece,int k,double alpha) throws WarpScriptException {\n  doubleCheck(gts);\n  List<Long> anomalous_ticks=new ArrayList<Long>();\n  if (!GTSHelper.isBucketized(gts)) {\n    throw new WarpScriptException(\"GTS must be bucketized\");\n  }\n  if (k >= periods_per_piece * buckets_per_period / 2) {\n    throw new WarpScriptException(\"Upper bound of number of outliers must be less than half of the number of observations per piece\");\n  }\n  GeoTimeSerie subgts=null;\n  GeoTimeSerie subsubgts=null;\n  GeoTimeSerie seasonal=null;\n  long pieces=gts.bucketcount / buckets_per_period / periods_per_piece;\n  int bpp=periods_per_piece * buckets_per_period;\n  long lb=gts.lastbucket;\n  long bs=gts.bucketspan;\n  for (int u=0; u < pieces; u++) {\n    long start=lb - bs * ((pieces - u) * bpp - 1);\n    long stop=lb - bs * (pieces - u - 1) * bpp;\n    subgts=GTSHelper.subSerie(gts,start,stop,false,false,subgts);\n    subgts.lastbucket=stop;\n    subgts.bucketcount=bpp;\n    subgts.bucketspan=bs;\n    if (null == seasonal) {\n      seasonal=new GeoTimeSerie(bpp);\n      seasonal.doubleValues=new double[bpp];\n      seasonal.ticks=new long[bpp];\n    }\n else {\n      GTSHelper.reset(seasonal);\n    }\n    seasonal.type=TYPE.DOUBLE;\n    for (int v=0; v < buckets_per_period; v++) {\n      subsubgts=GTSHelper.subCycleSerie(subgts,stop - v * bs,buckets_per_period,true,subsubgts);\n      double[] madsigma=madsigma(subsubgts,true);\n      double median=madsigma[0];\n      double mad=madsigma[1];\n      double sum=0.0D;\n      for (int w=0; w < subsubgts.values; w++) {\n        subsubgts.doubleValues[w]=0.0D != mad ? Math.abs((subsubgts.doubleValues[w] - median) / mad) : 1.0D;\n        sum+=subsubgts.doubleValues[w];\n      }\n      double entropy=0.0D;\n      for (int w=0; w < subsubgts.values; w++) {\n        subsubgts.doubleValues[w]/=sum;\n        double tmp=subsubgts.doubleValues[w];\n        if (0.0D != tmp) {\n          entropy-=tmp * Math.log(tmp);\n        }\n      }\n      if (0.0D != entropy) {\n        entropy/=Math.log(subsubgts.values);\n      }\n else {\n        entropy=1.0D;\n      }\n      for (int w=0; w < subsubgts.values; w++) {\n        GTSHelper.setValue(seasonal,subsubgts.ticks[w],entropy * subsubgts.doubleValues[w]);\n      }\n    }\n    GTSHelper.sort(seasonal);\n    double m=median(seasonal);\n    int idx=0;\n    for (int i=0; i < subgts.values; i++) {\n      idx=Arrays.binarySearch(seasonal.ticks,idx,seasonal.values,subgts.ticks[i]);\n      if (idx < 0) {\n        throw new WarpScriptException(\"Internal bug method entropyHybridTest: can't find tick \" + subgts.ticks[i] + \" in seasonal.ticks\");\n      }\n else {\n        subgts.doubleValues[i]-=(seasonal.doubleValues[idx] + m);\n      }\n    }\n    anomalous_ticks.addAll(ESDTest(subgts,k,true,alpha));\n  }\n  return anomalous_ticks;\n}\n", "nl": "Applying Seasonal Entropy Hybrid test This test is based on piecewise decomposition where trend components are approximated by median and seasonal components by entropy of the cycle sub-series. An ESD test is passed upon the residuals. It differs from hybridTest by approximating seasonal component instead of using STL. But in many cases this approximation is more useful than estimation of STL."}
{"code": "public static void collectAndFireTriggers(final HashSet<PlayerID> players,final Match<TriggerAttachment> triggerMatch,final IDelegateBridge aBridge,final String beforeOrAfter,final String stepName){\n  final HashSet<TriggerAttachment> toFirePossible=collectForAllTriggersMatching(players,triggerMatch,aBridge);\n  if (toFirePossible.isEmpty()) {\n    return;\n  }\n  final HashMap<ICondition,Boolean> testedConditions=collectTestsForAllTriggers(toFirePossible,aBridge);\n  final List<TriggerAttachment> toFireTestedAndSatisfied=Match.getMatches(toFirePossible,AbstractTriggerAttachment.isSatisfiedMatch(testedConditions));\n  if (toFireTestedAndSatisfied.isEmpty()) {\n    return;\n  }\n  TriggerAttachment.fireTriggers(new HashSet<>(toFireTestedAndSatisfied),testedConditions,aBridge,beforeOrAfter,stepName,true,true,true,true);\n}\n", "nl": "This will collect all triggers for the desired players, based on a match provided, and then it will gather all the conditions necessary, then test all the conditions, and then it will fire all the conditions which are satisfied."}
{"code": "public static long[] clone(long[] array){\n  if (array == null) {\n    return null;\n  }\n  return (long[])array.clone();\n}\n", "nl": "<p>Clones an array returning a typecast result and handling <code>null</code>.</p> <p>This method returns <code>null</code> for a <code>null</code> input array.</p>"}
{"code": "public ColorPredicate(String input) throws IllegalArgumentException {\n  String rest=input.trim().toLowerCase();\n  if (rest.startsWith(\"leaf\")) {\n    this.isLeaf=true;\n    rest=rest.substring(4).trim();\n  }\n else {\n    this.isLeaf=false;\n  }\n  int endOfStartToken=0;\n  while (endOfStartToken < rest.length() && Character.isLetter(rest.charAt(endOfStartToken))) {\n    endOfStartToken++;\n  }\n  String startToken=rest.substring(0,endOfStartToken);\n  String macro=getMacro(startToken);\n  if (macro != null) {\n    rest=macro;\n  }\n  if (rest.startsWith(\"some\")) {\n    this.isSome=true;\n    rest=rest.substring(4).trim();\n  }\n else   if (rest.startsWith(\"every\")) {\n    this.isSome=false;\n    rest=rest.substring(5).trim();\n  }\n else {\n    throw new IllegalArgumentException(\"\" + \" Color predicate must start with the optional keyword `leaf'\\n\" + \" followed by a legal macro name or `every' or `some'.\");\n  }\n  this.set=0;\n  while (!rest.equals(\"\")) {\n    if (rest.startsWith(\"omitted\")) {\n      this.set=this.set | (1 << NUMBER_OF_OMITTED_STATE);\n      rest=rest.substring(7).trim();\n    }\n else     if (rest.startsWith(\"missing\")) {\n      this.set=this.set | (1 << NUMBER_OF_MISSING_STATE);\n      rest=rest.substring(7).trim();\n    }\n else     if (rest.startsWith(\"(\")) {\n      rest=rest.substring(1).trim();\n      int[][] stateSetSpec=new int[NUMBER_OF_PROVERS][];\n      for (int i=0; i < NUMBER_OF_PROVERS; i++) {\n        boolean invert=false;\n        if (rest.startsWith(\"-\")) {\n          invert=true;\n          rest=rest.substring(1).trim();\n        }\n        boolean[] appears=new boolean[PROVER_STATUSES[i].length];\n        for (int j=0; j < appears.length; j++) {\n          appears[j]=invert;\n        }\n        String endChar=(i == NUMBER_OF_PROVERS - 1) ? \")\" : \",\";\n        while (rest.length() > 0 && !rest.startsWith(endChar)) {\n          int endOfToken=0;\n          while (endOfToken < rest.length() && Character.isLetter(rest.charAt(endOfToken))) {\n            endOfToken++;\n          }\n          String token=rest.substring(0,endOfToken);\n          rest=rest.substring(endOfToken).trim();\n          int statusNumber;\n          try {\n            statusNumber=numberOfProverStatus(i,token);\n          }\n catch (          IllegalArgumentException e) {\n            String errorMsg=\"Was expecting status of prover \" + PROVER_NAMES[i] + \" but found `\"+ token+ \"' followed by: \\n `\"+ rest+ \"'\";\n            throw new IllegalArgumentException(errorMsg);\n          }\n          appears[statusNumber]=!invert;\n        }\n        if (rest.length() == 0) {\n          throw new IllegalArgumentException(\"Color predicate specifier ended before `(...)' expression complete\");\n        }\n        rest=rest.substring(1).trim();\n        int count=0;\n        for (int j=0; j < appears.length; j++) {\n          if (appears[j]) {\n            count++;\n          }\n        }\n        if (count == 0) {\n          if (invert) {\n            throw new IllegalArgumentException(\"A `-' must be followed by one or more statuses\");\n          }\n else {\n            count=appears.length;\n            for (int j=0; j < count; j++) {\n              appears[j]=true;\n            }\n          }\n        }\n        stateSetSpec[i]=new int[count];\n        int k=0;\n        for (int j=0; j < appears.length; j++) {\n          if (appears[j]) {\n            stateSetSpec[i][k]=j;\n            k++;\n          }\n        }\n      }\n      this.set=this.set | bitVectorOfStates(stateSetSpec);\n    }\n else {\n      throw new IllegalArgumentException(\"Unexpected token at: `\" + rest + \"'\");\n    }\n  }\n}\n", "nl": "Returns a ColorPredicate obtained by parsing its argument. See the beginning of ProofStatus.tla for the grammar of the input."}
{"code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }\n", "nl": "Transfer all the sequences listed in the supplied file, interpreting entries appropriately."}
{"code": "public String toNamespacedString(){\n  return (_namespaceURI != null ? (\"{\" + _namespaceURI + \"}\"+ _localName) : _localName);\n}\n", "nl": "Return the string representation of the qualified name using the  the '{ns}foo' notation. Performs string concatenation, so beware of performance issues."}
{"code": "@SuppressWarnings(\"deprecation\") public void configureManagers(){\n  powerManager=new jmri.jmrix.nce.NcePowerManager(this);\n  InstanceManager.store(powerManager,jmri.PowerManager.class);\n  turnoutManager=new jmri.jmrix.nce.NceTurnoutManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setTurnoutManager(turnoutManager);\n  lightManager=new jmri.jmrix.nce.NceLightManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setLightManager(lightManager);\n  sensorManager=new jmri.jmrix.nce.NceSensorManager(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.setSensorManager(sensorManager);\n  throttleManager=new jmri.jmrix.nce.NceThrottleManager(this);\n  InstanceManager.setThrottleManager(throttleManager);\n  if (getNceUsbSystem() != NceTrafficController.USB_SYSTEM_NONE) {\n    if (getNceUsbSystem() != NceTrafficController.USB_SYSTEM_POWERHOUSE) {\n    }\n  }\n else {\n    InstanceManager.setProgrammerManager(getProgrammerManager());\n  }\n  clockManager=new jmri.jmrix.nce.NceClockControl(getNceTrafficController(),getSystemPrefix());\n  InstanceManager.addClockControl(clockManager);\n  consistManager=new jmri.jmrix.nce.NceConsistManager(this);\n  InstanceManager.setConsistManager(consistManager);\n}\n", "nl": "Configure the common managers for NCE connections. This puts the common manager config in one place."}
{"code": "public void newLine() throws IOException {\n  out.append('\\n');\n  for (int n=0; n < currentIndentLevel; n++)   out.append(indent);\n  currentLine++;\n  currentCol=currentIndentLevel * indent.length();\n}\n", "nl": "Emits a <code>'\\n'</code> plus required indentation characters for the current indentation level."}
{"code": "@Override protected void checkForDuplicatSnapshotName(String name,Volume vplexVolume){\n  Volume snapshotSourceVolume=getVPLEXSnapshotSourceVolume(vplexVolume);\n  super.checkForDuplicatSnapshotName(name,snapshotSourceVolume);\n}\n", "nl": "Check if a snapshot with the same name exists for the passed volume."}
{"code": "public boolean isOneAssetPerUOM(){\n  Object oo=get_Value(COLUMNNAME_IsOneAssetPerUOM);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get One Asset Per UOM."}
{"code": "public int value(){\n  return this.value;\n}\n", "nl": "Retrieve value for node computed so far. <p> Primarily here for testing"}
{"code": "public boolean isRemove(){\n  boolean is;\n  if (m_editFlag == FolderEditFlag.REMOVE)   is=true;\n else   is=false;\n  return is;\n}\n", "nl": "Devuelve <tt>true</tt> si el campo est? marcado como eliminado"}
{"code": "public static String encodeWebSafe(byte[] source,boolean doPadding){\n  return encode(source,0,source.length,WEBSAFE_ALPHABET,doPadding);\n}\n", "nl": "Encodes a byte array into web safe Base64 notation."}
{"code": "@Override public void commence(HttpServletRequest request,HttpServletResponse response,AuthenticationException arg2) throws IOException, ServletException {\n  log.debug(\"Pre-authenticated entry point called. Rejecting access\");\n  response.sendError(HttpServletResponse.SC_UNAUTHORIZED,\"Access Denied\");\n}\n", "nl": "Always returns a 401 error code to the client."}
{"code": "public int size(){\n  return _size;\n}\n", "nl": "Returns the current number of entries in the map."}
{"code": "private List<Volume> createVolumeData(String name,int numVolumes){\n  List<Volume> volumes=new ArrayList<Volume>();\n  URI cgUri=createBlockConsistencyGroup(name + \"-cg\");\n  for (int i=1; i <= numVolumes; i++) {\n    Volume volume=new Volume();\n    URI volumeURI=URIUtil.createId(Volume.class);\n    testVolumeURIs.add(volumeURI);\n    volume.setId(volumeURI);\n    volume.setLabel(name + i);\n    volume.setConsistencyGroup(cgUri);\n    _dbClient.createObject(volume);\n  }\n  return volumes;\n}\n", "nl": "Creates the BlockObject Volume data."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public static void closeStream(Closeable stream){\n  if (stream != null) {\n    try {\n      stream.close();\n    }\n catch (    IOException e) {\n      android.util.Log.e(\"IO\",\"Could not close stream\",e);\n    }\n  }\n}\n", "nl": "Closes the specified stream."}
{"code": "private static BufferedImage loadImage(final IdocScanInterface ui,int finalWidth,int finalHeight){\n  return loadImage(ui,finalWidth,finalHeight,0);\n}\n", "nl": "Muestra la imagen seleccionada de la lista en el visor del applet a escala real"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void configure(){\n  XpaSystemConnectionMemo memo=((XpaSystemConnectionMemo)getSystemConnectionMemo());\n  XpaTrafficController tc=memo.getXpaTrafficController();\n  tc.connectPort(this);\n  memo.setPowerManager(new jmri.jmrix.xpa.XpaPowerManager(tc));\n  jmri.InstanceManager.store(memo.getPowerManager(),jmri.PowerManager.class);\n  memo.setTurnoutManager(new jmri.jmrix.xpa.XpaTurnoutManager(memo));\n  jmri.InstanceManager.store(memo.getTurnoutManager(),jmri.TurnoutManager.class);\n  memo.setThrottleManager(new jmri.jmrix.xpa.XpaThrottleManager(memo));\n  jmri.InstanceManager.store(memo.getThrottleManager(),jmri.ThrottleManager.class);\n  tc.startTransmitThread();\n  sinkThread=new Thread(tc);\n  sinkThread.start();\n}\n", "nl": "set up all of the other objects to operate with an XPA+Modem Connected to an XPressNet based command station connected to this port"}
{"code": "public void executeQuery(IMiniTable miniTable){\n  log.info(\"\");\n  String sql=\"\";\n  if (m_DD_Order_ID == null)   return;\n  sql=getOrderSQL();\n  log.fine(sql);\n  int row=0;\n  miniTable.setRowCount(row);\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql.toString(),null);\n    pstmt.setInt(1,Integer.parseInt(m_DD_Order_ID.toString()));\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      miniTable.setRowCount(row + 1);\n      miniTable.setValueAt(new IDColumn(rs.getInt(1)),row,0);\n      miniTable.setValueAt(rs.getBigDecimal(2),row,1);\n      miniTable.setValueAt(rs.getString(3),row,2);\n      miniTable.setValueAt(rs.getString(4),row,4);\n      miniTable.setValueAt(rs.getString(5),row,3);\n      miniTable.setValueAt(rs.getString(6),row,5);\n      row++;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql.toString(),e);\n  }\n  miniTable.autoSize();\n}\n", "nl": "Query Info"}
{"code": "public ParameterDatabase(){\n  super();\n  accessed=new Hashtable();\n  gotten=new Hashtable();\n  directory=new File(new File(\"\").getAbsolutePath());\n  label=\"Basic Database\";\n  parents=new Vector();\n  checked=false;\n}\n", "nl": "Creates an empty parameter database."}
{"code": "private CTagHelpers(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public EventSourceImpl(){\n  LOG.entering(CLASS_NAME,\"<init>\");\n}\n", "nl": "EventSource provides a text-based stream abstraction for Java"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:01:25.281 -0500\",hash_original_method=\"8F9A0D25038BAA53AA87BFFA0D47316A\",hash_generated_method=\"D647B858B68B1333AC193E85FEBDEE73\") public static void registrationComplete(){\nsynchronized (mHandlerMap) {\n    mRegistrationComplete=true;\n    mHandlerMap.notifyAll();\n  }\n}\n", "nl": "The application must call here after it finishes registering handlers."}
{"code": "public long next(){\n  return next(RecurrenceUtil.now());\n}\n", "nl": "Returns the next recurrence from now."}
{"code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  mbr.writeExternal(out);\n}\n", "nl": "Calls the super method and writes the MBR object of this entry to the specified output stream."}
{"code": "protected void validate_return(StorageCapability[] param){\n}\n", "nl": "validate the array for _return"}
{"code": "public static String jQuote(String s){\n  if (s == null) {\n    return \"null\";\n  }\n  int ln=s.length();\n  StringBuilder b=new StringBuilder(ln + 4);\n  b.append('\"');\n  for (int i=0; i < ln; i++) {\n    char c=s.charAt(i);\n    if (c == '\"') {\n      b.append(\"\\\\\\\"\");\n    }\n else     if (c == '\\\\') {\n      b.append(\"\\\\\\\\\");\n    }\n else     if (c < 0x20) {\n      if (c == '\\n') {\n        b.append(\"\\\\n\");\n      }\n else       if (c == '\\r') {\n        b.append(\"\\\\r\");\n      }\n else       if (c == '\\f') {\n        b.append(\"\\\\f\");\n      }\n else       if (c == '\\b') {\n        b.append(\"\\\\b\");\n      }\n else       if (c == '\\t') {\n        b.append(\"\\\\t\");\n      }\n else {\n        b.append(\"\\\\u00\");\n        int x=c / 0x10;\n        b.append(toHexDigit(x));\n        x=c & 0xF;\n        b.append(toHexDigit(x));\n      }\n    }\n else {\n      b.append(c);\n    }\n  }\n  b.append('\"');\n  return b.toString();\n}\n", "nl": "Quotes string as Java Language string literal. Returns string <code>\"null\"</code> if <code>s</code> is <code>null</code>."}
{"code": "public FluentFunction<T3,R> partiallyApply(final T1 param1,final T2 param2){\n  return new FluentFunction<>(PartialApplicator.partial3(param1,param2,fn));\n}\n", "nl": "Partially apply the provided parameters to this BiFunction to generate a Function (single input)"}
{"code": "public static boolean deleteFile(String path){\n  if (Handler_String.isBlank(path)) {\n    return true;\n  }\n  File file=new File(path);\n  if (!file.exists()) {\n    return true;\n  }\n  if (file.isFile()) {\n    return file.delete();\n  }\n  if (!file.isDirectory()) {\n    return false;\n  }\n  for (  File f : file.listFiles()) {\n    if (f.isFile()) {\n      f.delete();\n    }\n else     if (f.isDirectory()) {\n      deleteFile(f.getAbsolutePath());\n    }\n  }\n  return file.delete();\n}\n", "nl": "delete file or directory <ul> <li>if path is null or empty, return true</li> <li>if path not exist, return true</li> <li>if path exist, delete recursion. return true</li> <ul>"}
{"code": "private ImmutableSet<CassandraJmxCompactionClient> createCompactionClients(CassandraJmxCompactionConfig jmxConfig){\n  Set<CassandraJmxCompactionClient> clients=Sets.newHashSet();\n  Set<InetSocketAddress> servers=config.servers();\n  int jmxPort=jmxConfig.port();\n  for (  InetSocketAddress addr : servers) {\n    CassandraJmxCompactionClient client=createCompactionClient(addr.getHostString(),jmxPort,jmxConfig.username(),jmxConfig.password());\n    clients.add(client);\n  }\n  return ImmutableSet.copyOf(clients);\n}\n", "nl": "Return an empty set if no client can be created."}
{"code": "public static String hashKeyForDisk(String key){\n  String cacheKey;\n  try {\n    final MessageDigest mDigest=MessageDigest.getInstance(\"MD5\");\n    mDigest.update(key.getBytes());\n    cacheKey=bytesToHexString(mDigest.digest());\n  }\n catch (  NoSuchAlgorithmException e) {\n    cacheKey=String.valueOf(key.hashCode());\n  }\n  return cacheKey;\n}\n", "nl": "A hashing method that changes a string (like a URL) into a hash suitable for using as a disk filename."}
{"code": "@Nullable public String space(){\n  return space;\n}\n", "nl": "Gets swap space name."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  SeriesInfo si=getSeriesInfo(stack);\n  return si == null ? \"\" : si.getDescription();\n}\n", "nl": "Returns the description for the specified SeriesInfo"}
{"code": "public UserEntry restoreUser(String username) throws AppsForYourDomainException, ServiceException, IOException {\n  LOGGER.log(Level.INFO,\"Restoring user '\" + username + \"'.\");\n  URL retrieveUrl=new URL(domainUrlBase + \"user/\" + SERVICE_VERSION+ \"/\"+ username);\n  UserEntry userEntry=userService.getEntry(retrieveUrl,UserEntry.class);\n  userEntry.getLogin().setSuspended(false);\n  URL updateUrl=new URL(domainUrlBase + \"user/\" + SERVICE_VERSION+ \"/\"+ username);\n  return userService.update(updateUrl,userEntry);\n}\n", "nl": "Restores a user. Note that executing this method for a user who is not suspended has no effect."}
{"code": "private Class(RVMType type){\n  this.type=type;\n}\n", "nl": "Prevents this class from being instantiated, except by the create method in this class."}
{"code": "public double weightedFMeasure(){\n  double[] classCounts=new double[m_NumClasses];\n  double classCountSum=0;\n  for (int i=0; i < m_NumClasses; i++) {\n    for (int j=0; j < m_NumClasses; j++) {\n      classCounts[i]+=m_ConfusionMatrix[i][j];\n    }\n    classCountSum+=classCounts[i];\n  }\n  double fMeasureTotal=0;\n  for (int i=0; i < m_NumClasses; i++) {\n    double temp=fMeasure(i);\n    fMeasureTotal+=(temp * classCounts[i]);\n  }\n  return fMeasureTotal / classCountSum;\n}\n", "nl": "Calculates the macro weighted (by class size) average F-Measure."}
{"code": "@DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:08.711 -0500\",hash_original_method=\"05A7D65C6D911E0B1F3261A66888CB52\",hash_generated_method=\"3AFFFBA2DDE5D54646A6F203B3BBAF40\") public int lastIndexOf(Object obj){\n  return this.hlist.lastIndexOf(obj);\n}\n", "nl": "Get the last index of the given object."}
{"code": "public Builder showNextButton(boolean showNextButton){\n  this.showNextButton=showNextButton;\n  return this;\n}\n", "nl": "Set the visibility of the next button"}
{"code": "public static ValueLobDb createSmallLob(int type,byte[] small,long precision){\n  return new ValueLobDb(type,small,precision);\n}\n", "nl": "Create a LOB object that fits in memory."}
{"code": "public void invDct8x8(double[][] input,int[][] output){\n  double[][] temp=new double[NJPEG][NJPEG];\n  double temp1=0.0;\n  int i=0;\n  int j=0;\n  int k=0;\n  for (i=0; i < NJPEG; i++) {\n    for (j=0; j < NJPEG; j++) {\n      temp[i][j]=0.0;\n      for (k=0; k < NJPEG; k++) {\n        temp[i][j]+=input[i][k] * this.C[k][j];\n      }\n    }\n  }\n  for (i=0; i < NJPEG; i++) {\n    for (j=0; j < NJPEG; j++) {\n      temp1=0.0;\n      for (k=0; k < NJPEG; k++) {\n        temp1+=this.Ct[i][k] * temp[k][j];\n      }\n      temp1+=128.0;\n      output[i][j]=ImageUtil.pixelRange(round(temp1));\n    }\n  }\n}\n", "nl": "Perform inverse DCT on the 8x8 matrix"}
{"code": "public static InputStream openDataFile(){\n  InputStream stream=SantaFeExample.class.getResourceAsStream(\"santafe.trail\");\n  if (stream == null) {\n    System.err.println(\"Unable to find the file santafe.trail.\");\n    System.exit(-1);\n  }\n  return stream;\n}\n", "nl": "Returns an input stream that contains the ant trail data file."}
{"code": "public ProductionRule(final String name,final GameData data,final IntegerMap<NamedAttachable> results,final IntegerMap<Resource> costs){\n  super(name,data);\n  m_results=results;\n  m_cost=costs;\n}\n", "nl": "Creates new ProductionRule"}
{"code": "public RootConfiguration(ApplicationInformation ai){\n  this(ai,getDefaultContexts(applicationClass(ai,CommonUtils.getCallingClass(2))));\n}\n", "nl": "Initializes the root configuration with default context relative to the calling (instantiating class)."}
{"code": "public void addString(String word,Tuple t){\n  TrieLeaf leaf=new TrieLeaf(word,t);\n  addLeaf(root,leaf,0);\n}\n", "nl": "Add a new word to the trie, associated with the given Tuple."}
{"code": "public void waitOnInitialization() throws InterruptedException {\n  this.initializationLatch.await();\n}\n", "nl": "Wait for the tracker to finishe being initialized"}
{"code": "@Override public Object execute(ExecutionEvent event) throws ExecutionException {\n  IWorkbenchPart viewPart=HandlerUtil.getActivePart(event);\n  if (viewPart instanceof DroidsafeInfoOutlineViewPart) {\n    Command command=event.getCommand();\n    boolean oldValue=HandlerUtil.toggleCommandState(command);\n    ((DroidsafeInfoOutlineViewPart)viewPart).setLongLabel(!oldValue);\n  }\n  return null;\n}\n", "nl": "Command implementation. Retrieves the value of the parameter value, and delegates to the view to set the correct value for the methods labels."}
{"code": "@Override protected EClass eStaticClass(){\n  return UmplePackage.eINSTANCE.getCodeLang_();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private static byte[] streamToBytes(InputStream in,int length) throws IOException {\n  byte[] bytes=new byte[length];\n  int count;\n  int pos=0;\n  while (pos < length && ((count=in.read(bytes,pos,length - pos)) != -1)) {\n    pos+=count;\n  }\n  if (pos != length) {\n    throw new IOException(\"Expected \" + length + \" bytes, read \"+ pos+ \" bytes\");\n  }\n  return bytes;\n}\n", "nl": "Reads the contents of an InputStream into a byte[]."}
{"code": "public void testUpdatePathDoesNotExist() throws Exception {\n  final Map<String,String> props=properties(\"owner\",\"group\",\"0555\");\n  assert igfs.update(SUBDIR,props) == null;\n  checkNotExist(igfs,igfsSecondary,SUBDIR);\n}\n", "nl": "Check that exception is thrown in case the path being updated doesn't exist remotely."}
{"code": "public void stopProcess() throws InterruptedException {\n  latch.await();\n  if (this.process != null) {\n    System.out.println(\"ProcessThread.stopProcess() will kill process\");\n    this.process.destroy();\n  }\n}\n", "nl": "Stops the process."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col, x, y;\n  int progress=0;\n  double z;\n  int i, c;\n  int[] dX=new int[]{1,1,1,0,-1,-1,-1,0};\n  int[] dY=new int[]{-1,0,1,1,1,0,-1,-1};\n  double zFactor=0;\n  double slopeThreshold=0;\n  double profCurvThreshold=0;\n  double planCurvThreshold=0;\n  double radToDeg=180 / Math.PI;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (i=0; i < args.length; i++) {\n    if (i == 0) {\n      inputHeader=args[i];\n    }\n else     if (i == 1) {\n      outputHeader=args[i];\n    }\n else     if (i == 2) {\n      zFactor=Double.parseDouble(args[i]);\n    }\n else     if (i == 3) {\n      slopeThreshold=Double.parseDouble(args[i]);\n    }\n else     if (i == 4) {\n      profCurvThreshold=Double.parseDouble(args[i]);\n    }\n else     if (i == 5) {\n      planCurvThreshold=Double.parseDouble(args[i]);\n    }\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster DEM=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=DEM.getNumberRows();\n    int cols=DEM.getNumberColumns();\n    double noData=DEM.getNoDataValue();\n    double gridResX=DEM.getCellSizeX();\n    double gridResY=DEM.getCellSizeY();\n    double diagGridRes=Math.sqrt(gridResX * gridResX + gridResY * gridResY);\n    double[] gridLengths=new double[]{diagGridRes,gridResX,diagGridRes,gridResY,diagGridRes,gridResX,diagGridRes,gridResY};\n    double Zx, Zy, Zxx, Zyy, Zxy, p, Zx2, q, Zy2;\n    double fx, fy;\n    double gridResTimes2=gridResX * 2;\n    double gridResSquared=gridResX * gridResX;\n    double fourTimesGridResSquared=gridResSquared * 4;\n    double planCurv, profCurv, slope;\n    double eightGridRes=8 * gridResX;\n    double[] N=new double[8];\n    WhiteboxRaster output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,-999);\n    output.setPreferredPalette(\"landclass.pal\");\n    output.setDataScale(WhiteboxRaster.DataScale.CONTINUOUS);\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=DEM.getValue(row,col);\n        if (z != noData) {\n          z=z * zFactor;\n          for (c=0; c < 8; c++) {\n            N[c]=DEM.getValue(row + dY[c],col + dX[c]);\n            if (N[c] != noData) {\n              N[c]=N[c] * zFactor;\n            }\n else {\n              N[c]=z;\n            }\n          }\n          Zx=(N[1] - N[5]) / gridResTimes2;\n          Zy=(N[7] - N[3]) / gridResTimes2;\n          Zxx=(N[1] - 2 * z + N[5]) / gridResSquared;\n          Zyy=(N[7] - 2 * z + N[3]) / gridResSquared;\n          Zxy=(-N[6] + N[0] + N[4] - N[2]) / fourTimesGridResSquared;\n          Zx2=Zx * Zx;\n          Zy2=Zy * Zy;\n          p=Zx2 + Zy2;\n          q=p + 1;\n          if (p > 0) {\n            fy=(N[6] - N[4] + 2 * (N[7] - N[3]) + N[0] - N[2]) / eightGridRes;\n            fx=(N[2] - N[4] + 2 * (N[1] - N[5]) + N[0] - N[6]) / eightGridRes;\n            slope=Math.atan(Math.sqrt(fx * fx + fy * fy));\n            slope=slope * radToDeg;\n            planCurv=-1 * (Zxx * Zy2 - 2 * Zxy * Zx* Zy + Zyy * Zx2) / Math.pow(p,1.5);\n            planCurv=(planCurv * radToDeg);\n            profCurv=-1 * (Zxx * Zx2 + 2 * Zxy * Zx* Zy + Zyy * Zy2) / Math.pow(p * q,1.5);\n            profCurv=(profCurv * radToDeg);\n            if (profCurv < -profCurvThreshold && planCurv <= -planCurvThreshold & slope > slopeThreshold) {\n              output.setValue(row,col,1);\n            }\n else             if (profCurv < -profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,2);\n            }\n else             if (profCurv > profCurvThreshold && planCurv <= planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,3);\n            }\n else             if (profCurv > profCurvThreshold && planCurv > planCurvThreshold && slope > slopeThreshold) {\n              output.setValue(row,col,4);\n            }\n else             if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv <= -planCurvThreshold) {\n              output.setValue(row,col,5);\n            }\n else             if (profCurv >= -profCurvThreshold && profCurv < profCurvThreshold && slope > slopeThreshold && planCurv > planCurvThreshold) {\n              output.setValue(row,col,6);\n            }\n else             if (slope <= slopeThreshold) {\n              output.setValue(row,col,7);\n            }\n else {\n              output.setValue(row,col,noData);\n            }\n          }\n else {\n            output.setValue(row,col,noData);\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (rows - 1));\n      updateProgress(progress);\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    DEM.close();\n    output.close();\n    returnData(outputHeader);\n    String retstr=\"LANDFORM CLASSIFICATION KEY\\n\";\n    retstr+=\"\\nValue:\\tClass\";\n    retstr+=\"\\n1\\tConvergent Footslope\";\n    retstr+=\"\\n2\\tDivergent Footslope\";\n    retstr+=\"\\n3\\tConvergent Shoulder\";\n    retstr+=\"\\n4\\tDivergent Shoulder\";\n    retstr+=\"\\n5\\tConvergent Backslope\";\n    retstr+=\"\\n6\\tDivergent Backslope\";\n    retstr+=\"\\n7\\tLevel\";\n    returnData(retstr);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public R reduce(R r1,R r2){\n  return r1;\n}\n", "nl": "Reduces two results into a combined result. The default implementation is to return the first parameter. The general contract of the method is that it may take any action whatsoever."}
{"code": "public void numParameters(int num) throws IOException {\n  output.write(num);\n}\n", "nl": "Writes <code>num_parameters</code> in <code>Runtime(In)VisibleParameterAnnotations_attribute</code>. This method must be followed by <code>num</code> calls to <code>numAnnotations()</code>."}
{"code": "public ResultFormatter(Object result){\n  this.result=result;\n  printHeader=true;\n}\n", "nl": "Creates a new formatter for a particular object."}
{"code": "@Override public Eval<String> join(){\n  return Eval.later(null);\n}\n", "nl": "Perform an asynchronous join operation"}
{"code": "public GetRequest type(@Nullable String type){\n  if (type == null) {\n    type=\"_all\";\n  }\n  this.type=type;\n  return this;\n}\n", "nl": "Sets the type of the document to fetch."}
{"code": "@Override public ImmutableSet<Entry<K,V>> entries(){\n  ImmutableSet<Entry<K,V>> result=entries;\n  return result == null ? (entries=new EntrySet<K,V>(this)) : result;\n}\n", "nl": "Returns an immutable collection of all key-value pairs in the multimap. Its iterator traverses the values for the first key, the values for the second key, and so on."}
{"code": "private int luminance(int r,int g,int b){\n  return (int)((0.299 * r) + (0.58 * g) + (0.11 * b));\n}\n", "nl": "Apply the luminance"}
{"code": "private void puntPlay(Team offense){\n  gameYardLine=(int)(100 - (gameYardLine + offense.getK(0).ratKickPow / 3 + 20 - 10 * Math.random()));\n  if (gameYardLine < 0) {\n    gameYardLine=20;\n  }\n  gameDown=1;\n  gameYardsNeed=10;\n  gamePoss=!gamePoss;\n  gameTime-=20 + 15 * Math.random();\n}\n", "nl": "Punt the ball if it is a 4th down and decided not to go for it. Will turnover possession."}
{"code": "private List<String[]> readSentence(BufferedReader aReader) throws IOException {\n  List<String[]> words=new ArrayList<String[]>();\n  String line;\n  boolean beginSentence=true;\n  while ((line=aReader.readLine()) != null) {\n    if (StringUtils.isBlank(line)) {\n      beginSentence=true;\n      break;\n    }\n    if (hasHeader && beginSentence) {\n      beginSentence=false;\n      continue;\n    }\n    String[] fields=line.split(columnSeparator.getValue());\n    if (!hasEmbeddedNamedEntity && fields.length != 2 + FORM) {\n      throw new IOException(String.format(\"Invalid file format. Line needs to have %d %s-separated fields: [%s]\",2 + FORM,columnSeparator.getName(),line));\n    }\n else     if (hasEmbeddedNamedEntity && fields.length != 3 + FORM) {\n      throw new IOException(String.format(\"Invalid file format. Line needs to have %d %s-separated fields: [%s]\",3 + FORM,columnSeparator.getName(),line));\n    }\n    words.add(fields);\n  }\n  if (line == null && words.isEmpty()) {\n    return null;\n  }\n else {\n    return words;\n  }\n}\n", "nl": "Read a single sentence."}
{"code": "public static ConditionOperand OVERFLOW_FROM_SUB(){\n  return new ConditionOperand(OVERFLOW_FROM_SUB);\n}\n", "nl": "Create the condition code operand for OVERFLOW_FROM_SUB"}
{"code": "protected void initCheckLists(){\n  List<IceMediaStream> streams=getStreamsWithPendingConnectivityEstablishment();\n  int streamCount=streams.size();\n  int maxCheckListSize=Integer.getInteger(StackProperties.MAX_CHECK_LIST_SIZE,DEFAULT_MAX_CHECK_LIST_SIZE);\n  int maxPerStreamSize=streamCount == 0 ? 0 : maxCheckListSize / streamCount;\n  for (  IceMediaStream stream : streams) {\n    logger.info(\"Init checklist for stream \" + stream.getName());\n    stream.setMaxCheckListSize(maxPerStreamSize);\n    stream.initCheckList();\n  }\n  if (streamCount > 0)   streams.get(0).getCheckList().computeInitialCheckListPairStates();\n}\n", "nl": "Creates, initializes and orders the list of candidate pairs that would be used for the connectivity checks for all components in this stream."}
{"code": "private void checkSearchables(ArrayList<SearchableInfo> searchablesList){\n  assertNotNull(searchablesList);\n  int count=searchablesList.size();\n  for (int ii=0; ii < count; ii++) {\n    SearchableInfo si=searchablesList.get(ii);\n    checkSearchable(si);\n  }\n}\n", "nl": "Generic health checker for an array of searchables. This is designed to pass for any semi-legal searchable, without knowing much about the format of the underlying data.  It's fairly easy for a non-compliant application to provide meta-data that will pass here (e.g. a non-existent suggestions authority)."}
{"code": "private void generateImplementsParcelableInterface(PsiClass targetPsiClass){\n  PsiJavaCodeReferenceElement referenceElement=factory.createReferenceFromText(PARCELABLE_CLASS_SIMPLE_NAME,null);\n  PsiReferenceList implementsList=targetPsiClass.getImplementsList();\n  if (null != implementsList) {\n    implementsList.add(referenceElement);\n  }\n  generateImportStatement(PARCELABLE_PACKAGE);\n  generateExtraMethods(targetPsiClass);\n}\n", "nl": "Implement android.os.Parcelable interface"}
{"code": "private RemoteDirectorGroup fetchRDFGroupFromCache(Map<URI,RemoteDirectorGroup> rdfGroupCache,URI srdfGroupURI){\n  if (rdfGroupCache.containsKey(srdfGroupURI)) {\n    return rdfGroupCache.get(srdfGroupURI);\n  }\n  RemoteDirectorGroup rdfGroup=this.getDbClient().queryObject(RemoteDirectorGroup.class,srdfGroupURI);\n  if (null != rdfGroup && !rdfGroup.getInactive()) {\n    rdfGroupCache.put(srdfGroupURI,rdfGroup);\n  }\n  return rdfGroup;\n}\n", "nl": "Return the RemoteDirectorGroup from cache otherwise query from db."}
{"code": "public static int minCut(String s){\n  Set<String> palin=new HashSet<String>();\n  return minCut(s,0,palin);\n}\n", "nl": "Backtracking, generate all cuts"}
{"code": "public ObjectWriter withDateFormat(DateFormat df){\n  SerializationConfig newConfig=_config.withDateFormat(df);\n  if (newConfig == _config) {\n    return this;\n  }\n  return new ObjectWriter(this,newConfig);\n}\n", "nl": "Fluent factory method that will construct a new writer instance that will use specified date format for serializing dates; or if null passed, one that will serialize dates as numeric timestamps."}
{"code": "LockMode(final boolean allowsTouch,final boolean allowsCommands){\n  this.allowsTouch=allowsTouch;\n  this.allowsCommands=allowsCommands;\n}\n", "nl": "Constructs a new LockMode instance."}
{"code": "public boolean match(Element e,String pseudoE){\n  return (e instanceof CSSStylableElement) ? ((CSSStylableElement)e).isPseudoInstanceOf(getValue()) : false;\n}\n", "nl": "Tests whether this selector matches the given element."}
{"code": "RandomAccessFile openInputFileAsZip(String fileName) throws IOException {\n  ZipFile zipFile;\n  try {\n    zipFile=new ZipFile(fileName);\n  }\n catch (  FileNotFoundException fnfe) {\n    System.err.println(\"Unable to open '\" + fileName + \"': \"+ fnfe.getMessage());\n    throw fnfe;\n  }\ncatch (  ZipException ze) {\n    return null;\n  }\n  ZipEntry entry=zipFile.getEntry(CLASSES_DEX);\n  if (entry == null) {\n    System.err.println(\"Unable to find '\" + CLASSES_DEX + \"' in '\"+ fileName+ \"'\");\n    zipFile.close();\n    throw new ZipException();\n  }\n  InputStream zis=zipFile.getInputStream(entry);\n  File tempFile=File.createTempFile(\"dexdeps\",\".dex\");\n  RandomAccessFile raf=new RandomAccessFile(tempFile,\"rw\");\n  tempFile.delete();\n  byte copyBuf[]=new byte[32768];\n  int actual;\n  while (true) {\n    actual=zis.read(copyBuf);\n    if (actual == -1)     break;\n    raf.write(copyBuf,0,actual);\n  }\n  zis.close();\n  raf.seek(0);\n  return raf;\n}\n", "nl": "Tries to open an input file as a Zip archive (jar/apk) with a \"classes.dex\" inside."}
{"code": "public boolean generate(Projection proj){\n  setNeedToRegenerate(true);\n  if (proj == null) {\n    Debug.message(\"omgraphic\",\"OMRect: null projection in generate!\");\n    return false;\n  }\nswitch (renderType) {\ncase RENDERTYPE_XY:\n    setShape(createBoxShape((int)Math.min(x2,x1),(int)Math.min(y2,y1),(int)Math.abs(x2 - x1),(int)Math.abs(y2 - y1)));\n  break;\ncase RENDERTYPE_OFFSET:\nif (!proj.isPlotable(lat1,lon1)) {\n  setNeedToRegenerate(true);\n  return false;\n}\nPoint p1=(Point)proj.forward(lat1,lon1,new Point());\nsetShape(createBoxShape((int)Math.min(p1.x + x1,p1.x + x2),(int)Math.min(p1.y + y1,p1.y + y2),(int)Math.abs(x2 - x1),(int)Math.abs(y2 - y1)));\nbreak;\ncase RENDERTYPE_LATLON:\nArrayList<float[]> rects;\nif (proj instanceof GeoProj) {\nrects=((GeoProj)proj).forwardRect(new LatLonPoint.Double(lat1,lon1),new LatLonPoint.Double(lat2,lon2),lineType,nsegs,!isClear(fillPaint));\n}\n else {\nrects=proj.forwardRect(new Point2D.Double(lon1,lat1),new Point2D.Double(lon2,lat2));\n}\nint size=rects.size();\nGeneralPath projectedShape=null;\nfor (int i=0; i < size; i+=2) {\nGeneralPath gp=createShape(rects.get(i),rects.get(i + 1),true);\nprojectedShape=appendShapeEdge(projectedShape,gp,false);\n}\nsetShape(projectedShape);\nbreak;\ncase RENDERTYPE_UNKNOWN:\nSystem.err.println(\"OMRect.generate(): invalid RenderType\");\nreturn false;\n}\nsetLabelLocation(getShape(),proj);\nsetNeedToRegenerate(false);\nreturn true;\n}\n", "nl": "Prepare the rectangle for rendering."}
{"code": "public void stream(OutputStream os) throws IOException {\n  MessageHeader globals=entries.elementAt(0);\n  if (globals.findValue(\"Signature-Version\") == null) {\n    throw new JarException(\"Signature file requires \" + \"Signature-Version: 1.0 in 1st header\");\n  }\n  PrintStream ps=new PrintStream(os);\n  globals.print(ps);\n  for (int i=1; i < entries.size(); ++i) {\n    MessageHeader mh=entries.elementAt(i);\n    mh.print(ps);\n  }\n}\n", "nl": "Add a signature file at current position in a stream"}
{"code": "public long readDateTimeAsLong(int index){\n  return this.readULong(index) << 32 | this.readULong(index + 4);\n}\n", "nl": "Reads the LONGDATETIME at the given index."}
{"code": "public static Value BagToSet(Value b){\n  FcnRcdValue fcn=FcnRcdValue.convert(b);\n  if (fcn == null) {\n    throw new EvalException(EC.TLC_MODULE_APPLYING_TO_WRONG_VALUE,new String[]{\"BagToSet\",\"a function with a finite domain\",Value.ppr(b.toString())});\n  }\n  return fcn.getDomain();\n}\n", "nl": "// For now, we do not override SubBag. So, We are using the TLA+ definition. public static Value SubBag(Value b) { FcnRcdValue fcn = FcnRcdValue.convert(b); if (fcn == null) { String msg = \"Applying SubBag to the following value, which is\\n\" + \"not a function with a finite domain:\\n\" + Value.ppr(b.toString()); throw new EvalException(msg); } throw new EvalException(\"SubBag is not implemented.\"); }"}
{"code": "public static ProjectActionEvent createProjectClosingEvent(ProjectDescriptor project){\n  return new ProjectActionEvent(project,ProjectAction.CLOSING,false);\n}\n", "nl": "Creates a Project Closing Event."}
{"code": "public int fullyConnectSync(Context srcContext,Handler srcHandler,Handler dstHandler){\n  int status=connectSync(srcContext,srcHandler,dstHandler);\n  if (status == STATUS_SUCCESSFUL) {\n    Message response=sendMessageSynchronously(CMD_CHANNEL_FULL_CONNECTION);\n    status=response.arg1;\n  }\n  return status;\n}\n", "nl": "Fully connect two local Handlers synchronously."}
{"code": "public static boolean hasInterface(String intf,String cls){\n  try {\n    return hasInterface(Class.forName(intf),Class.forName(cls));\n  }\n catch (  Exception e) {\n    return false;\n  }\n}\n", "nl": "Checks whether the given class implements the given interface."}
{"code": "public void removePropertyChangeListener(String propertyName,PropertyChangeListener in_pcl){\n  beanContextChildSupport.removePropertyChangeListener(propertyName,in_pcl);\n}\n", "nl": "Method for BeanContextChild interface. Uses the BeanContextChildSupport to remove a listener to this object's property. You don't need this function for objects that extend java.awt.Component."}
{"code": "private boolean isIgnoreLocallyExistingFiles(){\n  return ignoreLocallyExistingFiles;\n}\n", "nl": "Returns true to indicate that locally existing files are treated as they would not exist. This is a extension to the standard cvs-behaviour!"}
{"code": "private boolean isViewDescendantOf(View child,View parent){\n  if (child == parent) {\n    return true;\n  }\n  final ViewParent theParent=child.getParent();\n  return (theParent instanceof ViewGroup) && isViewDescendantOf((View)theParent,parent);\n}\n", "nl": "Return true if child is an descendant of parent, (or equal to the parent)."}
{"code": "public void add(double value){\n  if (count == 0) {\n    count=1;\n    mean=value;\n    min=value;\n    max=value;\n    if (!isFinite(value)) {\n      sumOfSquaresOfDeltas=NaN;\n    }\n  }\n else {\n    count++;\n    if (isFinite(value) && isFinite(mean)) {\n      double delta=value - mean;\n      mean+=delta / count;\n      sumOfSquaresOfDeltas+=delta * (value - mean);\n    }\n else {\n      mean=calculateNewMeanNonFinite(mean,value);\n      sumOfSquaresOfDeltas=NaN;\n    }\n    min=Math.min(min,value);\n    max=Math.max(max,value);\n  }\n}\n", "nl": "Adds the given value to the dataset."}
{"code": "private void init(Context context,RuqusTheme theme,String currClassName){\n  this.currClassName=currClassName;\n  inflate(context,R.layout.sort_field_view,this);\n  setOrientation(VERTICAL);\n  label=(TextView)findViewById(R.id.sort_field_label);\n  sortFieldChooser=(Spinner)findViewById(R.id.sort_field);\n  removeButton=(ImageButton)findViewById(R.id.remove_field);\n  sortDirRg=(RadioGroup)findViewById(R.id.rg_sort_dir);\n  ascRb=(RadioButton)findViewById(R.id.asc);\n  descRb=(RadioButton)findViewById(R.id.desc);\n  setTheme(theme);\n  sortFieldChooser.setOnTouchListener(sortFieldChooserListener);\n  sortFieldChooser.setOnItemSelectedListener(sortFieldChooserListener);\n}\n", "nl": "Initialize our view."}
{"code": "protected Future<Void> closeNoThrow(){\n  Promise<Void> closeFuture;\nsynchronized (this) {\n    if (null != closePromise) {\n      return closePromise;\n    }\n    closeFuture=closePromise=new Promise<Void>();\n  }\n  cancelTruncation();\n  Utils.closeSequence(bkDistributedLogManager.getScheduler(),true,getCachedLogWriter(),getAllocatedLogWriter(),getCachedWriteHandler()).proxyTo(closeFuture);\n  return closeFuture;\n}\n", "nl": "Close the writer and release all the underlying resources"}
{"code": "public Boolean isValidating(){\n  return validating;\n}\n", "nl": "Gets the value of the validating property."}
{"code": "private String scanPlainSpaces(){\n  int length=0;\n  while (reader.peek(length) == ' ' || reader.peek(length) == '\\t') {\n    length++;\n  }\n  String whitespaces=reader.prefixForward(length);\n  String lineBreak=scanLineBreak();\n  if (lineBreak.length() != 0) {\n    this.allowSimpleKey=true;\n    String prefix=reader.prefix(3);\n    if (\"---\".equals(prefix) || \"...\".equals(prefix) && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) {\n      return \"\";\n    }\n    StringBuilder breaks=new StringBuilder();\n    while (true) {\n      if (reader.peek() == ' ') {\n        reader.forward();\n      }\n else {\n        String lb=scanLineBreak();\n        if (lb.length() != 0) {\n          breaks.append(lb);\n          prefix=reader.prefix(3);\n          if (\"---\".equals(prefix) || \"...\".equals(prefix) && Constant.NULL_BL_T_LINEBR.has(reader.peek(3))) {\n            return \"\";\n          }\n        }\n else {\n          break;\n        }\n      }\n    }\n    if (!\"\\n\".equals(lineBreak)) {\n      return lineBreak + breaks;\n    }\n else     if (breaks.length() == 0) {\n      return \" \";\n    }\n    return breaks.toString();\n  }\n  return whitespaces;\n}\n", "nl": "See the specification for details. SnakeYAML and libyaml allow tabs inside plain scalar"}
{"code": "public static void w(String tag,String s,Throwable e){\n  if (LOG.WARN >= LOGLEVEL)   Log.w(tag,s,e);\n}\n", "nl": "Warning log message."}
{"code": "public static double mean(double[] vector){\n  double sum=0;\n  if (vector.length == 0) {\n    return 0;\n  }\n  for (int i=0; i < vector.length; i++) {\n    sum+=vector[i];\n  }\n  return sum / (double)vector.length;\n}\n", "nl": "Computes the mean for an array of doubles."}
{"code": "protected byte[] toJsonBytes(final Object object) throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  mapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);\n  return mapper.writeValueAsBytes(object);\n}\n", "nl": "Map object to JSON bytes"}
{"code": "public void shuffleInventory(@Nonnull IInventory inv,@Nonnull Random random){\n  final List<ItemStack> list=getInventoryList(inv);\n  Collections.shuffle(list,random);\n  for (int i=0; i < inv.getSizeInventory(); ++i) {\n    inv.setInventorySlotContents(i,list.get(i));\n  }\n}\n", "nl": "Shuffles all items in the inventory"}
{"code": "public QueueCursor(int capacity){\n  this(capacity,false);\n}\n", "nl": "Creates an <tt>QueueCursor</tt> with the given (fixed) capacity and default access policy."}
{"code": "public void destroy(DistributedRegion r){\n}\n", "nl": "Blows away all the data in this object."}
{"code": "public Process executeAsync(final CommandLine command,ExecuteResultHandler handler) throws IOException {\n  return executeAsync(command,null,handler);\n}\n", "nl": "Methods for starting asynchronous execution. The child process inherits all environment variables of the parent process. Result provided to callback handler."}
{"code": "public static void destroy(){\n  try {\n    Region region1=cache.getRegion(Region.SEPARATOR + REGION_NAME);\n    region1.localDestroy(\"key-1\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail(\"test failed due to exception in destroy \");\n  }\n}\n", "nl": "destroy key-1"}
{"code": "public boolean isSelected(){\n  return this.selected;\n}\n", "nl": "Check if item is selected"}
{"code": "public String(String string){\n  value=string.value;\n  offset=string.offset;\n  count=string.count;\n}\n", "nl": "Creates a string that is a copy of another string"}
{"code": "private void needNewBuffer(int newSize){\n  int delta=newSize - size;\n  int newBufferSize=Math.max(minChunkLen,delta);\n  currentBufferIndex++;\n  currentBuffer=new int[newBufferSize];\n  offset=0;\n  if (currentBufferIndex >= buffers.length) {\n    int newLen=buffers.length << 1;\n    int[][] newBuffers=new int[newLen][];\n    System.arraycopy(buffers,0,newBuffers,0,buffers.length);\n    buffers=newBuffers;\n  }\n  buffers[currentBufferIndex]=currentBuffer;\n  buffersCount++;\n}\n", "nl": "Prepares next chunk to match new size. The minimal length of new chunk is <code>minChunkLen</code>."}
{"code": "public void patch_splitMax(LinkedList<Patch> patches){\n  short patch_size=Match_MaxBits;\n  String precontext, postcontext;\n  Patch patch;\n  int start1, start2;\n  boolean empty;\n  Operation diff_type;\n  String diff_text;\n  ListIterator<Patch> pointer=patches.listIterator();\n  Patch bigpatch=pointer.hasNext() ? pointer.next() : null;\n  while (bigpatch != null) {\n    if (bigpatch.length1 <= Match_MaxBits) {\n      bigpatch=pointer.hasNext() ? pointer.next() : null;\n      continue;\n    }\n    pointer.remove();\n    start1=bigpatch.start1;\n    start2=bigpatch.start2;\n    precontext=\"\";\n    while (!bigpatch.diffs.isEmpty()) {\n      patch=new Patch();\n      empty=true;\n      patch.start1=start1 - precontext.length();\n      patch.start2=start2 - precontext.length();\n      if (precontext.length() != 0) {\n        patch.length1=patch.length2=precontext.length();\n        patch.diffs.add(new Diff(Operation.EQUAL,precontext));\n      }\n      while (!bigpatch.diffs.isEmpty() && patch.length1 < patch_size - Patch_Margin) {\n        diff_type=bigpatch.diffs.getFirst().operation;\n        diff_text=bigpatch.diffs.getFirst().text;\n        if (diff_type == Operation.INSERT) {\n          patch.length2+=diff_text.length();\n          start2+=diff_text.length();\n          patch.diffs.addLast(bigpatch.diffs.removeFirst());\n          empty=false;\n        }\n else         if (diff_type == Operation.DELETE && patch.diffs.size() == 1 && patch.diffs.getFirst().operation == Operation.EQUAL && diff_text.length() > 2 * patch_size) {\n          patch.length1+=diff_text.length();\n          start1+=diff_text.length();\n          empty=false;\n          patch.diffs.add(new Diff(diff_type,diff_text));\n          bigpatch.diffs.removeFirst();\n        }\n else {\n          diff_text=diff_text.substring(0,Math.min(diff_text.length(),patch_size - patch.length1 - Patch_Margin));\n          patch.length1+=diff_text.length();\n          start1+=diff_text.length();\n          if (diff_type == Operation.EQUAL) {\n            patch.length2+=diff_text.length();\n            start2+=diff_text.length();\n          }\n else {\n            empty=false;\n          }\n          patch.diffs.add(new Diff(diff_type,diff_text));\n          if (diff_text.equals(bigpatch.diffs.getFirst().text)) {\n            bigpatch.diffs.removeFirst();\n          }\n else {\n            bigpatch.diffs.getFirst().text=bigpatch.diffs.getFirst().text.substring(diff_text.length());\n          }\n        }\n      }\n      precontext=diff_text2(patch.diffs);\n      precontext=precontext.substring(Math.max(0,precontext.length() - Patch_Margin));\n      if (diff_text1(bigpatch.diffs).length() > Patch_Margin) {\n        postcontext=diff_text1(bigpatch.diffs).substring(0,Patch_Margin);\n      }\n else {\n        postcontext=diff_text1(bigpatch.diffs);\n      }\n      if (postcontext.length() != 0) {\n        patch.length1+=postcontext.length();\n        patch.length2+=postcontext.length();\n        if (!patch.diffs.isEmpty() && patch.diffs.getLast().operation == Operation.EQUAL) {\n          patch.diffs.getLast().text+=postcontext;\n        }\n else {\n          patch.diffs.add(new Diff(Operation.EQUAL,postcontext));\n        }\n      }\n      if (!empty) {\n        pointer.add(patch);\n      }\n    }\n    bigpatch=pointer.hasNext() ? pointer.next() : null;\n  }\n}\n", "nl": "Look through the patches and break up any which are longer than the maximum limit of the match algorithm. Intended to be called only from within patch_apply."}
{"code": "public static TestResult execJavac(String toCompile,File dir,String jflexTestVersion){\n  Project p=new Project();\n  Javac javac=new Javac();\n  Path path=new Path(p,dir.toString());\n  javac.setProject(p);\n  javac.setSrcdir(path);\n  javac.setDestdir(dir);\n  javac.setTarget(javaVersion);\n  javac.setSource(javaVersion);\n  javac.setSourcepath(new Path(p,\"\"));\n  javac.setIncludes(toCompile);\n  Path classPath=javac.createClasspath();\n  classPath.setPath(System.getProperty(\"user.home\") + \"/.m2/repository/de/jflex/jflex/\" + jflexTestVersion+ \"/jflex-\"+ jflexTestVersion+ \".jar\");\n  ByteArrayOutputStream out=new ByteArrayOutputStream();\n  PrintStream outSafe=System.err;\n  System.setErr(new PrintStream(out));\n  try {\n    javac.execute();\n    return new TestResult(out.toString(),true);\n  }\n catch (  BuildException e) {\n    return new TestResult(e + System.getProperty(\"line.separator\") + out.toString(),false);\n  }\n finally {\n    System.setErr(outSafe);\n  }\n}\n", "nl": "Call javac on toCompile in input dir. If toCompile is null,  all *.java files below dir will be compiled."}
{"code": "private void cloneProperties(BurpCertificate certificate,BurpCertificateBuilder burpCertificateBuilder){\n  burpCertificateBuilder.setVersion(certificate.getVersionNumber());\n  burpCertificateBuilder.setSerial(certificate.getSerialNumberBigInteger());\n  if (certificate.getPublicKeyAlgorithm().equals(\"RSA\")) {\n    burpCertificateBuilder.setSignatureAlgorithm(certificate.getSignatureAlgorithm());\n  }\n else {\n    burpCertificateBuilder.setSignatureAlgorithm(\"SHA256withRSA\");\n  }\n  burpCertificateBuilder.setIssuer(certificate.getIssuer());\n  burpCertificateBuilder.setNotAfter(certificate.getNotAfter());\n  burpCertificateBuilder.setNotBefore(certificate.getNotBefore());\n  burpCertificateBuilder.setKeySize(certificate.getKeySize());\n  for (  BurpCertificateExtension extension : certificate.getAllExtensions()) {\n    burpCertificateBuilder.addExtension(extension);\n  }\n}\n", "nl": "Copy all X.509v3 general information and all extensions 1:1 from one source certificat to one destination certificate."}
{"code": "protected void emit_PropertyMethodDeclaration_SemicolonKeyword_1_q(EObject semanticObject,ISynNavigable transition,List<INode> nodes){\n  acceptNodes(transition,nodes);\n}\n", "nl": "Ambiguous syntax: ';'? This ambiguous syntax occurs at: body=Block (ambiguity) (rule end) declaredName=LiteralOrComputedPropertyName '(' ')' (ambiguity) (rule end) fpars+=FormalParameter ')' (ambiguity) (rule end)"}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  Element rootNode;\n  Node newChild;\n  NodeList elementList;\n  Node oldChild;\n  Node replacedChild;\n  doc=(Document)load(\"hc_staff\",true);\n  newChild=doc.createAttribute(\"lang\");\n  elementList=doc.getElementsByTagName(\"p\");\n  oldChild=elementList.item(1);\n  rootNode=(Element)oldChild.getParentNode();\n{\n    boolean success=false;\n    try {\n      replacedChild=rootNode.replaceChild(newChild,oldChild);\n    }\n catch (    DOMException ex) {\n      success=(ex.code == DOMException.HIERARCHY_REQUEST_ERR);\n    }\n    assertTrue(\"throw_HIERARCHY_REQUEST_ERR\",success);\n  }\n}\n", "nl": "Runs the test case."}
{"code": "public void preComputeBestReplicaMapping(){\n  Map<String,Map<String,Map<String,String>>> collectionToShardToCoreMapping=getZkClusterData().getCollectionToShardToCoreMapping();\n  for (  String collection : collectionNames) {\n    Map<String,Map<String,String>> shardToCoreMapping=collectionToShardToCoreMapping.get(collection);\n    for (    String shard : shardToCoreMapping.keySet()) {\n      Map<String,String> coreToNodeMap=shardToCoreMapping.get(shard);\n      for (      String core : coreToNodeMap.keySet()) {\n        String currentCore=core;\n        String node=coreToNodeMap.get(core);\n        SolrCore currentReplica=new SolrCore(node,currentCore);\n        try {\n          currentReplica.loadStatus();\n          fillUpAllCoresForShard(currentReplica,coreToNodeMap);\n          break;\n        }\n catch (        Exception e) {\n          logger.info(ExceptionUtils.getFullStackTrace(e));\n          continue;\n        }\n      }\n      shardToBestReplicaMapping.put(shard,coreToBestReplicaMappingByHealth);\n    }\n  }\n}\n", "nl": "For all the collections in zookeeper, compute the best replica for every shard for every collection. Doing this computation at bootup significantly reduces the computation done during streaming."}
{"code": "private void statInit(){\n  lDocumentNo.setLabelFor(fDocumentNo);\n  fDocumentNo.setBackground(AdempierePLAF.getInfoBackground());\n  fDocumentNo.addActionListener(this);\n  lDescription.setLabelFor(fDescription);\n  fDescription.setBackground(AdempierePLAF.getInfoBackground());\n  fDescription.addActionListener(this);\n  lPOReference.setLabelFor(fPOReference);\n  fPOReference.setBackground(AdempierePLAF.getInfoBackground());\n  fPOReference.addActionListener(this);\n  fIsSOTrx.setSelected(!\"N\".equals(Env.getContext(Env.getCtx(),p_WindowNo,\"IsSOTrx\")));\n  fIsSOTrx.addActionListener(this);\n  fBPartner_ID=new VLookup(\"C_BPartner_ID\",false,false,true,MLookupFactory.get(Env.getCtx(),p_WindowNo,0,MColumn.getColumn_ID(MInOut.Table_Name,MInOut.COLUMNNAME_C_BPartner_ID),DisplayType.Search));\n  lBPartner_ID.setLabelFor(fBPartner_ID);\n  fBPartner_ID.setBackground(AdempierePLAF.getInfoBackground());\n  fBPartner_ID.addActionListener(this);\n  fShipper_ID=new VLookup(\"M_Shipper_ID\",false,false,true,MLookupFactory.get(Env.getCtx(),p_WindowNo,0,MColumn.getColumn_ID(MInOut.Table_Name,MInOut.COLUMNNAME_M_Shipper_ID),DisplayType.TableDir));\n  lShipper_ID.setLabelFor(fShipper_ID);\n  fShipper_ID.setBackground(AdempierePLAF.getInfoBackground());\n  fShipper_ID.addActionListener(this);\n  lDateFrom.setLabelFor(fDateFrom);\n  fDateFrom.setBackground(AdempierePLAF.getInfoBackground());\n  fDateFrom.setToolTipText(Msg.translate(Env.getCtx(),\"DateFrom\"));\n  fDateFrom.addActionListener(this);\n  lDateTo.setLabelFor(fDateTo);\n  fDateTo.setBackground(AdempierePLAF.getInfoBackground());\n  fDateTo.setToolTipText(Msg.translate(Env.getCtx(),\"DateTo\"));\n  fDateTo.addActionListener(this);\n  CPanel datePanel=new CPanel();\n  datePanel.setLayout(new ALayout(0,0,true));\n  datePanel.add(fDateFrom,new ALayoutConstraint(0,0));\n  datePanel.add(lDateTo,null);\n  datePanel.add(fDateTo,null);\n  p_criteriaGrid.add(lDocumentNo,new ALayoutConstraint(0,0));\n  p_criteriaGrid.add(fDocumentNo,null);\n  p_criteriaGrid.add(lBPartner_ID,null);\n  p_criteriaGrid.add(fBPartner_ID,null);\n  p_criteriaGrid.add(fIsSOTrx,new ALayoutConstraint(0,5));\n  p_criteriaGrid.add(lDescription,new ALayoutConstraint(1,0));\n  p_criteriaGrid.add(fDescription,null);\n  p_criteriaGrid.add(lDateFrom,null);\n  p_criteriaGrid.add(datePanel,null);\n  p_criteriaGrid.add(lPOReference,new ALayoutConstraint(2,0));\n  p_criteriaGrid.add(fPOReference,null);\n  p_criteriaGrid.add(lShipper_ID,null);\n  p_criteriaGrid.add(fShipper_ID,null);\n}\n", "nl": "Static Setup - add fields to parameterPanel"}
{"code": "@Override public boolean check(final CertificateToken certificateToken){\n  final boolean keyUsage=certificateToken.checkKeyUsage(bit);\n  return keyUsage == value;\n}\n", "nl": "Checks the condition for the given certificate."}
{"code": "public static boolean isValidFolderPath(Path path){\n  if (path == null) {\n    return false;\n  }\n  File f=path.toFile();\n  return path.toString().isEmpty() || (f.isDirectory() && f.canWrite());\n}\n", "nl": "Checks is the parameter path a valid for saving fixed file"}
{"code": "public float[][] extract(int maxFeatureValue,int[] distanceSet,int[][] img){\n  int[] histogram=new int[maxFeatureValue];\n  final int W=img.length;\n  final int H=img[0].length;\n  for (int x=0; x < W; x++) {\n    for (int y=0; y < H; y++) {\n      histogram[img[x][y]]++;\n    }\n  }\n  float[][] correlogram=new float[maxFeatureValue][distanceSet.length];\n  int[] tmpCorrelogram=new int[distanceSet.length];\n  for (int x=0; x < W; x++) {\n    for (int y=0; y < H; y++) {\n      int color=img[x][y];\n      getNumPixelsInNeighbourhood(x,y,img,tmpCorrelogram,maxFeatureValue,distanceSet);\n      for (int i=0; i < distanceSet.length; i++) {\n        correlogram[color][i]+=tmpCorrelogram[i];\n      }\n    }\n  }\n  float[] max=new float[distanceSet.length];\n  for (int c=0; c < maxFeatureValue; c++) {\n    for (int i=0; i < distanceSet.length; i++) {\n      max[i]=Math.max(correlogram[c][i],max[i]);\n    }\n  }\n  for (int c=0; c < maxFeatureValue; c++) {\n    for (int i=0; i < distanceSet.length; i++) {\n      correlogram[c][i]=correlogram[c][i] / max[i];\n    }\n  }\n  return correlogram;\n}\n", "nl": "extract extracts an auto-correlogram from an Image. This method create a cummulated auto-correlogram over different distances instead of standard method. Also, uses a different normalization method"}
{"code": "public static CC parseComponentConstraint(String s){\n  CC cc=new CC();\n  if (s.length() == 0) {\n    return cc;\n  }\n  String[] parts=toTrimmedTokens(s,',');\n  for (  String part : parts) {\n    try {\n      if (part.length() == 0) {\n        continue;\n      }\n      int ix=-1;\n      char c=part.charAt(0);\n      if (c == 'n') {\n        if (part.equals(\"north\")) {\n          cc.setDockSide(0);\n          continue;\n        }\n        if (part.equals(\"newline\")) {\n          cc.setNewline(true);\n          continue;\n        }\n        if (part.startsWith(\"newline \")) {\n          String gapSz=part.substring(7).trim();\n          cc.setNewlineGapSize(parseBoundSize(gapSz,true,true));\n          continue;\n        }\n      }\n      if (c == 'f' && (part.equals(\"flowy\") || part.equals(\"flowx\"))) {\n        cc.setFlowX(part.charAt(4) == 'x' ? Boolean.TRUE : Boolean.FALSE);\n        continue;\n      }\n      if (c == 's') {\n        ix=startsWithLenient(part,\"skip\",4,true);\n        if (ix > -1) {\n          String num=part.substring(ix).trim();\n          cc.setSkip(num.length() != 0 ? Integer.parseInt(num) : 1);\n          continue;\n        }\n        ix=startsWithLenient(part,\"split\",5,true);\n        if (ix > -1) {\n          String split=part.substring(ix).trim();\n          cc.setSplit(split.length() > 0 ? Integer.parseInt(split) : LayoutUtil.INF);\n          continue;\n        }\n        if (part.equals(\"south\")) {\n          cc.setDockSide(2);\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"spany\",\"sy\"},new int[]{5,2},true);\n        if (ix > -1) {\n          cc.setSpanY(parseSpan(part.substring(ix).trim()));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"spanx\",\"sx\"},new int[]{5,2},true);\n        if (ix > -1) {\n          cc.setSpanX(parseSpan(part.substring(ix).trim()));\n          continue;\n        }\n        ix=startsWithLenient(part,\"span\",4,true);\n        if (ix > -1) {\n          String[] spans=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.setSpanX(spans[0].length() > 0 ? Integer.parseInt(spans[0]) : LayoutUtil.INF);\n          cc.setSpanY(spans.length > 1 ? Integer.parseInt(spans[1]) : 1);\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrinkx\",7,true);\n        if (ix > -1) {\n          cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrinky\",7,true);\n        if (ix > -1) {\n          cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrink\",6,false);\n        if (ix > -1) {\n          String[] shrinks=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          if (shrinks.length > 1) {\n            cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          }\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"shrinkprio\",\"shp\"},new int[]{10,3},true);\n        if (ix > -1) {\n          String sp=part.substring(ix).trim();\n          if (sp.startsWith(\"x\") || sp.startsWith(\"y\")) {\n            (sp.startsWith(\"x\") ? cc.getHorizontal() : cc.getVertical()).setShrinkPriority(Integer.parseInt(sp.substring(2)));\n          }\n else {\n            String[] shrinks=toTrimmedTokens(sp,' ');\n            cc.getHorizontal().setShrinkPriority(Integer.parseInt(shrinks[0]));\n            if (shrinks.length > 1) {\n              cc.getVertical().setShrinkPriority(Integer.parseInt(shrinks[1]));\n            }\n          }\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"sizegroupx\",\"sizegroupy\",\"sgx\",\"sgy\"},new int[]{9,9,2,2},true);\n        if (ix > -1) {\n          String sg=part.substring(ix).trim();\n          char lc=part.charAt(ix - 1);\n          if (lc != 'y') {\n            cc.getHorizontal().setSizeGroup(sg);\n          }\n          if (lc != 'x') {\n            cc.getVertical().setSizeGroup(sg);\n          }\n          continue;\n        }\n      }\n      if (c == 'g') {\n        ix=startsWithLenient(part,\"growx\",5,true);\n        if (ix > -1) {\n          cc.getHorizontal().setGrow(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"growy\",5,true);\n        if (ix > -1) {\n          cc.getVertical().setGrow(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"grow\",4,false);\n        if (ix > -1) {\n          String[] grows=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setGrow(parseFloat(grows[0],ResizeConstraint.WEIGHT_100));\n          cc.getVertical().setGrow(parseFloat(grows.length > 1 ? grows[1] : \"\",ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"growprio\",\"gp\"},new int[]{8,2},true);\n        if (ix > -1) {\n          String gp=part.substring(ix).trim();\n          char c0=gp.length() > 0 ? gp.charAt(0) : ' ';\n          if (c0 == 'x' || c0 == 'y') {\n            (c0 == 'x' ? cc.getHorizontal() : cc.getVertical()).setGrowPriority(Integer.parseInt(gp.substring(2)));\n          }\n else {\n            String[] grows=toTrimmedTokens(gp,' ');\n            cc.getHorizontal().setGrowPriority(Integer.parseInt(grows[0]));\n            if (grows.length > 1) {\n              cc.getVertical().setGrowPriority(Integer.parseInt(grows[1]));\n            }\n          }\n          continue;\n        }\n        if (part.startsWith(\"gap\")) {\n          BoundSize[] gaps=parseGaps(part);\n          if (gaps[0] != null) {\n            cc.getVertical().setGapBefore(gaps[0]);\n          }\n          if (gaps[1] != null) {\n            cc.getHorizontal().setGapBefore(gaps[1]);\n          }\n          if (gaps[2] != null) {\n            cc.getVertical().setGapAfter(gaps[2]);\n          }\n          if (gaps[3] != null) {\n            cc.getHorizontal().setGapAfter(gaps[3]);\n          }\n          continue;\n        }\n      }\n      if (c == 'a') {\n        ix=startsWithLenient(part,new String[]{\"aligny\",\"ay\"},new int[]{6,2},true);\n        if (ix > -1) {\n          cc.getVertical().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(),false,null));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"alignx\",\"ax\"},new int[]{6,2},true);\n        if (ix > -1) {\n          cc.getHorizontal().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(),true,null));\n          continue;\n        }\n        ix=startsWithLenient(part,\"align\",2,true);\n        if (ix > -1) {\n          String[] gaps=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setAlign(parseUnitValueOrAlign(gaps[0],true,null));\n          if (gaps.length > 1) {\n            cc.getVertical().setAlign(parseUnitValueOrAlign(gaps[1],false,null));\n          }\n          continue;\n        }\n      }\n      if ((c == 'x' || c == 'y') && part.length() > 2) {\n        char c2=part.charAt(1);\n        if (c2 == ' ' || (c2 == '2' && part.charAt(2) == ' ')) {\n          if (cc.getPos() == null) {\n            cc.setPos(new UnitValue[4]);\n          }\n else           if (cc.isBoundsInGrid() == false) {\n            throw new IllegalArgumentException(\"Cannot combine 'position' with 'x/y/x2/y2' keywords.\");\n          }\n          int edge=(c == 'x' ? 0 : 1) + (c2 == '2' ? 2 : 0);\n          UnitValue[] pos=cc.getPos();\n          pos[edge]=parseUnitValue(part.substring(2).trim(),null,c == 'x');\n          cc.setPos(pos);\n          cc.setBoundsInGrid(true);\n          continue;\n        }\n      }\n      if (c == 'c') {\n        ix=startsWithLenient(part,\"cell\",4,true);\n        if (ix > -1) {\n          String[] grs=toTrimmedTokens(part.substring(ix).trim(),' ');\n          if (grs.length < 2) {\n            throw new IllegalArgumentException(\"At least two integers must follow \" + part);\n          }\n          cc.setCellX(Integer.parseInt(grs[0]));\n          cc.setCellY(Integer.parseInt(grs[1]));\n          if (grs.length > 2) {\n            cc.setSpanX(Integer.parseInt(grs[2]));\n          }\n          if (grs.length > 3) {\n            cc.setSpanY(Integer.parseInt(grs[3]));\n          }\n          continue;\n        }\n      }\n      if (c == 'p') {\n        ix=startsWithLenient(part,\"pos\",3,true);\n        if (ix > -1) {\n          if (cc.getPos() != null && cc.isBoundsInGrid()) {\n            throw new IllegalArgumentException(\"Can not combine 'pos' with 'x/y/x2/y2' keywords.\");\n          }\n          String[] pos=toTrimmedTokens(part.substring(ix).trim(),' ');\n          UnitValue[] bounds=new UnitValue[4];\n          for (int j=0; j < pos.length; j++) {\n            bounds[j]=parseUnitValue(pos[j],null,j % 2 == 0);\n          }\n          if (bounds[0] == null && bounds[2] == null || bounds[1] == null && bounds[3] == null) {\n            throw new IllegalArgumentException(\"Both x and x2 or y and y2 can not be null!\");\n          }\n          cc.setPos(bounds);\n          cc.setBoundsInGrid(false);\n          continue;\n        }\n        ix=startsWithLenient(part,\"pad\",3,true);\n        if (ix > -1) {\n          UnitValue[] p=parseInsets(part.substring(ix).trim(),false);\n          cc.setPadding(new UnitValue[]{p[0],p.length > 1 ? p[1] : null,p.length > 2 ? p[2] : null,p.length > 3 ? p[3] : null});\n          continue;\n        }\n        ix=startsWithLenient(part,\"pushx\",5,true);\n        if (ix > -1) {\n          cc.setPushX(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"pushy\",5,true);\n        if (ix > -1) {\n          cc.setPushY(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"push\",4,false);\n        if (ix > -1) {\n          String[] pushs=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.setPushX(parseFloat(pushs[0],ResizeConstraint.WEIGHT_100));\n          cc.setPushY(parseFloat(pushs.length > 1 ? pushs[1] : \"\",ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n      }\n      if (c == 't') {\n        ix=startsWithLenient(part,\"tag\",3,true);\n        if (ix > -1) {\n          cc.setTag(part.substring(ix).trim());\n          continue;\n        }\n      }\n      if (c == 'w' || c == 'h') {\n        if (part.equals(\"wrap\")) {\n          cc.setWrap(true);\n          continue;\n        }\n        if (part.startsWith(\"wrap \")) {\n          String gapSz=part.substring(5).trim();\n          cc.setWrapGapSize(parseBoundSize(gapSz,true,true));\n          continue;\n        }\n        boolean isHor=c == 'w';\n        if (isHor && (part.startsWith(\"w \") || part.startsWith(\"width \"))) {\n          String uvStr=part.substring(part.charAt(1) == ' ' ? 2 : 6).trim();\n          cc.getHorizontal().setSize(parseBoundSize(uvStr,false,true));\n          continue;\n        }\n        if (!isHor && (part.startsWith(\"h \") || part.startsWith(\"height \"))) {\n          String uvStr=part.substring(part.charAt(1) == ' ' ? 2 : 7).trim();\n          cc.getVertical().setSize(parseBoundSize(uvStr,false,false));\n          continue;\n        }\n        if (part.startsWith(\"wmin \") || part.startsWith(\"wmax \") || part.startsWith(\"hmin \")|| part.startsWith(\"hmax \")) {\n          String uvStr=part.substring(5).trim();\n          if (uvStr.length() > 0) {\n            UnitValue uv=parseUnitValue(uvStr,null,isHor);\n            boolean isMin=part.charAt(3) == 'n';\n            DimConstraint dc=isHor ? cc.getHorizontal() : cc.getVertical();\n            dc.setSize(new BoundSize(isMin ? uv : dc.getSize().getMin(),dc.getSize().getPreferred(),isMin ? (dc.getSize().getMax()) : uv,uvStr));\n            continue;\n          }\n        }\n        if (part.equals(\"west\")) {\n          cc.setDockSide(1);\n          continue;\n        }\n        if (part.startsWith(\"hidemode \")) {\n          cc.setHideMode(Integer.parseInt(part.substring(9)));\n          continue;\n        }\n      }\n      if (c == 'i' && part.startsWith(\"id \")) {\n        cc.setId(part.substring(3).trim());\n        int dIx=cc.getId().indexOf('.');\n        if (dIx == 0 || dIx == cc.getId().length() - 1) {\n          throw new IllegalArgumentException(\"Dot must not be first or last!\");\n        }\n        continue;\n      }\n      if (c == 'e') {\n        if (part.equals(\"east\")) {\n          cc.setDockSide(3);\n          continue;\n        }\n        if (part.equals(\"external\")) {\n          cc.setExternal(true);\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"endgroupx\",\"endgroupy\",\"egx\",\"egy\"},new int[]{-1,-1,-1,-1},true);\n        if (ix > -1) {\n          String sg=part.substring(ix).trim();\n          char lc=part.charAt(ix - 1);\n          DimConstraint dc=(lc == 'x' ? cc.getHorizontal() : cc.getVertical());\n          dc.setEndGroup(sg);\n          continue;\n        }\n      }\n      if (c == 'd') {\n        if (part.equals(\"dock north\")) {\n          cc.setDockSide(0);\n          continue;\n        }\n        if (part.equals(\"dock west\")) {\n          cc.setDockSide(1);\n          continue;\n        }\n        if (part.equals(\"dock south\")) {\n          cc.setDockSide(2);\n          continue;\n        }\n        if (part.equals(\"dock east\")) {\n          cc.setDockSide(3);\n          continue;\n        }\n        if (part.equals(\"dock center\")) {\n          cc.getHorizontal().setGrow(new Float(100f));\n          cc.getVertical().setGrow(new Float(100f));\n          cc.setPushX(new Float(100f));\n          cc.setPushY(new Float(100f));\n          continue;\n        }\n      }\n      if (c == 'v') {\n        ix=startsWithLenient(part,new String[]{\"visualpadding\",\"vp\"},new int[]{3,2},true);\n        if (ix > -1) {\n          UnitValue[] p=parseInsets(part.substring(ix).trim(),false);\n          cc.setVisualPadding(new UnitValue[]{p[0],p.length > 1 ? p[1] : null,p.length > 2 ? p[2] : null,p.length > 3 ? p[3] : null});\n          continue;\n        }\n      }\n      UnitValue horAlign=parseAlignKeywords(part,true);\n      if (horAlign != null) {\n        cc.getHorizontal().setAlign(horAlign);\n        continue;\n      }\n      UnitValue verAlign=parseAlignKeywords(part,false);\n      if (verAlign != null) {\n        cc.getVertical().setAlign(verAlign);\n        continue;\n      }\n      throw new IllegalArgumentException(\"Unknown keyword.\");\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n      throw new IllegalArgumentException(\"Error parsing Constraint: '\" + part + \"'\");\n    }\n  }\n  return cc;\n}\n", "nl": "Parses one component constraint and returns the parsed value."}
{"code": "SegmentTreeNode<?> computeRightChild(SegmentTreeNode<?> node){\n  if (node.right - node.left > 1) {\n    return constructor.construct((node.left + node.right) / 2,node.right);\n  }\n  return null;\n}\n", "nl": "Compute the right child node, if it exists"}
{"code": "public static boolean isValidIPAddress(String address){\n  if (address == null || address.length() == 0) {\n    return false;\n  }\n  boolean ipv6Expected=false;\n  if (address.charAt(0) == '[') {\n    if (address.length() > 2 && address.charAt(address.length() - 1) == ']') {\n      address=address.substring(1,address.length() - 1);\n      ipv6Expected=true;\n    }\n else {\n      return false;\n    }\n  }\n  if (Character.digit(address.charAt(0),16) != -1 || (address.charAt(0) == ':')) {\n    byte[] addr=null;\n    addr=strToIPv4(address);\n    if (addr == null) {\n      addr=strToIPv6(address);\n    }\n else     if (ipv6Expected) {\n      return false;\n    }\n    if (addr != null) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks whether <tt>address</tt> is a valid IP address string."}
{"code": "private void loadVerticesAndRelatives(){\n  List<CnATreeElement> elementList=new LinkedList<CnATreeElement>();\n  for (  IGraphElementLoader loader : getLoaderList()) {\n    loader.setCnaTreeElementDao(getCnaTreeElementDao());\n    elementList.addAll(loader.loadElements());\n  }\n  for (  CnATreeElement element : elementList) {\n    graph.addVertex(element);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Vertex added: \" + element.getTitle());\n    }\n    uuidMap.put(element.getUuid(),element);\n  }\n  for (  CnATreeElement parent : elementList) {\n    Set<CnATreeElement> children=parent.getChildren();\n    for (    CnATreeElement child : children) {\n      createParentChildEdge(parent,child);\n    }\n  }\n}\n", "nl": "Loads all vertices and adds them to the graph. An edge for each children is added if the child is part of the graph."}
{"code": "private void initializeLiveAttributes(){\n  transform=createLiveAnimatedTransformList(null,SVG_TRANSFORM_ATTRIBUTE,\"\");\n  externalResourcesRequired=createLiveAnimatedBoolean(null,SVG_EXTERNAL_RESOURCES_REQUIRED_ATTRIBUTE,false);\n}\n", "nl": "Initializes the live attribute values of this element."}
{"code": "public void putParcelable(String key,Parcelable value){\n  unparcel();\n  mMap.put(key,value);\n  mFdsKnown=false;\n}\n", "nl": "Inserts a Parcelable value into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "public static <T>Collection<T> flatten(Iterable<T> self,Closure<? extends T> flattenUsing){\n  return flatten(self,createSimilarCollection(self),flattenUsing);\n}\n", "nl": "Flatten an Iterable.  This Iterable and any nested arrays or collections have their contents (recursively) added to the new collection. For any non-Array, non-Collection object which represents some sort of collective type, the supplied closure should yield the contained items; otherwise, the closure should just return any element which corresponds to a leaf."}
{"code": "public double semiDeviation(){\n  return Math.sqrt(semiVariance());\n}\n", "nl": "returns the semi deviation, defined as the square root of the semi variance."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String val=getString(stack);\n  Sage.put(getString(stack),val);\n  return null;\n}\n", "nl": "Sets the property with the specified name to the specified value. If this is called from a client instance then it will use the properties on the server system for this call and the change will be made on the server system."}
{"code": "protected Preference createUserDictionaryPreference(String locale,Activity activity){\n  final Preference newPref=new Preference(getActivity());\n  final Intent intent=new Intent(USER_DICTIONARY_SETTINGS_INTENT_ACTION);\n  if (null == locale) {\n    newPref.setTitle(Locale.getDefault().getDisplayName());\n  }\n else {\n    if (\"\".equals(locale))     newPref.setTitle(getString(R.string.user_dict_settings_all_languages));\n else     newPref.setTitle(Utils.createLocaleFromString(locale).getDisplayName());\n    intent.putExtra(\"locale\",locale);\n    newPref.getExtras().putString(\"locale\",locale);\n  }\n  newPref.setIntent(intent);\n  newPref.setFragment(com.android.settings.UserDictionarySettings.class.getName());\n  return newPref;\n}\n", "nl": "Create a single User Dictionary Preference object, with its parameters set."}
{"code": "public static <T>T withPrintWriter(Path self,@ClosureParams(value=SimpleType.class,options=\"java.io.PrintWriter\") Closure<T> closure) throws IOException {\n  return IOGroovyMethods.withWriter(newPrintWriter(self),closure);\n}\n", "nl": "Create a new PrintWriter for this file which is then passed it into the given closure.  This method ensures its the writer is closed after the closure returns."}
{"code": "public void testBug77649() throws Exception {\n  Properties props=getPropertiesFromTestsuiteUrl();\n  String host=props.getProperty(NonRegisteringDriver.HOST_PROPERTY_KEY);\n  String port=props.getProperty(NonRegisteringDriver.PORT_PROPERTY_KEY);\n  String[] hosts=new String[]{host,\"address\",\"address.somewhere\",\"addressing\",\"addressing.somewhere\"};\n  UnreliableSocketFactory.flushAllStaticData();\n  for (int i=1; i < hosts.length; i++) {\n    UnreliableSocketFactory.mapHost(hosts[i],host);\n  }\n  props=getHostFreePropertiesFromTestsuiteUrl();\n  props.setProperty(\"socketFactory\",UnreliableSocketFactory.class.getName());\n  for (  String h : hosts) {\n    getConnectionWithProps(String.format(\"jdbc:mysql://%s:%s\",h,port),props).close();\n    getConnectionWithProps(String.format(\"jdbc:mysql://address=(protocol=tcp)(host=%s)(port=%s)\",h,port),props).close();\n  }\n}\n", "nl": "Tests fix for Bug#77649 - URL start with word \"address\",JDBC can't parse the \"host:port\" Correctly."}
{"code": "public final Iterator<PluginPatternMatcher> pathsIterator(){\n  return mDataPaths != null ? mDataPaths.iterator() : null;\n}\n", "nl": "Return an iterator over the filter's data paths."}
{"code": "private void checkInMoving(float x,float y){\n  final int xDiff=(int)Math.abs(x - lastMotionX);\n  final int yDiff=(int)Math.abs(y - lastMotionY);\n  final int touchSlop=this.touchSlop;\n  boolean xMoved=xDiff > touchSlop;\n  boolean yMoved=yDiff > touchSlop;\n  if (xMoved) {\n    touchState=TOUCH_STATE_SCROLLING_X;\n    lastMotionX=x;\n    lastMotionY=y;\n  }\n  if (yMoved) {\n    touchState=TOUCH_STATE_SCROLLING_Y;\n    lastMotionX=x;\n    lastMotionY=y;\n  }\n}\n", "nl": "Check if the user is moving the cell"}
{"code": "public final boolean checkInstance(Instance instance){\n  if (instance.numAttributes() != numAttributes()) {\n    return false;\n  }\n  for (int i=0; i < numAttributes(); i++) {\n    if (instance.isMissing(i)) {\n      continue;\n    }\n else     if (attribute(i).isNominal() || attribute(i).isString()) {\n      if (!(Utils.eq(instance.value(i),(double)(int)instance.value(i)))) {\n        return false;\n      }\n else       if (Utils.sm(instance.value(i),0) || Utils.gr(instance.value(i),attribute(i).numValues())) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Checks if the given instance is compatible with this dataset. Only looks at the size of the instance and the ranges of the values for  nominal and string attributes."}
{"code": "private static byte[] concatBytes(byte[] array1,byte[] array2){\n  byte[] cBytes=new byte[array1.length + array2.length];\n  try {\n    System.arraycopy(array1,0,cBytes,0,array1.length);\n    System.arraycopy(array2,0,cBytes,array1.length,array2.length);\n  }\n catch (  Exception e) {\n    throw new FacesException(e);\n  }\n  return cBytes;\n}\n", "nl": "This method concatenates two byte arrays"}
{"code": "void layout(int delta,boolean animate){\n  if (mDataChanged) {\n    handleDataChanged();\n  }\n  if (getCount() == 0) {\n    resetList();\n    return;\n  }\n  if (mNextSelectedPosition >= 0) {\n    setSelectedPositionInt(mNextSelectedPosition);\n  }\n  recycleAllViews();\n  detachAllViewsFromParent();\n  int count=getAdapter().getCount();\n  float angleUnit=360.0f / count;\n  float angleOffset=mSelectedPosition * angleUnit;\n  for (int i=0; i < getAdapter().getCount(); i++) {\n    float angle=angleUnit * i - angleOffset;\n    if (angle < 0.0f)     angle=360.0f + angle;\n    makeAndAddView(i,angle);\n  }\n  mRecycler.clear();\n  invalidate();\n  setNextSelectedPositionInt(mSelectedPosition);\n  checkSelectionChanged();\n  mNeedSync=false;\n  updateSelectedItemMetadata();\n}\n", "nl": "Setting up images."}
{"code": "private void updateMenuItems(boolean isGpsStarted,boolean isRecording){\n  boolean hasTrack=listView != null && listView.getCount() != 0;\n  if (startGpsMenuItem != null) {\n    startGpsMenuItem.setVisible(!isRecording);\n    if (!isRecording) {\n      startGpsMenuItem.setTitle(isGpsStarted ? R.string.menu_stop_gps : R.string.menu_start_gps);\n      startGpsMenuItem.setIcon(isGpsStarted ? R.drawable.ic_menu_stop_gps : R.drawable.ic_menu_start_gps);\n      TrackIconUtils.setMenuIconColor(startGpsMenuItem);\n    }\n  }\n  if (playMultipleItem != null) {\n    playMultipleItem.setVisible(hasTrack);\n  }\n  if (syncNowMenuItem != null) {\n    syncNowMenuItem.setTitle(driveSync ? R.string.menu_sync_now : R.string.menu_sync_drive);\n  }\n  if (aggregatedStatisticsMenuItem != null) {\n    aggregatedStatisticsMenuItem.setVisible(hasTrack);\n  }\n  if (exportAllMenuItem != null) {\n    exportAllMenuItem.setVisible(hasTrack && !isRecording);\n  }\n  if (importAllMenuItem != null) {\n    importAllMenuItem.setVisible(!isRecording);\n  }\n  if (deleteAllMenuItem != null) {\n    deleteAllMenuItem.setVisible(hasTrack && !isRecording);\n  }\n}\n", "nl": "Updates the menu items."}
{"code": "public boolean isDuplicateSupported(){\n  return duplicateSupported;\n}\n", "nl": "Indicates whether this connection request supports duplicate entries in the request queue"}
{"code": "public void onStart(){\n}\n", "nl": "Called when the animation starts."}
{"code": "public static int[][] loadPNMFile(InputStream str) throws IOException {\n  BufferedInputStream stream=new BufferedInputStream(str);\n  String type=tokenizeString(stream);\n  if (type.equals(\"P1\"))   return loadPlainPBM(stream);\n else   if (type.equals(\"P2\"))   return loadPlainPGM(stream);\n else   if (type.equals(\"P4\"))   return loadRawPBM(stream);\n else   if (type.equals(\"P5\"))   return loadRawPGM(stream);\n else   throw new IOException(\"Not a viable PBM or PGM stream\");\n}\n", "nl": "Loads plain or raw PGM files or plain or raw PBM files and return the result as an int[][]. The Y dimension is not flipped."}
{"code": "public BiCorpus alignedFromFiles(String f) throws IOException {\n  return new BiCorpus(fpath + f + extf,epath + f + exte,apath + f + exta);\n}\n", "nl": "Generate aligned BiCorpus."}
{"code": "public LognormalDistr(double shape,double scale){\n  numGen=new LogNormalDistribution(scale,shape);\n}\n", "nl": "Instantiates a new Log-normal pseudo random number generator."}
{"code": "private static String contentLengthHeader(final long length){\n  return String.format(\"Content-Length: %d\",length);\n}\n", "nl": "Format Content-Length header."}
{"code": "@Bean @ConditionalOnMissingBean public AmqpSenderService amqpSenderServiceBean(){\n  return new DefaultAmqpSenderService(rabbitTemplate());\n}\n", "nl": "Create default amqp sender service bean."}
{"code": "@Override protected void initialize(){\n  super.initialize();\n  m_Processor=new MarkdownProcessor();\n  m_Markdown=\"\";\n}\n", "nl": "Initializes the members."}
{"code": "public void upperBound(byte[] key) throws IOException {\n  upperBound(key,0,key.length);\n}\n", "nl": "Move the cursor to the first entry whose key is strictly greater than the input key. Synonymous to upperBound(key, 0, key.length). The entry returned by the previous entry() call will be invalid."}
{"code": "public static String replaceLast(String s,char sub,char with){\n  int index=s.lastIndexOf(sub);\n  if (index == -1) {\n    return s;\n  }\n  char[] str=s.toCharArray();\n  str[index]=with;\n  return new String(str);\n}\n", "nl": "Replaces the very last occurrence of a character in a string."}
{"code": "public static void main(String[] args){\n  Thrust simulation=new Thrust();\n  simulation.run();\n}\n", "nl": "Entry point for the example application."}
{"code": "public static <T>T checkNotNull(T reference,@Nullable String errorMessageTemplate,@Nullable Object... errorMessageArgs){\n  if (reference == null) {\n    throw new NullPointerException(format(errorMessageTemplate,errorMessageArgs));\n  }\n  return reference;\n}\n", "nl": "Ensures that an object reference passed as a parameter to the calling method is not null."}
{"code": "public boolean insert(String name,RegExp definition){\n  if (Options.DEBUG)   Out.debug(\"inserting macro \" + name + \" with definition :\"+ Out.NL+ definition);\n  used.put(name,Boolean.FALSE);\n  return macros.put(name,definition) == null;\n}\n", "nl": "Stores a new macro and its definition."}
{"code": "public boolean add(Object o){\n  ensureCapacity(size + 1);\n  elementData[size++]=o;\n  return true;\n}\n", "nl": "Appends the specified element to the end of this list."}
{"code": "public InvocationTargetException(Throwable target,String s){\n  super(s,null);\n  this.target=target;\n}\n", "nl": "Constructs a InvocationTargetException with a target exception and a detail message."}
{"code": "public boolean isExternalSkin(){\n  return !isDefaultSkin && mResources != null;\n}\n", "nl": "whether the skin being used is from external .skin file"}
{"code": "private void updateActions(){\n  actions.removeAll();\n  final ActionGroup mainActionGroup=(ActionGroup)actionManager.getAction(getGroupMenu());\n  if (mainActionGroup == null) {\n    return;\n  }\n  final Action[] children=mainActionGroup.getChildren(null);\n  for (  final Action action : children) {\n    final Presentation presentation=presentationFactory.getPresentation(action);\n    final ActionEvent e=new ActionEvent(ActionPlaces.MAIN_CONTEXT_MENU,presentation,actionManager,0);\n    action.update(e);\n    if (presentation.isVisible()) {\n      actions.add(action);\n    }\n  }\n}\n", "nl": "Updates the list of visible actions."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "TechCategory fallthrough(){\nswitch (this) {\ncase OMNI_AERO:\n    return OMNI;\ncase CLAN_AERO:\ncase CLAN_VEE:\n  return CLAN;\ncase IS_ADVANCED_AERO:\ncase IS_ADVANCED_VEE:\nreturn IS_ADVANCED;\ndefault :\nreturn null;\n}\n}\n", "nl": "If no value is provided for ASFs or Vees, use the base value."}
{"code": "static void svd_dscal(int n,double da,double[] dx,int incx){\n  if (n <= 0 || incx == 0)   return;\n  int ix=(incx < 0) ? n - 1 : 0;\n  for (int i=0; i < n; i++) {\n    dx[ix]*=da;\n    ix+=incx;\n  }\n  return;\n}\n", "nl": "Function scales a vector by a constant. * Based on Fortran-77 routine from Linpack by J. Dongarra"}
{"code": "public CampoFechaVO insertValue(final CampoFechaVO value){\n  try {\n    DbConnection conn=getConnection();\n    DbInsertFns.insert(conn,TABLE_NAME,DbUtil.getColumnNames(COL_DEFS),new SigiaDbInputRecord(COL_DEFS,value));\n    return value;\n  }\n catch (  Exception e) {\n    logger.error(\"Error insertando campo de tipo fecha para el descriptor \" + value.getIdObjeto(),e);\n    throw new DBException(\"insertando campo de tipo fecha\",e);\n  }\n}\n", "nl": "Inserta un valor de tipo fecha."}
{"code": "private synchronized void closeActiveFile(){\n  StringWriterFile activeFile=this.activeFile;\n  try {\n    this.activeFile=null;\n    if (activeFile != null) {\n      activeFile.close();\n      getPolicy().closeActiveFile(activeFile.path());\n      activeFile=null;\n    }\n  }\n catch (  IOException e) {\n    trace.error(\"error closing active file '{}'\",activeFile.path(),e);\n  }\n}\n", "nl": "close, finalize, and apply retention policy"}
{"code": "public void testWARTypeEquality(){\n  WAR war1=new WAR(\"/some/path/to/file.war\");\n  WAR war2=new WAR(\"/otherfile.war\");\n  assertEquals(war1.getType(),war2.getType());\n}\n", "nl": "Test equality between WAR deployables."}
{"code": "public static Vector readSignatureAlgorithmsExtension(byte[] extensionData) throws IOException {\n  if (extensionData == null) {\n    throw new IllegalArgumentException(\"'extensionData' cannot be null\");\n  }\n  ByteArrayInputStream buf=new ByteArrayInputStream(extensionData);\n  Vector supported_signature_algorithms=parseSupportedSignatureAlgorithms(false,buf);\n  TlsProtocol.assertEmpty(buf);\n  return supported_signature_algorithms;\n}\n", "nl": "Read 'signature_algorithms' extension data."}
{"code": "public void updateNCharacterStream(int columnIndex,java.io.Reader x,long length) throws SQLException {\n  throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(\"jdbcrowsetimpl.featnotsupp\").toString());\n}\n", "nl": "Updates the designated column with a character stream value, which will have the specified number of bytes. The driver does the necessary conversion from Java character format to the national character set in the database. It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns. The updater methods are used to update column values in the current row or the insert row. The updater methods do not update the underlying database; instead the updateRow or insertRow methods are called to update the database."}
{"code": "public boolean isModified(){\n  return isCustom() && !isUserAdded();\n}\n", "nl": "Returns whether the receiver represents a modified template, i.e. a contributed template that has been changed."}
{"code": "public String toString(){\n  return this.getClass().getName() + \"(\" + my_k+ \")\";\n}\n", "nl": "Returns a String representation of the receiver."}
{"code": "private static PostingsEnum termDocs(IndexReader reader,Term term) throws IOException {\n  return MultiFields.getTermDocsEnum(reader,MultiFields.getLiveDocs(reader),term.field(),term.bytes());\n}\n", "nl": "NB: this is a convenient but very slow way of getting termDocs. It is sufficient for testing purposes."}
{"code": "public boolean isSubregion(){\n  return subregion;\n}\n", "nl": "Returns true if the Region is a subregion of a Component, otherwise false. For example, <code>Region.BUTTON</code> corresponds do a <code>Component</code> so that <code>Region.BUTTON.isSubregion()</code> returns false."}
{"code": "public static void encodeToFile(byte[] dataToEncode,String filename) throws java.io.IOException {\n  if (dataToEncode == null) {\n    throw new NullPointerException(\"Data to encode was null.\");\n  }\n  Base64.OutputStream bos=null;\n  try {\n    bos=new Base64.OutputStream(new java.io.FileOutputStream(filename),Base64.ENCODE);\n    bos.write(dataToEncode);\n  }\n catch (  java.io.IOException e) {\n    throw e;\n  }\n finally {\n    try {\n      bos.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Convenience method for encoding data to a file. <p>As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.</p>"}
{"code": "public synchronized void addDataStatusListener(DataStatusListener l){\n  m_mTab.addDataStatusListener(l);\n}\n", "nl": "Add Data Status Listener - pass on to MTab"}
{"code": "protected void addField(DurationFieldType field,int value){\n  addFieldInto(iValues,field,value);\n}\n", "nl": "Adds the value of a field in this period."}
{"code": "@Override public int perimeter(int size){\n  size=size / 2;\n  int retval=sw.perimeter(size);\n  retval+=se.perimeter(size);\n  retval+=ne.perimeter(size);\n  retval+=nw.perimeter(size);\n  return retval;\n}\n", "nl": "Compute the perimeter for a grey node using Samet's algorithm."}
{"code": "public BigdataStatementIterator addedIterator(){\n  final IChunkedOrderedIterator<ISPO> src=new ChunkedWrappedIterator<ISPO>(added.iterator());\n  return new BigdataStatementIteratorImpl(kb,src).start(kb.getExecutorService());\n}\n", "nl": "Return iterator visiting the inferences that were added to the KB."}
{"code": "public <V extends Object,C extends RTSpan<V>>void applyEffect(Effect<V,C> effect,V value){\n  if (mUseRTFormatting && !mIsSelectionChanging && !mIsSaving) {\n    Spannable oldSpannable=mIgnoreTextChanges ? null : cloneSpannable();\n    effect.applyToSelection(this,value);\nsynchronized (this) {\n      if (mListener != null && !mIgnoreTextChanges) {\n        Spannable newSpannable=cloneSpannable();\n        mListener.onTextChanged(this,oldSpannable,newSpannable,getSelectionStart(),getSelectionEnd(),getSelectionStart(),getSelectionEnd());\n      }\n      mLayoutChanged=true;\n    }\n  }\n}\n", "nl": "Call this to have an effect applied to the current selection. You get the Effect object via the static data members (e.g., RTEditText.BOLD). The value for most effects is a Boolean, indicating whether to add or remove the effect."}
{"code": "public DefaultLmlParser(final LmlData data,final LmlSyntax syntax,final LmlTemplateReader templateReader,final boolean strict){\n  super(data,syntax,templateReader,new DefaultLmlStyleSheet(),strict);\n}\n", "nl": "Creates a new parser with custom syntax, reader and strict setting."}
{"code": "private static void populateFancy(SQLiteDatabase writableDb){\n  long startOfToday=DateUtil.parse(DateUtil.format(System.currentTimeMillis()));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Clothes\",\"New jeans\",10000,startOfToday,Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Flat / House\",\"Monthly rent\",35000,startOfToday,Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Grocery\",\"Fruits & vegetables\",3567,DateUtil.parse(\"19/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Fuel\",\"Full gas tank\",7590,DateUtil.parse(\"14/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Clothes\",\"New shirt\",3599,DateUtil.parse(\"11/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Restaurant\",\"Family get together\",3691,DateUtil.parse(\"05/08/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_INCOME,\"Salary\",\"\",90000,DateUtil.parse(\"31/07/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Personal care\",\"New perfume\",3865,DateUtil.parse(\"29/07/2015\"),Item.NO_ID));\n  ItemDao.saveItem(writableDb,new Item(Item.TYPE_EXPENSE,\"Grocery\",\"Bottle of milk\",345,DateUtil.parse(\"26/07/2015\"),Item.NO_ID));\n}\n", "nl": "Generates reasonable amount of good-looking income / expense items."}
{"code": "public TestEntity(int index,String text,String value,double minConfidence){\n  super(index,text);\n  this.value=value;\n  this.minConfidence=minConfidence;\n}\n", "nl": "New instance, with a value."}
{"code": "public boolean contains(JComponent a,int b,int c){\n  boolean returnValue=((ComponentUI)(uis.elementAt(0))).contains(a,b,c);\n  for (int i=1; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).contains(a,b,c);\n  }\n  return returnValue;\n}\n", "nl": "Invokes the <code>contains</code> method on each UI handled by this object."}
{"code": "public boolean isClosed(){\n  return closed;\n}\n", "nl": "Returns true if this contour path is closed (loops back on itself) or false if it is not."}
{"code": "public void store(float val,Offset offset){\n  this.plus(offset).store(val);\n}\n", "nl": "Stores the float value in the memory location pointed to by the current instance."}
{"code": "public List<IvrZone> showIvrZones(boolean active) throws NetworkDeviceControllerException {\n  List<IvrZone> zones=new ArrayList<IvrZone>();\n  SSHPrompt[] prompts={SSHPrompt.POUND,SSHPrompt.GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  String cmdKey=active ? \"MDSDialog.ivr.show.zone.active.cmd\" : \"MDSDialog.ivr.show.zone.cmd\";\n  sendWaitFor(MDSDialogProperties.getString(cmdKey),defaultTimeout,prompts,buf);\n  String[] lines=getLines(buf);\n  IvrZone zone=null;\n  IvrZoneMember member=null;\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.ivr.showZoneset.zone.name.match\"),MDSDialogProperties.getString(\"MDSDialog.ivr.showZoneset.zone.member.match\")};\n  String[] groups=new String[10];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      zone=new IvrZone(groups[0]);\n    zones.add(zone);\n  break;\ncase 1:\nmember=new IvrZoneMember(groups[0],Integer.valueOf(groups[3]));\nzone.getMembers().add(member);\nbreak;\n}\n}\nreturn zones;\n}\n", "nl": "Get switch ivr zones"}
{"code": "public static void append(File file,Reader reader,String charset) throws IOException {\n  append(file,reader,charset,false);\n}\n", "nl": "Append the text supplied by the Reader at the end of the File without writing a BOM, using a specified encoding."}
{"code": "public static LifetimeAttribute createLifetimeAttribute(int lifetime){\n  LifetimeAttribute attribute=new LifetimeAttribute();\n  attribute.setLifetime(lifetime);\n  return attribute;\n}\n", "nl": "Create a LifetimeAttribute."}
{"code": "public void testFilePrimary() throws Exception {\n  start();\n  igfsPrimary.create(FILE,true).close();\n  checkEvictionPolicy(0,0);\n  int blockSize=igfsPrimary.info(FILE).blockSize();\n  append(FILE,blockSize);\n  checkEvictionPolicy(0,0);\n  read(FILE,0,blockSize);\n  checkEvictionPolicy(0,0);\n}\n", "nl": "Test how evictions are handled for a file working in PRIMARY mode."}
{"code": "public static String createTestPtStationCSVFile(File file){\n  try (BufferedWriter bw=new BufferedWriter(new FileWriter(file))){\n    bw.write(\"id,x,y\");\n    bw.newLine();\n    bw.write(\"1,10,10\");\n    bw.newLine();\n    bw.write(\"2,10, 190\");\n    bw.newLine();\n    bw.write(\"3,190,190\");\n    bw.newLine();\n    bw.write(\"4,190,10\");\n    bw.newLine();\n    return file.getCanonicalPath();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "This method creates 4 pt stops for the test network from createTestNetwork(). The information about the coordinates will be written to a csv file. The 4 pt stops are located as a square in the coordinate plane with a side length of 180 meter (see the sketch below)."}
{"code": "@Override public int hashCode(){\n  int result=super.hashCode();\n  return result;\n}\n", "nl": "Returns a hash code for the renderer."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase SGenPackage.FEATURE_TYPE__DEPRECATED:\n    setDeprecated(DEPRECATED_EDEFAULT);\n  return;\ncase SGenPackage.FEATURE_TYPE__COMMENT:\nsetComment(COMMENT_EDEFAULT);\nreturn;\ncase SGenPackage.FEATURE_TYPE__PARAMETERS:\ngetParameters().clear();\nreturn;\ncase SGenPackage.FEATURE_TYPE__OPTIONAL:\nsetOptional(OPTIONAL_EDEFAULT);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isVMAX3VolumeCompressionEnabled(URI blockObjectURI){\n  VirtualPool virtualPool=null;\n  Volume volume=null;\n  if (URIUtil.isType(blockObjectURI,Volume.class)) {\n    volume=_dbClient.queryObject(Volume.class,blockObjectURI);\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockSnapshot.class)) {\n    BlockSnapshot snapshot=_dbClient.queryObject(BlockSnapshot.class,blockObjectURI);\n    volume=_dbClient.queryObject(Volume.class,snapshot.getParent());\n  }\n else   if (URIUtil.isType(blockObjectURI,BlockMirror.class)) {\n    BlockMirror mirror=_dbClient.queryObject(BlockMirror.class,blockObjectURI);\n    virtualPool=_dbClient.queryObject(VirtualPool.class,mirror.getVirtualPool());\n  }\n  if (volume != null) {\n    virtualPool=_dbClient.queryObject(VirtualPool.class,volume.getVirtualPool());\n  }\n  return ((virtualPool != null) && virtualPool.getCompressionEnabled());\n}\n", "nl": "This method is will check if the volume associated with virtual Pool has compression enabled."}
{"code": "public void releaseConnection(Database conn){\n  if (conn != null)   conn.close();\n}\n", "nl": "Releases a connection."}
{"code": "public final void testRemoveHelperTextId(){\n  PasswordEditText passwordEditText=new PasswordEditText(getContext());\n  passwordEditText.addHelperTextId(android.R.string.cancel);\n  passwordEditText.addHelperTextId(android.R.string.copy);\n  passwordEditText.removeHelperTextId(android.R.string.cancel);\n  passwordEditText.removeHelperTextId(android.R.string.cancel);\n  assertEquals(1,passwordEditText.getHelperTexts().size());\n  assertEquals(getContext().getText(android.R.string.copy),passwordEditText.getHelperTexts().iterator().next());\n}\n", "nl": "Tests the functionality of the method, which allows to remove a helper text by its id."}
{"code": "private void logMessage(String msg,Object[] obj){\n  if (getMonitoringPropertiesLoader().isToLogIndications()) {\n    _logger.debug(msg,obj);\n  }\n}\n", "nl": "Log the messages. This method eliminates the logging condition check every time when we need to log a message."}
{"code": "public static Float toRef(float f){\n  return new Float(f);\n}\n", "nl": "cast a float value to his (CFML) reference type Float"}
{"code": "@Override protected boolean shouldComposeCreationImage(){\n  return true;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public synchronized void promote(Tile tile){\n  if (tileQueue.contains(tile)) {\n    try {\n      tileQueue.remove(tile);\n      tile.setPriority(Tile.Priority.High);\n      tileQueue.put(tile);\n    }\n catch (    Exception ex) {\n      ex.printStackTrace();\n    }\n  }\n}\n", "nl": "Increase the priority of this tile so it will be loaded sooner."}
{"code": "public void exitApp(){\n  this.webView.getPluginManager().postMessage(\"exit\",null);\n}\n", "nl": "Exit the Android application."}
{"code": "public void test_getInnerCause01_reject_otherType(){\n  Throwable t=new Throwable();\n  assertNull(getInnerCause(t,Exception.class));\n}\n", "nl": "Does not find cause when it is on top of the stack trace and not either the desired type or a subclass of the desired type."}
{"code": "public Handshake handshake(){\n  return handshake;\n}\n", "nl": "Returns the TLS handshake of the connection that carried this response, or null if the response was received without TLS."}
{"code": "private Coordinate averagePoint(CoordinateSequence seq){\n  Coordinate a=new Coordinate(0,0,0);\n  int n=seq.size();\n  for (int i=0; i < n; i++) {\n    a.x+=seq.getOrdinate(i,CoordinateSequence.X);\n    a.y+=seq.getOrdinate(i,CoordinateSequence.Y);\n    a.z+=seq.getOrdinate(i,CoordinateSequence.Z);\n  }\n  a.x/=n;\n  a.y/=n;\n  a.z/=n;\n  return a;\n}\n", "nl": "Computes a point which is the average of all coordinates in a sequence. If the sequence lies in a single plane, the computed point also lies in the plane."}
{"code": "public static void invokeWebserviceASync(WSDefinition def,SuccessCallback scall,FailureCallback fcall,Object... arguments){\n  WSConnection cr=new WSConnection(def,scall,fcall,arguments);\n  NetworkManager.getInstance().addToQueue(cr);\n}\n", "nl": "Invokes a web asynchronously and calls the callback on completion"}
{"code": "public PutResponseMessage(PutResponseMessage other){\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "private boolean isSynthetic(Method m){\n  if ((m.getAccessFlags() & Constants.ACC_SYNTHETIC) != 0) {\n    return true;\n  }\n  Attribute[] attrs=m.getAttributes();\n  for (  Attribute attr : attrs) {\n    if (attr instanceof Synthetic) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Methods marked with the \"Synthetic\" attribute do not appear in the source code"}
{"code": "public boolean isTagline(){\n  return tagline;\n}\n", "nl": "Checks if is tagline."}
{"code": "protected LocaTable(TrueTypeFont ttf){\n  super(TrueTypeTable.LOCA_TABLE);\n  MaxpTable maxp=(MaxpTable)ttf.getTable(\"maxp\");\n  int numGlyphs=maxp.getNumGlyphs();\n  HeadTable head=(HeadTable)ttf.getTable(\"head\");\n  short format=head.getIndexToLocFormat();\n  isLong=(format == 1);\n  offsets=new int[numGlyphs + 1];\n}\n", "nl": "Creates a new instance of HmtxTable"}
{"code": "public static <T>T create(Class<T> theQueryClass){\n  return AgentClass.createAgent(theQueryClass);\n}\n", "nl": "Create a database query dynamically"}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:44.163 -0500\",hash_original_method=\"CE28B7D5A93F674A0286463AAF68C789\",hash_generated_method=\"4C5D61097E13A407D793E43190510D41\") public synchronized void addFailure(Test test,AssertionFailedError t){\n  fFailures.addElement(new TestFailure(test,t));\n  for (Enumeration e=cloneListeners().elements(); e.hasMoreElements(); ) {\n    ((TestListener)e.nextElement()).addFailure(test,t);\n  }\n}\n", "nl": "Adds a failure to the list of failures. The passed in exception caused the failure."}
{"code": "public ExtendedKeyUsage(byte[] encoding){\n  super(encoding);\n}\n", "nl": "Creates the extension object on the base of its encoded form."}
{"code": "public Iterator<E> subsetIterator(E from,E to){\n  return new BinarySearchTreeIterator<E>(this.root,from,to);\n}\n", "nl": "Returns the in-order (ascending) iterator."}
{"code": "public int valueForXPosition(int xPos){\n  int value;\n  int minValue=slider.getMinimum();\n  int maxValue=slider.getMaximum();\n  int trackLeft=trackRect.x + thumbRect.width / 2 + trackBorder;\n  int trackRight=trackRect.x + trackRect.width - thumbRect.width / 2 - trackBorder;\n  int trackLength=trackRight - trackLeft;\n  if (xPos <= trackLeft) {\n    value=drawInverted() ? maxValue : minValue;\n  }\n else   if (xPos >= trackRight) {\n    value=drawInverted() ? minValue : maxValue;\n  }\n else {\n    int distanceFromTrackLeft=xPos - trackLeft;\n    double valueRange=(double)maxValue - (double)minValue;\n    double valuePerPixel=valueRange / (double)trackLength;\n    int valueFromTrackLeft=(int)Math.round(distanceFromTrackLeft * valuePerPixel);\n    value=drawInverted() ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft;\n  }\n  return value;\n}\n", "nl": "Returns a value give an x position. If xPos is past the track at the left or the right it will set the value to the min or max of the slider, depending if the slider is inverted or not."}
{"code": "@Override protected EClass eStaticClass(){\n  return SRuntimePackage.Literals.COMPOSITE_SLOT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(documentcreateattributeNS03.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public ListIterator<AbstractInsnNode> iterator(){\n  return iterator(0);\n}\n", "nl": "Returns an iterator over the instructions in this list."}
{"code": "public static String escapeXml(String str){\n  if (str == null) {\n    return null;\n  }\n  return EntitiesUtils.XML.escape(str);\n}\n", "nl": "<p>Escapes the characters in a <code>String</code> using XML entities.</p> <p>For example: <tt>\"bread\" & \"butter\"</tt> => <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>. </p> <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos). Does not support DTDs or external entities.</p> <p>Note that unicode characters greater than 0x7f are currently escaped to  their numerical \\\\u equivalent. This may change in future releases. </p>"}
{"code": "public boolean isProcessed(){\n  Object oo=get_Value(COLUMNNAME_Processed);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Processed."}
{"code": "public void processResponse(SIPResponse response,MessageChannel incomingMessageChannel,SIPDialog dialog){\n  if (sipStack.isLoggingEnabled()) {\n    sipStack.getStackLogger().logDebug(\"PROCESSING INCOMING RESPONSE\" + response.encodeMessage());\n  }\n  if (listeningPoint == null) {\n    if (sipStack.isLoggingEnabled())     sipStack.getStackLogger().logError(\"Dropping message: No listening point\" + \" registered!\");\n    return;\n  }\n  if (sipStack.checkBranchId() && !Utils.getInstance().responseBelongsToUs(response)) {\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logError(\"Dropping response - topmost VIA header does not originate from this stack\");\n    }\n    return;\n  }\n  SipProviderImpl sipProvider=listeningPoint.getProvider();\n  if (sipProvider == null) {\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logError(\"Dropping message:  no provider\");\n    }\n    return;\n  }\n  if (sipProvider.getSipListener() == null) {\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logError(\"No listener -- dropping response!\");\n    }\n    return;\n  }\n  SIPClientTransaction transaction=(SIPClientTransaction)this.transactionChannel;\n  SipStackImpl sipStackImpl=sipProvider.sipStack;\n  if (sipStack.isLoggingEnabled()) {\n    sipStackImpl.getStackLogger().logDebug(\"Transaction = \" + transaction);\n  }\n  if (transaction == null) {\n    if (dialog != null) {\n      if (response.getStatusCode() / 100 != 2) {\n        if (sipStack.isLoggingEnabled()) {\n          sipStack.getStackLogger().logDebug(\"Response is not a final response and dialog is found for response -- dropping response!\");\n        }\n        return;\n      }\n else       if (dialog.getState() == DialogState.TERMINATED) {\n        if (sipStack.isLoggingEnabled()) {\n          sipStack.getStackLogger().logDebug(\"Dialog is terminated -- dropping response!\");\n        }\n        return;\n      }\n else {\n        boolean ackAlreadySent=false;\n        if (dialog.isAckSeen() && dialog.getLastAckSent() != null) {\n          if (dialog.getLastAckSent().getCSeq().getSeqNumber() == response.getCSeq().getSeqNumber()) {\n            ackAlreadySent=true;\n          }\n        }\n        if (ackAlreadySent && response.getCSeq().getMethod().equals(dialog.getMethod())) {\n          try {\n            if (sipStack.isLoggingEnabled()) {\n              sipStack.getStackLogger().logDebug(\"Retransmission of OK detected: Resending last ACK\");\n            }\n            dialog.resendAck();\n            return;\n          }\n catch (          SipException ex) {\n            if (sipStack.isLoggingEnabled())             sipStack.getStackLogger().logError(\"could not resend ack\",ex);\n          }\n        }\n      }\n    }\n    if (sipStack.isLoggingEnabled()) {\n      sipStack.getStackLogger().logDebug(\"could not find tx, handling statelessly Dialog =  \" + dialog);\n    }\n    ResponseEventExt sipEvent=new ResponseEventExt(sipProvider,transaction,dialog,(Response)response);\n    if (response.getCSeqHeader().getMethod().equals(Request.INVITE)) {\n      SIPClientTransaction forked=this.sipStack.getForkedTransaction(response.getTransactionId());\n      sipEvent.setOriginalTransaction(forked);\n    }\n    sipProvider.handleEvent(sipEvent,transaction);\n    return;\n  }\n  ResponseEventExt responseEvent=null;\n  responseEvent=new ResponseEventExt(sipProvider,(ClientTransactionExt)transaction,dialog,(Response)response);\n  if (response.getCSeqHeader().getMethod().equals(Request.INVITE)) {\n    SIPClientTransaction forked=this.sipStack.getForkedTransaction(response.getTransactionId());\n    responseEvent.setOriginalTransaction(forked);\n  }\n  if (dialog != null && response.getStatusCode() != 100) {\n    dialog.setLastResponse(transaction,response);\n    transaction.setDialog(dialog,dialog.getDialogId());\n  }\n  sipProvider.handleEvent(responseEvent,transaction);\n}\n", "nl": "Process the response."}
{"code": "public AnnotationAtttributeProposalInfo(IJavaProject project,CompletionProposal proposal){\n  super(project,proposal);\n}\n", "nl": "Creates a new proposal info."}
{"code": "public static void restoreReminderPreference(Context context){\n  int hour=MehPreferencesManager.getNotificationPreferenceHour(context);\n  int minute=MehPreferencesManager.getNotificationPreferenceMinute(context);\n  scheduleDailyReminder(context,hour,minute);\n}\n", "nl": "Restore the daily reminder, with the times already in preferences. Useful for device reboot or switched on from the settings screen"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "BarChart(){\n}\n", "nl": "Instantiates a new bar chart."}
{"code": "public boolean isTransactionRelevant(Transaction tx) throws ScriptException {\n  lock.lock();\n  try {\n    return tx.getValueSentFromMe(this).signum() > 0 || tx.getValueSentToMe(this).signum() > 0 || !findDoubleSpendsAgainst(tx,transactions).isEmpty();\n  }\n  finally {\n    lock.unlock();\n  }\n}\n", "nl": "<p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs, and also returns true if tx has inputs that are spending outputs which are not ours but which are spent by pending transactions.</p> <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet, it will not be considered relevant.</p>"}
{"code": "public void free(GL2 gl){\n  if (vbos[0] >= 0) {\n    gl.glDeleteBuffers(1,vbos,0);\n  }\n  vbos[0]=-1;\n}\n", "nl": "Free all memory allocations."}
{"code": "public Vector3(float x,float y,float z){\n  this.set(x,y,z);\n}\n", "nl": "Creates a vector with the given components"}
{"code": "protected S_ActionImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void clear(int maximumCapacity){\n  if (capacity <= maximumCapacity) {\n    clear();\n    return;\n  }\n  zeroValue=null;\n  hasZeroValue=false;\n  size=0;\n  resize(maximumCapacity);\n}\n", "nl": "Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger."}
{"code": "public void bulkLoad(DBIDs ids){\n  if (ids.size() == 0) {\n    return;\n  }\n  assert (root == null) : \"Tree already initialized.\";\n  DBIDIter it=ids.iter();\n  DBID first=DBIDUtil.deref(it);\n  ModifiableDoubleDBIDList candidates=DBIDUtil.newDistanceDBIDList(ids.size() - 1);\n  for (it.advance(); it.valid(); it.advance()) {\n    candidates.add(distance(first,it),it);\n  }\n  root=bulkConstruct(first,Integer.MAX_VALUE,candidates);\n}\n", "nl": "Bulk-load the index."}
{"code": "protected ExtendedSolrQueryParser createEdismaxQueryParser(QParser qParser,String field){\n  return new ExtendedSolrQueryParser(qParser,field);\n}\n", "nl": "Creates an instance of ExtendedSolrQueryParser, the query parser that's going to be used to parse the query."}
{"code": "protected void appendSummary(StringBuffer buffer,String fieldName,long[] array){\n  appendSummarySize(buffer,fieldName,array.length);\n}\n", "nl": "<p>Append to the <code>toString</code> a summary of a <code>long</code> array.</p>"}
{"code": "protected UndoableEdit editToBeRedone(){\n  int count=edits.size();\n  int i=indexOfNextAdd;\n  while (i < count) {\n    UndoableEdit edit=edits.elementAt(i++);\n    if (edit.isSignificant()) {\n      return edit;\n    }\n  }\n  return null;\n}\n", "nl": "Returns the the next significant edit to be redone if <code>redo</code> is invoked. This returns <code>null</code> if there are no edits to be redone."}
{"code": "public void actionPerformed(ActionEvent e){\n  Box b1=Box.createVerticalBox();\n  Version currentVersion=Version.currentViewableVersion();\n  String copyright=LicenseUtils.copyright();\n  copyright=copyright.replaceAll(\"\\n\",\"<br>\");\n  String latestVersion=LatestClient.getInstance().getLatestResult(60);\n  latestVersion=latestVersion.replaceAll(\"\\n\",\"<br>\");\n  JLabel label=new JLabel();\n  label.setText(\"<html>\" + \"<b>Tetrad \" + currentVersion + \"</b>\"+ \"<br>\"+ \"<br>Laboratory for Symbolic and Educational Computing\"+ \"<br>Department of Philosophy\"+ \"<br>Carnegie Mellon University\"+ \"<br>\"+ \"<br>Project Direction: Clark Glymour, Richard Scheines, Peter Spirtes\"+ \"<br>Lead Developer: Joseph Ramsey\"+ \"<br>\"+ copyright+ \"<br>\"+ latestVersion+ \"</html>\");\n  label.setBackground(Color.LIGHT_GRAY);\n  label.setFont(new Font(\"Dialog\",Font.PLAIN,12));\n  label.setBorder(new CompoundBorder(new LineBorder(Color.DARK_GRAY),new EmptyBorder(10,10,10,10)));\n  b1.add(label);\n  JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),b1,\"About Tetrad...\",JOptionPane.PLAIN_MESSAGE);\n}\n", "nl": "Closes the frontmost session of this action's desktop."}
{"code": "private void redrawMarkers(){\n  UI.execute(null);\n}\n", "nl": "Redraw all markers and set them straight to their current locations without animations."}
{"code": "public void addToolTipSeries(List toolTips){\n  this.toolTipSeries.add(toolTips);\n}\n", "nl": "Adds a list of tooltips for a series."}
{"code": "static private String[] alphaMixedNumeric(){\n  return StringFunctions.combineStringArrays(StringFunctions.alphaMixed(),StringFunctions.numeric);\n}\n", "nl": "Combine the alpha mixed and numeric collections into one"}
{"code": "long incrementInMsgs(){\n  return inMsgs.incrementAndGet();\n}\n", "nl": "Increments the number of messages received on this connection."}
{"code": "public final void yyreset(java.io.Reader reader){\n  zzBuffer=s.array;\n  zzStartRead=s.offset;\n  zzEndRead=zzStartRead + s.count - 1;\n  zzCurrentPos=zzMarkedPos=s.offset;\n  zzLexicalState=YYINITIAL;\n  zzReader=reader;\n  zzAtEOF=false;\n}\n", "nl": "Resets the scanner to read from a new input stream. Does not close the old reader. All internal variables are reset, the old input stream <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical state is set to <tt>YY_INITIAL</tt>."}
{"code": "public IntArraySpliterator(int[] array,int origin,int fence,int additionalCharacteristics){\n  this.array=array;\n  this.index=origin;\n  this.fence=fence;\n  this.characteristics=additionalCharacteristics | Spliterator.SIZED | Spliterator.SUBSIZED;\n}\n", "nl": "Creates a spliterator covering the given array and range"}
{"code": "@Override public void populateDAG(DAG dag,Configuration conf){\n  TweetsInput input=new TweetsInput();\n  Collector collector=new Collector();\n  WindowOption windowOption=new WindowOption.GlobalWindow();\n  ApexStream<String> tags=StreamFactory.fromInput(input,input.output,name(\"tweetSampler\")).flatMap(new ExtractHashtags());\n  tags.window(windowOption,new TriggerOption().accumulatingFiredPanes().withEarlyFiringsAtEvery(1)).addCompositeStreams(ComputeTopCompletions.top(10,true)).print(name(\"console\")).endWith(collector,collector.input,name(\"collector\")).populateDag(dag);\n}\n", "nl": "Populate the dag with High-Level API."}
{"code": "public void testBug21947042() throws Exception {\n  Connection sslConn=null;\n  Properties props=new Properties();\n  props.setProperty(\"logger\",\"StandardLogger\");\n  StandardLogger.startLoggingToBuffer();\n  try {\n    int searchFrom=0;\n    int found=0;\n    sslConn=getConnectionWithProps(props);\n    if (versionMeetsMinimum(5,7)) {\n      assertTrue(((MySQLConnection)sslConn).getUseSSL());\n      assertFalse(((MySQLConnection)sslConn).getVerifyServerCertificate());\n      assertTrue(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    }\n else {\n      assertFalse(((MySQLConnection)sslConn).getUseSSL());\n      assertTrue(((MySQLConnection)sslConn).getVerifyServerCertificate());\n      assertFalse(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    }\n    ResultSet rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_cipher'\");\n    assertTrue(rset.next());\n    String cipher=rset.getString(2);\n    System.out.println(\"ssl_cipher=\" + cipher);\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_version'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_version=\" + cipher);\n    sslConn.close();\n    String log=StandardLogger.getBuffer().toString();\n    found=log.indexOf(Messages.getString(\"MysqlIO.SSLWarning\"),searchFrom);\n    searchFrom=found + 1;\n    if (versionMeetsMinimum(5,7)) {\n      assertTrue(found != -1);\n    }\n    props.setProperty(\"useSSL\",\"false\");\n    sslConn=getConnectionWithProps(props);\n    assertFalse(((MySQLConnection)sslConn).getUseSSL());\n    assertTrue(((MySQLConnection)sslConn).getVerifyServerCertificate());\n    assertFalse(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_cipher'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_cipher=\" + cipher);\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_version'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_version=\" + cipher);\n    sslConn.close();\n    log=StandardLogger.getBuffer().toString();\n    found=log.indexOf(Messages.getString(\"MysqlIO.SSLWarning\"),searchFrom);\n    if (found != -1) {\n      searchFrom=found + 1;\n      fail(\"Warning is not expected when useSSL is explicitly set to 'false'.\");\n    }\n    props.setProperty(\"useSSL\",\"true\");\n    props.setProperty(\"trustCertificateKeyStoreUrl\",\"file:src/testsuite/ssl-test-certs/test-cert-store\");\n    props.setProperty(\"trustCertificateKeyStoreType\",\"JKS\");\n    props.setProperty(\"trustCertificateKeyStorePassword\",\"password\");\n    sslConn=getConnectionWithProps(props);\n    assertTrue(((MySQLConnection)sslConn).getUseSSL());\n    assertTrue(((MySQLConnection)sslConn).getVerifyServerCertificate());\n    assertTrue(((MySQLConnection)sslConn).getIO().isSSLEstablished());\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_cipher'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_cipher=\" + cipher);\n    rset=sslConn.createStatement().executeQuery(\"SHOW STATUS LIKE 'ssl_version'\");\n    assertTrue(rset.next());\n    cipher=rset.getString(2);\n    System.out.println(\"ssl_version=\" + cipher);\n    sslConn.close();\n    log=StandardLogger.getBuffer().toString();\n    found=log.indexOf(Messages.getString(\"MysqlIO.SSLWarning\"),searchFrom);\n    if (found != -1) {\n      searchFrom=found + 1;\n      fail(\"Warning is not expected when useSSL is explicitly set to 'false'.\");\n    }\n  }\n  finally {\n    StandardLogger.dropBuffer();\n  }\n}\n", "nl": "Tests fix for BUG#21947042, PREFER TLS WHERE SUPPORTED BY MYSQL SERVER. Requires test certificates from testsuite/ssl-test-certs to be installed on the server being tested."}
{"code": "public JComponent createEmbeddedPropertyGUI(String prefix,Properties props,Properties info){\n  if (Debug.debugging(\"inspectordetail\")) {\n    Debug.output(\"Inspector creating GUI for \" + prefix + \"\\nPROPERTIES \"+ props+ \"\\nPROP INFO \"+ info);\n  }\n  String propertyList=info.getProperty(PropertyConsumer.initPropertiesProperty);\n  Vector<String> sortedKeys;\n  if (propertyList != null) {\n    Vector<String> propertiesToShow=PropUtils.parseSpacedMarkers(propertyList);\n    for (int i=0; i < propertiesToShow.size(); i++) {\n      propertiesToShow.set(i,prefix + \".\" + propertiesToShow.get(i));\n    }\n    sortedKeys=propertiesToShow;\n  }\n else {\n    sortedKeys=sortKeys(props.keySet());\n  }\n  editors=new Hashtable<String,PropertyEditor>(sortedKeys.size());\n  JPanel component=new JPanel();\n  component.setLayout(new BorderLayout());\n  JPanel propertyPanel=new JPanel();\n  GridBagLayout gridbag=new GridBagLayout();\n  GridBagConstraints c=new GridBagConstraints();\n  c.insets=new Insets(2,10,2,10);\n  propertyPanel.setLayout(gridbag);\n  int i=0;\n  for (  String prop : sortedKeys) {\n    String marker=prop;\n    if (prefix != null && prop.startsWith(prefix)) {\n      marker=prop.substring(prefix.length() + 1);\n    }\n    if (marker.startsWith(\".\")) {\n      marker=marker.substring(1);\n    }\n    String editorMarker=marker + PropertyConsumer.ScopedEditorProperty;\n    String editorClass=info.getProperty(editorMarker);\n    if (editorClass == null) {\n      editorClass=defaultEditorClass;\n    }\n    Class<?> propertyEditorClass=null;\n    PropertyEditor editor=null;\n    try {\n      propertyEditorClass=Class.forName(editorClass);\n      editor=(PropertyEditor)propertyEditorClass.newInstance();\n      if (editor instanceof PropertyConsumer) {\n        ((PropertyConsumer)editor).setProperties(marker,info);\n      }\n      editors.put(prop,editor);\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n      editorClass=null;\n    }\n    Component editorFace=null;\n    if (editor != null && editor.supportsCustomEditor()) {\n      editorFace=editor.getCustomEditor();\n    }\n else {\n      editorFace=new JLabel(i18n.get(Inspector.class,\"Does_not_support_custom_editor\",\"Does not support custom editor\"));\n    }\n    if (editor != null) {\n      Object propVal=props.get(prop);\n      if (Debug.debugging(\"inspector\")) {\n        Debug.output(\"Inspector loading \" + prop + \"(\"+ propVal+ \")\");\n      }\n      editor.setValue(propVal);\n    }\n    String labelMarker=marker + PropertyConsumer.LabelEditorProperty;\n    String labelText=info.getProperty(labelMarker);\n    if (labelText == null) {\n      labelText=marker;\n    }\n    JLabel label=new JLabel(labelText + \":\");\n    label.setHorizontalAlignment(SwingConstants.RIGHT);\n    c.gridx=0;\n    c.gridy=i++;\n    c.weightx=0;\n    c.fill=GridBagConstraints.NONE;\n    c.anchor=GridBagConstraints.EAST;\n    gridbag.setConstraints(label,c);\n    propertyPanel.add(label);\n    c.gridx=1;\n    c.anchor=GridBagConstraints.WEST;\n    c.fill=GridBagConstraints.HORIZONTAL;\n    c.weightx=1f;\n    gridbag.setConstraints(editorFace,c);\n    propertyPanel.add(editorFace);\n    String toolTip=(String)info.get(marker);\n    label.setToolTipText(toolTip == null ? i18n.get(Inspector.class,\"No_further_information_available\",\"No further information available.\") : toolTip);\n  }\n  JScrollPane scrollPane=new JScrollPane(propertyPanel,ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n  scrollPane.setBorder(null);\n  scrollPane.setAlignmentY(Component.TOP_ALIGNMENT);\n  component.add(scrollPane,BorderLayout.CENTER);\n  return component;\n}\n", "nl": "Creates a JComponent with the properties to be changed. This component is suitable for inclusion into a GUI. Don't use this method directly! Use the createPropertyGUI(PropertyConsumer) instead. You will get a NullPointerException if you use this method without setting the PropertyConsumer in the Inspector."}
{"code": "public void onScanImageClick(View v){\n  Intent intent=new Intent(this,ScanImageActivity.class);\n  intent.putExtra(ExtrasKeys.EXTRAS_LICENSE_KEY,LICENSE_KEY);\n  intent.putExtra(ExtrasKeys.EXTRAS_RECOGNITION_SETTINGS,mRecognitionSettings);\n  startActivityForResult(intent,MY_REQUEST_CODE);\n}\n", "nl": "Handler for \"Scan Image\" button"}
{"code": "public boolean isReadOnly(){\n  Object oo=get_Value(COLUMNNAME_IsReadOnly);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Read Only."}
{"code": "public static <K,V>Map<K,V> asSynchronized(Map<K,V> self){\n  return Collections.synchronizedMap(self);\n}\n", "nl": "A convenience method for creating a synchronized Map."}
{"code": "private boolean isRecursive(Nonterminal nonterm){\n  return comp.getNodes().contains(nonterm);\n}\n", "nl": "Return true if the nonterminal is recursive."}
{"code": "private void initInfo(int record_id,String value){\n  if (!(record_id == 0) && value != null && value.length() > 0) {\n    log.severe(\"Received both a record_id and a value: \" + record_id + \" - \"+ value);\n  }\n  if (!(record_id == 0)) {\n    fieldID=record_id;\n  }\n else {\n    if (value != null && value.length() > 0) {\n      fDocumentNo.setValue(value);\n    }\n else {\n      String id;\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"M_InOut_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0)) {\n        fieldID=new Integer(id).intValue();\n      }\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"C_BPartner_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0))       fBPartner_ID.setValue(new Integer(id));\n      id=Env.getContext(Env.getCtx(),p_WindowNo,p_TabNo,\"M_Shipper_ID\",true);\n      if (id != null && id.length() != 0 && (new Integer(id).intValue() > 0)) {\n        fShipper_ID.setValue(new Integer(id).intValue());\n      }\n    }\n  }\n}\n", "nl": "General Init"}
{"code": "public IssueMatcher add(){\n  IssueMatcher issueMatcher=new IssueMatcher();\n  issueMatchers.add(issueMatcher);\n  return issueMatcher;\n}\n", "nl": "Creates a new issue matcher and adds it to this matcher."}
{"code": "protected ParameterizedPropertyAccessExpression_IMImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void loadFinishScreen(){\n  CoordinatorLayout.LayoutParams lp=new CoordinatorLayout.LayoutParams(CoordinatorLayout.LayoutParams.WRAP_CONTENT,CoordinatorLayout.LayoutParams.WRAP_CONTENT);\n  mFloatingActionButton.setLayoutParams(lp);\n  mFloatingActionButton.setVisibility(View.INVISIBLE);\n  NestedScrollView contentLayout=(NestedScrollView)findViewById(R.id.challenge_rootcontainer);\n  if (contentLayout != null) {\n    contentLayout.removeAllViews();\n    View view=getLayoutInflater().inflate(R.layout.fragment_finish_challenge,contentLayout,false);\n    contentLayout.addView(view);\n  }\n}\n", "nl": "Loads the finish screen and unloads all other screens"}
{"code": "private void compactSegment(Segment segment,OffsetPredicate predicate,Segment compactSegment){\n  for (long i=segment.firstIndex(); i <= segment.lastIndex(); i++) {\n    checkEntry(i,segment,predicate,compactSegment);\n  }\n}\n", "nl": "Compacts the given segment."}
{"code": "public static Class<?> forName(String name,ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n  Assert.notNull(name,\"Name must not be null\");\n  Class<?> clazz=resolvePrimitiveClassName(name);\n  if (clazz == null) {\n    clazz=commonClassCache.get(name);\n  }\n  if (clazz != null) {\n    return clazz;\n  }\n  if (name.endsWith(ARRAY_SUFFIX)) {\n    String elementClassName=name.substring(0,name.length() - ARRAY_SUFFIX.length());\n    Class<?> elementClass=forName(elementClassName,classLoader);\n    return Array.newInstance(elementClass,0).getClass();\n  }\n  if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n    String elementName=name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(),name.length() - 1);\n    Class<?> elementClass=forName(elementName,classLoader);\n    return Array.newInstance(elementClass,0).getClass();\n  }\n  if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n    String elementName=name.substring(INTERNAL_ARRAY_PREFIX.length());\n    Class<?> elementClass=forName(elementName,classLoader);\n    return Array.newInstance(elementClass,0).getClass();\n  }\n  ClassLoader classLoaderToUse=classLoader;\n  if (classLoaderToUse == null) {\n    classLoaderToUse=getDefaultClassLoader();\n  }\n  try {\n    return classLoaderToUse.loadClass(name);\n  }\n catch (  ClassNotFoundException ex) {\n    int lastDotIndex=name.lastIndexOf('.');\n    if (lastDotIndex != -1) {\n      String innerClassName=name.substring(0,lastDotIndex) + '$' + name.substring(lastDotIndex + 1);\n      try {\n        return classLoaderToUse.loadClass(innerClassName);\n      }\n catch (      ClassNotFoundException ex2) {\n      }\n    }\n    throw ex;\n  }\n}\n", "nl": "Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (e.g.\"int\") and array class names (e.g. \"String[]\"). Furthermore, it is also capable of resolving inner class names in Java source style (e.g. \"java.lang.Thread.State\" instead of \"java.lang.Thread$State\")."}
{"code": "public String toString(int indentFactor) throws JSONException {\n  return toString(indentFactor,0);\n}\n", "nl": "Make a prettyprinted JSON text of this JSONObject. <p> Warning: This method assumes that the data structure is acyclical."}
{"code": "@SuppressWarnings(\"MethodWithMultipleReturnPoints\") public static boolean checkSu(){\n  if (!new File(\"/system/bin/su\").exists() && !new File(\"/system/xbin/su\").exists()) {\n    Log.e(TAG,\"su binary does not exist!!!\");\n    return false;\n  }\n  try {\n    if (runSuCommand(\"ls /data/app-private\").success()) {\n      Log.i(TAG,\" SU exists and we have permission\");\n      return true;\n    }\n else {\n      Log.i(TAG,\" SU exists but we don't have permission\");\n      return false;\n    }\n  }\n catch (  NullPointerException e) {\n    Log.e(TAG,\"NullPointer throw while looking for su binary\",e);\n    return false;\n  }\n}\n", "nl": "Checks device for SuperUser permission"}
{"code": "public String toString(int indentFactor) throws JSONException {\n  StringWriter sw=new StringWriter();\nsynchronized (sw.getBuffer()) {\n    return this.write(sw,indentFactor,0).toString();\n  }\n}\n", "nl": "Make a prettyprinted JSON text of this JSONArray. Warning: This method assumes that the data structure is acyclical."}
{"code": "public Boolean isHttpSupportInformation(){\n  return httpSupportInformation;\n}\n", "nl": "Ruft den Wert der httpSupportInformation-Eigenschaft ab."}
{"code": "public static URLConnection createConnectionToURL(final String url,final Map<String,String> requestHeaders) throws IOException {\n  final URL connectionURL=URLUtility.stringToUrl(url);\n  if (connectionURL == null) {\n    throw new IOException(\"Invalid url format: \" + url);\n  }\n  final URLConnection urlConnection=connectionURL.openConnection();\n  urlConnection.setConnectTimeout(CONNECTION_TIMEOUT);\n  urlConnection.setReadTimeout(READ_TIMEOUT);\n  if (requestHeaders != null) {\n    for (    final Map.Entry<String,String> entry : requestHeaders.entrySet()) {\n      urlConnection.setRequestProperty(entry.getKey(),entry.getValue());\n    }\n  }\n  return urlConnection;\n}\n", "nl": "Create URLConnection instance."}
{"code": "public ASN1Primitive toASN1Primitive(){\n  try {\n    if (certificateType == profileType) {\n      return profileToASN1Object();\n    }\n    if (certificateType == requestType) {\n      return requestToASN1Object();\n    }\n  }\n catch (  IOException e) {\n    return null;\n  }\n  return null;\n}\n", "nl": "create a \"request\" or \"profile\" type Iso7816CertificateBody according to the variables sets."}
{"code": "public Builder mapper(final Mapper<ObjectMapper> mapper){\n  this.mapper=mapper;\n  return this;\n}\n", "nl": "Override all of the builder options with this mapper.  If this value is set to something other than null then that value will be used to construct the writer."}
{"code": "private int[][] div(int[] a,int[] f){\n  int df=computeDegree(f);\n  int da=computeDegree(a) + 1;\n  if (df == -1) {\n    throw new ArithmeticException(\"Division by zero.\");\n  }\n  int[][] result=new int[2][];\n  result[0]=new int[1];\n  result[1]=new int[da];\n  int hc=headCoefficient(f);\n  hc=field.inverse(hc);\n  result[0][0]=0;\n  System.arraycopy(a,0,result[1],0,result[1].length);\n  while (df <= computeDegree(result[1])) {\n    int[] q;\n    int[] coeff=new int[1];\n    coeff[0]=field.mult(headCoefficient(result[1]),hc);\n    q=multWithElement(f,coeff[0]);\n    int n=computeDegree(result[1]) - df;\n    q=multWithMonomial(q,n);\n    coeff=multWithMonomial(coeff,n);\n    result[0]=add(coeff,result[0]);\n    result[1]=add(q,result[1]);\n  }\n  return result;\n}\n", "nl": "Compute the result of the division of two polynomials over the field <tt>GF(2^m)</tt>."}
{"code": "public static short toShort(byte[] bytes,int start){\n  return toShort(bytes[start],bytes[start + 1]);\n}\n", "nl": "Returns short from given array of bytes. <br> Array must have at least start + 2 elements in it."}
{"code": "public void addAttribute(AttributedCharacterIterator.Attribute attribute,Object value,int start,int end){\n  if (attribute == null) {\n    throw new NullPointerException(\"attribute == null\");\n  }\n  if (start < 0 || end > text.length() || start >= end) {\n    throw new IllegalArgumentException();\n  }\n  if (value == null) {\n    return;\n  }\n  List<Range> ranges=attributeMap.get(attribute);\n  if (ranges == null) {\n    ranges=new ArrayList<Range>(1);\n    ranges.add(new Range(start,end,value));\n    attributeMap.put(attribute,ranges);\n    return;\n  }\n  ListIterator<Range> it=ranges.listIterator();\n  while (it.hasNext()) {\n    Range range=it.next();\n    if (end <= range.start) {\n      it.previous();\n      break;\n    }\n else     if (start < range.end || (start == range.end && value.equals(range.value))) {\n      Range r1=null, r3;\n      it.remove();\n      r1=new Range(range.start,start,range.value);\n      r3=new Range(end,range.end,range.value);\n      while (end > range.end && it.hasNext()) {\n        range=it.next();\n        if (end <= range.end) {\n          if (end > range.start || (end == range.start && value.equals(range.value))) {\n            it.remove();\n            r3=new Range(end,range.end,range.value);\n            break;\n          }\n        }\n else {\n          it.remove();\n        }\n      }\n      if (value.equals(r1.value)) {\n        if (value.equals(r3.value)) {\n          it.add(new Range(r1.start < start ? r1.start : start,r3.end > end ? r3.end : end,r1.value));\n        }\n else {\n          it.add(new Range(r1.start < start ? r1.start : start,end,r1.value));\n          if (r3.start < r3.end) {\n            it.add(r3);\n          }\n        }\n      }\n else {\n        if (value.equals(r3.value)) {\n          if (r1.start < r1.end) {\n            it.add(r1);\n          }\n          it.add(new Range(start,r3.end > end ? r3.end : end,r3.value));\n        }\n else {\n          if (r1.start < r1.end) {\n            it.add(r1);\n          }\n          it.add(new Range(start,end,value));\n          if (r3.start < r3.end) {\n            it.add(r3);\n          }\n        }\n      }\n      return;\n    }\n  }\n  it.add(new Range(start,end,value));\n}\n", "nl": "Applies a given attribute to the given range of this string."}
{"code": "@Override public Double hincrByFloat(final String key,final String field,final double value){\n  checkIsInMultiOrPipeline();\n  client.hincrByFloat(key,field,value);\n  final String dval=client.getBulkReply();\n  return (dval != null ? new Double(dval) : null);\n}\n", "nl": "Increment the number stored at field in the hash at key by a double precision floating point value. If key does not exist, a new key holding a hash is created. If field does not exist or holds a string, the value is set to 0 before applying the operation. Since the value argument is signed you can use this command to perform both increments and decrements. <p> The range of values supported by HINCRBYFLOAT is limited to double precision floating point values. <p> <b>Time complexity:</b> O(1)"}
{"code": "public DrawerBuilder withFooter(@NonNull View footerView){\n  this.mFooterView=footerView;\n  return this;\n}\n", "nl": "Add a footer to the DrawerBuilder ListView. This can be any view"}
{"code": "@Override public int compareTo(final Object obj) throws ClassCastException {\n  final URI another=(URI)obj;\n  if (!equals(_authority,another.getRawAuthority())) {\n    return -1;\n  }\n  return toString().compareTo(another.toString());\n}\n", "nl": "Compare this URI to another object."}
{"code": "public boolean isNavigationAtBottom(){\n  return (mSmallestWidthDp >= 600 || mInPortrait);\n}\n", "nl": "Should a navigation bar appear at the bottom of the screen in the current device configuration? A navigation bar may appear on the right side of the screen in certain configurations."}
{"code": "@Override public void execute(String filePath){\n  final CurrentProject currentProject=appContext.getCurrentProject();\n  if (filePath != null && !filePath.startsWith(\"/\")) {\n    filePath=\"/\".concat(filePath);\n  }\n  if (currentProject != null) {\n    String fullPath=currentProject.getRootProject().getPath() + filePath;\n    log.debug(\"Open file {0}\",fullPath);\n    currentProject.getCurrentTree().getNodeByPath(fullPath,new TreeNodeAsyncCallback());\n  }\n}\n", "nl": "Open a file for the current given path."}
{"code": "public void executionDetailsEnd(final ConcurrentHashMap<Integer,TradeOrder> tradeOrders){\n  try {\n    Tradingday todayTradingday=m_tradingdays.getTradingday(TradingCalendar.getTradingDayStart(TradingCalendar.getDateTimeNowMarketTimeZone()),TradingCalendar.getTradingDayEnd(TradingCalendar.getDateTimeNowMarketTimeZone()));\n    if (null == todayTradingday) {\n      return;\n    }\n    tradingdayPanel.doRefresh(todayTradingday);\n    tradingdayPanel.doRefreshTradingdayTable(todayTradingday);\n  }\n catch (  Exception ex) {\n    this.setErrorMessage(\"Error starting PositionManagerRule.\",ex.getMessage(),ex);\n  }\n}\n", "nl": "This method is fired when the Brokermodel has completed the request for Execution Details see doFetchExecution or connectionOpened i.e from a BrokerModel event all executions for the filter have now been received. Check to see if we need to close any trades for these order fills."}
{"code": "public void successfullyCreated(){\n  if (notification != null) {\n    notification.setStatus(SUCCESS);\n    notification.setTitle(locale.createSnapshotSuccess());\n  }\n}\n", "nl": "Changes notification state to successfully finished."}
{"code": "public HybridTimestampFactory(int counterBits){\n  if (counterBits < 0 || counterBits > 31) {\n    throw new IllegalArgumentException(\"counterBits must be in [0:31]\");\n  }\n  lastTimestamp=0L;\n  this.counterBits=counterBits;\n  maxCounter=BigInteger.valueOf(2).pow(counterBits).intValue() - 1;\n  log.warn(\"#counterBits=\" + counterBits + \", maxCounter=\"+ maxCounter);\n}\n", "nl": "Allows up to <code>2^counterBits</code> distinct timestamps per millisecond."}
{"code": "@Override public void clear(){\n  this._map.clear();\n}\n", "nl": "Empties the map."}
{"code": "public boolean removeElement(int s){\n  if (null == m_map)   return false;\n  for (int i=0; i < m_firstFree; i++) {\n    int node=m_map[i];\n    if (node == s) {\n      if (i > m_firstFree)       System.arraycopy(m_map,i + 1,m_map,i - 1,m_firstFree - i);\n else       m_map[i]=DTM.NULL;\n      m_firstFree--;\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Removes the first occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object's index is shifted downward to have an index one smaller than the value it had previously."}
{"code": "private void addSingleton(TempCluster clus,DBIDRef id,double dist,boolean asCluster){\n  if (asCluster) {\n    clus.addChild(makeSingletonCluster(id,dist));\n  }\n else {\n    clus.add(id);\n  }\n  clus.depth=dist;\n}\n", "nl": "Add a singleton object, as point or cluster."}
{"code": "public int size(){\n  return values.length;\n}\n", "nl": "Returns the number of values in this kernel."}
{"code": "private void testServerJoinLate(Member.Type type,CopycatServer.State state) throws Throwable {\n  createServers(3);\n  CopycatClient client=createClient();\n  submit(client,0,1000);\n  await(30000);\n  CopycatServer joiner=createServer(nextMember(type));\n  joiner.onStateChange(null);\n  joiner.join(members.stream().map(null).collect(Collectors.toList())).thenRun(null);\n  await(30000,2);\n}\n", "nl": "Tests joining a server after many entries have been committed."}
{"code": "public Shape createRadioButton(int x,int y,int diameter){\n  return createEllipseInternal(x,y,diameter,diameter);\n}\n", "nl": "Return a path for a radio button's concentric sections."}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:57:11.638 -0500\",hash_original_method=\"3CEC44303CC022BBEC9F119BC403FDBC\",hash_generated_method=\"FD349EDA389F166F5AB5B32AD7B69928\") public int size(){\n  return al.size();\n}\n", "nl": "Returns the number of elements in this set."}
{"code": "public static String formatRateString(float rate){\n  return String.format(java.util.Locale.US,\"%.2fx\",rate);\n}\n", "nl": "Get the formatted current playback speed in the form of 1.00x"}
{"code": "private static BitmapFactory.Options decodeImageForOption(ContentResolver resolver,Uri uri) throws FileNotFoundException {\n  InputStream stream=null;\n  try {\n    stream=resolver.openInputStream(uri);\n    BitmapFactory.Options options=new BitmapFactory.Options();\n    options.inJustDecodeBounds=true;\n    BitmapFactory.decodeStream(stream,EMPTY_RECT,options);\n    options.inJustDecodeBounds=false;\n    return options;\n  }\n  finally {\n    closeSafe(stream);\n  }\n}\n", "nl": "Decode image from uri using \"inJustDecodeBounds\" to get the image dimensions."}
{"code": "public FinalSQLString(BasicSQLString sqlstring){\n  this.delegate=sqlstring;\n}\n", "nl": "Should only be called inside SQLString because this class essentially verifies that we've checked for updates."}
{"code": "public void loadArgArray(){\n  push(argumentTypes.length);\n  newArray(OBJECT_TYPE);\n  for (int i=0; i < argumentTypes.length; i++) {\n    dup();\n    push(i);\n    loadArg(i);\n    box(argumentTypes[i]);\n    arrayStore(OBJECT_TYPE);\n  }\n}\n", "nl": "Generates the instructions to load all the method arguments on the stack, as a single object array."}
{"code": "public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  WebUtil.createLoginPage(request,response,this,null,null);\n}\n", "nl": "Process the HTTP Get request"}
{"code": "private DeferredFileOutputStream(int threshold,File outputFile,String prefix,String suffix,File directory){\n  super(threshold);\n  this.outputFile=outputFile;\n  memoryOutputStream=new ByteArrayOutputStream();\n  currentOutputStream=memoryOutputStream;\n  this.prefix=prefix;\n  this.suffix=suffix;\n  this.directory=directory;\n}\n", "nl": "Constructs an instance of this class which will trigger an event at the specified threshold, and save data either to a file beyond that point."}
{"code": "public final void testSetSystemScope(){\n  IdentityScope systemScope=IdentityScope.getSystemScope();\n  try {\n    is=new IdentityScopeStub(\"Aleksei Semenov\");\n    IdentityScopeStub.mySetSystemScope(is);\n    assertSame(is,IdentityScope.getSystemScope());\n  }\n  finally {\n    IdentityScopeStub.mySetSystemScope(systemScope);\n  }\n}\n", "nl": "check that if permission given - set/get works if permission is denied than SecurityException is thrown"}
{"code": "public static void main(String[] args){\n  runEvaluator(new WrapperSubsetEval(),args);\n}\n", "nl": "Main method for testing this class."}
{"code": "public static void v(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_VERBOSE) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.v(tag,msg);\n}\n", "nl": "Send a VERBOSE log message."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:58:04.267 -0500\",hash_original_method=\"2CE5F24A4C571BEECB25C40400E44908\",hash_generated_method=\"A3579B97578194B5EA0183D0F747142C\") void computeNextElement(){\n  while (true) {\n    if (currentBits != 0) {\n      mask=currentBits & -currentBits;\n      return;\n    }\n else     if (++index < bits.length) {\n      currentBits=bits[index];\n    }\n else {\n      mask=0;\n      return;\n    }\n  }\n}\n", "nl": "Assigns mask and index to the next available value, cycling currentBits as necessary."}
{"code": "public HierarchyEvent(Component source,int id,Component changed,Container changedParent,long changeFlags){\n  super(source,id);\n  this.changed=changed;\n  this.changedParent=changedParent;\n  this.changeFlags=changeFlags;\n}\n", "nl": "Constructs an <code>HierarchyEvent</code> object to identify a change in the <code>Component</code> hierarchy. <p> This method throws an <code>IllegalArgumentException</code> if <code>source</code> is <code>null</code>."}
{"code": "public void step(SimState state){\n}\n", "nl": "This method is performed when the next step for the agent is computed. This agent does nothing, so nothing is inside the body of the method."}
{"code": "public static void resetRuntime(){\n  currentTime=1392409281320L;\n  wasTimeAccessed=false;\n  hashKeys.clear();\n  restoreProperties();\n  needToRestoreProperties=false;\n}\n", "nl": "Reset runtime to initial state"}
{"code": "public ExpandCaseMultipliersAction(DataEditor editor){\n  super(\"Expand Case Multipliers\");\n  if (editor == null) {\n    throw new NullPointerException();\n  }\n  this.dataEditor=editor;\n}\n", "nl": "Creates a new action to split by collinear columns."}
{"code": "public ScaleFake(){\n}\n", "nl": "Creates a new instance of ScaleFake"}
{"code": "protected ArrayElementImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public FilterRowIterator(IntIterator rows,Table t,Predicate p){\n  this.predicate=p;\n  this.rows=rows;\n  this.t=t;\n  next=advance();\n}\n", "nl": "Create a new FilterRowIterator."}
{"code": "private void scanJar(JarURLConnection conn,List<String> tldNames,boolean isLocal) throws JasperException {\n  String resourcePath=conn.getJarFileURL().toString();\n  TldInfo[] tldInfos=jarTldCacheLocal.get(resourcePath);\n  if (tldInfos != null && tldInfos.length == 0) {\n    try {\n      conn.getJarFile().close();\n    }\n catch (    IOException ex) {\n    }\n    return;\n  }\n  if (tldInfos == null) {\n    JarFile jarFile=null;\n    ArrayList<TldInfo> tldInfoA=new ArrayList<TldInfo>();\n    try {\n      jarFile=conn.getJarFile();\n      if (tldNames != null) {\n        for (        String tldName : tldNames) {\n          JarEntry entry=jarFile.getJarEntry(tldName);\n          InputStream stream=jarFile.getInputStream(entry);\n          tldInfoA.add(scanTld(resourcePath,tldName,stream));\n        }\n      }\n else {\n        Enumeration<JarEntry> entries=jarFile.entries();\n        while (entries.hasMoreElements()) {\n          JarEntry entry=entries.nextElement();\n          String name=entry.getName();\n          if (!name.startsWith(\"META-INF/\"))           continue;\n          if (!name.endsWith(\".tld\"))           continue;\n          InputStream stream=jarFile.getInputStream(entry);\n          tldInfoA.add(scanTld(resourcePath,name,stream));\n        }\n      }\n    }\n catch (    IOException ex) {\n      if (resourcePath.startsWith(FILE_PROTOCOL) && !((new File(resourcePath)).exists())) {\n        if (log.isLoggable(Level.WARNING)) {\n          log.log(Level.WARNING,Localizer.getMessage(\"jsp.warn.nojar\",resourcePath),ex);\n        }\n      }\n else {\n        throw new JasperException(Localizer.getMessage(\"jsp.error.jar.io\",resourcePath),ex);\n      }\n    }\n finally {\n      if (jarFile != null) {\n        try {\n          jarFile.close();\n        }\n catch (        Throwable t) {\n        }\n      }\n    }\n    tldInfos=tldInfoA.toArray(new TldInfo[tldInfoA.size()]);\n    jarTldCacheLocal.put(resourcePath,tldInfos);\n    if (!isLocal) {\n      jarTldCache.put(resourcePath,tldInfos);\n    }\n  }\n  for (  TldInfo tldInfo : tldInfos) {\n    if (scanListeners) {\n      addListener(tldInfo,isLocal);\n    }\n    mapTldLocation(resourcePath,tldInfo,isLocal);\n  }\n}\n", "nl": "Scans the given JarURLConnection for TLD files located in META-INF (or a subdirectory of it).  If the scanning in is done as part of the ServletContextInitializer, the listeners in the tlds in this jar file are added to the servlet context, and for any  TLD that has a <uri> element, an implicit map entry is added to the taglib map."}
{"code": "public static void cosft1(double[] y){\n  com.nr.fft.FFT.cosft1(y);\n}\n", "nl": "Calculates the cosine transform of a set y[0..n] of real-valued data points. The transformed data replace the original data in array y. n must be a power of 2. This program, without changes, also calculates the inverse cosine transform, but in this case the output array should be multiplied by 2/n."}
{"code": "public void stop(){\n  mRunning=false;\n  mStop=true;\n}\n", "nl": "Stops the animation in place. It does not snap the image to its final translation."}
{"code": "public boolean hasNext(){\n  return cursor > 0;\n}\n", "nl": "This is used to determine if the cursor has reached the start of the list. When the cursor reaches the start of the list then this method returns false."}
{"code": "@Override protected void onFinished(final Player player,final boolean successful){\n  if (successful) {\n    final String itemName=items[Rand.rand(items.length)];\n    final Item item=SingletonRepository.getEntityManager().getItem(itemName);\n    int amount=1;\n    if (itemName.equals(\"dark dagger\") || itemName.equals(\"horned golden helmet\")) {\n      item.setBoundTo(player.getName());\n    }\n else     if (itemName.equals(\"money\")) {\n      amount=Rand.roll1D100();\n      ((StackableItem)item).setQuantity(amount);\n    }\n    player.equipOrPutOnGround(item);\n    player.incObtainedForItem(item.getName(),item.getQuantity());\n    SingletonRepository.getAchievementNotifier().onObtain(player);\n    player.sendPrivateText(\"You were lucky and found \" + Grammar.quantityplnoun(amount,itemName,\"a\") + \".\");\n  }\n else {\n    player.sendPrivateText(\"Your wish didn't come true.\");\n  }\n}\n", "nl": "Called when the activity has finished."}
{"code": "public void saveWalletAndWalletInfoSimple(WalletData perWalletModelData,String walletFilename,String walletInfoFilename){\n  File walletFile=new File(walletFilename);\n  WalletInfoData walletInfo=perWalletModelData.getWalletInfo();\n  FileOutputStream fileOutputStream=null;\n  try {\n    if (perWalletModelData.getWallet() != null) {\n      if (walletInfo != null) {\n        String walletDescriptionInInfoFile=walletInfo.getProperty(WalletInfoData.DESCRIPTION_PROPERTY);\n        if (walletDescriptionInInfoFile != null) {\n          perWalletModelData.getWallet().setDescription(walletDescriptionInInfoFile);\n        }\n      }\n      log.debug(\"Saving wallet file '\" + walletFile.getAbsolutePath() + \"' ...\");\n      if (MultiBitWalletVersion.SERIALIZED == walletInfo.getWalletVersion()) {\n        throw new WalletSaveException(\"Cannot save wallet '\" + walletFile.getAbsolutePath() + \"'. Serialized wallets are no longer supported.\");\n      }\n else {\n        boolean walletIsActuallyEncrypted=false;\n        Wallet wallet=perWalletModelData.getWallet();\n        for (        ECKey key : wallet.getKeychain()) {\n          if (key.isEncrypted()) {\n            walletIsActuallyEncrypted=true;\n            break;\n          }\n        }\n        if (walletIsActuallyEncrypted) {\n          walletInfo.setWalletVersion(MultiBitWalletVersion.PROTOBUF_ENCRYPTED);\n        }\n        if (MultiBitWalletVersion.PROTOBUF == walletInfo.getWalletVersion()) {\n          perWalletModelData.getWallet().saveToFile(walletFile);\n        }\n else         if (MultiBitWalletVersion.PROTOBUF_ENCRYPTED == walletInfo.getWalletVersion()) {\n          fileOutputStream=new FileOutputStream(walletFile);\n          walletProtobufSerializer.writeWallet(perWalletModelData.getWallet(),fileOutputStream);\n        }\n else {\n          throw new WalletVersionException(\"Cannot save wallet '\" + perWalletModelData.getWalletFilename() + \"'. Its wallet version is '\"+ walletInfo.getWalletVersion().toString()+ \"' but this version of MultiBit does not understand that format.\");\n        }\n      }\n      log.debug(\"... done saving wallet file.\");\n    }\n  }\n catch (  IOException ioe) {\n    throw new WalletSaveException(\"Cannot save wallet '\" + perWalletModelData.getWalletFilename(),ioe);\n  }\n finally {\n    if (fileOutputStream != null) {\n      try {\n        fileOutputStream.flush();\n        fileOutputStream.close();\n      }\n catch (      IOException e) {\n        throw new WalletSaveException(\"Cannot save wallet '\" + perWalletModelData.getWalletFilename(),e);\n      }\n    }\n  }\n  walletInfo.writeToFile(walletInfoFilename,walletInfo.getWalletVersion());\n}\n", "nl": "Simply save the wallet and wallet info files. Used for backup writes."}
{"code": "@Override public Object clone() throws CloneNotSupportedException {\n  DefaultIntervalXYDataset clone=(DefaultIntervalXYDataset)super.clone();\n  clone.seriesKeys=new java.util.ArrayList(this.seriesKeys);\n  clone.seriesList=new ArrayList(this.seriesList.size());\n  for (int i=0; i < this.seriesList.size(); i++) {\n    double[][] data=(double[][])this.seriesList.get(i);\n    double[] x=data[0];\n    double[] xStart=data[1];\n    double[] xEnd=data[2];\n    double[] y=data[3];\n    double[] yStart=data[4];\n    double[] yEnd=data[5];\n    double[] xx=new double[x.length];\n    double[] xxStart=new double[xStart.length];\n    double[] xxEnd=new double[xEnd.length];\n    double[] yy=new double[y.length];\n    double[] yyStart=new double[yStart.length];\n    double[] yyEnd=new double[yEnd.length];\n    System.arraycopy(x,0,xx,0,x.length);\n    System.arraycopy(xStart,0,xxStart,0,xStart.length);\n    System.arraycopy(xEnd,0,xxEnd,0,xEnd.length);\n    System.arraycopy(y,0,yy,0,y.length);\n    System.arraycopy(yStart,0,yyStart,0,yStart.length);\n    System.arraycopy(yEnd,0,yyEnd,0,yEnd.length);\n    clone.seriesList.add(i,new double[][]{xx,xxStart,xxEnd,yy,yyStart,yyEnd});\n  }\n  return clone;\n}\n", "nl": "Returns a clone of this dataset."}
{"code": "public EveningActivityMovement(Settings settings){\n  super(settings);\n  super.backAllowed=false;\n  pathFinder=new DijkstraPathFinder(null);\n  mode=WALKING_TO_MEETING_SPOT_MODE;\n  nrOfMeetingSpots=settings.getInt(NR_OF_MEETING_SPOTS_SETTING);\n  minGroupSize=settings.getInt(MIN_GROUP_SIZE_SETTING);\n  maxGroupSize=settings.getInt(MAX_GROUP_SIZE_SETTING);\n  MapNode[] mapNodes=(MapNode[])getMap().getNodes().toArray(new MapNode[0]);\n  String shoppingSpotsFile=null;\n  try {\n    shoppingSpotsFile=settings.getSetting(MEETING_SPOTS_FILE_SETTING);\n  }\n catch (  Throwable t) {\n  }\n  List<Coord> meetingSpotLocations=null;\n  if (shoppingSpotsFile == null) {\n    meetingSpotLocations=new LinkedList<Coord>();\n    for (int i=0; i < mapNodes.length; i++) {\n      if ((i % (mapNodes.length / nrOfMeetingSpots)) == 0) {\n        startAtLocation=mapNodes[i].getLocation().clone();\n        meetingSpotLocations.add(startAtLocation.clone());\n      }\n    }\n  }\n else {\n    try {\n      meetingSpotLocations=new LinkedList<Coord>();\n      List<Coord> locationsRead=(new WKTReader()).readPoints(new File(shoppingSpotsFile));\n      for (      Coord coord : locationsRead) {\n        SimMap map=getMap();\n        Coord offset=map.getOffset();\n        if (map.isMirrored()) {\n          coord.setLocation(coord.getX(),-coord.getY());\n        }\n        coord.translate(offset.getX(),offset.getY());\n        meetingSpotLocations.add(coord);\n      }\n    }\n catch (    Exception e) {\n      e.printStackTrace();\n    }\n  }\n  this.id=nextID++;\n  int scsID=settings.getInt(EVENING_ACTIVITY_CONTROL_SYSTEM_NR_SETTING);\n  scs=EveningActivityControlSystem.getEveningActivityControlSystem(scsID);\n  scs.setRandomNumberGenerator(rng);\n  scs.addEveningActivityNode(this);\n  scs.setMeetingSpots(meetingSpotLocations);\n  maxPathLength=100;\n  minPathLength=10;\n  maxWaitTime=settings.getInt(MAX_WAIT_TIME_SETTING);\n  minWaitTime=settings.getInt(MIN_WAIT_TIME_SETTING);\n}\n", "nl": "Creates a new instance of EveningActivityMovement"}
{"code": "protected Polygon makeHullComplex(double[][] pc){\n  GrahamScanConvexHull2D hull=new GrahamScanConvexHull2D();\n  double[] diag=new double[]{0,0};\n  for (int j=0; j < pc.length; j++) {\n    hull.add(pc[j]);\n    hull.add(times(pc[j],-1));\n    for (int k=j + 1; k < pc.length; k++) {\n      double[] q=pc[k];\n      double[] ppq=timesEquals(plus(pc[j],q),MathUtil.SQRTHALF);\n      double[] pmq=timesEquals(minus(pc[j],q),MathUtil.SQRTHALF);\n      hull.add(ppq);\n      hull.add(times(ppq,-1));\n      hull.add(pmq);\n      hull.add(times(pmq,-1));\n      for (int l=k + 1; l < pc.length; l++) {\n        double[] r=pc[k];\n        double[] ppqpr=timesEquals(plus(ppq,r),Math.sqrt(1 / 3.));\n        double[] pmqpr=timesEquals(plus(pmq,r),Math.sqrt(1 / 3.));\n        double[] ppqmr=timesEquals(minus(ppq,r),Math.sqrt(1 / 3.));\n        double[] pmqmr=timesEquals(minus(pmq,r),Math.sqrt(1 / 3.));\n        hull.add(ppqpr);\n        hull.add(times(ppqpr,-1));\n        hull.add(pmqpr);\n        hull.add(times(pmqpr,-1));\n        hull.add(ppqmr);\n        hull.add(times(ppqmr,-1));\n        hull.add(pmqmr);\n        hull.add(times(pmqmr,-1));\n      }\n    }\n    plusEquals(diag,pc[j]);\n  }\n  timesEquals(diag,1.0 / Math.sqrt(pc.length));\n  hull.add(diag);\n  hull.add(times(diag,-1));\n  return hull.getHull();\n}\n", "nl": "Build a convex hull to approximate the sphere."}
{"code": "public void visitAnnotations(AnnotatedNode node){\n  super.visitAnnotations(node);\n  for (  AnnotationNode annotation : node.getAnnotations()) {\n    if (transforms.containsKey(annotation)) {\n      targetNodes.add(new ASTNode[]{annotation,node});\n    }\n  }\n}\n", "nl": "Adds the annotation to the internal target list if a match is found."}
{"code": "Node(Node<K,V> next){\n  this.key=null;\n  this.value=this;\n  this.next=next;\n}\n", "nl": "Creates a new marker node. A marker is distinguished by having its value field point to itself.  Marker nodes also have null keys, a fact that is exploited in a few places, but this doesn't distinguish markers from the base-level header node (head.node), which also has a null key."}
{"code": "public void onDrawerClosed(View view){\n  super.onDrawerClosed(view);\n}\n", "nl": "Called when a drawer has settled in a completely closed state."}
{"code": "public static List<String> deserializeAddressList(String serializedAddresses){\n  return Arrays.asList(serializedAddresses.split(\",\"));\n}\n", "nl": "Deserialize a list of IP addresses from a string."}
{"code": "void challengeReceived(String challenge) throws IOException {\n  currentMechanism.challengeReceived(challenge);\n}\n", "nl": "The server is challenging the SASL authentication we just sent. Forward the challenge to the current SASLMechanism we are using. The SASLMechanism will send a response to the server. The length of the challenge-response sequence varies according to the SASLMechanism in use."}
{"code": "public boolean fitsType(Environment env,Context ctx,Type t){\n  if (this.type.isType(TC_CHAR)) {\n    return super.fitsType(env,ctx,t);\n  }\nswitch (t.getTypeCode()) {\ncase TC_BYTE:\n    return value == (byte)value;\ncase TC_SHORT:\n  return value == (short)value;\ncase TC_CHAR:\nreturn value == (char)value;\n}\nreturn super.fitsType(env,ctx,t);\n}\n", "nl": "See if this number fits in the given type."}
{"code": "public ServiceManager(Iterable<? extends Service> services){\n  ImmutableList<Service> copy=ImmutableList.copyOf(services);\n  if (copy.isEmpty()) {\n    logger.log(Level.WARNING,\"ServiceManager configured with no services.  Is your application configured properly?\",new EmptyServiceManagerWarning());\n    copy=ImmutableList.<Service>of(new NoOpService());\n  }\n  this.state=new ServiceManagerState(copy);\n  this.services=copy;\n  WeakReference<ServiceManagerState> stateReference=new WeakReference<ServiceManagerState>(state);\n  for (  Service service : copy) {\n    service.addListener(new ServiceListener(service,stateReference),directExecutor());\n    checkArgument(service.state() == NEW,\"Can only manage NEW services, %s\",service);\n  }\n  this.state.markReady();\n}\n", "nl": "Constructs a new instance for managing the given services."}
{"code": "public boolean hasModule(String moduleName){\n  return moduleStore.containsKey(moduleName) || moduleStore.containsValue(moduleName);\n}\n", "nl": "Looks up a module"}
{"code": "private void removeUnusedTilesets(final Map map){\n  for (final Iterator<?> sets=map.getTileSets().iterator(); sets.hasNext(); ) {\n    final TileSet tileset=(TileSet)sets.next();\n    if (!isUsedTileset(map,tileset)) {\n      sets.remove();\n    }\n  }\n}\n", "nl": "Remove any tilesets in a map that are not actually in use."}
{"code": "public vec3 transformPoint(vec3 v){\n  vec3 result=new vec3();\n  result.m[0]=this.m[0] * v.m[0] + this.m[4] * v.m[1] + this.m[8] * v.m[2] + this.m[12];\n  result.m[1]=this.m[1] * v.m[0] + this.m[5] * v.m[1] + this.m[9] * v.m[2] + this.m[13];\n  result.m[2]=this.m[2] * v.m[0] + this.m[6] * v.m[1] + this.m[10] * v.m[2] + this.m[14];\n  return result;\n}\n", "nl": "\\fn transformPoint \\brief Returns a transformed point \\param v [vec3]"}
{"code": "static AttrSessionID createFromString(final String str){\n  return new AttrSessionID(str);\n}\n", "nl": "Creates a new attribute instance from the provided String."}
{"code": "Spinner(ListModel model,ListCellRenderer rendererInstance){\n  super(model);\n  ios7Mode=UIManager.getInstance().isThemeConstant(\"ios7SpinnerBool\",false);\n  if (ios7Mode) {\n    super.setMinElementHeight(6);\n  }\n  SpinnerRenderer.iOS7Mode=ios7Mode;\n  setRenderer(rendererInstance);\n  setUIID(\"Spinner\");\n  setFixedSelection(FIXED_CENTER);\n  setOrientation(VERTICAL);\n  setInputOnFocus(false);\n  setIsScrollVisible(false);\n  initSpinnerRenderer();\n  quickType.setReplaceMenu(false);\n  quickType.setInputModeOrder(new String[]{\"123\"});\n  quickType.setFocus(true);\n  quickType.setRTL(false);\n  quickType.setAlignment(LEFT);\n  quickType.setConstraint(TextField.NUMERIC);\n  setIgnoreFocusComponentWhenUnfocused(true);\n  setRenderingPrototype(model.getItemAt(model.getSize() - 1));\n  if (getRenderer() instanceof DateTimeRenderer) {\n    quickType.setColumns(2);\n  }\n}\n", "nl": "Creates a new spinner instance with the given spinner model"}
{"code": "@SuppressWarnings(\"resource\") @Override public void start(){\n  paused=false;\n  log.info(\"Starting text-only user interface...\");\n  log.info(\"Local address: \" + system.getLocalAddress());\n  log.info(\"Press Ctrl + C to exit\");\n  new Thread(null).start();\n}\n", "nl": "Starts the interface."}
{"code": "public static byte[] encodeBase64(byte[] binaryData){\n  return org.apache.commons.codec.binary.Base64.encodeBase64(binaryData);\n}\n", "nl": "Encodes binary data using the base64 algorithm but does not chunk the output."}
{"code": "public int previousNode(){\n  if (!m_cacheNodes)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE,null));\n  if ((m_next - 1) > 0) {\n    m_next--;\n    return this.elementAt(m_next);\n  }\n else   return DTM.NULL;\n}\n", "nl": "Returns the previous node in the set and moves the position of the iterator backwards in the set."}
{"code": "public synchronized void decrease(Bitmap bitmap){\n  final int bitmapSize=BitmapUtil.getSizeInBytes(bitmap);\n  Preconditions.checkArgument(mCount > 0,\"No bitmaps registered.\");\n  Preconditions.checkArgument(bitmapSize <= mSize,\"Bitmap size bigger than the total registered size: %d, %d\",bitmapSize,mSize);\n  mSize-=bitmapSize;\n  mCount--;\n}\n", "nl": "Excludes given bitmap from the count."}
{"code": "public void addExcludedName(String name){\n  Object obj=lookupQualifiedName(scope,name);\n  if (!(obj instanceof Scriptable)) {\n    throw new IllegalArgumentException(\"Object for excluded name \" + name + \" not found.\");\n  }\n  table.put(obj,name);\n}\n", "nl": "Adds a qualified name to the list of objects to be excluded from serialization. Names excluded from serialization are looked up in the new scope and replaced upon deserialization."}
{"code": "public void normalizeExcitatoryFanIn(){\n  double sum=0;\n  double str=0;\n  for (int i=0, n=fanIn.size(); i < n; i++) {\n    str=fanIn.get(i).getStrength();\n    if (str > 0) {\n      sum+=str;\n    }\n  }\n  Synapse s=null;\n  for (int i=0, n=fanIn.size(); i < n; i++) {\n    s=fanIn.get(i);\n    str=s.getStrength();\n    if (str > 0) {\n      s.setStrength(s.getStrength() / sum);\n    }\n  }\n}\n", "nl": "Normalizes the excitatory synaptic strengths impinging on this neuron, that is finds the sum of the exctiatory weights and divides each weight value by that sum;"}
{"code": "@MethodDesc(description=\"Configure properties by either rereading them or setting all properties from outside.\",usage=\"configure <properties>\") public void configure(@ParamDesc(name=\"tp\",description=\"Optional properties to replace replicator.properties\") TungstenProperties tp) throws Exception {\n  handleEventSynchronous(new ConfigureEvent(tp));\n}\n", "nl": "Local wrapper of configure to help with unit testing."}
{"code": "public boolean isArrayIndex(){\n  return true;\n}\n", "nl": "Return true if variable is an array"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  return NetworkClient.getConnectedClients();\n}\n", "nl": "Returns a list of all the clients that are currently connected to this server."}
{"code": "public Debug(String filename){\n  this(filename,1000000,1);\n}\n", "nl": "logs the output to the specified file (and stdout). Size is 1,000,000 bytes  and 1 file."}
{"code": "private String createKeywordDisplayName(TaxonKeyword keyword){\n  String combined=null;\n  if (keyword != null) {\n    String scientificName=StringUtils.trimToNull(keyword.getScientificName());\n    String commonName=StringUtils.trimToNull(keyword.getCommonName());\n    if (scientificName != null && commonName != null) {\n      combined=scientificName + \" (\" + commonName+ \")\";\n    }\n else     if (scientificName != null) {\n      combined=scientificName;\n    }\n else     if (commonName != null) {\n      combined=commonName;\n    }\n  }\n  return combined;\n}\n", "nl": "Construct display name from TaxonKeyword's scientific name and common name properties. It will look like: scientific name (common name) provided both properties are not null."}
{"code": "public static void w(String tag,String msg){\n  w(tag,msg,null);\n}\n", "nl": "Prints a message at WARN priority."}
{"code": "public BehaviorEvent(FacesContext facesContext,UIComponent component,Behavior behavior){\n  super(facesContext,component);\n  if (null == behavior) {\n    throw new IllegalArgumentException(\"Behavior agrument cannot be null\");\n  }\n  this.behavior=behavior;\n}\n", "nl": "<p class=\"changed_added_2_3\">Construct a new event object  from the Faces context, specified source component and behavior.</p>"}
{"code": "public static Number intdiv(Number left,Character right){\n  return intdiv(left,Integer.valueOf(right));\n}\n", "nl": "Integer Divide a Number by a Character. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value)."}
{"code": "public SQLDataException(String reason,Throwable cause){\n  super(reason,cause);\n}\n", "nl": "Creates an SQLDataException object. The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object."}
{"code": "public boolean isSetHeader(){\n  return this.header != null;\n}\n", "nl": "Returns true if field header is set (has been assigned a value) and false otherwise"}
{"code": "public boolean increment(float key){\n  return adjustValue(key,1);\n}\n", "nl": "Increments the primitive value mapped to key by 1"}
{"code": "public boolean finish(){\n  if (!started)   return false;\n  boolean ok=true;\n  started=false;\n  try {\n    out.write(0x3b);\n    out.flush();\n    if (closeStream) {\n      out.close();\n    }\n  }\n catch (  IOException e) {\n    ok=false;\n  }\n  transIndex=0;\n  out=null;\n  image=null;\n  pixels=null;\n  indexedPixels=null;\n  colorTab=null;\n  closeStream=false;\n  firstFrame=true;\n  return ok;\n}\n", "nl": "Flushes any pending data and closes output file. If writing to an OutputStream, the stream is not closed."}
{"code": "public void initializeDefinition(String tableName,boolean isUnique){\n  m_table=tableName;\n  m_isUnique=isUnique;\n  s_logger.log(Level.FINEST,toString());\n}\n", "nl": "initialize detailed definitions forindex"}
{"code": "private static String concatHeirTokens(SyntaxTreeNode stn){\n  SyntaxTreeNode[] heirs=stn.getHeirs();\n  if (heirs.length == 0) {\n    if (stn.getKind() < SyntaxTreeConstants.NULL_ID) {\n      return stn.getImage();\n    }\n else {\n      return \"\";\n    }\n  }\n  String val=\"\";\n  for (int i=0; i < heirs.length; i++) {\n    val=val + concatHeirTokens(heirs[i]);\n  }\n  return val;\n}\n", "nl": "Returns the concatenation of the images of all leaf nodes of the node stn that correspond to actual tokens"}
{"code": "public Object jjtAccept(ParserVisitor visitor,Object data){\n  return visitor.visit(this,data);\n}\n", "nl": "Accept the visitor."}
{"code": "public static Bitmap createImageThumbnail(String filePath,int kind){\n  boolean wantMini=(kind == Images.Thumbnails.MINI_KIND);\n  int targetSize=wantMini ? TARGET_SIZE_MINI_THUMBNAIL : TARGET_SIZE_MICRO_THUMBNAIL;\n  int maxPixels=wantMini ? MAX_NUM_PIXELS_THUMBNAIL : MAX_NUM_PIXELS_MICRO_THUMBNAIL;\n  SizedThumbnailBitmap sizedThumbnailBitmap=new SizedThumbnailBitmap();\n  Bitmap bitmap=null;\n  MediaFileType fileType=MediaFile.getFileType(filePath);\n  if (fileType != null && fileType.fileType == MediaFile.FILE_TYPE_JPEG) {\n    createThumbnailFromEXIF(filePath,targetSize,maxPixels,sizedThumbnailBitmap);\n    bitmap=sizedThumbnailBitmap.mBitmap;\n  }\n  if (bitmap == null) {\n    FileInputStream stream=null;\n    try {\n      stream=new FileInputStream(filePath);\n      FileDescriptor fd=stream.getFD();\n      BitmapFactory.Options options=new BitmapFactory.Options();\n      options.inSampleSize=1;\n      options.inJustDecodeBounds=true;\n      BitmapFactory.decodeFileDescriptor(fd,null,options);\n      if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) {\n        return null;\n      }\n      options.inSampleSize=computeSampleSize(options,targetSize,maxPixels);\n      options.inJustDecodeBounds=false;\n      options.inDither=false;\n      options.inPreferredConfig=Bitmap.Config.ARGB_8888;\n      bitmap=BitmapFactory.decodeFileDescriptor(fd,null,options);\n    }\n catch (    IOException ex) {\n      Log.e(TAG,\"\",ex);\n    }\ncatch (    OutOfMemoryError oom) {\n      Log.e(TAG,\"Unable to decode file \" + filePath + \". OutOfMemoryError.\",oom);\n    }\n finally {\n      try {\n        if (stream != null) {\n          stream.close();\n        }\n      }\n catch (      IOException ex) {\n        Log.e(TAG,\"\",ex);\n      }\n    }\n  }\n  if (kind == Images.Thumbnails.MICRO_KIND) {\n    bitmap=extractThumbnail(bitmap,TARGET_SIZE_MICRO_THUMBNAIL,TARGET_SIZE_MICRO_THUMBNAIL,OPTIONS_RECYCLE_INPUT);\n  }\n  return bitmap;\n}\n", "nl": "This method first examines if the thumbnail embedded in EXIF is bigger than our target size. If not, then it'll create a thumbnail from original image. Due to efficiency consideration, we want to let MediaThumbRequest avoid calling this method twice for both kinds, so it only requests for MICRO_KIND and set saveImage to true. This method always returns a \"square thumbnail\" for MICRO_KIND thumbnail."}
{"code": "public static <T extends Annotation>T checkAnnotationPresent(AnnotatedElement annotatedType,Class<T> annotationClass){\n  return getAnnotation(annotatedType,annotationClass);\n}\n", "nl": "Check if the annotation is present and if not throws an exception, this is just an overload for more clear naming."}
{"code": "public Element store(Object o){\n  PortalIcon p=(PortalIcon)o;\n  if (!p.isActive()) {\n    return null;\n  }\n  Element element=new Element(\"PortalIcon\");\n  storeCommonAttributes(p,element);\n  element.setAttribute(\"scale\",String.valueOf(p.getScale()));\n  element.setAttribute(\"rotate\",String.valueOf(p.getDegrees()));\n  Portal portal=p.getPortal();\n  if (portal == null) {\n    log.info(\"PortalIcon has no associated Portal.\");\n    return null;\n  }\n  element.setAttribute(\"portalName\",portal.getName());\n  if (portal.getToBlock() != null) {\n    element.setAttribute(\"toBlockName\",portal.getToBlockName());\n  }\n  if (portal.getFromBlockName() != null) {\n    element.setAttribute(\"fromBlockName\",portal.getFromBlockName());\n  }\n  element.setAttribute(\"arrowSwitch\",\"\" + (p.getArrowSwitch() ? \"yes\" : \"no\"));\n  element.setAttribute(\"arrowHide\",\"\" + (p.getArrowHide() ? \"yes\" : \"no\"));\n  element.setAttribute(\"class\",\"jmri.jmrit.display.controlPanelEditor.configurexml.PortalIconXml\");\n  return element;\n}\n", "nl": "Default implementation for storing the contents of a PortalIcon"}
{"code": "public Address __rxor__(final Object rhs){\n  return new Address(m_value.xor(getBigInteger(rhs)));\n}\n", "nl": "Used to support reverse XOR operations on addresses in Python scripts."}
{"code": "public SimpleUser(String username,Collection<String> userIdentifiers,Collection<String> connectionIdentifiers,Collection<String> connectionGroupIdentifiers){\n  this(username);\n  addReadPermissions(userPermissions,userIdentifiers);\n  addReadPermissions(connectionPermissions,connectionIdentifiers);\n  addReadPermissions(connectionGroupPermissions,connectionGroupIdentifiers);\n}\n", "nl": "Creates a new SimpleUser having the given username and READ access to the users, connections, and groups having the given identifiers."}
{"code": "public void startDocument() throws org.xml.sax.SAXException {\n}\n", "nl": "Receive notification of the beginning of a document. <p>The SAX parser will invoke this method only once, before any other methods in this interface or in DTDHandler (except for setDocumentLocator).</p>"}
{"code": "protected AbstractIntSpliterator(long est,int additionalCharacteristics){\n  this.est=est;\n  this.characteristics=((additionalCharacteristics & Spliterator.SIZED) != 0) ? additionalCharacteristics | Spliterator.SUBSIZED : additionalCharacteristics;\n}\n", "nl": "Creates a spliterator reporting the given estimated size and characteristics."}
{"code": "private Set<DefUseCoverageTestFitness> preAnalyzeMethods(){\n  Set<DefUseCoverageTestFitness> r=new HashSet<DefUseCoverageTestFitness>();\n  LinkedList<ClassCallNode> toAnalyze=new LinkedList<ClassCallNode>();\n  toAnalyze.addAll(getInitialPreAnalyzeableMethods());\n  while (!toAnalyze.isEmpty()) {\n    ClassCallNode currentMethod=toAnalyze.poll();\n    CCFGMethodEntryNode analyzeableEntry=ccfg.getMethodEntryNodeForClassCallNode(currentMethod);\n    if (analyzedMethods.contains(analyzeableEntry))     continue;\n    r.addAll(determineIntraInterMethodPairs(analyzeableEntry));\n    Set<ClassCallNode> parents=ccfg.getCcg().getParents(currentMethod);\n    for (    ClassCallNode parent : parents) {\n      if (toAnalyze.contains(parent))       continue;\n      if (analyzedMethods.contains(ccfg.getMethodEntryNodeForClassCallNode(parent)))       continue;\n      Set<ClassCallNode> parentsChildren=ccfg.getCcg().getChildren(parent);\n      boolean canAnalyzeNow=true;\n      for (      ClassCallNode parentsChild : parentsChildren) {\n        if (parentsChild == null)         continue;\n        if (!parentsChild.equals(parent) && !(toAnalyze.contains(parentsChild) || analyzedMethods.contains(ccfg.getMethodEntryNodeForClassCallNode(parentsChild)))) {\n          canAnalyzeNow=false;\n          break;\n        }\n      }\n      if (canAnalyzeNow) {\n        toAnalyze.offer(parent);\n      }\n    }\n  }\n  return r;\n}\n", "nl": "Checks if there are methods in the CCG that dont call any other methods except for maybe itself. For these we can predetermine free uses and activeDefs prior to looking for inter_method_pairs. After that we can even repeat this process for methods we now have determined free uses and activeDefs! that way you can save a lot of computation. Map activeDefs and freeUses according to the variable so you can easily determine which defs will be active and which uses are free once you encounter a methodCall to that method without looking at its part of the CCFG"}
{"code": "public SimpleProjectDescription createSimpleProjectDescription(){\n  SimpleProjectDescriptionImpl simpleProjectDescription=new SimpleProjectDescriptionImpl();\n  return simpleProjectDescription;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void writeAll(){\n  for (int row=0; row < _numRows; row++) {\n    writeState[row]=WRITE;\n  }\n  issueNextOperation();\n}\n", "nl": "Start writing all rows out"}
{"code": "public String str(){\n  return (m_obj != null) ? m_obj.toString() : \"\";\n}\n", "nl": "Cast result object to a string."}
{"code": "public int checkThreadIDAllow0(int uid){\n  if (uid == 0) {\n    uid=currentThread.uid;\n  }\n  if (!threadMap.containsKey(uid)) {\n    log.warn(String.format(\"checkThreadID not found thread 0x%08X\",uid));\n    throw new SceKernelErrorException(ERROR_KERNEL_NOT_FOUND_THREAD);\n  }\n  if (!SceUidManager.checkUidPurpose(uid,\"ThreadMan-thread\",true)) {\n    throw new SceKernelErrorException(ERROR_KERNEL_NOT_FOUND_THREAD);\n  }\n  return uid;\n}\n", "nl": "Check the validity of the thread UID. Allow uid=0."}
{"code": "public boolean isPowerOfThreeB(int n){\n  return n > 0 && maxPow3 % n == 0;\n}\n", "nl": "Find the max power of 3 within int range. It should be divisible by all power of 3s."}
{"code": "protected void addDefinitionRef(Element defRef){\n  String ref=defRef.getAttributeNS(null,XBL_REF_ATTRIBUTE);\n  Element e=ctx.getReferencedElement(defRef,ref);\n  if (!XBL_NAMESPACE_URI.equals(e.getNamespaceURI()) || !XBL_DEFINITION_TAG.equals(e.getLocalName())) {\n    throw new BridgeException(ctx,defRef,ErrorConstants.ERR_URI_BAD_TARGET,new Object[]{ref});\n  }\n  ImportRecord ir=new ImportRecord(defRef,e);\n  imports.put(defRef,ir);\n  NodeEventTarget et=(NodeEventTarget)defRef;\n  et.addEventListenerNS(XMLConstants.XML_EVENTS_NAMESPACE_URI,\"DOMAttrModified\",refAttrListener,false,null);\n  XBLOMDefinitionElement d=(XBLOMDefinitionElement)defRef;\n  String ns=d.getElementNamespaceURI();\n  String ln=d.getElementLocalName();\n  addDefinition(ns,ln,(XBLOMDefinitionElement)e,defRef);\n}\n", "nl": "Adds a definition through its referring definition element (one with a 'ref' attribute)."}
{"code": "public ActiveMQRATopicSubscriber(final TopicSubscriber consumer,final ActiveMQRASession session){\n  super(consumer,session);\n  if (ActiveMQRATopicSubscriber.trace) {\n    ActiveMQRALogger.LOGGER.trace(\"constructor(\" + consumer + \", \"+ session+ \")\");\n  }\n}\n", "nl": "Create a new wrapper"}
{"code": "private void fieldInsn(final int opcode,final Type ownerType,final String name,final Type fieldType){\n  mv.visitFieldInsn(opcode,ownerType.getInternalName(),name,fieldType.getDescriptor());\n}\n", "nl": "Generates a get field or set field instruction."}
{"code": "@Override public void doFrame(long frameTimeNanos){\n  if (isPaused.get()) {\n    return;\n  }\n  long frameTimeMillis=frameTimeNanos / 1000000;\n  WritableArray timersToCall=null;\nsynchronized (mTimerGuard) {\n    while (!mTimers.isEmpty() && mTimers.peek().mTargetTime < frameTimeMillis) {\n      Timer timer=mTimers.poll();\n      if (timersToCall == null) {\n        timersToCall=Arguments.createArray();\n      }\n      timersToCall.pushInt(timer.mCallbackID);\n      if (timer.mRepeat) {\n        timer.mTargetTime=frameTimeMillis + timer.mInterval;\n        mTimers.add(timer);\n      }\n else {\n        mTimerIdsToTimers.remove(timer.mCallbackID);\n      }\n    }\n  }\n  if (timersToCall != null) {\n    Assertions.assertNotNull(mJSTimersModule).callTimers(timersToCall);\n  }\n  Assertions.assertNotNull(mReactChoreographer).postFrameCallback(ReactChoreographer.CallbackType.TIMERS_EVENTS,this);\n}\n", "nl": "Calls all timers that have expired since the last time this frame callback was called."}
{"code": "protected void executeLogoutCommand(){\n  shoppingCartCommandFactory.execute(ShoppingCartCommand.CMD_LOGIN,cartMixin.getCurrentCart(),new HashMap<String,Object>(){\n{\n      put(ShoppingCartCommand.CMD_LOGOUT,ShoppingCartCommand.CMD_LOGOUT);\n    }\n  }\n);\n}\n", "nl": "Execute logout command."}
{"code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (obj instanceof CharSet == false) {\n    return false;\n  }\n  CharSet other=(CharSet)obj;\n  return set.equals(other.set);\n}\n", "nl": "<p>Compares two CharSet objects, returning true if they represent exactly the same set of characters defined in the same way.</p> <p>The two sets <code>abc</code> and <code>a-c</code> are <i>not</i> equal according to this method.</p>"}
{"code": "private PlatformUtils(){\n}\n", "nl": "Creates a new PlatformUtils object."}
{"code": "@Override @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED) public InstanceStatus deleteInstance(String instanceId,ProvisioningSettings settings) throws APPlatformException {\n  PropertyHandler paramHandler=new PropertyHandler(settings);\n  paramHandler.setState(Status.DELETION_REQUESTED);\n  InstanceStatus result=new InstanceStatus();\n  result.setChangedParameters(settings.getParameters());\n  return result;\n}\n", "nl": "Starts the deletion of an application instance. <p> The internal status <code>DELETION_REQUESTED</code> is stored as a controller configuration setting. It is evaluated and handled by the status dispatcher, which is invoked at regular intervals by APP through the <code>getInstanceStatus</code> method."}
{"code": "public boolean isOnline(){\n  Object oo=get_Value(COLUMNNAME_IsOnline);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Online Access."}
{"code": "public EditSensorsAction(final VisionWorld visionWorld){\n  super(\"Edit selected sensor(s)...\");\n  if (visionWorld == null) {\n    throw new IllegalArgumentException(\"visionWorld must not be null\");\n  }\n  this.visionWorld=visionWorld;\n  this.visionWorld.getSensorSelectionModel().addSensorSelectionListener(new SelectionListener());\n}\n", "nl": "Create a new edit sensors action."}
{"code": "@Override public final V replace(K key,V value){\n  long hash, allocIndex;\n  Segment<K,V> segment;\n  V oldValue;\n  if ((allocIndex=(segment=segment(segmentIndex(hash=keyHashCode(key)))).find(this,hash,key)) > 0) {\n    oldValue=segment.readValue(allocIndex);\n    segment.writeValue(allocIndex,value);\n    return oldValue;\n  }\n  return null;\n}\n", "nl": "Replaces the entry for the specified key only if it is currently mapped to some value."}
{"code": "public UserResource user(){\n  return user;\n}\n", "nl": "Get the subresource containing all of the commands related to a tenant's users."}
{"code": "private boolean isExportable(Step step){\n  return Exporter.class.getResource(String.format(\"/edu/wpi/grip/ui/codegeneration/%s/operations/%s.vm\",lang.filePath,step.getOperationDescription().name().replace(' ','_'))) != null;\n}\n", "nl": "Checks if a step is exportable to this exporter's language."}
{"code": "public static List<Long> view(long[] array,int length){\n  return new LongList(array,length);\n}\n", "nl": "Creates and returns a view of the given long array that  requires only a small object allocation."}
{"code": "final public MutableString insert(final int index,final Object o){\n  return insert(index,String.valueOf(o));\n}\n", "nl": "Inserts the string representation of an object in this mutable string, starting from index <code>index</code>."}
{"code": "public boolean checkAttributeValuesChanged(BlockVirtualPoolUpdateParam param,VirtualPool vpool){\n  return super.checkAttributeValuesChanged(param,vpool) || checkPathParameterModified(vpool.getNumPaths(),param.getMaxPaths()) || checkPathParameterModified(vpool.getMinPaths(),param.getMinPaths())|| checkPathParameterModified(vpool.getPathsPerInitiator(),param.getPathsPerInitiator())|| checkPathParameterModified(vpool.getHostIOLimitBandwidth(),param.getHostIOLimitBandwidth())|| checkPathParameterModified(vpool.getHostIOLimitIOPs(),param.getHostIOLimitIOPs())|| VirtualPoolUtil.checkRaidLevelsChanged(vpool.getArrayInfo(),param.getRaidLevelChanges())|| VirtualPoolUtil.checkForVirtualPoolAttributeModification(vpool.getDriveType(),param.getDriveType())|| VirtualPoolUtil.checkThinVolumePreAllocationChanged(vpool.getThinVolumePreAllocationPercentage(),param.getThinVolumePreAllocationPercentage())|| VirtualPoolUtil.checkProtectionChanged(vpool,param.getProtection())|| VirtualPoolUtil.checkHighAvailabilityChanged(vpool,param.getHighAvailability());\n}\n", "nl": "Check if any VirtualPool attribute values have changed."}
{"code": "@Override public Boolean visitIntersection_Intersection(final AnnotatedIntersectionType type1,final AnnotatedIntersectionType type2,final VisitHistory visited){\n  if (!arePrimeAnnosEqual(type1,type2)) {\n    return false;\n  }\n  visited.add(type1,type2);\n  return areAllEqual(type1.directSuperTypes(),type2.directSuperTypes(),visited);\n}\n", "nl": "//TODO: SHOULD PRIMARY ANNOTATIONS OVERRIDE INDIVIDUAL BOUND ANNOTATIONS? //TODO: IF SO THEN WE SHOULD REMOVE THE arePrimeAnnosEqual AND FIX AnnotatedIntersectionType Two intersection types are equal if: 1) Their sets of primary annotations are equal 2) Their sets of bounds (the types being intersected) are equal"}
{"code": "public void writeEnum(final int fieldNumber,final int value) throws IOException {\n  writeTag(fieldNumber,WireFormat.WIRETYPE_VARINT);\n  writeEnumNoTag(value);\n}\n", "nl": "Write an enum field, including tag, to the stream.  Caller is responsible for converting the enum value to its numeric value."}
{"code": "@Override protected char[] escape(int cp){\n  if (cp < safeOctets.length && safeOctets[cp]) {\n    return null;\n  }\n else   if (cp == ' ' && plusForSpace) {\n    return PLUS_SIGN;\n  }\n else   if (cp <= 0x7F) {\n    char[] dest=new char[3];\n    dest[0]='%';\n    dest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n    dest[1]=UPPER_HEX_DIGITS[cp >>> 4];\n    return dest;\n  }\n else   if (cp <= 0x7ff) {\n    char[] dest=new char[6];\n    dest[0]='%';\n    dest[3]='%';\n    dest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[1]=UPPER_HEX_DIGITS[0xC | cp];\n    return dest;\n  }\n else   if (cp <= 0xffff) {\n    char[] dest=new char[9];\n    dest[0]='%';\n    dest[1]='E';\n    dest[3]='%';\n    dest[6]='%';\n    dest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[2]=UPPER_HEX_DIGITS[cp];\n    return dest;\n  }\n else   if (cp <= 0x10ffff) {\n    char[] dest=new char[12];\n    dest[0]='%';\n    dest[1]='F';\n    dest[3]='%';\n    dest[6]='%';\n    dest[9]='%';\n    dest[11]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[10]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n    cp>>>=4;\n    dest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp>>>=2;\n    dest[2]=UPPER_HEX_DIGITS[cp & 0x7];\n    return dest;\n  }\n else {\n    throw new IllegalArgumentException(\"Invalid unicode character value \" + cp);\n  }\n}\n", "nl": "Escapes the given Unicode code point in UTF-8."}
{"code": "public X509CRLImpl(InputStream inStrm) throws CRLException {\n  try {\n    parse(new DerValue(inStrm));\n  }\n catch (  IOException e) {\n    signedCRL=null;\n    throw new CRLException(\"Parsing error: \" + e.getMessage());\n  }\n}\n", "nl": "Unmarshals an X.509 CRL from an input stream. Only one CRL is expected at the end of the input stream."}
{"code": "protected boolean removeTurntable(LayoutTurntable o){\n  if (!noWarnTurntable) {\n    int selectedValue=JOptionPane.showOptionDialog(this,rb.getString(\"Question4r\"),Bundle.getMessage(\"WarningTitle\"),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,new Object[]{Bundle.getMessage(\"ButtonYes\"),Bundle.getMessage(\"ButtonNo\"),rb.getString(\"ButtonYesPlus\")},Bundle.getMessage(\"ButtonNo\"));\n    if (selectedValue == 1) {\n      return (false);\n    }\n    if (selectedValue == 2) {\n      noWarnTurntable=true;\n    }\n  }\n  if (selectedObject == o) {\n    selectedObject=null;\n  }\n  if (prevSelectedObject == o) {\n    prevSelectedObject=null;\n  }\n  for (int j=0; j < o.getNumberRays(); j++) {\n    TrackSegment t=o.getRayConnectOrdered(j);\n    if (t != null) {\n      substituteAnchor(o.getRayCoordsIndexed(j),o,t);\n    }\n  }\n  for (int i=0; i < turntableList.size(); i++) {\n    LayoutTurntable lx=turntableList.get(i);\n    if (lx == o) {\n      turntableList.remove(i);\n      o.remove();\n      setDirty(true);\n      repaint();\n      return (true);\n    }\n  }\n  return (false);\n}\n", "nl": "Remove a Layout Turntable"}
{"code": "protected void emptyTag(Element elem) throws BadLocationException, IOException {\n  if (!inContent && !inPre) {\n    indentSmart();\n  }\n  AttributeSet attr=elem.getAttributes();\n  closeOutUnwantedEmbeddedTags(attr);\n  writeEmbeddedTags(attr);\n  if (matchNameAttribute(attr,HTML.Tag.CONTENT)) {\n    inContent=true;\n    text(elem);\n  }\n else   if (matchNameAttribute(attr,HTML.Tag.COMMENT)) {\n    comment(elem);\n  }\n else {\n    boolean isBlock=isBlockTag(elem.getAttributes());\n    if (inContent && isBlock) {\n      writeLineSeparator();\n      indentSmart();\n    }\n    Object nameTag=(attr != null) ? attr.getAttribute(StyleConstants.NameAttribute) : null;\n    Object endTag=(attr != null) ? attr.getAttribute(HTML.Attribute.ENDTAG) : null;\n    boolean outputEndTag=false;\n    if (nameTag != null && endTag != null && (endTag instanceof String) && endTag.equals(\"true\")) {\n      outputEndTag=true;\n    }\n    if (completeDoc && matchNameAttribute(attr,HTML.Tag.HEAD)) {\n      if (outputEndTag) {\n        writeStyles(((HTMLDocument)getDocument()).getStyleSheet());\n      }\n      wroteHead=true;\n    }\n    write('<');\n    if (outputEndTag) {\n      write('/');\n    }\n    write(elem.getName());\n    writeAttributes(attr);\n    write('>');\n    if (matchNameAttribute(attr,HTML.Tag.TITLE) && !outputEndTag) {\n      Document doc=elem.getDocument();\n      String title=(String)doc.getProperty(Document.TitleProperty);\n      write(title);\n    }\n else     if (!inContent || isBlock) {\n      writeLineSeparator();\n      if (isBlock && inContent) {\n        indentSmart();\n      }\n    }\n  }\n}\n", "nl": "Writes out all empty elements (all tags that have no corresponding end tag)."}
{"code": "public boolean isPending(){\n  return getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING;\n}\n", "nl": "Convenience wrapper around getConfidence().getConfidenceType()"}
{"code": "public final void fireSensorMatrixChanged(final SensorMatrix oldSensorMatrix,final SensorMatrix sensorMatrix){\n  if (oldSensorMatrix == null) {\n    throw new IllegalArgumentException(\"oldSensorMatrix must not be null\");\n  }\n  if (sensorMatrix == null) {\n    throw new IllegalArgumentException(\"sensorMatrix must not be null\");\n  }\n  Object[] listeners=listenerList.getListenerList();\n  VisionWorldModelEvent event=null;\n  for (int i=listeners.length - 2; i >= 0; i-=2) {\n    if (listeners[i] == VisionWorldModelListener.class) {\n      if (event == null) {\n        event=new VisionWorldModelEvent(source,oldSensorMatrix,sensorMatrix);\n      }\n      ((VisionWorldModelListener)listeners[i + 1]).sensorMatrixChanged(event);\n    }\n  }\n}\n", "nl": "Fire a sensor matrix changed event to all registered vision world model listeners."}
{"code": "public DNameConstraints(JDialog parent){\n  super(parent);\n  setTitle(res.getString(\"DNameConstraints.Title\"));\n  initComponents();\n}\n", "nl": "Creates a new DNameConstraints dialog."}
{"code": "@Override public void visit(NodeVisitor v){\n  v.visit(this);\n}\n", "nl": "Visits this node.  There are no children."}
{"code": "@Override public void LDC(int x){\n  env.topFrame().operandStack.pushBv32(ExpressionFactory.buildNewIntegerConstant(x));\n}\n", "nl": "Bytecode instruction stream: ... ,0x12, index, ... <p> Push corresponding symbolic constant from constant pool (at index) onto the operand stack. http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2. doc8.html#ldc"}
{"code": "@SuppressWarnings(\"unused\") private SentenceFilteredTrie filter_regexp(Trie unfilteredTrie){\n  SentenceFilteredTrie trie=null;\n  if (unfilteredTrie.hasRules())   if (matchesSentence(unfilteredTrie))   trie=new SentenceFilteredTrie(unfilteredTrie);\n else   return null;\n  if (unfilteredTrie.hasExtensions())   for (  Entry<Integer,? extends Trie> arc : unfilteredTrie.getChildren().entrySet()) {\n    Trie unfilteredChildTrie=arc.getValue();\n    SentenceFilteredTrie nextTrie=filter_regexp(unfilteredChildTrie);\n    if (nextTrie != null) {\n      if (trie == null)       trie=new SentenceFilteredTrie(unfilteredTrie);\n      trie.children.put(arc.getKey(),nextTrie);\n    }\n  }\n  return trie;\n}\n", "nl": "Alternate filter that uses regular expressions, walking the grammar trie and matching the source side of each rule collection against the input sentence. Failed matches are discarded, and trie nodes extending from that position need not be explored."}
{"code": "protected void engineUpdate(byte input){\n  if (first == true) {\n    md.update(k_ipad);\n    first=false;\n  }\n  md.update(input);\n}\n", "nl": "Processes the given byte."}
{"code": "@Override public void configureZone(final StendhalRPZone zone,final Map<String,String> attributes){\n  buildAdosGreetingSoldier(zone);\n}\n", "nl": "Configure a zone."}
{"code": "public static KerberosTime parse(DerInputStream data,byte explicitTag,boolean optional) throws Asn1Exception, IOException {\n  if ((optional) && (((byte)data.peekByte() & (byte)0x1F) != explicitTag))   return null;\n  DerValue der=data.getDerValue();\n  if (explicitTag != (der.getTag() & (byte)0x1F)) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n else {\n    DerValue subDer=der.getData().getDerValue();\n    Date temp=subDer.getGeneralizedTime();\n    return new KerberosTime(temp.getTime(),0);\n  }\n}\n", "nl": "Parse (unmarshal) a kerberostime from a DER input stream.  This form parsing might be used when expanding a value which is part of a constructed sequence and uses explicitly tagged type."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:02:38.770 -0500\",hash_original_method=\"C464D16A28A9DCABA3B0B8FD02F52155\",hash_generated_method=\"0A183B7841054C14E915336FD1A0DC9E\") public static boolean hasExtension(String extension){\n  if (extension == null || extension.isEmpty()) {\n    return false;\n  }\n  return extensionToMimeTypeMap.containsKey(extension);\n}\n", "nl": "Returns true if the given extension has a registered MIME type."}
{"code": "public void testExhaustContentSource() throws Exception {\n  String algLines[]={\"# ----- properties \",\"content.source=org.apache.lucene.benchmark.byTask.feeds.SingleDocSource\",\"content.source.log.step=1\",\"doc.term.vector=false\",\"content.source.forever=false\",\"directory=RAMDirectory\",\"doc.stored=false\",\"doc.tokenized=false\",\"# ----- alg \",\"CreateIndex\",\"{ AddDoc } : * \",\"ForceMerge(1)\",\"CloseIndex\",\"OpenReader\",\"{ CountingSearchTest } : 100\",\"CloseReader\",\"[ CountingSearchTest > : 30\",\"[ CountingSearchTest > : 9\"};\n  CountingSearchTestTask.numSearches=0;\n  Benchmark benchmark=execBenchmark(algLines);\n  assertEquals(\"TestSearchTask was supposed to be called!\",139,CountingSearchTestTask.numSearches);\n  assertTrue(\"Index does not exist?...!\",DirectoryReader.indexExists(benchmark.getRunData().getDirectory()));\n  IndexWriter iw=new IndexWriter(benchmark.getRunData().getDirectory(),new IndexWriterConfig(new MockAnalyzer(random())).setOpenMode(OpenMode.APPEND));\n  iw.close();\n  IndexReader ir=DirectoryReader.open(benchmark.getRunData().getDirectory());\n  assertEquals(\"1 docs were added to the index, this is what we expect to find!\",1,ir.numDocs());\n  ir.close();\n}\n", "nl": "Test Exhasting Doc Maker logic"}
{"code": "@DSSource({DSSourceKind.NETWORK}) @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:10.723 -0500\",hash_original_method=\"8EB7107FA2367D701AF7CBC234A81F19\",hash_generated_method=\"B23ED7B4CA5FBA5E6343C71EA6EDB1E4\") public String toString(){\n  StringBuffer header=new StringBuffer();\n  header.append(\"From: \");\n  header.append(__from);\n  header.append(\"\\nNewsgroups: \");\n  header.append(__newsgroups.toString());\n  header.append(\"\\nSubject: \");\n  header.append(__subject);\n  header.append('\\n');\n  if (__headerFields.length() > 0)   header.append(__headerFields.toString());\n  header.append('\\n');\n  return header.toString();\n}\n", "nl": "Converts the SimpleNNTPHeader to a properly formatted header in the form of a String, including the blank line used to separate the header from the article body. <p>"}
{"code": "private void sincronizarBase(){\n  listaOrganizacao=ControleDAO.getBanco().getOrganizacaoDAO().listar();\n}\n", "nl": "Sincronizar dados com banco de dados"}
{"code": "protected int newlines(char[] text){\n  int result=0;\n  for (int i=0; i < text.length; i++) {\n    if (text[i] == 10) {\n      result++;\n    }\n  }\n  return result;\n}\n", "nl": "Returns the number of newlines in the given char array."}
{"code": "protected BinaryBitmap toBitmap(LuminanceSource source){\n  return new BinaryBitmap(new HybridBinarizer(source));\n}\n", "nl": "Given an image source, convert to a binary bitmap. Override this to use a custom binarizer."}
{"code": "protected void handleMergeException(Directory dir,Throwable exc){\n  throw new MergePolicy.MergeException(exc,dir);\n}\n", "nl": "Called when an exception is hit in a background merge thread"}
{"code": "public FactoryDto merge(FactoryDto factory,ProjectConfigDto computedProjectConfig){\n  final List<ProjectConfigDto> projects=factory.getWorkspace().getProjects();\n  if (projects == null || projects.isEmpty()) {\n    factory.getWorkspace().setProjects(singletonList(computedProjectConfig));\n    return factory;\n  }\n  if (projects.size() == 1) {\n    ProjectConfigDto projectConfig=projects.get(0);\n    if (projectConfig.getSource() == null)     projectConfig.setSource(computedProjectConfig.getSource());\n  }\n  return factory;\n}\n", "nl": "Apply the merging of project config dto including source storage dto into the existing factory <p> here are the following rules <ul> <li>no projects --> add whole project</li> <li>if projects <ul> <li>: if there is only one project: add source if missing</li> <li> if many projects: do nothing</li> </ul></li> </ul>"}
{"code": "public StatusLine parseSIPStatusLine(String statusLine) throws ParseException {\n  statusLine+=\"\\n\";\n  return new StatusLineParser(statusLine).parse();\n}\n", "nl": "Parse the SIP Response message status line"}
{"code": "public void initQuitAction(QuitAction quitAction){\n  if (quitAction == null)   throw new IllegalArgumentException(\"quitAction is null\");\n  if (this.quitAction != null)   throw new IllegalArgumentException(\"The method is once-call.\");\n  this.quitAction=quitAction;\n}\n", "nl": "Set the action to call from quit()."}
{"code": "public static boolean isFileStoragePool(StoragePool storagePool,DbClient dbClient){\n  URI storageSystemUri=storagePool.getStorageDevice();\n  StorageSystem storageSystem=dbClient.queryObject(StorageSystem.class,storageSystemUri);\n  ArgValidator.checkEntity(storageSystem,storageSystemUri,false);\n  StorageSystem.Type storageSystemType=StorageSystem.Type.valueOf(storageSystem.getSystemType());\n  return (storageSystemType.equals(StorageSystem.Type.isilon) || storageSystemType.equals(StorageSystem.Type.vnxfile));\n}\n", "nl": "Finds if a pool is file storage pool"}
{"code": "public static Object invokeStatic(String clazz,String methodName,Class[] types,Object[] values,Object defaultValue){\n  try {\n    return invokeStatic(Class.forName(clazz),methodName,types,values);\n  }\n catch (  ClassNotFoundException e) {\n    return defaultValue;\n  }\ncatch (  NoSuchMethodException e) {\n    return defaultValue;\n  }\n}\n", "nl": "Invokes the specified parameterless method if it exists."}
{"code": "String internalsprintf(double s) throws IllegalArgumentException {\n  String s2=\"\";\nswitch (conversionCharacter) {\ncase 'f':\n    s2=printFFormat(s);\n  break;\ncase 'E':\ncase 'e':\ns2=printEFormat(s);\nbreak;\ncase 'G':\ncase 'g':\ns2=printGFormat(s);\nbreak;\ndefault :\nthrow new IllegalArgumentException(\"Cannot \" + \"format a double with a format using a \" + conversionCharacter + \" conversion character.\");\n}\nreturn s2;\n}\n", "nl": "Format a double argument using this conversion specification."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase N4mfPackage.MODULE_FILTER__MODULE_SPECIFIERS:\n    return ((InternalEList<?>)getModuleSpecifiers()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean hasUiObjectExpression(){\n  return !StringUtils.isEmpty(getUiObjectExpression);\n}\n", "nl": "If this databinding reference an ui element that is not the widget bound to this binding,  then an expression is used to retrieve the target ui element"}
{"code": "public void restore(){\n  try {\n    if (inCurrentStorage)     currentStorage.insertElementSafe(element);\n else     currentStorage.removeElement(element);\n    if (inApiStorage)     apiStorage.insertElementSafe(element);\n else     apiStorage.removeElement(element);\n  }\n catch (  StorageException e) {\n    e.printStackTrace();\n  }\n  element.osmId=osmId;\n  element.osmVersion=osmVersion;\n  element.state=state;\n  element.setTags(tags);\n  if (parentRelations != null) {\n    element.parentRelations=new ArrayList<Relation>();\n    element.parentRelations.addAll(parentRelations);\n  }\n else {\n    element.parentRelations=null;\n  }\n}\n", "nl": "Restores the saved state of the element"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:00.382 -0500\",hash_original_method=\"A7CC818E7F384DAEC54D76069E9C5019\",hash_generated_method=\"E8FCEBA0D995DB6EE22CA1B5390C8697\") protected int available() throws IOException {\n  return getInputStream().available();\n}\n", "nl": "Returns the number of bytes available for reading without blocking."}
{"code": "public boolean isOverwriteMode(){\n  return hexEditControl == null || hexEditControl.isOverwriteMode();\n}\n", "nl": "Tells whether the input is in overwrite or insert mode"}
{"code": "public String[] loadStrings(String filename){\n  InputStream is=createInput(filename);\n  if (is != null)   return loadStrings(is);\n  System.err.println(\"The file \\\"\" + filename + \"\\\" \"+ \"is missing or inaccessible, make sure \"+ \"the URL is valid or that the file has been \"+ \"added to your sketch and is readable.\");\n  return null;\n}\n", "nl": "Load data from a file and shove it into a String array. <p/> Exceptions are handled internally, when an error, occurs, an exception is printed to the console and 'null' is returned, but the program continues running. This is a tradeoff between 1) showing the user that there was a problem but 2) not requiring that all i/o code is contained in try/catch blocks, for the sake of new users (or people who are just trying to get things done in a \"scripting\" fashion. If you want to handle exceptions, use Java methods for I/O."}
{"code": "private Iterable<Field> fieldsWithAnnotation(Class<?> cls){\nsynchronized (mux) {\n    List<Field> fields=fieldCache.get(cls);\n    if (fields == null) {\n      fields=new ArrayList<>();\n      for (      Field field : cls.getDeclaredFields()) {\n        Annotation ann=field.getAnnotation(annCls);\n        if (ann != null || needsRecursion(field))         fields.add(field);\n      }\n      if (!fields.isEmpty())       fieldCache.put(cls,fields);\n    }\n    return fields;\n  }\n}\n", "nl": "Gets all entries from the specified class or its super-classes that have been annotated with annotation provided."}
{"code": "public Resource mapRelations(Resource object,JSONObject jsonObject,List<Resource> included) throws Exception {\n  HashMap<String,String> relationshipNames=getRelationshipNames(object.getClass());\n  for (  String relationship : relationshipNames.keySet()) {\n    JSONObject relationJsonObject=null;\n    try {\n      relationJsonObject=jsonObject.getJSONObject(relationship);\n    }\n catch (    JSONException e) {\n      Logger.debug(\"Relationship named \" + relationship + \"not found in JSON\");\n      continue;\n    }\n    JSONObject relationDataObject=null;\n    try {\n      relationDataObject=relationJsonObject.getJSONObject(\"data\");\n      Resource relationObject=Factory.newObjectFromJSONObject(relationDataObject,null);\n      relationObject=matchIncludedToRelation(relationObject,included);\n      mDeserializer.setField(object,relationshipNames.get(relationship),relationObject);\n    }\n catch (    JSONException e) {\n      Logger.debug(\"JSON relationship does not contain data\");\n    }\n    JSONArray relationDataArray=null;\n    try {\n      relationDataArray=relationJsonObject.getJSONArray(\"data\");\n      List<Resource> relationArray=Factory.newObjectFromJSONArray(relationDataArray,null);\n      relationArray=matchIncludedToRelation(relationArray,included);\n      mDeserializer.setField(object,relationshipNames.get(relationship),relationArray);\n    }\n catch (    JSONException e) {\n      Logger.debug(\"JSON relationship does not contain data\");\n    }\n  }\n  return object;\n}\n", "nl": "Loops through relation JSON array and maps annotated objects."}
{"code": "@Override public void onDestroyView(){\n  mIsWebViewAvailable=false;\n  super.onDestroyView();\n}\n", "nl": "Called when the WebView has been detached from the fragment. The WebView is no longer available after this time."}
{"code": "public void clearMovementData(){\n  pathSprites=new ArrayList<StepSprite>();\n  movementTarget=null;\n  checkFoVHexImageCacheClear();\n  repaint();\n  refreshMoveVectors();\n}\n", "nl": "Clears current movement data from the screen"}
{"code": "public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {\n  EditRoomDeptForm editRoomDeptForm=(EditRoomDeptForm)form;\n  MessageResources rsc=getResources(request);\n  String doit=editRoomDeptForm.getDoit();\n  if (doit != null) {\n    if (doit.equals(rsc.getMessage(\"button.update\"))) {\n      ActionMessages errors=new ActionMessages();\n      errors=editRoomDeptForm.validate(mapping,request);\n      if (errors.size() == 0) {\n        doUpdate(editRoomDeptForm,request);\n        return mapping.findForward(\"showRoomDetail\");\n      }\n else {\n        saveErrors(request,errors);\n      }\n    }\n    if (doit.equals(rsc.getMessage(\"button.returnToRoomDetail\"))) {\n      response.sendRedirect(\"roomDetail.do?id=\" + editRoomDeptForm.getId());\n      return null;\n    }\n    if (doit.equals(rsc.getMessage(\"button.addRoomDept\"))) {\n      if (editRoomDeptForm.getDept() == null || editRoomDeptForm.getDept().length() == 0) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.required\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else       if (editRoomDeptForm.getDepartmentIds().contains(new Long(editRoomDeptForm.getDept()))) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.alreadyPresent\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else {\n        editRoomDeptForm.addDepartment(editRoomDeptForm.getDept());\n      }\n    }\n    if (doit.equals(rsc.getMessage(\"button.removeRoomDept\"))) {\n      if (editRoomDeptForm.getDept() == null || editRoomDeptForm.getDept().length() == 0) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.required\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else       if (!editRoomDeptForm.getDepartmentIds().contains(new Long(editRoomDeptForm.getDept()))) {\n        ActionMessages errors=new ActionMessages();\n        errors.add(\"roomDept\",new ActionMessage(\"errors.notPresent\",\"Department\"));\n        saveErrors(request,errors);\n      }\n else {\n        editRoomDeptForm.removeDepartment(editRoomDeptForm.getDept());\n      }\n    }\n  }\n  Long id=Long.valueOf(request.getParameter(\"id\"));\n  LocationDAO ldao=new LocationDAO();\n  Location location=ldao.get(id);\n  sessionContext.checkPermission(location,Right.RoomEditAvailability);\n  if (doit != null && doit.equals(rsc.getMessage(\"button.modifyRoomDepts\"))) {\n    TreeSet roomDepts=new TreeSet(location.getRoomDepts());\n    for (Iterator i=roomDepts.iterator(); i.hasNext(); ) {\n      RoomDept roomDept=(RoomDept)i.next();\n      editRoomDeptForm.addDepartment(roomDept.getDepartment().getUniqueId().toString());\n    }\n  }\n  boolean timeVertical=CommonValues.VerticalGrid.eq(UserProperty.GridOrientation.get(sessionContext.getUser()));\n  RequiredTimeTable rtt=location.getRoomSharingTable(sessionContext.getUser(),editRoomDeptForm.getDepartmentIds());\n  rtt.getModel().setDefaultSelection(UserProperty.GridSize.get(sessionContext.getUser()));\n  if (doit != null && (doit.equals(rsc.getMessage(\"button.removeRoomDept\")) || doit.equals(rsc.getMessage(\"button.addRoomDept\")))) {\n    rtt.update(request);\n  }\n  editRoomDeptForm.setSharingTable(rtt.print(true,timeVertical));\n  if (location instanceof Room) {\n    Room r=(Room)location;\n    editRoomDeptForm.setName(r.getLabel());\n    editRoomDeptForm.setNonUniv(false);\n  }\n else   if (location instanceof NonUniversityLocation) {\n    NonUniversityLocation nonUnivLocation=(NonUniversityLocation)location;\n    editRoomDeptForm.setName(nonUnivLocation.getName());\n    editRoomDeptForm.setNonUniv(true);\n  }\n else {\n    ActionMessages errors=new ActionMessages();\n    errors.add(\"editRoomDept\",new ActionMessage(\"errors.lookup.notFound\",\"Room Department\"));\n    saveErrors(request,errors);\n  }\n  setupDepartments(editRoomDeptForm,request,location);\n  return mapping.findForward(\"showEditRoomDept\");\n}\n", "nl": "Method execute"}
{"code": "@Override public void execute(MetricTimeSeries timeSeries,FunctionValueMap functionValueMap){\n  if (timeSeries.isEmpty()) {\n    functionValueMap.add(this,false,null);\n    return;\n  }\n  DoubleList points=timeSeries.getValues();\n  double q1=Percentile.evaluate(points,.25);\n  double q3=Percentile.evaluate(points,.75);\n  double threshold=(q3 - q1) * 1.5 + q3;\n  for (int i=0; i < points.size(); i++) {\n    double point=points.get(i);\n    if (point > threshold) {\n      functionValueMap.add(this,true,null);\n      return;\n    }\n  }\n  functionValueMap.add(this,false,null);\n}\n", "nl": "Detects outliers using the default box plot implementation. An outlier every value that is above (q3-q1)*1.5*q3 where qN is the nth percentile"}
{"code": "public DuplicatePrimaryPartitionException(String message){\n  super(message);\n}\n", "nl": "Creates a new <code>DuplicatePrimaryPartitionException</code> with the given detail message."}
{"code": "public void buildFieldTypes(TableDefinition tableDef){\n  ((JPAMTableDefinition)tableDef).buildFieldTypes(getSession());\n}\n", "nl": "INTERNAL: builds the field names based on the type read in from the builder"}
{"code": "public static void clearCache(){\n  softCache=new SoftReference<String[]>(null);\n}\n", "nl": "Clear the cache. This method is used for testing."}
{"code": "public void clear(){\n  oredCriteria.clear();\n  orderByClause=null;\n  distinct=false;\n}\n", "nl": "This method was generated by MyBatis Generator. This method corresponds to the database table activity"}
{"code": "protected void remove(int id){\n  nodes.remove(id);\n}\n", "nl": "Removes the node with the specified identifier from this problem instance."}
{"code": "public void addHaptic(int id){\n  mHapticFeedback.add(id);\n}\n", "nl": "Adds haptic feedback to this utterance."}
{"code": "private void init(){\n  Grid grid=new Grid();\n  appendChild(grid);\n  grid.setWidth(\"100%\");\n  grid.setStyle(\"margin:0; padding:0; position: absolute;\");\n  grid.makeNoStrip();\n  grid.setOddRowSclass(\"even\");\n  Rows rows=new Rows();\n  grid.appendChild(rows);\n  for (int i=0; i < m_goals.length; i++) {\n    Row row=new Row();\n    rows.appendChild(row);\n    row.setWidth(\"100%\");\n    WPerformanceIndicator pi=new WPerformanceIndicator(m_goals[i]);\n    row.appendChild(pi);\n    pi.addEventListener(Events.ON_CLICK,this);\n  }\n}\n", "nl": "Static/Dynamic Init"}
{"code": "public int deleteBack(){\n  int oldBack=getBack();\n  size=size - 1;\n  return oldBack;\n}\n", "nl": "Deletes item from back of the list and returns deleted item."}
{"code": "public boolean isLicensed(){\n  return resourceExists(thresholdFileResource) && resourceExists(overlappingFileResource);\n}\n", "nl": "This method returns true if the threshold and overlap files are present."}
{"code": "protected SimplePhase(String name){\n  super(name);\n}\n", "nl": "Construct a phase given just a name and a global/local ordering scheme."}
{"code": "private void URIUtil(){\n}\n", "nl": "Prevent instance creation."}
{"code": "public synchronized void processResponse(SIPResponse transactionResponse,MessageChannel sourceChannel,SIPDialog dialog){\n  if (getState() == null)   return;\n  if ((TransactionState.COMPLETED == this.getState() || TransactionState.TERMINATED == this.getState()) && transactionResponse.getStatusCode() / 100 == 1) {\n    return;\n  }\n  if (sipStack.isLoggingEnabled()) {\n    sipStack.getStackLogger().logDebug(\"processing \" + transactionResponse.getFirstLine() + \"current state = \"+ getState());\n    sipStack.getStackLogger().logDebug(\"dialog = \" + dialog);\n  }\n  this.lastResponse=transactionResponse;\n  try {\n    if (isInviteTransaction())     inviteClientTransaction(transactionResponse,sourceChannel,dialog);\n else     nonInviteClientTransaction(transactionResponse,sourceChannel,dialog);\n  }\n catch (  IOException ex) {\n    if (sipStack.isLoggingEnabled())     sipStack.getStackLogger().logException(ex);\n    this.setState(TransactionState.TERMINATED);\n    raiseErrorEvent(SIPTransactionErrorEvent.TRANSPORT_ERROR);\n  }\n}\n", "nl": "Process a new response message through this transaction. If necessary, this message will also be passed onto the TU."}
{"code": "public void disable(BluetoothAdapter adapter){\n  int mask=(BluetoothReceiver.STATE_TURNING_OFF_FLAG | BluetoothReceiver.STATE_OFF_FLAG | BluetoothReceiver.SCAN_MODE_NONE_FLAG);\n  long start=-1;\n  BluetoothReceiver receiver=getBluetoothReceiver(mask);\n  int state=adapter.getState();\nswitch (state) {\ncase BluetoothAdapter.STATE_OFF:\n    assertFalse(adapter.isEnabled());\n  removeReceiver(receiver);\nreturn;\ncase BluetoothAdapter.STATE_TURNING_ON:\nassertFalse(adapter.isEnabled());\nstart=System.currentTimeMillis();\nbreak;\ncase BluetoothAdapter.STATE_ON:\nassertTrue(adapter.isEnabled());\nstart=System.currentTimeMillis();\nassertTrue(adapter.disable());\nbreak;\ncase BluetoothAdapter.STATE_TURNING_OFF:\nassertFalse(adapter.isEnabled());\nmask=0;\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"disable() invalid state: state=%d\",state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) {\nstate=adapter.getState();\nif (state == BluetoothAdapter.STATE_OFF && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.isEnabled());\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"disable() completed in %d ms\",(finish - start)));\n}\n else {\nwriteOutput(\"disable() completed\");\n}\nremoveReceiver(receiver);\nreturn;\n}\nsleep(POLL_TIME);\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",state,BluetoothAdapter.STATE_OFF,firedFlags,mask));\n}\n", "nl": "Disables Bluetooth and checks to make sure that Bluetooth was turned off and that the correct actions were broadcast."}
{"code": "public boolean isLocal(){\n  return local;\n}\n", "nl": "Indicates if the ejb referenced is a local ejb."}
{"code": "public PowerDecay(){\n  this(10,0.5);\n}\n", "nl": "Creates a new Power Decay rate"}
{"code": "public Boolean isStorageIORMSupported(){\n  return storageIORMSupported;\n}\n", "nl": "Gets the value of the storageIORMSupported property."}
{"code": "public final byte[] array(){\n  return array;\n}\n", "nl": "Returns the underlying byte array."}
{"code": "public void buildClassifier(Instances D) throws Exception {\n  Random r=new Random(m_seed);\n  if (fastaram) {\n    networks=new ARAMNetworkfast[numberofnetworks];\n  }\n else   if (sparsearam) {\n    networks=new ARAMNetworkSparse[numberofnetworks];\n  }\n else   if (sparsearamH) {\n    networks=new ARAMNetworkSparseV[numberofnetworks];\n  }\n else   if (sparsearamHT) {\n    networks=new ARAMNetworkSparseHT[numberofnetworks];\n  }\n else {\n    networks=new ARAMNetwork[numberofnetworks];\n  }\n  numClasses=D.classIndex();\n  if (tfastaram) {\n    BuildClassifier[] bc=new BuildClassifier[numberofnetworks];\n    for (int i=0; i < numberofnetworks; i++) {\n      List<Integer> list=new ArrayList<Integer>();\n      for (int j=0; j < D.numInstances(); j++) {\n        list.add(j);\n      }\n      java.util.Collections.shuffle(list,r);\n      if (fastaram) {\n        networks[i]=new ARAMNetworkfast();\n      }\n else       if (sparsearam) {\n        networks[i]=new ARAMNetworkSparse();\n      }\n else       if (sparsearamH) {\n        networks[i]=new ARAMNetworkSparseV();\n      }\n else       if (sparsearamHT) {\n        networks[i]=new ARAMNetworkSparseHT();\n      }\n else {\n        networks[i]=new ARAMNetwork();\n      }\n      networks[i].order=list;\n      networks[i].roa=roa;\n      bc[i]=new BuildClassifier(networks[i]);\n      bc[i].setinstances(D);\n      bc[i].start();\n    }\n    for (int i=0; i < numberofnetworks; i++) {\n      bc[i].join();\n      networks[i]=bc[i].m_network;\n      networks[i].learningphase=false;\n    }\n  }\n else {\n    for (int i=0; i < numberofnetworks; i++) {\n      if (fastaram) {\n        networks[i]=new ARAMNetworkfast();\n      }\n else       if (sparsearam) {\n        networks[i]=new ARAMNetworkSparse();\n      }\n else       if (sparsearamH) {\n        networks[i]=new ARAMNetworkSparseV();\n      }\n else       if (sparsearamHT) {\n        networks[i]=new ARAMNetworkSparseHT();\n      }\n else {\n        networks[i]=new ARAMNetwork();\n      }\n      networks[i].roa=roa;\n      networks[i].buildClassifier(D);\n      networks[i].learningphase=false;\n      D.randomize(r);\n    }\n  }\n  dc=new DistributionCalc[numberofnetworks];\n}\n", "nl": "Generates the classifier."}
{"code": "private void startCameraSource(){\n  int code=GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(getApplicationContext());\n  if (code != ConnectionResult.SUCCESS) {\n    Dialog dlg=GoogleApiAvailability.getInstance().getErrorDialog(this,code,RC_HANDLE_GMS);\n    dlg.show();\n  }\n  if (mCameraSource != null) {\n    try {\n      mPreview.start(mCameraSource,mGraphicOverlay);\n    }\n catch (    IOException e) {\n      Log.e(TAG,\"Unable to start camera source.\",e);\n      mCameraSource.release();\n      mCameraSource=null;\n    }\n  }\n}\n", "nl": "Starts or restarts the camera source, if it exists.  If the camera source doesn't exist yet (e.g., because onResume was called before the camera source was created), this will be called again when the camera source is created."}
{"code": "public Timezone(String text){\n  this(null,text);\n}\n", "nl": "Creates a timezone property."}
{"code": "public static <K,V>V putAt(Map<K,V> self,K key,V value){\n  self.put(key,value);\n  return value;\n}\n", "nl": "A helper method to allow maps to work with subscript operators"}
{"code": "@Override public String toString(){\n  return toString(\",\");\n}\n", "nl": "Form a string listing all elements with comma as the separator character."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:51.857 -0400\",hash_original_method=\"8DBE36D3CC23C0C9E5FAAD9804EB9F8E\",hash_generated_method=\"B8E268DF01A1D59287B8F2ED5303EAE7\") private void processInput(boolean endOfInput) throws IOException {\n  decoderIn.flip();\n  CoderResult coderResult;\n  while (true) {\n    coderResult=decoder.decode(decoderIn,decoderOut,endOfInput);\n    if (coderResult.isOverflow()) {\n      flushOutput();\n    }\n else     if (coderResult.isUnderflow()) {\n      break;\n    }\n else {\n      throw new IOException(\"Unexpected coder result\");\n    }\n  }\n  decoderIn.compact();\n}\n", "nl": "Decode the contents of the input ByteBuffer into a CharBuffer."}
{"code": "public static float byte52ToFloat(byte b){\n  if (b == 0)   return 0.0f;\n  int bits=(b & 0xff) << (24 - 5);\n  bits+=(63 - 2) << 24;\n  return Float.intBitsToFloat(bits);\n}\n", "nl": "byteToFloat(b, mantissaBits=5, zeroExponent=2)"}
{"code": "private void createAndRegisterObserverProxyLocked(IContentObserver observer){\n  if (mObserver != null) {\n    throw new IllegalStateException(\"an observer is already registered\");\n  }\n  mObserver=new ContentObserverProxy(observer,this);\n  mCursor.registerContentObserver(mObserver);\n}\n", "nl": "Create a ContentObserver from the observer and register it as an observer on the underlying cursor."}
{"code": "public int compressEstim(byte[] src,int srcOff,final int srcLen){\n  if (srcLen < 10)   return srcLen;\n  int stride=LZ4_64K_LIMIT - 1;\n  int segments=(srcLen + stride - 1) / stride;\n  stride=srcLen / segments;\n  if (stride >= LZ4_64K_LIMIT - 1 || stride * segments > srcLen || segments < 1 || stride < 1)   throw new RuntimeException(\"?? \" + srcLen);\n  int bytesIn=0;\n  int bytesOut=0;\n  int len=srcLen;\n  while (len > 0) {\n    if (len > stride)     len=stride;\n    bytesOut+=compress64k(src,srcOff,len);\n    srcOff+=len;\n    bytesIn+=len;\n    len=srcLen - bytesIn;\n  }\n  double ratio=bytesOut / (double)bytesIn;\n  return bytesIn == srcLen ? bytesOut : (int)(ratio * srcLen + 0.5);\n}\n", "nl": "Estimates the length of the compressed bytes, as compressed by Lz4 WARNING: if larger than LZ4_64K_LIMIT it cuts it in fragments WARNING: if some part of the input is discarded, this should return the proportional (so that returnValue/srcLen=compressionRatio)"}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase N4JSPackage.ARRAY_LITERAL__ELEMENTS:\n    return elements != null && !elements.isEmpty();\ncase N4JSPackage.ARRAY_LITERAL__TRAILING_COMMA:\n  return trailingComma != TRAILING_COMMA_EDEFAULT;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public FilterStreamSpecRaw(){\n}\n", "nl": "Default ctor."}
{"code": "void onMenuVisibilityChanged(boolean isVisible){\n  for (int i=0; i < mObservers.size(); ++i) {\n    mObservers.get(i).onMenuVisibilityChanged(isVisible);\n  }\n}\n", "nl": "Called by AppMenu to report that the App Menu visibility has changed."}
{"code": "public void updateDownload(){\n  ArrayList<DownloadInfoRunnable> ongoingDownloads=getOngoingDownloads();\n  if (!ongoingDownloads.isEmpty()) {\n    updateProgress();\n  }\n else {\n    timer.cancel();\n    timer.purge();\n    stopSelf();\n    mBuilder=null;\n    stopForeground(true);\n    isStopped=true;\n  }\n}\n", "nl": "Updates the download list and stops the service if it's empty. If not, updates the progress in the Notification bar"}
{"code": "private int remoteAddPois(List<Poi> pois,String changeSetId){\n  int count=0;\n  for (  Poi poi : pois) {\n    if (remoteAddPoi(poi,changeSetId)) {\n      count++;\n    }\n  }\n  return count;\n}\n", "nl": "Add a List of POIs to the backend."}
{"code": "public CopyOnWriteArraySet(Collection<? extends E> c){\n  al=new CopyOnWriteArrayList<E>();\n  al.addAllAbsent(c);\n}\n", "nl": "Creates a set containing all of the elements of the specified collection."}
{"code": "@Override public void close() throws SQLException {\n  try {\n    super.close();\n  }\n  finally {\n    this.outputLogger.close();\n  }\n}\n", "nl": "This method will close the connection to the output."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:41.688 -0500\",hash_original_method=\"1623111994CBCA0890DA0FF2A1E140E0\",hash_generated_method=\"478ACA79A313929F4EF55B9242DEEF4D\") public boolean isBackToBackUserAgent(){\n  return super.isBackToBackUserAgent;\n}\n", "nl": "Get the \"back to back User Agent\" flag. return the value of the flag"}
{"code": "public EnglishMinimalStemFilterFactory(Map<String,String> args){\n  super(args);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "nl": "Creates a new EnglishMinimalStemFilterFactory"}
{"code": "public AABB(ReadonlyVec3D pos,float extent){\n  super(pos);\n  setExtent(new Vec3D(extent,extent,extent));\n}\n", "nl": "Creates a new instance from centre point and uniform extent in all directions."}
{"code": "public static <T>JavaslangSubscriber<T> subscriber(){\n  return new JavaslangSubscriber<T>();\n}\n", "nl": "A reactive-streams subscriber than can generate Javaslang traversable types"}
{"code": "public SQLNonTransientException(String reason,Throwable cause){\n  super(reason,cause);\n}\n", "nl": "Creates an SQLNonTransientException object. The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object."}
{"code": "public void localTransactionCommitted(ConnectionEvent event){\n}\n", "nl": "Ignored event callback"}
{"code": "protected boolean runAndReset(){\n  if (state != NEW || !UNSAFE.compareAndSwapObject(this,runnerOffset,null,Thread.currentThread()))   return false;\n  boolean ran=false;\n  int s=state;\n  try {\n    Callable<V> c=callable;\n    if (c != null && s == NEW) {\n      try {\n        c.call();\n        ran=true;\n      }\n catch (      Throwable ex) {\n        setException(ex);\n      }\n    }\n  }\n  finally {\n    runner=null;\n    s=state;\n    if (s >= INTERRUPTING)     handlePossibleCancellationInterrupt(s);\n  }\n  return ran && s == NEW;\n}\n", "nl": "Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled.  This is designed for use with tasks that intrinsically execute more than once."}
{"code": "public void addCookie(GoogleCookie cookie){\n  if (cookieManager != null) {\n    cookieManager.addCookie(cookie);\n  }\n}\n", "nl": "Adds a new GoogleCookie instance to the cache."}
{"code": "public void debug(String trace){\n  printTrace(trace,DEBUG_LEVEL);\n}\n", "nl": "Debug trace"}
{"code": "public boolean isAutoIndentEnabled(){\n  return autoIndentEnabled;\n}\n", "nl": "Returns whether or not auto-indent is enabled."}
{"code": "public void disableHardwareLayersForContent(){\n  View widget=getContent();\n  if (widget != null) {\n    widget.setLayerType(LAYER_TYPE_NONE,null);\n  }\n}\n", "nl": "Because this view has fading outlines, it is essential that we enable hardware layers on the content (child) so that updating the alpha of the outlines doesn't result in the content layer being recreated."}
{"code": "public PaymentGatewayDescriptorImpl(final String description,final String label,final String url){\n  super(description,label);\n  this.url=url;\n}\n", "nl": "Construct payment gateway descriptor."}
{"code": "public static Date parseDateLong(String dateString,String pattern) throws ParseException {\n  return getSimplDateFormat(pattern).parse(dateString);\n}\n", "nl": "Returns date parsed from string by given pattern"}
{"code": "public void add(int i,Coordinate coord,boolean allowRepeated){\n  if (!allowRepeated) {\n    int size=size();\n    if (size > 0) {\n      if (i > 0) {\n        Coordinate prev=(Coordinate)get(i - 1);\n        if (prev.equals2D(coord))         return;\n      }\n      if (i < size) {\n        Coordinate next=(Coordinate)get(i);\n        if (next.equals2D(coord))         return;\n      }\n    }\n  }\n  super.add(i,coord);\n}\n", "nl": "Inserts the specified coordinate at the specified position in this list."}
{"code": "private void loadAppThemeDefaults(){\n  TypedValue typedValue=new TypedValue();\n  TypedArray a=getContext().obtainStyledAttributes(typedValue.data,new int[]{R.attr.colorAccent,android.R.attr.textColorPrimary,R.attr.colorControlNormal});\n  dialColor=a.getColor(0,dialColor);\n  textColor=a.getColor(1,textColor);\n  clockColor=a.getColor(2,clockColor);\n  a.recycle();\n}\n", "nl": "Sets default theme attributes for picker These will be used if picker's attributes are'nt set"}
{"code": "public void increaseRefcount(){\n  refcount++;\n}\n", "nl": "Increase number of data points by one."}
{"code": "public static double computePolygonAreaFromVertices(Iterable<? extends Vec4> points){\n  if (points == null) {\n    String message=Logging.getMessage(\"nullValue.IterableIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  java.util.Iterator<? extends Vec4> iter=points.iterator();\n  if (!iter.hasNext()) {\n    return 0;\n  }\n  double area=0;\n  Vec4 firstPoint=iter.next();\n  Vec4 point=firstPoint;\n  while (iter.hasNext()) {\n    Vec4 nextLocation=iter.next();\n    area+=point.x * nextLocation.y;\n    area-=nextLocation.x * point.y;\n    point=nextLocation;\n  }\n  if (!point.equals(firstPoint)) {\n    area+=point.x * firstPoint.y;\n    area-=firstPoint.x * point.y;\n  }\n  area/=2.0;\n  return area;\n}\n", "nl": "Returns the area enclosed by the specified (x, y) points (the z and w coordinates are ignored). If the specified points do not define a closed loop, then the loop is automatically closed by simulating appending the first point to the last point."}
{"code": "public void init(KeyGenerationParameters param){\n  this.params=(NTRUEncryptionKeyGenerationParameters)param;\n}\n", "nl": "Constructs a new instance with a set of encryption parameters."}
{"code": "public static JPanel createDemoPanel(){\n  JFreeChart chart=createChart(createDataset());\n  ChartPanel panel=new ChartPanel(chart,false);\n  panel.setFillZoomRectangle(true);\n  panel.setMouseWheelEnabled(true);\n  return panel;\n}\n", "nl": "Creates a panel for the demo (used by SuperDemo.java)."}
{"code": "public static void deleteVMsOnThisEndpoint(VerificationHost host,boolean isMock,String parentComputeLink,List<String> instanceIdsToDelete) throws Throwable {\n  deleteVMsOnThisEndpoint(host,null,isMock,parentComputeLink,instanceIdsToDelete,null);\n}\n", "nl": "A utility method that deletes the VMs on the specified endpoint filtered by the instanceIds that are passed in."}
{"code": "public boolean isIn(byte i){\n  return (i >= this.min) && (i <= this.max);\n}\n", "nl": "Check if given number is in range."}
{"code": "public void completeAll(){\n  long currentCompleted=completedCount;\n  int size=Math.max(1,actionList.size());\n  while (completedCount - currentCompleted < size) {\n    if (getState() != Thread.State.BLOCKED && getState() != Thread.State.RUNNABLE)     break;\n    try {\n      Thread.sleep(50);\n    }\n catch (    InterruptedException ex) {\n      break;\n    }\n  }\n}\n", "nl": "<p>Complete all scheduled actions at the time of this call. Since other threads may keep adding actions, this method makes sure that only the actions in the queue at the time of the call are waited upon.  </p>"}
{"code": "public String toString(){\n  return image;\n}\n", "nl": "Returns the image."}
{"code": "public KtVisualPanel1(){\n  initComponents();\n}\n", "nl": "Creates new form KtVisualPanel1"}
{"code": "public URI(String p_scheme,String p_schemeSpecificPart) throws MalformedURIException {\n  if (p_scheme == null || p_scheme.trim().length() == 0) {\n    throw new MalformedURIException(\"Cannot construct URI with null/empty scheme!\");\n  }\n  if (p_schemeSpecificPart == null || p_schemeSpecificPart.trim().length() == 0) {\n    throw new MalformedURIException(\"Cannot construct URI with null/empty scheme-specific part!\");\n  }\n  setScheme(p_scheme);\n  setPath(p_schemeSpecificPart);\n}\n", "nl": "Construct a new URI that does not follow the generic URI syntax. Only the scheme and scheme-specific part (stored as the path) are initialized."}
{"code": "public boolean isDoingRangedAttack(){\n  return isDoingRangedAttack;\n}\n", "nl": "Check if the currently performed attack is ranged."}
{"code": "public SdfReaderWrapper(File sdfDir,boolean useMem,boolean checkConsistency) throws IOException {\n  mIsPaired=ReaderUtils.isPairedEndDirectory(sdfDir);\n  if (mIsPaired) {\n    mSingle=null;\n    mLeft=createSequencesReader(ReaderUtils.getLeftEnd(sdfDir),useMem);\n    mRight=createSequencesReader(ReaderUtils.getRightEnd(sdfDir),useMem);\n    if (checkConsistency) {\n      if (mLeft.numberSequences() != mRight.numberSequences() || !mLeft.type().equals(mRight.type()) || mLeft.hasQualityData() != mRight.hasQualityData() || mLeft.hasNames() != mRight.hasNames()) {\n        throw new NoTalkbackSlimException(ErrorType.INFO_ERROR,\"Paired end SDF has inconsistencies between arms.\");\n      }\n    }\n  }\n else {\n    mLeft=null;\n    mRight=null;\n    mSingle=createSequencesReader(sdfDir,useMem);\n  }\n}\n", "nl": "Wrapper for the readers."}
{"code": "public DefaultRenderStack(){\n  stack=new ArrayDeque<>();\n}\n", "nl": "Constructs the stack."}
{"code": "public void onLocationChanged(Location location){\n  if (location == null) {\n    return;\n  }\n  float distance=getDistanceFromNetwork(location);\n  mTrackerData.writeEntry(location,distance);\n}\n", "nl": "Writes details of location update to tracking file, including recording the distance between this location update and the last network location update"}
{"code": "public static File secondaryIndexFileName(File data){\n  final int extensionIndex=data.getName().lastIndexOf('.');\n  if (extensionIndex != -1) {\n    return new File(data.getParentFile(),data.getName().substring(0,extensionIndex) + BamIndexer.BAM_INDEX_EXTENSION);\n  }\n  return indexFileName(data);\n}\n", "nl": "Get the secondary possible name for an index to have for a given data file (Will return same as indexFileName if there is no file extension)"}
{"code": "private void cancelOrder(Contract contract,TradeOrder order) throws IOException {\n  OrderState orderState=new OrderState();\n  orderState.m_status=OrderStatus.CANCELLED;\n  this.brokerModel.openOrder(order.getOrderKey(),contract,order,orderState);\n  order.setStatus(OrderStatus.CANCELLED);\n}\n", "nl": "Method cancelOrder."}
{"code": "private TempTripleStore(final TemporaryStore store,final Properties properties){\n  this(store,UUID.randomUUID() + \"kb\",ITx.UNISOLATED,properties);\n}\n", "nl": "Note: This is here just to make it easy to have the reference to the [store] and its [uuid] when we create one in the calling ctor."}
{"code": "public static <T>T[] newSameSize(List<?> list,Class<T> cpType){\n  if (list == null)   return create(cpType,0);\n else   return create(cpType,list.size());\n}\n", "nl": "Creates an array with the same size as the given list. If the list is null, a zero-length array is created."}
{"code": "public void addPaintListener(PaintListener pl){\n  if (m_painters == null) {\n    m_painters=new CopyOnWriteArrayList();\n  }\n  m_painters.add(pl);\n}\n", "nl": "Add a PaintListener to this Display to receive notifications about paint events."}
{"code": "@Override public boolean isNamed(){\n  return (flags & NO_NAME) == 0;\n}\n", "nl": "Returns true if this method is anonymous."}
{"code": "public CopyOnWriteMap(){\n  internalMap=new HashMap<K,V>();\n}\n", "nl": "Creates a new instance of CopyOnWriteMap."}
{"code": "public static void runTrialParallel(int size,TrialSuite set,IPoint[] pts,IPivotIndex selector,int numThreads,int ratio){\n  Integer[] ar=new Integer[size];\n  for (int i=0, idx=0; i < pts.length; i++) {\n    ar[idx++]=(int)(pts[i].getX() * BASE);\n    ar[idx++]=(int)(pts[i].getY() * BASE);\n  }\n  MultiThreadQuickSort<Integer> qs=new MultiThreadQuickSort<Integer>(ar);\n  qs.setPivotMethod(selector);\n  qs.setNumberHelperThreads(numThreads);\n  qs.setThresholdRatio(ratio);\n  System.gc();\n  long start=System.currentTimeMillis();\n  qs.qsort(0,size - 1);\n  long end=System.currentTimeMillis();\n  set.addTrial(size,start,end);\n  for (int i=0; i < ar.length - 1; i++) {\n    assert (ar[i] <= ar[i + 1]);\n  }\n}\n", "nl": "Change the number of helper threads inside to try different configurations. <p> Set to NUM_THREADS by default."}
{"code": "private void initResumableMediaRequest(GDataRequest request,MediaFileSource file,String title){\n  initMediaRequest(request,title);\n  request.setHeader(GDataProtocol.Header.X_UPLOAD_CONTENT_TYPE,file.getContentType());\n  request.setHeader(GDataProtocol.Header.X_UPLOAD_CONTENT_LENGTH,new Long(file.getContentLength()).toString());\n}\n", "nl": "Initialize a resumable media upload request."}
{"code": "public static short[] toShortArray(Short[] array){\n  short[] result=new short[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i];\n  }\n  return result;\n}\n", "nl": "Coverts given shorts array to array of shorts."}
{"code": "public static void createTable(SQLiteDatabase db,boolean ifNotExists){\n  String constraint=ifNotExists ? \"IF NOT EXISTS \" : \"\";\n  db.execSQL(\"CREATE TABLE \" + constraint + \"'SIMPLE_ADDRESS_ITEM' (\"+ \"'_id' INTEGER PRIMARY KEY ,\"+ \"'NAME' TEXT,\"+ \"'ADDRESS' TEXT,\"+ \"'CITY' TEXT,\"+ \"'STATE' TEXT,\"+ \"'PHONE' INTEGER);\");\n}\n", "nl": "Creates the underlying database table."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.ABSTRACT_METHOD_DECLARATION___METHOD_DECLARATOR_1:\n    return ((InternalEList<?>)getMethodDeclarator_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected void emit_N4SetterDeclaration_SemicolonKeyword_5_q(EObject semanticObject,ISynNavigable transition,List<INode> nodes){\n  acceptNodes(transition,nodes);\n}\n", "nl": "Ambiguous syntax: ';'? This ambiguous syntax occurs at: body=Block (ambiguity) (rule end) fpar=FormalParameter ')' (ambiguity) (rule end)"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public FitsDate(String dStr) throws FitsException {\n  if (dStr == null || dStr.isEmpty()) {\n    return;\n  }\n  Matcher match=FitsDate.NORMAL_REGEX.matcher(dStr);\n  if (match.matches()) {\n    this.year=getInt(match,FitsDate.NEW_FORMAT_YEAR_GROUP);\n    this.month=getInt(match,FitsDate.NEW_FORMAT_MONTH_GROUP);\n    this.mday=getInt(match,FitsDate.NEW_FORMAT_DAY_OF_MONTH_GROUP);\n    this.hour=getInt(match,FitsDate.NEW_FORMAT_HOUR_GROUP);\n    this.minute=getInt(match,FitsDate.NEW_FORMAT_MINUTE_GROUP);\n    this.second=getInt(match,FitsDate.NEW_FORMAT_SECOND_GROUP);\n    this.millisecond=getMilliseconds(match,FitsDate.NEW_FORMAT_MILLISECOND_GROUP);\n  }\n else {\n    match=FitsDate.OLD_REGEX.matcher(dStr);\n    if (match.matches()) {\n      this.year=getInt(match,FitsDate.OLD_FORMAT_YEAR_GROUP) + FitsDate.YEAR_OFFSET;\n      this.month=getInt(match,FitsDate.OLD_FORMAT_MONTH_GROUP);\n      this.mday=getInt(match,FitsDate.OLD_FORMAT_DAY_OF_MONTH_GROUP);\n    }\n else {\n      if (dStr.trim().isEmpty()) {\n        return;\n      }\n      throw new FitsException(\"Bad FITS date string \\\"\" + dStr + '\"');\n    }\n  }\n}\n", "nl": "Convert a FITS date string to a Java <CODE>Date</CODE> object."}
{"code": "public static <T>T fromBytes(byte[] value,Class<T> clazz){\n  try {\n    Input input=new Input(new ByteArrayInputStream(value));\n    return clazz.cast(kryo.get().readClassAndObject(input));\n  }\n catch (  Throwable t) {\n    LOG.error(\"Unable to deserialize  because \" + t.getMessage(),t);\n    throw t;\n  }\n}\n", "nl": "Deserialize a profile measurement's value. The value produced by a Profile definition can be any numeric data type.  The data type depends on how the profile is defined by the user.  The user should be able to choose the data type that is most suitable for their use case."}
{"code": "public SequencesWriter(SequenceDataSource source,File outputDir,long sizeLimit,PrereadType type,boolean compressed){\n  this(source,outputDir,sizeLimit,null,type,compressed,null);\n}\n", "nl": "Creates a writer for processing sequences from provided data source."}
{"code": "public HtmlPolicyBuilder allowStyling(){\n  allowStyling(CssSchema.DEFAULT);\n  return this;\n}\n", "nl": "Convert <code>style=\"&lt;CSS&gt;\"</code> to sanitized CSS which allows color, font-size, type-face, and other styling using the default schema; but which does not allow content to escape its clipping context."}
{"code": "private PhoneUtil(){\n  throw new Error(\"Do not need instantiate!\");\n}\n", "nl": "Don't let anyone instantiate this class."}
{"code": "@Override public void unregisterTap(Tap tap){\n  mTaps.remove(tap);\n}\n", "nl": "Remove instrumentation tap"}
{"code": "public boolean isNavBarTintEnabled(){\n  return mNavBarTintEnabled;\n}\n", "nl": "Is tinting enabled for the system navigation bar?"}
{"code": "@Override public boolean equals(Object other){\n  if (_map.equals(other)) {\n    return true;\n  }\n else   if (other instanceof Map) {\n    Map that=(Map)other;\n    if (that.size() != _map.size()) {\n      return false;\n    }\n else {\n      Iterator it=that.entrySet().iterator();\n      for (int i=that.size(); i-- > 0; ) {\n        Map.Entry e=(Map.Entry)it.next();\n        Object key=e.getKey();\n        Object val=e.getValue();\n        if (key instanceof Float) {\n          float k=unwrapKey(key);\n          Object v=unwrapValue((V)val);\n          if (_map.containsKey(k) && v == _map.get(k)) {\n          }\n else {\n            return false;\n          }\n        }\n else {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Compares this map with another map for equality of their stored entries."}
{"code": "public boolean becomePrimary(boolean isRebalance){\n  initializationGate();\n  long startTime=getPartitionedRegionStats().startPrimaryTransfer(isRebalance);\n  try {\n    long waitTime=2000;\n    while (!isPrimary()) {\n      this.getAdvisee().getCancelCriterion().checkCancelInProgress(null);\n      boolean attemptToBecomePrimary=false;\n      boolean attemptToDeposePrimary=false;\n      if (Thread.currentThread().isInterrupted()) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Breaking from becomePrimary loop due to thread interrupt flag being set\");\n        }\n        break;\n      }\n      if (isClosed() || !isHosting()) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Breaking from becomePrimary loop because {} is closed or not hosting\",this);\n        }\n        break;\n      }\n      VolunteeringDelegate vDelegate=null;\nsynchronized (this) {\n        if (isVolunteering()) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(\"Waiting for volunteering thread {}. Time left: {} ms\",this,waitTime);\n          }\n          this.wait(waitTime);\n          continue;\n        }\n else         if (isBecomingPrimary()) {\n          attemptToDeposePrimary=true;\n        }\n else {\n          vDelegate=this.volunteeringDelegate;\n          if (vDelegate == null) {\n            vDelegate=new VolunteeringDelegate();\n            this.volunteeringDelegate=vDelegate;\n          }\n        }\n      }\n      if (vDelegate != null) {\n        attemptToBecomePrimary=vDelegate.reserveForBecomePrimary();\n      }\n      if (attemptToBecomePrimary) {\nsynchronized (this) {\n          if (this.volunteeringDelegate == null) {\n            this.volunteeringDelegate=new VolunteeringDelegate();\n          }\n          this.volunteeringDelegate.volunteerForPrimary();\n          attemptToDeposePrimary=true;\n        }\n        Thread.sleep(10);\n      }\n      if (attemptToDeposePrimary) {\n        InternalDistributedMember otherPrimary=getPrimary();\n        if (otherPrimary != null && !getDistributionManager().getId().equals(otherPrimary)) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(\"Attempting to depose primary on {} for {}\",otherPrimary,this);\n          }\n          DeposePrimaryBucketResponse response=DeposePrimaryBucketMessage.send(otherPrimary,this.pRegion,getBucket().getId());\n          if (response != null) {\n            response.waitForRepliesUninterruptibly();\n            if (logger.isDebugEnabled()) {\n              logger.debug(\"Deposed primary on {}\",otherPrimary);\n            }\n          }\n        }\n        Thread.sleep(10);\n      }\n    }\n  }\n catch (  InterruptedException e) {\n    Thread.currentThread().interrupt();\n  }\n finally {\n    getPartitionedRegionStats().endPrimaryTransfer(startTime,isPrimary(),isRebalance);\n  }\n  return isPrimary();\n}\n", "nl": "Makes this <code>BucketAdvisor</code> become the primary if it is already a secondary."}
{"code": "private void declareExtensions(){\n  new BlogCommentFeed().declareExtensions(extProfile);\n  new BlogFeed().declareExtensions(extProfile);\n  new BlogPostFeed().declareExtensions(extProfile);\n  new PostCommentFeed().declareExtensions(extProfile);\n}\n", "nl": "Declare the extensions of the feeds for the Blogger service."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase UmplePackage.ANONYMOUS_GEN_EXPR_2__INDEX_1:\n    return INDEX_1_EDEFAULT == null ? index_1 != null : !INDEX_1_EDEFAULT.equals(index_1);\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public ReferenceSequence sequence(final String name){\n  return mReferences.get(name);\n}\n", "nl": "Get the <code>ReferenceSequence</code> selected by name."}
{"code": "private ChainBuilder(JFrame frame){\n  super(new BorderLayout());\n  this.frame=frame;\n  THIS=this;\n  JPanel customPanel=createCustomizationPanel();\n  JPanel presetPanel=createPresetPanel();\n  label=new JLabel(\"Click the \\\"Begin Generating\\\" button\" + \" to begin generating phrases\",JLabel.CENTER);\n  Border padding=BorderFactory.createEmptyBorder(20,20,5,20);\n  customPanel.setBorder(padding);\n  presetPanel.setBorder(padding);\n  JTabbedPane tabbedPane=new JTabbedPane();\n  tabbedPane.addTab(\"Build your own\",null,customPanel,customizationPanelDescription);\n  tabbedPane.addTab(\"Presets\",null,presetPanel,presetPanelDescription);\n  add(tabbedPane,BorderLayout.CENTER);\n  add(label,BorderLayout.PAGE_END);\n  label.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));\n}\n", "nl": "Creates the GUI shown inside the frame's content pane."}
{"code": "public String toString(){\n  return this.materialPackageBO.toString();\n}\n", "nl": "A method that returns a string representation of a parsed MaterialPackage object"}
{"code": "protected VirtualBaseTypeImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void removeParserNotices(Parser parser){\n  if (noticesToHighlights != null) {\n    RSyntaxTextAreaHighlighter h=(RSyntaxTextAreaHighlighter)textArea.getHighlighter();\n    for (Iterator i=noticesToHighlights.entrySet().iterator(); i.hasNext(); ) {\n      Map.Entry entry=(Map.Entry)i.next();\n      ParserNotice notice=(ParserNotice)entry.getKey();\n      if (notice.getParser() == parser && entry.getValue() != null) {\n        h.removeParserHighlight(entry.getValue());\n        i.remove();\n      }\n    }\n  }\n}\n", "nl": "Removes all parser notices (and clears highlights in the editor) from a particular parser."}
{"code": "public TextLineDecoder(Charset charset,String delimiter){\n  this(charset,new LineDelimiter(delimiter));\n}\n", "nl": "Creates a new instance with the spcified <tt>charset</tt> and the specified <tt>delimiter</tt>."}
{"code": "@Override public void resetViewableArea(){\n  throw new RuntimeException(\"resetViewableArea called in PdfDecoderFx\");\n}\n", "nl": "NOT PART OF API turns off the viewable area, scaling the page back to original scaling"}
{"code": "private void postResults(){\n  this.reportTestCase.host.updateSystemInfo(false);\n  this.trState.systemInfo=this.reportTestCase.host.getSystemInfo();\n  Operation factoryPost=Operation.createPost(this.remoteTestResultService).setReferer(this.reportTestCase.host.getReferer()).setBody(this.trState).setCompletion(null);\n  this.reportTestCase.host.testStart(1);\n  this.reportTestCase.host.sendRequest(factoryPost);\n  try {\n    this.reportTestCase.host.testWait();\n  }\n catch (  Throwable throwable) {\n    throwable.printStackTrace();\n  }\n}\n", "nl": "Send current test state to a remote server, by creating an instance for this particular run."}
{"code": "static void clear(Iterator<?> iterator){\n  checkNotNull(iterator);\n  while (iterator.hasNext()) {\n    iterator.next();\n    iterator.remove();\n  }\n}\n", "nl": "Clears the iterator using its remove method."}
{"code": "@Override public boolean isTop(BitSet fact){\n  return fact.get(topBit);\n}\n", "nl": "Return whether or not given fact is the special TOP value."}
{"code": "public void eraseMap(){\n  if (MAP_STORE.getMap(MAP_STORE.getSelectedMapName()) == null) {\n    return;\n  }\n  for (  Route r : MAP_STORE.getMap(MAP_STORE.getSelectedMapName()).getRoutes()) {\n    eraseRoute(r);\n  }\n}\n", "nl": "Non-destructively erases all displayed content from the map display"}
{"code": "public void doTestTransfer(int size){\n  Thread.setDefaultUncaughtExceptionHandler(this);\n  long start, elapsed;\n  int received;\n  sendData=createDummyData(size);\n  sendStreamSize=size;\n  recvStream=new ByteArrayOutputStream(size);\n  start=PseudoTCPBase.now();\n  startClocks();\n  try {\n    connect();\n  }\n catch (  IOException ex) {\n    fail(ex.getMessage());\n  }\n  assert_Connected_wait(kConnectTimeoutMs);\n  long transferTout=maxTransferTime(sendData.length,kMinTransferRate);\n  boolean transfferInTime=assert_Disconnected_wait(transferTout);\n  elapsed=PseudoTCPBase.now() - start;\n  stopClocks();\n  received=recvStream.size();\n  assertEquals(\"Transfer timeout, transferred: \" + received + \" required: \"+ sendData.length+ \" elapsed: \"+ elapsed+ \" limit: \"+ transferTout,true,transfferInTime);\n  assertEquals(size,received);\n  byte[] recvdArray=recvStream.toByteArray();\n  assertArrayEquals(sendData,recvdArray);\n  logger.log(Level.INFO,\"Transferred \" + received + \" bytes in \"+ elapsed+ \" ms (\"+ (size * 8 / elapsed)+ \" Kbps\");\n}\n", "nl": "Transfers the data of <tt>size</tt> bytes"}
{"code": "protected void sequence_SkillFakeDefinition(ISerializationContext context,SkillFakeDefinition semanticObject){\n  if (errorAcceptor != null) {\n    if (transientValues.isValueTransient(semanticObject,GamlPackage.Literals.GAML_DEFINITION__NAME) == ValueTransient.YES)     errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,GamlPackage.Literals.GAML_DEFINITION__NAME));\n  }\n  SequenceFeeder feeder=createSequencerFeeder(context,semanticObject);\n  feeder.accept(grammarAccess.getSkillFakeDefinitionAccess().getNameIDTerminalRuleCall_1_0(),semanticObject.getName());\n  feeder.finish();\n}\n", "nl": "Contexts: GamlDefinition returns SkillFakeDefinition SkillFakeDefinition returns SkillFakeDefinition Constraint: name=ID"}
{"code": "public void closeDriver(){\n  if (camera != null) {\n    FlashlightManager.disableFlashlight();\n    camera.release();\n    camera=null;\n  }\n}\n", "nl": "Closes the camera driver if still in use."}
{"code": "public void removeSecurityManager(Password password,String id) throws PageException {\n  checkWriteAccess();\n  ((ConfigServerImpl)ConfigImpl.getConfigServer(config,password)).removeSecurityManager(id);\n  Element security=_getRootElement(\"security\");\n  Element[] children=XMLConfigWebFactory.getChildren(security,\"accessor\");\n  for (int i=0; i < children.length; i++) {\n    if (id.equals(children[i].getAttribute(\"id\"))) {\n      security.removeChild(children[i]);\n    }\n  }\n}\n", "nl": "remove security manager matching given id"}
{"code": "public static void circle(double x,double y,double r){\n  if (r < 0)   throw new IllegalArgumentException(\"circle radius must be nonnegative\");\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  double ws=factorX(2 * r);\n  double hs=factorY(2 * r);\n  if (ws <= 1 && hs <= 1)   pixel(x,y);\n else   offscreen.draw(new Ellipse2D.Double(xs - ws / 2,ys - hs / 2,ws,hs));\n  draw();\n}\n", "nl": "Draw a circle of radius r, centered on (x, y)."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile=args[0];\n  if (inputFile.toLowerCase().contains(\".dep\")) {\n    calculateRaster();\n  }\n else   if (inputFile.toLowerCase().contains(\".shp\")) {\n    calculateVector();\n  }\n else {\n    showFeedback(\"There was a problem reading the input file.\");\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) private static <T>T create(Class<T> cls,QName qname){\n  return (T)Configuration.getBuilderFactory().getBuilder(qname).buildObject(qname);\n}\n", "nl": "Create object using OpenSAML's builder system."}
{"code": "public HttpConnection createHttpConnection(){\n  return new AndroidHttpConnection();\n}\n", "nl": "Create an HTTP connection"}
{"code": "@SuppressWarnings(\"unchecked\") private Map<Integer,float[]> parseWaveformsFromJsonFile(File waveformsFile){\n  Map<Integer,float[]> waveformsMap;\n  try {\n    waveformsMap=(Map<Integer,float[]>)parseJsonFile(waveformsFile);\n    LOG.info(\"Loaded waveform images from {}\",waveformsFile);\n  }\n catch (  IOException exception) {\n    waveformsMap=new HashMap<>();\n    LOG.error(\"Error loading waveform thumbnails: {}\",exception.getMessage(),exception);\n  }\n  return waveformsMap;\n}\n", "nl": "Loads the waveforms from a saved file formatted in JSON"}
{"code": "public static final void drawShape(GL2 gl,Shape s,boolean points){\n  if (s instanceof Circle) {\n    RenderUtilities.drawCircle(gl,(Circle)s,points,true);\n  }\n else   if (s instanceof Rectangle) {\n    RenderUtilities.drawRectangle(gl,(Rectangle)s,points);\n  }\n else   if (s instanceof Polygon) {\n    RenderUtilities.drawPolygon(gl,(Polygon)s,points);\n  }\n else   if (s instanceof Segment) {\n    RenderUtilities.drawLineSegment(gl,(Segment)s,points);\n  }\n else {\n  }\n}\n", "nl": "Draws the given shape."}
{"code": "public void write(Writer writer) throws IOException {\n  Map<String,Object> map=new HashMap<String,Object>();\n  map.put(\"vcards\",vcards);\n  map.put(\"utils\",new TemplateUtils());\n  map.put(\"translucentBg\",readImage(\"translucent-bg.png\",ImageType.PNG));\n  map.put(\"noProfile\",readImage(\"no-profile.png\",ImageType.PNG));\n  map.put(\"ezVCardVersion\",Ezvcard.VERSION);\n  map.put(\"ezVCardUrl\",Ezvcard.URL);\n  map.put(\"scribeIndex\",new ScribeIndex());\n  try {\n    template.process(map,writer);\n  }\n catch (  TemplateException e) {\n    throw new RuntimeException(e);\n  }\n  writer.flush();\n}\n", "nl": "Writes the HTML document to a writer."}
{"code": "@Override public String toString(String field){\n  StringBuilder buffer=new StringBuilder();\n  if (!getField().equals(field)) {\n    buffer.append(getField());\n    buffer.append(\":\");\n  }\n  buffer.append(includeLower ? '[' : '{');\n  buffer.append(lowerTerm != null ? (\"*\".equals(Term.toString(lowerTerm)) ? \"\\\\*\" : Term.toString(lowerTerm)) : \"*\");\n  buffer.append(\" TO \");\n  buffer.append(upperTerm != null ? (\"*\".equals(Term.toString(upperTerm)) ? \"\\\\*\" : Term.toString(upperTerm)) : \"*\");\n  buffer.append(includeUpper ? ']' : '}');\n  return buffer.toString();\n}\n", "nl": "Prints a user-readable version of this query."}
{"code": "public void prepare(PluginContext context) throws ReplicatorException, InterruptedException {\n  logger.info(\"Import tables from \" + this.uri.getPath() + \" to the \"+ this.getDefaultSchema()+ \" schema\");\n  tableNames=new ArrayList<String>();\n  columnDefinitions=new HashMap<String,ArrayList<ColumnSpec>>();\n  parser=new CSVParser(',','\"');\n  File importDirectory=new File(this.uri.getPath());\n  if (!importDirectory.exists()) {\n    throw new ReplicatorException(\"The \" + this.uri.getPath() + \" directory does not exist\");\n  }\n  for (  File f : importDirectory.listFiles()) {\n    if (f.getName().endsWith(\".def\")) {\n      this.prepareTableDefinition(f);\n    }\n  }\n  if (this.tableNames.size() == 0) {\n    throw new ReplicatorException(\"There are no tables to load\");\n  }\n}\n", "nl": "Prepare plug-in for use. This method is assumed to allocate all required resources. It is called before the plug-in performs any operations."}
{"code": "public void plot(AbstractDrawer draw){\n  if (!visible)   return;\n  draw.setColor(color);\n  draw.setFont(font);\n  draw.setBaseOffset(base_offset);\n  draw.setTextOffset(cornerE,cornerN);\n  draw.setTextAngle(angle);\n  draw.drawText(label,coord);\n  draw.setBaseOffset(null);\n}\n", "nl": "see Text for formatted text output"}
{"code": "public void testShiftRight4(){\n  byte aBytes[]={1,-128,56,100,-2,-76,89,45,91,3,-15,35,26};\n  int aSign=1;\n  int number=45;\n  byte rBytes[]={12,1,-61,39,-11,-94,-55};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger result=aNumber.shiftRight(number);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "nl": "shiftRight(int n), n > 32"}
{"code": "public void fixStatsError(int sendCommand){\n  for (; this.affectedRows.length < sendCommand; ) {\n    this.affectedRows[currentStat++]=Statement.EXECUTE_FAILED;\n  }\n}\n", "nl": "Add missing information when Exception is thrown."}
{"code": "public byte[] readRawBytes(final int size) throws IOException {\n  if (size < 0) {\n    throw InvalidProtocolBufferNanoException.negativeSize();\n  }\n  if (bufferPos + size > currentLimit) {\n    skipRawBytes(currentLimit - bufferPos);\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n  if (size <= bufferSize - bufferPos) {\n    final byte[] bytes=new byte[size];\n    System.arraycopy(buffer,bufferPos,bytes,0,size);\n    bufferPos+=size;\n    return bytes;\n  }\n else {\n    throw InvalidProtocolBufferNanoException.truncatedMessage();\n  }\n}\n", "nl": "Read a fixed size of bytes from the input."}
{"code": "private void resetToXMLSAXHandler(){\n  this.m_escapeSetting=true;\n}\n", "nl": "Reset all of the fields owned by ToXMLSAXHandler class"}
{"code": "public static cuComplex cuCmplx(float r,float i){\n  cuComplex res=new cuComplex();\n  res.x=r;\n  res.y=i;\n  return res;\n}\n", "nl": "Creates a new complex number consisting of the given real and imaginary part."}
{"code": "public static MethodRepository make(String rawSig,GenericsFactory f){\n  return new MethodRepository(rawSig,f);\n}\n", "nl": "Static factory method."}
{"code": "public void add(final T object){\n  mObjects.add(object);\n  notifyItemInserted(getItemCount() - 1);\n}\n", "nl": "Adds the specified object at the end of the array."}
{"code": "public static String compareHardware(Map<String,String> hwMap,boolean checkDisk){\n  String localMemSizeStr=ServerProbe.getInstance().getMemorySize();\n  String localCpuCoreStr=ServerProbe.getInstance().getCpuCoreNum();\n  hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY);\n  if (!localMemSizeStr.equals(hwMap.get(PropertyConstants.PROPERTY_KEY_MEMORY_SIZE))) {\n    log.warn(\"Local memory {} is not the same as selected cluster {}\",localMemSizeStr,hwMap.get(PropertyConstants.PROPERTY_KEY_MEMORY_SIZE));\n    return String.format(\"Local memory {%s} is not the same as selected cluster {%s}\",localMemSizeStr,hwMap.get(PropertyConstants.PROPERTY_KEY_MEMORY_SIZE));\n  }\n  if (!localCpuCoreStr.equals(hwMap.get(PropertyConstants.PROPERTY_KEY_CPU_CORE))) {\n    log.warn(\"Local CPU core number {} is not the same as selected cluster {}\",localCpuCoreStr,hwMap.get(PropertyConstants.PROPERTY_KEY_CPU_CORE));\n    return String.format(\"Local CPU core number {%s} is not the same as selected cluster {%s}\",localCpuCoreStr,hwMap.get(PropertyConstants.PROPERTY_KEY_CPU_CORE));\n  }\n  if (checkDisk && !hasSameDiskInfo(hwMap.get(PropertyConstants.PROPERTY_KEY_DISK),hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY))) {\n    log.warn(\"Local disk(s) are not the same as selected cluster capacity {}\",hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY));\n    return String.format(\"Local disk(s) are not the same as selected cluster capacity {%s}\",hwMap.get(PropertyConstants.PROPERTY_KEY_DISK_CAPACITY));\n  }\n  return null;\n}\n", "nl": "Check local node hardware (i.e. Memory size, CPU core, Disk Capacity) are the same as in the input map."}
{"code": "public static void tearDown(SWTWorkbenchBot bot){\n  SwtBotUtils.print(\"Tear Down\");\n  bot.resetWorkbench();\n  SwtBotUtils.print(\"Tear Down Done\");\n}\n", "nl": "Performs the necessary tear down work for most SWTBot tests."}
{"code": "private void handleMessage(byte[] data){\n  Buffer buffer=new Buffer();\n  buffer.write(data);\n  int type=(buffer.readShort() & 0xffff) & ~(APP_MSG_RESPONSE_BIT);\n  if (type == BeanMessageID.SERIAL_DATA.getRawValue()) {\n    beanListener.onSerialMessageReceived(buffer.readByteArray());\n  }\n else   if (type == BeanMessageID.BT_GET_CONFIG.getRawValue()) {\n    returnConfig(buffer);\n  }\n else   if (type == BeanMessageID.CC_TEMP_READ.getRawValue()) {\n    returnTemperature(buffer);\n  }\n else   if (type == BeanMessageID.BL_GET_META.getRawValue()) {\n    returnMetadata(buffer);\n  }\n else   if (type == BeanMessageID.BT_GET_SCRATCH.getRawValue()) {\n    returnScratchData(buffer);\n  }\n else   if (type == BeanMessageID.CC_LED_READ_ALL.getRawValue()) {\n    returnLed(buffer);\n  }\n else   if (type == BeanMessageID.CC_ACCEL_READ.getRawValue()) {\n    returnAcceleration(buffer);\n  }\n else   if (type == BeanMessageID.CC_ACCEL_GET_RANGE.getRawValue()) {\n    returnAccelerometerRange(buffer);\n  }\n else   if (type == BeanMessageID.CC_GET_AR_POWER.getRawValue()) {\n    returnArduinoPowerState(buffer);\n  }\n else   if (type == BeanMessageID.BL_STATUS.getRawValue()) {\n    try {\n      Status status=Status.fromPayload(buffer);\n      handleStatus(status);\n    }\n catch (    NoEnumFoundException e) {\n      Log.e(TAG,\"Unable to parse status from buffer: \" + buffer.toString());\n      e.printStackTrace();\n    }\n  }\n else {\n    String fourDigitHex=Integer.toHexString(type);\n    while (fourDigitHex.length() < 4) {\n      fourDigitHex=\"0\" + fourDigitHex;\n    }\n    Log.e(TAG,\"Received message of unknown type 0x\" + fourDigitHex);\n    returnError(BeanError.UNKNOWN_MESSAGE_ID);\n  }\n}\n", "nl": "Handles incoming messages from the Bean and dispatches them to the proper handlers."}
{"code": "public static <K,V>HashMap<K,V> newEmptyHashMap(Iterable<?> iterable){\n  if (iterable instanceof Collection<?>)   return Maps.newHashMapWithExpectedSize(((Collection<?>)iterable).size());\n  return Maps.newHashMap();\n}\n", "nl": "Returns an empty map with expected size matching the iterable size if it's of type Collection. Otherwise, an empty map with the default size is returned."}
{"code": "public int calculateScrollY(int firstVisiblePosition,int visibleItemCount){\n  mFirstVisiblePosition=firstVisiblePosition;\n  if (mReferencePosition < 0) {\n    mReferencePosition=mFirstVisiblePosition;\n  }\n  if (visibleItemCount > 0) {\n    View c=mListView.getListChildAt(0);\n    int scrollY=-c.getTop();\n    mListViewItemHeights.put(firstVisiblePosition,c.getMeasuredHeight());\n    if (mFirstVisiblePosition >= mReferencePosition) {\n      for (int i=mReferencePosition; i < firstVisiblePosition; ++i) {\n        if (mListViewItemHeights.get(i) == null) {\n          mListViewItemHeights.put(i,c.getMeasuredHeight());\n        }\n        scrollY+=mListViewItemHeights.get(i);\n      }\n      return scrollY;\n    }\n else {\n      for (int i=mReferencePosition - 1; i >= firstVisiblePosition; --i) {\n        if (mListViewItemHeights.get(i) == null) {\n          mListViewItemHeights.put(i,c.getMeasuredHeight());\n        }\n        scrollY-=mListViewItemHeights.get(i);\n      }\n      return scrollY;\n    }\n  }\n  return 0;\n}\n", "nl": "Call from an AbsListView.OnScrollListener to calculate the scrollY (Here we definite as the distance in pixels compared to the position representing the current date)."}
{"code": "public DynamicRegionFactoryImpl(){\n}\n", "nl": "create an instance of the factory. This is normally only done by DynamicRegionFactory's static initialization"}
{"code": "public DViewAsymmetricKeyFields(JDialog parent,String title,DSAPublicKey dsaPublicKey){\n  super(parent,title,Dialog.ModalityType.DOCUMENT_MODAL);\n  key=dsaPublicKey;\n  initFields();\n}\n", "nl": "Creates new DViewAsymmetricKeyFields dialog."}
{"code": "public void removeAllActions(CCNode target){\n  if (target == null)   return;\n  HashElement element=targets.get(target);\n  if (element != null) {\n    deleteHashElement(element);\n  }\n else {\n  }\n}\n", "nl": "Removes all actions from a certain target. All the actions that belongs to the target will be removed."}
{"code": "private static String normalizeName(String name){\n  name=(name == null) ? \"\" : name.trim();\n  return name.isEmpty() ? MISSING_NAME : name;\n}\n", "nl": "Normalizes a name to something OpenMRS will accept."}
{"code": "@Override public Object build(QueryNode queryNode) throws QueryNodeException {\n  process(queryNode);\n  return queryNode.getTag(QUERY_TREE_BUILDER_TAGID);\n}\n", "nl": "Builds some kind of object from a query tree. Each node in the query tree is built using an specific builder associated to it."}
{"code": "public boolean isEnableLighting(){\n  return false;\n}\n", "nl": "Returns false."}
{"code": "protected void prepare(){\n  ProcessInfoParameter[] para=getParameter();\n  for (int i=0; i < para.length; i++) {\n    String name=para[i].getParameterName();\n    if (para[i].getParameter() == null)     ;\n else     log.log(Level.SEVERE,\"prepare - Unknown Parameter: \" + name);\n  }\n}\n", "nl": "Prepare - e.g., get Parameters."}
{"code": "public void fling(int velocityX,int velocityY){\n  if (getChildCount() > 0) {\n    int height=getHeight() - getPaddingBottom() - getPaddingTop();\n    int bottom=getChildAt(0).getHeight();\n    int width=getWidth() - getPaddingRight() - getPaddingLeft();\n    int right=getChildAt(0).getWidth();\n    mScroller.fling(getScrollX(),getScrollY(),velocityX,velocityY,0,right - width,0,bottom - height);\n    final boolean movingDown=velocityY > 0;\n    final boolean movingRight=velocityX > 0;\n    View newFocused=findFocusableViewInMyBounds(movingRight,mScroller.getFinalX(),movingDown,mScroller.getFinalY(),findFocus());\n    if (newFocused == null) {\n      newFocused=this;\n    }\n    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {\n      mTwoDScrollViewMovedFocus=true;\n      mTwoDScrollViewMovedFocus=false;\n    }\n    awakenScrollBars(mScroller.getDuration());\n    invalidate();\n  }\n}\n", "nl": "Fling the scroll view"}
{"code": "protected Socket createSocket(){\n  return new Socket();\n}\n", "nl": "Creates a new unconnected Socket instance. Subclasses may use this method to override the default socket implementation."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:21.616 -0500\",hash_original_method=\"F5BF0DDF083843E14FDE0C117BAE250E\",hash_generated_method=\"E1C3BB6772CE07721D8608A1E4D81EE1\") public static int netmaskIntToPrefixLength(int netmask){\n  return Integer.bitCount(netmask);\n}\n", "nl": "Convert a IPv4 netmask integer to a prefix length"}
{"code": "public WritableRaster createWritableChild(int x,int y,int width,int height,int x0,int y0,int[] bandList){\n  if (x < this.minX) {\n    throw new RasterFormatException(\"x lies outside the raster\");\n  }\n  if (y < this.minY) {\n    throw new RasterFormatException(\"y lies outside the raster\");\n  }\n  if ((x + width < x) || (x + width > this.minX + this.width)) {\n    throw new RasterFormatException(\"(x + width) is outside of Raster\");\n  }\n  if ((y + height < y) || (y + height > this.minY + this.height)) {\n    throw new RasterFormatException(\"(y + height) is outside of Raster\");\n  }\n  SampleModel sm;\n  if (bandList != null)   sm=sampleModel.createSubsetSampleModel(bandList);\n else   sm=sampleModel;\n  int deltaX=x0 - x;\n  int deltaY=y0 - y;\n  return new ShortInterleavedRaster(sm,dataBuffer,new Rectangle(x0,y0,width,height),new Point(sampleModelTranslateX + deltaX,sampleModelTranslateY + deltaY),this);\n}\n", "nl": "Creates a Writable subRaster given a region of the Raster. The x and y coordinates specify the horizontal and vertical offsets from the upper-left corner of this Raster to the upper-left corner of the subRaster.  A subset of the bands of the parent Raster may be specified.  If this is null, then all the bands are present in the subRaster. A translation to the subRaster may also be specified. Note that the subRaster will reference the same DataBuffers as the parent Raster, but using different offsets."}
{"code": "private boolean isBlockCommented(int startLine,int endLine,String[] prefixes,IDocument document){\n  try {\n    for (int i=startLine; i <= endLine; i++) {\n      IRegion line=document.getLineInformation(i);\n      String text=document.get(line.getOffset(),line.getLength());\n      int[] found=TextUtilities.indexOf(prefixes,text,0);\n      if (found[0] == -1)       return false;\n      String s=document.get(line.getOffset(),found[0]);\n      s=s.trim();\n      if (s.length() != 0)       return false;\n    }\n    return true;\n  }\n catch (  BadLocationException x) {\n  }\n  return false;\n}\n", "nl": "Determines whether each line is prefixed by one of the prefixes."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase GamlPackage.PARAMETERS__PARAMS:\n    setParams((ExpressionList)null);\n  return;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(String[] args){\n  String matrixFilename=null;\n  String coordinateFilename=null;\n  String externalZonesFilename=null;\n  String networkFilename=null;\n  String plansFilename=null;\n  Double populationFraction=null;\n  if (args.length != 6) {\n    throw new IllegalArgumentException(\"Wrong number of arguments\");\n  }\n else {\n    matrixFilename=args[0];\n    coordinateFilename=args[1];\n    externalZonesFilename=args[2];\n    networkFilename=args[3];\n    plansFilename=args[4];\n    populationFraction=Double.parseDouble(args[5]);\n  }\n  List<String> list=new ArrayList<>();\n  try {\n    BufferedReader br=IOUtils.getBufferedReader(externalZonesFilename);\n    try {\n      String line=null;\n      while ((line=br.readLine()) != null) {\n        list.add(line);\n      }\n    }\n  finally {\n      br.close();\n    }\n  }\n catch (  FileNotFoundException e) {\n    e.printStackTrace();\n  }\ncatch (  IOException e) {\n    e.printStackTrace();\n  }\n  MyDemandMatrix mdm=new MyDemandMatrix();\n  mdm.readLocationCoordinates(coordinateFilename,2,0,1);\n  mdm.parseMatrix(matrixFilename,\"Saturn\",\"Saturn model received for Sanral project\");\n  Scenario sc=mdm.generateDemand(list,new Random(5463),populationFraction,\"car\");\n  NetworkReaderMatsimV1 nr=new NetworkReaderMatsimV1(sc.getNetwork());\n  nr.readFile(networkFilename);\n  XY2Links xy=new XY2Links(sc.getNetwork(),null);\n  xy.run(sc.getPopulation());\n  PopulationWriter pw=new PopulationWriter(sc.getPopulation(),sc.getNetwork());\n  pw.write(plansFilename);\n}\n", "nl": "Class to generate plans files from the Saturn OD-matrices provided  by Sanral's modelling consultant, Alan Robinson."}
{"code": "private int partition(int[] a,int left,int right){\n  int pivot=a[left + (right - left) / 2];\n  while (left <= right) {\n    while (a[left] > pivot)     left++;\n    while (a[right] < pivot)     right--;\n    if (left <= right) {\n      int temp=a[left];\n      a[left]=a[right];\n      a[right]=temp;\n      left++;\n      right--;\n    }\n  }\n  return left;\n}\n", "nl": "Choose mid value as pivot Move two pointers Swap and move on Return left pointer"}
{"code": "public boolean isDone(){\n  return one.getHand().empty() || two.getHand().empty();\n}\n", "nl": "Returns true if either hand is empty."}
{"code": "public ClassNotFoundException(@Nullable String s,@Nullable Throwable ex){\n  super(s,null);\n  this.ex=ex;\n}\n", "nl": "Constructs a <code>ClassNotFoundException</code> with the specified detail message and optional exception that was raised while loading the class."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase BasePackage.DOCUMENTED_ELEMENT__DOCUMENTATION:\n    return DOCUMENTATION_EDEFAULT == null ? documentation != null : !DOCUMENTATION_EDEFAULT.equals(documentation);\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public void drawRangeLine(Graphics2D g2,CategoryPlot plot,ValueAxis axis,Rectangle2D dataArea,double value,Paint paint,Stroke stroke){\n  Range range=axis.getRange();\n  if (!range.contains(value)) {\n    return;\n  }\n  Rectangle2D adjusted=new Rectangle2D.Double(dataArea.getX(),dataArea.getY() + getYOffset(),dataArea.getWidth() - getXOffset(),dataArea.getHeight() - getYOffset());\n  Line2D line1=null;\n  Line2D line2=null;\n  PlotOrientation orientation=plot.getOrientation();\n  if (orientation == PlotOrientation.HORIZONTAL) {\n    double x0=axis.valueToJava2D(value,adjusted,plot.getRangeAxisEdge());\n    double x1=x0 + getXOffset();\n    double y0=dataArea.getMaxY();\n    double y1=y0 - getYOffset();\n    double y2=dataArea.getMinY();\n    line1=new Line2D.Double(x0,y0,x1,y1);\n    line2=new Line2D.Double(x1,y1,x1,y2);\n  }\n else   if (orientation == PlotOrientation.VERTICAL) {\n    double y0=axis.valueToJava2D(value,adjusted,plot.getRangeAxisEdge());\n    double y1=y0 - getYOffset();\n    double x0=dataArea.getMinX();\n    double x1=x0 + getXOffset();\n    double x2=dataArea.getMaxX();\n    line1=new Line2D.Double(x0,y0,x1,y1);\n    line2=new Line2D.Double(x1,y1,x2,y1);\n  }\n  g2.setPaint(paint);\n  g2.setStroke(stroke);\n  g2.draw(line1);\n  g2.draw(line2);\n}\n", "nl": "Draws a line perpendicular to the range axis."}
{"code": "void startFading(){\n  mHandler.removeMessages(MSG_FADE);\n  scheduleFade();\n}\n", "nl": "Start up the pulse to fade the screen, clearing any existing pulse to ensure that we don't have multiple pulses running at a time."}
{"code": "protected Connection createConnection() throws Exception {\n  ActiveMQConnectionFactory factory=new ActiveMQConnectionFactory(\"vm://localhost?broker.persistent=false\");\n  return factory.createConnection();\n}\n", "nl": "Creates a connection."}
{"code": "protected void drawView(Graphics2D g,Rectangle r,View view,int fontHeight,int y){\n  float x=r.x;\n  LayeredHighlighter h=(LayeredHighlighter)host.getHighlighter();\n  RSyntaxDocument document=(RSyntaxDocument)getDocument();\n  Element map=getElement();\n  int p0=view.getStartOffset();\n  int lineNumber=map.getElementIndex(p0);\n  int p1=view.getEndOffset();\n  setSegment(p0,p1 - 1,document,drawSeg);\n  int start=p0 - drawSeg.offset;\n  Token token=document.getTokenListForLine(lineNumber);\n  if (token != null && token.type == Token.NULL) {\n    h.paintLayeredHighlights(g,p0,p1,r,host,this);\n    return;\n  }\n  while (token != null && token.isPaintable()) {\n    int p=calculateBreakPosition(p0,token,x);\n    x=r.x;\n    h.paintLayeredHighlights(g,p0,p,r,host,this);\n    while (token != null && token.isPaintable() && token.offset + token.textCount - 1 < p) {\n      x=token.paint(g,x,y,host,this);\n      token=token.getNextToken();\n    }\n    if (token != null && token.isPaintable() && token.offset < p) {\n      int tokenOffset=token.offset;\n      Token temp=new DefaultToken(drawSeg,tokenOffset - start,p - 1 - start,tokenOffset,token.type);\n      temp.paint(g,x,y,host,this);\n      temp=null;\n      token.makeStartAt(p);\n    }\n    p0=(p == p0) ? p1 : p;\n    y+=fontHeight;\n  }\n  if (host.getEOLMarkersVisible()) {\n    g.setColor(host.getForegroundForTokenType(Token.WHITESPACE));\n    g.setFont(host.getFontForTokenType(Token.WHITESPACE));\n    g.drawString(\"\\u00B6\",x,y - fontHeight);\n  }\n}\n", "nl": "Draws a single view (i.e., a line of text for a wrapped view), wrapping the text onto multiple lines if necessary."}
{"code": "@Override public boolean containsKey(Object key){\n  if (key == null) {\n    key=NULL_OBJECT;\n  }\n  int index=findIndex(key,elementData);\n  return elementData[index] == key;\n}\n", "nl": "Returns whether this map contains the specified key."}
{"code": "public boolean autoCorrectText(){\n  return preferences.getBoolean(resources.getString(R.string.key_autocorrect_text),Boolean.parseBoolean(resources.getString(R.string.default_autocorrect_text)));\n}\n", "nl": "Whether message text should be autocorrected."}
{"code": "protected void removeNode(int id) throws Exception {\n  int idx;\n  FolderTokenDocTreeNode node=null;\n  idx=findIndexById(id);\n  if (idx == -1) {\n    throw new IeciTdException(FolderBaseError.EC_NOT_FOUND,FolderBaseError.EM_NOT_FOUND);\n  }\n  node=(FolderTokenDocTreeNode)m_nodes.get(idx);\n  if (node.isNew())   m_nodes.remove(idx);\n else   node.setEditFlag(FolderEditFlag.REMOVE);\n}\n", "nl": "Elimina de la lista de nodos el nodo con el id especificado"}
{"code": "public void deleteAttributes(int[] columnIndices){\n  ((ArffTableModel)getModel()).deleteAttributes(columnIndices);\n}\n", "nl": "deletes the attributes at the given indices"}
{"code": "public void onSuccess(int statusCode,Header[] headers,JSONObject response){\n  Log.w(LOG_TAG,\"onSuccess(int, Header[], JSONObject) was not overriden, but callback was received\");\n}\n", "nl": "Returns when request succeeds"}
{"code": "public int lastIndexOfFromTo(byte element,int from,int to){\n  if (size == 0)   return -1;\n  checkRangeFromTo(from,to,size);\n  byte[] theElements=elements;\n  for (int i=to; i >= from; i--) {\n    if (element == theElements[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "nl": "Returns the index of the last occurrence of the specified element. Returns <code>-1</code> if the receiver does not contain this element. Searches beginning at <code>to</code>, inclusive until <code>from</code>, inclusive. Tests for identity."}
{"code": "public void put(final long key){\n  if (key == FREE_KEY) {\n    m_hasFreeKey=true;\n    return;\n  }\n  int ptr=(int)((Tools.phiMix(key) & m_mask));\n  long e=m_data[ptr];\n  if (e == FREE_KEY) {\n    m_data[ptr]=key;\n    if (m_size >= m_threshold) {\n      rehash(m_data.length * 2);\n    }\n else {\n      ++m_size;\n    }\n    return;\n  }\n else   if (e == key) {\n    return;\n  }\n  while (true) {\n    ptr=(int)((ptr + 1) & m_mask);\n    e=m_data[ptr];\n    if (e == FREE_KEY) {\n      m_data[ptr]=key;\n      if (m_size >= m_threshold) {\n        rehash(m_data.length * 2);\n      }\n else {\n        ++m_size;\n      }\n      return;\n    }\n else     if (e == key) {\n      return;\n    }\n  }\n}\n", "nl": "Add a single element to the map"}
{"code": "public PredictiveInfoCalculatorKraskov(String calculatorName) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n  super(calculatorName);\n  if (!calculatorName.equalsIgnoreCase(MI_CALCULATOR_KRASKOV1) && !calculatorName.equalsIgnoreCase(MI_CALCULATOR_KRASKOV2)) {\n    throw new ClassNotFoundException(\"Must be an underlying Kraskov-Grassberger calculator\");\n  }\n}\n", "nl": "Creates a new instance of the Kraskov-Stoegbauer-Grassberger estimator for PI, with the supplied MI calculator name."}
{"code": "public DefaultDirectAdjacentSelector(short type,Selector parent,SimpleSelector simple){\n  super(type,parent,simple);\n}\n", "nl": "Creates a new DefaultDirectAdjacentSelector object."}
{"code": "@Inline public void postCopy(ObjectReference object,boolean majorGC){\n  initializeHeader(object,false);\n  if (!HEADER_MARK_BITS) {\n    testAndSetLiveBit(object);\n  }\n}\n", "nl": "Perform any required post copy (i.e. in-GC allocation) initialization. This is relevant (for example) when MS is used as the mature space in a copying GC."}
{"code": "public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is){\n  LinkedHashMap<Pattern,String> rules=new LinkedHashMap<>();\n  BufferedReader br=new BufferedReader(IOUtils.getDecodingReader(is,StandardCharsets.UTF_8));\n  String line;\n  try {\n    int linenum=0;\n    while ((line=br.readLine()) != null) {\n      linenum++;\n      String[] arr=line.split(\"#\");\n      if (arr.length > 0)       line=arr[0].trim();\n      if (line.length() == 0)       continue;\n      int sep=line.indexOf(\"=\");\n      if (sep <= 0) {\n        log.warn(\"Wrong format of password line \" + linenum);\n        continue;\n      }\n      String pass=line.substring(sep + 1).trim();\n      String regex=line.substring(0,sep).trim();\n      try {\n        Pattern pattern=Pattern.compile(regex);\n        rules.put(pattern,pass);\n      }\n catch (      PatternSyntaxException pse) {\n        log.warn(\"Key of line \" + linenum + \" was not a valid regex pattern\",pse);\n        continue;\n      }\n    }\n    is.close();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n  return rules;\n}\n", "nl": "Parses rule file from stream and returns a Map of all rules found"}
{"code": "public boolean isItemForce(){\n  return true;\n}\n", "nl": "Returns true."}
{"code": "public Builder document(InputStream document,String mediaType){\n  documentInputStream=document;\n  this.mediaType=mediaType;\n  return this;\n}\n", "nl": "Sets the document as an input stream and its media type."}
{"code": "public final String toString(){\n  StringBuffer text=new StringBuffer();\n  text.append(\"Print statistic values of instances (\" + first + \"-\"+ last+ \"\\n\");\n  text.append(\"    Number of instances:\\t\" + numInstances + \"\\n\");\n  text.append(\"    NUmber of instances with unknowns:\\t\" + missingInstances + \"\\n\");\n  text.append(\"    Attribute:\\t\\t\\t:\" + attr + \"\\n\");\n  text.append(\"    Sum:\\t\\t\\t\" + sum + \"\\n\");\n  text.append(\"    Squared sum:\\t\\t\" + sqrSum + \"\\n\");\n  text.append(\"    Stanard Deviation:\\t\\t\" + sd + \"\\n\");\n  return text.toString();\n}\n", "nl": "Converts the stats to a string"}
{"code": "private void scanAndLock(Object key,int hash){\n  HashEntry<K,V> first=entryForHash(this,hash);\n  HashEntry<K,V> e=first;\n  int retries=-1;\n  while (!tryLock()) {\n    HashEntry<K,V> f;\n    if (retries < 0) {\n      if (e == null || key.equals(e.key))       retries=0;\n else       e=e.next;\n    }\n else     if (++retries > MAX_SCAN_RETRIES) {\n      lock();\n      break;\n    }\n else     if ((retries & 1) == 0 && (f=entryForHash(this,hash)) != first) {\n      e=first=f;\n      retries=-1;\n    }\n  }\n}\n", "nl": "Scans for a node containing the given key while trying to acquire lock for a remove or replace operation. Upon return, guarantees that lock is held.  Note that we must lock even if the key is not found, to ensure sequential consistency of updates."}
{"code": "public IntentBuilder oldColor(int oldColor){\n  mOldColor=oldColor;\n  return this;\n}\n", "nl": "Sets the old color to show on the bottom \"Cancel\" half circle, and also the initial value for the picked color. The default value is black."}
{"code": "public void __setDaoSession(DaoSession daoSession){\n  this.daoSession=daoSession;\n  myDao=daoSession != null ? daoSession.getUserDBDao() : null;\n}\n", "nl": "called by internal mechanisms, do not call yourself."}
{"code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof TimeTableXYDataset)) {\n    return false;\n  }\n  TimeTableXYDataset that=(TimeTableXYDataset)obj;\n  if (this.domainIsPointsInTime != that.domainIsPointsInTime) {\n    return false;\n  }\n  if (this.xPosition != that.xPosition) {\n    return false;\n  }\n  if (!this.workingCalendar.getTimeZone().equals(that.workingCalendar.getTimeZone())) {\n    return false;\n  }\n  if (!this.values.equals(that.values)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Tests this dataset for equality with an arbitrary object."}
{"code": "private void startContext(CrawlJob crawlJob){\n  LOGGER.debug(\"Starting context\");\n  PathSharingContext ac=crawlJob.getJobContext();\n  ac.addApplicationListener(this);\n  try {\n    ac.start();\n  }\n catch (  BeansException be) {\n    LOGGER.warn(be.getMessage());\n    ac.close();\n  }\ncatch (  Exception e) {\n    LOGGER.warn(e.getMessage());\n    try {\n      ac.close();\n    }\n catch (    Exception e2) {\n      e2.printStackTrace(System.err);\n    }\n finally {\n    }\n  }\n  LOGGER.debug(\"Context started\");\n}\n", "nl": "Start the context, catching and reporting any BeansExceptions."}
{"code": "@Override public boolean performCancel(){\n  CnAElementFactory.getInstance().reloadModelFromDatabase();\n  return true;\n}\n", "nl": "Cause update to risk analysis object in loaded model."}
{"code": "public boolean isOpaque(){\n  checkOpacityMethodClient();\n  return explicitlyOpaque;\n}\n", "nl": "Returns whether the background of this <code>BasicPanel</code> will be painted when it is rendered."}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "@Override public void resetDistribution(Instances data) throws Exception {\n  Instances insts=new Instances(data,data.numInstances());\n  for (int i=0; i < data.numInstances(); i++) {\n    if (whichSubset(data.instance(i)) > -1) {\n      insts.add(data.instance(i));\n    }\n  }\n  Distribution newD=new Distribution(insts,this);\n  newD.addInstWithUnknown(data,m_attIndex);\n  m_distribution=newD;\n}\n", "nl": "Sets distribution associated with model."}
{"code": "public static <T,R>R readStaticField(Class<T> klass,String fieldName) throws NoSuchFieldException {\n  return readAvailableField(klass,null,fieldName);\n}\n", "nl": "Reads the static field with given fieldName in given klass."}
{"code": "public static String extractFactor_Display(String laggedFactor){\n  int colonIndex=laggedFactor.indexOf(\":L\");\n  String factor=laggedFactor.substring(0,colonIndex);\n  return factor;\n}\n", "nl": "Parses the given string representing a lagged factor and return the part that represents the factor."}
{"code": "protected void deployCargoPing(WebLogicLocalContainer container) throws IOException {\n  String deployDir=getFileHandler().createDirectory(getDomainHome(),container.getAutoDeployDirectory());\n  getResourceUtils().copyResource(RESOURCE_PATH + \"cargocpc.war\",getFileHandler().append(deployDir,\"cargocpc.war\"),getFileHandler());\n}\n", "nl": "Deploy the Cargo Ping utility to the container."}
{"code": "public int size(){\n  return this.count;\n}\n", "nl": "Returns the number of mappings in this map"}
{"code": "protected void parse(DataInputStream stream) throws Exception {\n  int size=stream.readInt();\n  int ret, read=0;\n  data=new byte[size];\n  while (size > 0) {\n    ret=stream.read(data,read,size);\n    size-=ret;\n    read+=ret;\n  }\n}\n", "nl": "Loading method. (see NBT_Tag)"}
{"code": "@Ignore(\"NaN behavior TBD\") @Test public void testLinearAzimuth_WithNaN() throws Exception {\n  Location begin=new Location(Double.NaN,Double.NaN);\n  Location end=new Location(34.2,-119.2);\n  double azimuth=begin.linearAzimuth(end);\n  assertTrue(\"expecting NaN\",Double.isNaN(azimuth));\n}\n", "nl": "Ensures linear azimuth is NaN when NaN members are used."}
{"code": "public MutableValueBuffer(final int capacity,final IRaba src){\n  if (src == null)   throw new IllegalArgumentException();\n  checkCapacity(capacity);\n  if (capacity < src.capacity())   throw new IllegalArgumentException();\n  nvalues=src.size();\n  values=new byte[capacity][];\n  int i=0;\n  for (  byte[] a : src) {\n    values[i++]=a;\n  }\n}\n", "nl": "Builds a mutable value buffer."}
{"code": "private void checkCircuits(){\n  _portalIconMap.clear();\n  _darkTrack.clear();\n  _unconvertedTrack.clear();\n  PortalManager portalMgr=InstanceManager.getDefault(jmri.jmrit.logix.PortalManager.class);\n  Iterator<Positionable> it=_editor.getContents().iterator();\n  while (it.hasNext()) {\n    Positionable pos=it.next();\n    if (pos instanceof IndicatorTrack) {\n      OBlock block=((IndicatorTrack)pos).getOccBlock();\n      ((IndicatorTrack)pos).removePath(EditCircuitPaths.TEST_PATH);\n      if (block != null) {\n        addIcon(block,pos);\n      }\n else {\n        _darkTrack.add(pos);\n      }\n    }\n else     if (pos instanceof PortalIcon) {\n      PortalIcon pIcon=(PortalIcon)pos;\n      String name=pIcon.getName();\n      Portal portal=portalMgr.getByUserName(name);\n      if (portal == null) {\n        log.error(\"No Portal for PortalIcon called \\\"\" + name + \"\\\". Discarding icon.\");\n        pIcon.remove();\n      }\n else {\n        PortalIcon pi=_portalIconMap.get(name);\n        if (pi != null) {\n          log.error(\"Removing duplicate PortalIcon for Portal \\\"\" + name + \"\\\".\");\n          pi.remove();\n        }\n        _portalIconMap.put(name,pIcon);\n      }\n    }\n  }\n  Iterator<Entry<OBlock,ArrayList<Positionable>>> iters=_circuitMap.entrySet().iterator();\n  while (iters.hasNext()) {\n    Entry<OBlock,ArrayList<Positionable>> entry=iters.next();\n    Iterator<Positionable> iter=entry.getValue().iterator();\n    while (iter.hasNext()) {\n      Positionable pos=iter.next();\n      if (isUnconvertedTrack(pos)) {\n        if (!_unconvertedTrack.contains(pos)) {\n          _unconvertedTrack.add(pos);\n        }\n      }\n    }\n  }\n  _bareBlock.clear();\n  _convertBlock.clear();\n  _badPortalIcon.clear();\n  OBlockManager manager=InstanceManager.getDefault(jmri.jmrit.logix.OBlockManager.class);\n  String[] sysNames=manager.getSystemNameArray();\n  hasOBlocks=(sysNames.length > 0);\n  for (int i=0; i < sysNames.length; i++) {\n    OBlock block=manager.getBySystemName(sysNames[i]);\n    java.util.List<Portal> list=block.getPortals();\n    if (list != null) {\n      Iterator<Portal> iter=list.iterator();\n      while (iter.hasNext()) {\n        Portal portal=iter.next();\n        PortalIcon pi=_portalIconMap.get(portal.getName());\n        if (pi != null) {\n          addIcon(block,pi);\n        }\n      }\n    }\n    java.util.List<Positionable> icons=_circuitMap.get(block);\n    if (log.isDebugEnabled()) {\n      log.debug(\"checkCircuits: block \" + block.getDisplayName() + \" has \"+ icons.size()+ \" icons.\");\n    }\n    if (icons == null || icons.size() == 0) {\n      _bareBlock.add(block);\n    }\n else {\n      _bareBlock.remove(block);\n      for (int k=0; k < icons.size(); k++) {\n        Positionable pos=icons.get(k);\n        if (!(pos instanceof IndicatorTrack) && !(pos instanceof PortalIcon)) {\n          if (!_convertBlock.contains(block)) {\n            _convertBlock.add(block);\n            break;\n          }\n        }\n      }\n    }\n  }\n  List<NamedBean> list=portalMgr.getNamedBeanList();\n  Iterator<NamedBean> iter=list.iterator();\n  while (iter.hasNext()) {\n    Portal portal=(Portal)iter.next();\n    String name=portal.getName();\n    PortalIcon pi=_portalIconMap.get(name);\n    if (pi != null) {\n      if (!checkPortalIcon(portal,pi)) {\n        _badPortalIcon.put(name,portal);\n      }\n    }\n else {\n      _badPortalIcon.put(name,portal);\n    }\n  }\n  makeToDoMenu();\n}\n", "nl": "Find the blocks with no icons and the blocks with icons that need conversion Setup for main Frame - used in both initialization and close of an editing frame Build Lists that are used to create menu items"}
{"code": "public OutOfLineContent(){\n  super(KEY);\n}\n", "nl": "Constructs a new instance using the default metadata."}
{"code": "private static List<String> rewriteTermBruteForce(String term){\n  List<String> termsList=rewriteBrute(term);\n  if (term == \"\" || !term.equals(termsList.get(termsList.size() - 1)))   termsList.add(term);\n  return termsList;\n}\n", "nl": "Wrapper over main recursive method, rewriteBrute which performs the fuzzy tokenization of a term The original term may not be a valid dictionary word, but be a term particular to the database The method rewriteBrute only considers terms which are valid dictionary words In case original term is not a dictionary word, it will not be added to queryList by method rewriteBrute This wrapper ensures that if rewriteBrute does not include the original term, it will still be included For example, for the term \"newyork\", rewriteBrute will return the list <\"new york\"> But \"newyork\" also needs to be included in the list to support particular user queries This wrapper includes \"newyork\" in this list"}
{"code": "public void test_sssp_linkType_constraint() throws Exception {\n  final SmallWeightedGraphProblem p=setupSmallWeightedGraphProblem();\n  final IGASEngine gasEngine=getGraphFixture().newGASEngine(1);\n  try {\n    final IGraphAccessor graphAccessor=getGraphFixture().newGraphAccessor(null);\n    final IGASContext<SSSP.VS,SSSP.ES,Integer> gasContext=gasEngine.newGASContext(graphAccessor,new SSSP());\n    gasContext.setLinkType((URI)p.getFoafKnows());\n    final IGASState<SSSP.VS,SSSP.ES,Integer> gasState=gasContext.getGASState();\n    gasState.setFrontier(gasContext,p.getV1());\n    gasContext.call();\n    assertEquals(0.0,gasState.getState(p.getV1()).dist());\n    assertEquals(1.0,gasState.getState(p.getV2()).dist());\n    assertEquals(1.0,gasState.getState(p.getV3()).dist());\n    assertEquals(2.0,gasState.getState(p.getV4()).dist());\n    assertEquals(2.0,gasState.getState(p.getV5()).dist());\n  }\n  finally {\n    gasEngine.shutdownNow();\n  }\n}\n", "nl": "A unit test based on graph with link weights - in this version of the test we constrain the link type but do not specify the link attribute type. Hence it ignores the link weights. This provides a test of the optimized access path when just the link type constraint is specified."}
{"code": "public Id<DgCrossingNode> convertNodeId2NotExpandedCrossingNodeId(Id<Node> nodeId){\n  String idString=nodeId.toString();\n  return idPool.createId(idString,DgCrossingNode.class);\n}\n", "nl": "converts a matsim node ID of a node outside the signals bounding box  to the single crossing node ID existing for the not expanded crossing in the ks-model. (the signals bounding box determines the region of spatial expansion: all nodes within this area will be expanded.)"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String k=getString(stack);\n  String r=getString(stack);\n  if (!Sage.WINDOWS_OS)   return Pooler.EMPTY_STRING_ARRAY;\n  return Sage.getRegistryNames(Sage.getHKEYForName(r),k);\n}\n", "nl": "Returns a list of the Windows registry names which exist under the specified root &amp; key (Windows only) Acceptable values for the Root are: \"HKCR\", \"HKEY_CLASSES_ROOT\", \"HKCC\", \"HKEY_CURRENT_CONFIG\", \"HKCU\", \"HKEY_CURRENT_USER\", \"HKU\", \"HKEY_USERS\", \"HKLM\" or \"HKEY_LOCAL_MACHINE\" (HKLM is the default if nothing matches)"}
{"code": "public APIPermissionSet(){\n}\n", "nl": "Creates a new permission set which contains no granted permissions. Any permissions must be added by manipulating or replacing the applicable permission collection."}
{"code": "@RequestMapping(value=\"/upload/single/initiation\",method=RequestMethod.POST,consumes={\"application/xml\",\"application/json\"}) @Secured(SecurityFunctions.FN_UPLOAD_POST) public UploadSingleInitiationResponse initiateUploadSingle(@RequestBody UploadSingleInitiationRequest uploadSingleInitiationRequest){\n  UploadSingleInitiationResponse uploadSingleInitiationResponse=uploadDownloadService.initiateUploadSingle(uploadSingleInitiationRequest);\n  for (  BusinessObjectData businessObjectData : Arrays.asList(uploadSingleInitiationResponse.getSourceBusinessObjectData(),uploadSingleInitiationResponse.getTargetBusinessObjectData())) {\n    BusinessObjectDataKey businessObjectDataKey=businessObjectDataHelper.getBusinessObjectDataKey(businessObjectData);\n    for (    NotificationEventTypeEntity.EventTypesBdata eventType : Arrays.asList(NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_RGSTN,NotificationEventTypeEntity.EventTypesBdata.BUS_OBJCT_DATA_STTS_CHG)) {\n      notificationEventService.processBusinessObjectDataNotificationEventAsync(eventType,businessObjectDataKey,businessObjectData.getStatus(),null);\n    }\n    for (    StorageUnit storageUnit : businessObjectData.getStorageUnits()) {\n      notificationEventService.processStorageUnitNotificationEventAsync(NotificationEventTypeEntity.EventTypesStorageUnit.STRGE_UNIT_STTS_CHG,businessObjectDataKey,storageUnit.getStorage().getName(),storageUnit.getStorageUnitStatus(),null);\n    }\n  }\n  return uploadSingleInitiationResponse;\n}\n", "nl": "Initiates a single file upload capability by creating the relative business object data instance in UPLOADING state and allowing write access to a specific location in S3_MANAGED_LOADING_DOCK storage. <p>Requires WRITE permission on namespace</p>"}
{"code": "public ArrayIntCompressed(int size,int leadingClearBits,int trailingClearBits){\n  init(size,BIT_LENGTH - leadingClearBits - trailingClearBits,trailingClearBits);\n}\n", "nl": "Create <code>IntArrayCompressed</code> from number of ints to be stored, the number of leading and trailing clear bits. Everything else is stored in the internal data structure."}
{"code": "public String compXmlStringAt(byte[] arr,int strOff){\n  int strLen=arr[strOff + 1] << 8 & 0xff00 | arr[strOff] & 0xff;\n  char[] chars=new char[strLen];\n  for (int ii=0; ii < strLen; ii++) {\n    int p0=strOff + 2 + ii * 2;\n    if (p0 >= arr.length - 1)     break;\n    chars[ii]=(char)(((arr[p0 + 1] & 0x00FF) << 8) + (arr[p0] & 0x00FF));\n  }\n  return new String(chars);\n}\n", "nl": "Return the string stored in StringTable format at offset strOff. This offset points to the 16 bit string length, which is followed by that number of 16 bit (Unicode) chars."}
{"code": "public AbstractExportOperation(File archiveFile,IFile mainFile,IN4JSEclipseProject project){\n  this.targetFile=archiveFile;\n  this.mainFile=mainFile;\n  this.project=project;\n  this.workspace=project.getProject().getWorkspace();\n  rootLocation=project.getLocation().appendSegment(\"\");\n}\n", "nl": "Create an operation that will export the given project to the given zip file."}
{"code": "@Override public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n  debugCodeCall(\"supportsMixedCaseQuotedIdentifiers\");\n  String m=conn.getMode();\n  if (m.equals(\"MySQL\")) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Checks if a table created with CREATE TABLE \"Test\"(ID INT) is a different table than a table created with CREATE TABLE TEST(ID INT)."}
{"code": "private static Shape leftEdge(BufferedImage image){\n  GeneralPath path=new GeneralPath();\n  Point2D p1=null;\n  Point2D p2=null;\n  Line2D line=new Line2D.Float();\n  Point2D p=new Point2D.Float();\n  int foundPointY=-1;\n  for (int i=0; i < image.getHeight(); i++) {\n    for (int j=0; j < image.getWidth(); j++) {\n      if ((image.getRGB(j,i) & 0xff000000) != 0) {\n        p=new Point2D.Float(j,i);\n        foundPointY=i;\n        break;\n      }\n    }\n    if (foundPointY >= 0) {\n      if (p2 == null) {\n        p1=new Point2D.Float(image.getWidth() - 1,foundPointY);\n        path.moveTo(p1.getX(),p1.getY());\n        p2=new Point2D.Float();\n        p2.setLocation(p);\n      }\n else {\n        p2=detectLine(p1,p2,p,line,path);\n      }\n    }\n  }\n  path.lineTo(p.getX(),p.getY());\n  if (foundPointY >= 0) {\n    path.lineTo(image.getWidth() - 1,foundPointY);\n  }\n  path.closePath();\n  return path;\n}\n", "nl": "trace the left side of the image"}
{"code": "public void testSetMaxRows() throws Exception {\n  Statement maxRowsStmt=null;\n  try {\n    maxRowsStmt=this.conn.createStatement();\n    maxRowsStmt.setMaxRows(1);\n    this.rs=maxRowsStmt.executeQuery(\"SELECT 1\");\n  }\n  finally {\n    if (maxRowsStmt != null) {\n      maxRowsStmt.close();\n    }\n  }\n}\n", "nl": "Tests fix for BUG#907"}
{"code": "public static void unregisterMbeans(){\n  unregisterMbeans(ManagementFactory.getPlatformMBeanServer());\n}\n", "nl": "unRegister all jamon related mbeans"}
{"code": "public boolean free(T value){\n  return _ringQueue.offer(value);\n}\n", "nl": "Frees the object.  If the free list is full, the object will be garbage collected."}
{"code": "public NotificationChain basicSet_lok(LocalArgumentsVariable new_lok,NotificationChain msgs){\n  LocalArgumentsVariable old_lok=_lok;\n  _lok=new_lok;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,N4JSPackage.FUNCTION_DECLARATION__LOK,old_lok,new_lok);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void query(boolean onlyCurrentRows,int onlyCurrentDays,int maxRows){\n  m_mTab.query(onlyCurrentRows,onlyCurrentDays,maxRows);\n  if (!isSingleRow())   vTable.autoSize(true);\n  activateChilds();\n}\n", "nl": "Query Tab and resize Table (called from APanel)"}
{"code": "@Override public EmpiricalDistribution queryProb(Query.ProbQuery query){\n  LikelihoodWeighting isquery=new LikelihoodWeighting(query,nbSamples,maxSamplingTime);\n  List<Sample> samples=isquery.getSamples();\n  return new EmpiricalDistribution(samples);\n}\n", "nl": "Queries for the probability distribution of the set of random variables in the Bayesian network, given the provided evidence"}
{"code": "public char loadChar(Offset offset){\n  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);\n  return (char)0;\n}\n", "nl": "Loads a char from the memory location pointed to by the current instance."}
{"code": "public FloatBuffer put(float[] src,int off,int len){\n  int length=src.length;\n  if (off < 0 || len < 0 || (long)off + (long)len > length) {\n    throw new IndexOutOfBoundsException();\n  }\n  if (len > remaining()) {\n    throw new BufferOverflowException();\n  }\n  for (int i=off; i < off + len; i++) {\n    put(src[i]);\n  }\n  return this;\n}\n", "nl": "Writes floats from the given float array, starting from the specified offset, to the current position and increases the position by the number of floats written."}
{"code": "public static void deleteCollectionLevelSnapshot(SolrZkClient zkClient,String collectionName,String commitName) throws InterruptedException, KeeperException {\n  String zkPath=getSnapshotMetaDataZkPath(collectionName,Optional.of(commitName));\n  zkClient.delete(zkPath,-1,true);\n}\n", "nl": "This method deletes an entry for the named snapshot for the specified collection in Zookeeper."}
{"code": "private void sortAndPrintSQL() throws SQLException {\n  final Vector<String> statements=new Vector<String>(1000,500);\n  final Vector<String> sortedStatements=new Vector<String>(1000,500);\n  for (int i=0; i < m_newTables.size(); i++) {\n    statements.add(m_newTables.get(i).getCreateStatement());\n  }\n  for (int i=0; i < m_changedTables.size(); i++) {\n    if (m_changedTables.get(i).isAlterAdd()) {\n      statements.add(m_changedTables.get(i).getAlterAddStatement());\n    }\n else     if (m_changedTables.get(i).isAlterDrop()) {\n      statements.add(m_changedTables.get(i).getAlterDropStatement());\n    }\n else     if (m_changedTables.get(i).isAlterModify()) {\n      statements.add(m_changedTables.get(i).getAlterModifyStatement());\n    }\n  }\n  for (int i=0; i < m_constraintsToDrop.size(); i++) {\n    statements.add(m_constraintsToDrop.get(i).getDropString());\n  }\n  for (int i=0; i < m_newConstraints.size(); i++) {\n    statements.add(m_newConstraints.get(i).getAlterTableString());\n  }\n  Vector<String> tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  sortedStatements.add(\"COMMIT;\");\n  sortedStatements.add(\"SET DEFINE OFF;\");\n  statements.clear();\n  for (int i=0; i < m_newTableEntry.size(); i++) {\n    statements.add(m_newTableEntry.get(i).replaceAll(\"\\n\",\" \"));\n  }\n  tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  sortedStatements.add(\"COMMIT;\");\n  sortedStatements.add(\"SET DEFINE OFF;\");\n  statements.clear();\n  for (int i=0; i < m_alterADEntry.size(); i++) {\n    statements.add(m_alterADEntry.get(i).replaceAll(\"\\n\",\" \"));\n  }\n  tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  sortedStatements.add(\"COMMIT;\");\n  sortedStatements.add(\"SET DEFINE OFF;\");\n  statements.clear();\n  for (int i=0; i < m_deleteADEntry.size(); i++) {\n    statements.add(m_deleteADEntry.get(i).replaceAll(\"\\n\",\" \"));\n  }\n  tempVector=sortStatements(statements);\n  for (int i=0; i < tempVector.size(); i++) {\n    sortedStatements.add(tempVector.get(i));\n  }\n  System.out.println();\n  System.out.println(\"---------------------------\");\n  System.out.println(\"--   SCRIPT STARTS HERE!\");\n  System.out.println(\"---------------------------\");\n  System.out.println(\"-- UNABLE TO APPLY THESE STATEMENTS - START\");\n  for (int i=0; i < m_unappliableStatements.size(); i++) {\n    System.out.println(m_unappliableStatements.get(i));\n  }\n  System.out.println(\"-- UNABLE TO APPLY THESE STATEMENTS - END\");\n  System.out.println();\n  System.out.println(\"-- NEW/CHANGED TABLES - NEW/CHANGED AD_ENTRIES\");\n  for (int i=0; i < sortedStatements.size(); i++) {\n    System.out.println(sortedStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- NEW VIEWS\");\n  for (int i=0; i < m_newViews.size(); i++) {\n    System.out.println(m_newViews.get(i).getCreateStatement());\n  }\n  System.out.println();\n  System.out.println(\"-- CHANGED VIEWS - but check them first - don't overwrite your customizations...\");\n  for (int i=0; i < m_changedViews.size(); i++) {\n    System.out.println(m_changedViews.get(i).getCreateStatement());\n  }\n  System.out.println();\n  System.out.println(\"-- NEW OR CHANGED FUNCTIONS/PROCEDURES\");\n  for (int i=0; i < m_newFunctionStatements.size(); i++) {\n    System.out.println(m_newFunctionStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- DROP FUNCTIONS/PROCEDURES\");\n  for (int i=0; i < m_dropFunctionStatements.size(); i++) {\n    System.out.println(m_dropFunctionStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- DROP TRIGGERS\");\n  for (int i=0; i < m_dropTriggerStatements.size(); i++) {\n    System.out.println(m_dropTriggerStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- DROP INDEXES\");\n  for (int i=0; i < m_dropIndexStatements.size(); i++) {\n    System.out.println(m_dropIndexStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- NEW OR CHANGED INDEXES\");\n  for (int i=0; i < m_newIndexStatements.size(); i++) {\n    System.out.println(m_newIndexStatements.get(i));\n  }\n  System.out.println();\n  System.out.println(\"-- PLEASE CHECK THE SEQUENCES BY HAND - USE:\");\n  System.out.println(\"-- select * from user_sequences;\");\n  System.out.println();\n  System.out.println(getUpdateVersionStatement());\n  System.out.println(\"COMMIT;\");\n}\n", "nl": "Sorts the generated sql statements by applying them to db1 and prints the sorted statement list."}
{"code": "final private void turn22(IntGrid2D grid,int x,int y){\n  int p1, p2, p3, p4;\n  p1=grid.get(grid.stx(x),grid.sty(y));\n  p2=grid.get(grid.stx(x + 1),grid.sty(y));\n  p3=grid.get(grid.stx(x + 1),grid.sty(y + 1));\n  p4=grid.get(grid.stx(x),grid.sty(y + 1));\n  if (p.r.nextBoolean()) {\n    grid.set(grid.stx(x),grid.sty(y),p4);\n    grid.set(grid.stx(x + 1),grid.sty(y),p1);\n    grid.set(grid.stx(x + 1),grid.sty(y + 1),p2);\n    grid.set(grid.stx(x),grid.sty(y + 1),p3);\n  }\n else {\n    grid.set(grid.stx(x),grid.sty(y),p2);\n    grid.set(grid.stx(x + 1),grid.sty(y),p3);\n    grid.set(grid.stx(x + 1),grid.sty(y + 1),p4);\n    grid.set(grid.stx(x),grid.sty(y + 1),p1);\n  }\n}\n", "nl": "Diffuse a 2x2 block clockwise or counter-clockwise. This procedure was published by Toffoli and Margolus to simulate the diffusion in an ideal gas. The 2x2 blocks will be turned by random in one direction (clockwise or counter clockwise). Usually a second run will be done but this time with a offset of one to the previous run"}
{"code": "public static double magnitude(double[] u){\n  return Math.sqrt(dot(u,u));\n}\n", "nl": "Returns the magnitude (Euclidean norm) of the specified vector."}
{"code": "public String toString(){\n  return statusString;\n}\n", "nl": "Returns the String representation for thiz."}
{"code": "public void chopFrame(int offsetDelta,int k){\n  numOfEntries++;\n  output.write(251 - k);\n  write16(offsetDelta);\n}\n", "nl": "Writes a <code>chop_frame</code>."}
{"code": "public AsyncHttpClient(boolean fixNoHttpResponseException,int httpPort,int httpsPort){\n  this(getDefaultSchemeRegistry(fixNoHttpResponseException,httpPort,httpsPort));\n}\n", "nl": "Creates new AsyncHttpClient using given params"}
{"code": "public boolean verify(byte[] signature){\n  return verify(signature,false);\n}\n", "nl": "Verifies the data (computes the secure hash and compares it to the input)"}
{"code": "public synchronized void reqHistoricalData(int tickerId,Contract contract,String endDateTime,String durationStr,String barSizeSetting,String whatToShow,int useRTH,int formatDate,List<TagValue> chartOptions){\n  if (!m_connected) {\n    notConnected();\n    return;\n  }\n  final int VERSION=6;\n  try {\n    if (m_serverVersion < 16) {\n      error(EClientErrors.NO_VALID_ID,EClientErrors.UPDATE_TWS,\"  It does not support historical data backfill.\");\n      return;\n    }\n    if (m_serverVersion < MIN_SERVER_VER_TRADING_CLASS) {\n      if (!IsEmpty(contract.m_tradingClass) || (contract.m_conId > 0)) {\n        error(tickerId,EClientErrors.UPDATE_TWS,\"  It does not support conId and tradingClass parameters in reqHistroricalData.\");\n        return;\n      }\n    }\n    send(REQ_HISTORICAL_DATA);\n    send(VERSION);\n    send(tickerId);\n    if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {\n      send(contract.m_conId);\n    }\n    send(contract.m_symbol);\n    send(contract.m_secType);\n    send(contract.m_expiry);\n    send(contract.m_strike);\n    send(contract.m_right);\n    send(contract.m_multiplier);\n    send(contract.m_exchange);\n    send(contract.m_primaryExch);\n    send(contract.m_currency);\n    send(contract.m_localSymbol);\n    if (m_serverVersion >= MIN_SERVER_VER_TRADING_CLASS) {\n      send(contract.m_tradingClass);\n    }\n    if (m_serverVersion >= 31) {\n      send(contract.m_includeExpired ? 1 : 0);\n    }\n    if (m_serverVersion >= 20) {\n      send(endDateTime);\n      send(barSizeSetting);\n    }\n    send(durationStr);\n    send(useRTH);\n    send(whatToShow);\n    if (m_serverVersion > 16) {\n      send(formatDate);\n    }\n    if (BAG_SEC_TYPE.equalsIgnoreCase(contract.m_secType)) {\n      if (contract.m_comboLegs == null) {\n        send(0);\n      }\n else {\n        send(contract.m_comboLegs.size());\n        ComboLeg comboLeg;\n        for (int i=0; i < contract.m_comboLegs.size(); i++) {\n          comboLeg=contract.m_comboLegs.get(i);\n          send(comboLeg.m_conId);\n          send(comboLeg.m_ratio);\n          send(comboLeg.m_action);\n          send(comboLeg.m_exchange);\n        }\n      }\n    }\n    if (m_serverVersion >= MIN_SERVER_VER_LINKING) {\n      StringBuilder chartOptionsStr=new StringBuilder();\n      int chartOptionsCount=chartOptions == null ? 0 : chartOptions.size();\n      if (chartOptionsCount > 0) {\n        for (int i=0; i < chartOptionsCount; ++i) {\n          TagValue tagValue=(TagValue)chartOptions.get(i);\n          chartOptionsStr.append(tagValue.m_tag);\n          chartOptionsStr.append(\"=\");\n          chartOptionsStr.append(tagValue.m_value);\n          chartOptionsStr.append(\";\");\n        }\n      }\n      send(chartOptionsStr.toString());\n    }\n  }\n catch (  Exception e) {\n    error(tickerId,EClientErrors.FAIL_SEND_REQHISTDATA,\"\" + e);\n    close();\n  }\n}\n", "nl": "Note that formatData parameter affects intra-day bars only; 1-day bars always return with date in YYYYMMDD format."}
{"code": "@Override public String toString(){\n  return name().toLowerCase();\n}\n", "nl": "Returns the string representation of this instance, suitable for use in output. This is a lowercase version of the name."}
{"code": "public StringBand(int initialCapacity){\n  if (initialCapacity <= 0) {\n    throw new IllegalArgumentException(\"Invalid initial capacity\");\n  }\n  array=new String[initialCapacity];\n}\n", "nl": "Creates an empty <code>StringBand</code> with provided capacity. Capacity refers to internal string array (i.e. number of joins) and not the total string size."}
{"code": "public boolean removeConstraint(ParticleConstraint2D c){\n  return constraints.remove(c);\n}\n", "nl": "Attempts to remove the given constraint instance from the list of active constraints."}
{"code": "private DoneCallback(GridClientFutureCallback<R,T> cb,GridClientFutureListener<R> lsnr,GridClientFutureAdapter<T> chainedFut){\n  this.cb=cb;\n  this.lsnr=lsnr;\n  this.chainedFut=chainedFut;\n}\n", "nl": "Constructs future finished notification callback."}
{"code": "private void addSignatureProfile(SignatureWrapper signature,XmlSignature xmlSignature){\n  SignatureType signatureType=SignatureType.NA;\n  String certificateId=signature.getSigningCertificateId();\n  if (certificateId != null) {\n    signatureType=getSignatureType(certificateId);\n  }\n  xmlSignature.setSignatureLevel(signatureType.name());\n}\n", "nl": "Here we determine the type of the signature."}
{"code": "public boolean isArray(){\n  return false;\n}\n", "nl": "Determines if this Class object represents an array class."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:00:03.708 -0400\",hash_original_method=\"AD50C4AE43C84CAFDA529E78BF7FE7D8\",hash_generated_method=\"C8CCC8804046A2687F8D3D90AEE56A06\") public Collection<? extends Certificate> engineGenerateCertificates(InputStream inStream) throws CertificateException {\n  if (inStream == null) {\n    throw new CertificateException(\"inStream == null\");\n  }\n  ArrayList<Certificate> result=new ArrayList<Certificate>();\n  try {\n    if (!inStream.markSupported()) {\n      inStream=new RestoringInputStream(inStream);\n    }\n    byte[] encoding=null;\n    int second_asn1_tag=-1;\n    inStream.mark(1);\n    int ch;\n    while ((ch=inStream.read()) != -1) {\n      if (ch == '-') {\n        encoding=decodePEM(inStream,FREE_BOUND_SUFFIX);\n      }\n else       if (ch == 0x30) {\n        encoding=null;\n        inStream.reset();\n        inStream.mark(CERT_CACHE_SEED_LENGTH);\n      }\n else {\n        if (result.size() == 0) {\n          throw new CertificateException(\"Unsupported encoding\");\n        }\n else {\n          inStream.reset();\n          return result;\n        }\n      }\n      BerInputStream in=(encoding == null) ? new BerInputStream(inStream) : new BerInputStream(encoding);\n      second_asn1_tag=in.next();\n      if (encoding == null) {\n        inStream.reset();\n      }\n      if (second_asn1_tag != ASN1Constants.TAG_C_SEQUENCE) {\n        if (result.size() == 0) {\n          break;\n        }\n else {\n          return result;\n        }\n      }\n else {\n        if (encoding == null) {\n          result.add(getCertificate(inStream));\n        }\n else {\n          result.add(getCertificate(encoding));\n        }\n      }\n      inStream.mark(1);\n    }\n    if (result.size() != 0) {\n      return result;\n    }\n else     if (ch == -1) {\n      return result;\n    }\n    if (second_asn1_tag == ASN1Constants.TAG_OID) {\n      ContentInfo info=(ContentInfo)((encoding != null) ? ContentInfo.ASN1.decode(encoding) : ContentInfo.ASN1.decode(inStream));\n      SignedData data=info.getSignedData();\n      if (data == null) {\n        throw new CertificateException(\"Invalid PKCS7 data provided\");\n      }\n      List<org.apache.harmony.security.x509.Certificate> certs=data.getCertificates();\n      if (certs != null) {\n        for (        org.apache.harmony.security.x509.Certificate cert : certs) {\n          result.add(new X509CertImpl(cert));\n        }\n      }\n      return result;\n    }\n    throw new CertificateException(\"Unsupported encoding\");\n  }\n catch (  IOException e) {\n    throw new CertificateException(e);\n  }\n}\n", "nl": "Generates the collection of the certificates on the base of provided via input stream encodings."}
{"code": "public NewSessionAction(){\n  super(\"New Session\");\n}\n", "nl": "Creates a new session action for the given desktop."}
{"code": "private StringBuilder appendIfNotNull(StringBuilder source,String addStr,String delimiter){\n  if (addStr != null) {\n    if (addStr.length() == 0) {\n      delimiter=\"\";\n    }\n    return source.append(addStr).append(delimiter);\n  }\n  return source;\n}\n", "nl": "Takes a string and adds to it, with a separator, if the bit to be added isn't null. Since the logger takes so many arguments that might be null, this method helps cut out some of the agonizing tedium of writing the same 3 lines over and over."}
{"code": "public void write(OutStream out) throws IOException {\n  out.flushBits();\n  out.writeUBits(5,getBitSize());\n  out.writeSBits(bitSize,minX);\n  out.writeSBits(bitSize,maxX);\n  out.writeSBits(bitSize,minY);\n  out.writeSBits(bitSize,maxY);\n  out.flushBits();\n}\n", "nl": "Write the rect contents to the output stream"}
{"code": "@SuppressWarnings(\"unused\") private void checkCenter(LatLon center){\n  System.out.println(\"Testing fromLatLngToPoint using: \" + center);\n  Point2D p=googleMap.fromLatLngToPoint(center.toLatLong());\n  System.out.println(\"Testing fromLatLngToPoint result: \" + p);\n  System.out.println(\"Testing fromLatLngToPoint expected: \" + mapComponent.getWidth() / 2 + \", \" + mapComponent.getHeight() / 2);\n  System.out.println(\"type = \" + MarkerType.BROWN.iconPath());\n}\n", "nl": "Demonstrates how to go from lat/lon to pixel coordinates."}
{"code": "public BusinessObjectDataAttributeEntity createBusinessObjectDataAttributeEntity(String namespaceCode,String businessObjectDefinitionName,String businessObjectFormatUsage,String businessObjectFormatFileType,Integer businessObjectFormatVersion,String businessObjectDataPartitionValue,List<String> businessObjectDataSubPartitionValues,Integer businessObjectDataVersion,String businessObjectDataAttributeName,String businessObjectDataAttributeValue){\n  BusinessObjectDataKey businessObjectDataKey=new BusinessObjectDataKey(namespaceCode,businessObjectDefinitionName,businessObjectFormatUsage,businessObjectFormatFileType,businessObjectFormatVersion,businessObjectDataPartitionValue,businessObjectDataSubPartitionValues,businessObjectDataVersion);\n  return createBusinessObjectDataAttributeEntity(businessObjectDataKey,businessObjectDataAttributeName,businessObjectDataAttributeValue);\n}\n", "nl": "Creates and persists a new business object data attribute entity."}
{"code": "private synchronized boolean containsMapping(Object key,Object value){\n  int hash=Collections.secondaryHash(key);\n  HashtableEntry<K,V>[] tab=table;\n  int index=hash & (tab.length - 1);\n  for (HashtableEntry<K,V> e=tab[index]; e != null; e=e.next) {\n    if (e.hash == hash && e.key.equals(key)) {\n      return e.value.equals(value);\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if this map contains the specified mapping."}
{"code": "public Setting(Object value,int type,boolean save,String file){\n  this.value=value;\n  if (type == MAP) {\n    this.defaultValue=new HashMap<>((Map)value);\n  }\n else   if (type == LIST) {\n    this.defaultValue=copyCollection((Collection)value);\n  }\n else {\n    this.defaultValue=value;\n  }\n  this.save=save;\n  this.type=type;\n  this.file=file;\n}\n", "nl": "Creates a new Setting object with some initial values."}
{"code": "protected void layoutGraphicModifiers(DrawContext dc,AVList modifiers,OrderedSymbol osym){\n}\n", "nl": "Layout static graphic modifiers around the symbol. Static modifiers are not expected to change due to changes in view. The static layout is computed when a modifier is changed, but may not be computed each frame. For example, a text modifier indicating a symbol identifier would only need to be laid out when the text is changed, so this is best treated as a static modifier. However a direction of movement line that needs to be computed based on the current eye position should be treated as a dynamic modifier."}
{"code": "@HLEFunction(nid=0xE1D621D7,version=150,checkInsideInterrupt=true) public int sceNetAdhocInit(){\n  log.info(String.format(\"sceNetAdhocInit: using MAC address=%s, nick name='%s'\",sceNet.convertMacAddressToString(Wlan.getMacAddress()),sceUtility.getSystemParamNickname()));\n  if (isInitialized) {\n    return SceKernelErrors.ERROR_NET_ADHOC_ALREADY_INITIALIZED;\n  }\n  isInitialized=true;\n  return 0;\n}\n", "nl": "Initialize the adhoc library."}
{"code": "public Assignment(List<String> booleanAssigns){\n  this();\n  booleanAssigns.stream().forEach(null);\n}\n", "nl": "Creates an assignment with a list of boolean assignments (cf. method above)."}
{"code": "public void testMergeSameFilterInTwoDocuments() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"  <filter-mapping>\"+ \"    <filter-name>f1</filter-name>\"+ \"    <url-pattern>/f1mapping1</url-pattern>\"+ \"  </filter-mapping>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  String mergeXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"  <filter-mapping>\"+ \"    <filter-name>f1</filter-name>\"+ \"    <url-pattern>/f1mapping1</url-pattern>\"+ \"  </filter-mapping>\"+ \"</web-app>\";\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(mergeXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.mergeFilters(mergeWebXml);\n  assertTrue(WebXmlUtils.hasFilter(srcWebXml,\"f1\"));\n  List<String> filterMappings=WebXmlUtils.getFilterMappings(srcWebXml,\"f1\");\n  assertEquals(1,filterMappings.size());\n  assertEquals(\"/f1mapping1\",filterMappings.get(0));\n}\n", "nl": "Tests whether the same filter in two different files is mapped correctly (i.e., once)."}
{"code": "public static int countPeriods(String haystack){\n  return StringUtils.countOccurrencesOf(haystack,\".\");\n}\n", "nl": "Count the number of periods in a value."}
{"code": "public TwoColumnOutput(Writer out,int leftWidth,int rightWidth,String spacer){\n  if (out == null) {\n    throw new NullPointerException(\"out == null\");\n  }\n  if (leftWidth < 1) {\n    throw new IllegalArgumentException(\"leftWidth < 1\");\n  }\n  if (rightWidth < 1) {\n    throw new IllegalArgumentException(\"rightWidth < 1\");\n  }\n  if (spacer == null) {\n    throw new NullPointerException(\"spacer == null\");\n  }\n  StringWriter leftWriter=new StringWriter(1000);\n  StringWriter rightWriter=new StringWriter(1000);\n  this.out=out;\n  this.leftWidth=leftWidth;\n  this.leftBuf=leftWriter.getBuffer();\n  this.rightBuf=rightWriter.getBuffer();\n  this.leftColumn=new IndentingWriter(leftWriter,leftWidth);\n  this.rightColumn=new IndentingWriter(rightWriter,rightWidth,spacer);\n}\n", "nl": "Constructs an instance."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(nodegetfirstchildnull.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public void actionPerformed(ActionEvent e){\n  JTextComponent target=getTextComponent(e);\n  if ((target != null) && (e != null)) {\n    if ((!target.isEditable()) || (!target.isEnabled())) {\n      UIManager.getLookAndFeel().provideErrorFeedback(target);\n      return;\n    }\n    String content=target.getText();\n    if (content != null && target.getSelectionStart() > 0) {\n      content=content.substring(0,target.getSelectionStart());\n    }\n    if (content != null) {\n      target.setText(getNextMatch(content));\n      adaptor.markText(content.length());\n    }\n  }\n}\n", "nl": "Shows the next match."}
{"code": "public void clear(){\n  super.clear();\n  LEFT_PARENTHESES=\"\";\n  RIGHT_PARENTHESES=\"\";\n}\n", "nl": "removes the stored data but retains the dimensions of the matrix."}
{"code": "public void deleteChannel(CumulusChannel jsonChannel){\n  String jsonString=jsonChannel.toString();\n  Intent i=new Intent(\"com.felkertech.cumulustv.RECEIVER\");\n  i.putExtra(INTENT_EXTRA_JSON,jsonString);\n  i.putExtra(INTENT_EXTRA_ACTION,INTENT_EXTRA_ACTION_DELETE);\n  sendBroadcast(i);\n  finish();\n}\n", "nl": "Deletes the provided channel and resyncs. Then the app closes."}
{"code": "public static String toStringExclude(Object object,Collection excludeFieldNames){\n  return toStringExclude(object,toNoNullStringArray(excludeFieldNames));\n}\n", "nl": "Builds a String for a toString method excluding the given field names."}
{"code": "public StringDict(BufferedReader reader){\n  String[] lines=PApplet.loadStrings(reader);\n  keys=new String[lines.length];\n  values=new String[lines.length];\n  for (int i=0; i < lines.length; i++) {\n    String[] pieces=PApplet.split(lines[i],'\\t');\n    if (pieces.length == 2) {\n      keys[count]=pieces[0];\n      values[count]=pieces[1];\n      count++;\n    }\n  }\n}\n", "nl": "Read a set of entries from a Reader that has each key/value pair on a single line, separated by a tab."}
{"code": "static <K,V>void writeMap(Map<K,V> map,ObjectOutputStream stream) throws IOException {\n  stream.writeInt(map.size());\n  for (  Map.Entry<K,V> entry : map.entrySet()) {\n    stream.writeObject(entry.getKey());\n    stream.writeObject(entry.getValue());\n  }\n}\n", "nl": "Stores the contents of a map in an output stream, as part of serialization. It does not support concurrent maps whose content may change while the method is running. <p>The serialized output consists of the number of entries, first key, first value, second key, second value, and so on."}
{"code": "public NioDatagramAcceptor(){\n  this(new DefaultDatagramSessionConfig(),null);\n}\n", "nl": "Creates a new instance."}
{"code": "public final <V>V callWithRetry(Callable<V> callable,Predicate<Throwable> isRetryable){\n  int failures=0;\n  while (true) {\n    try {\n      return callable.call();\n    }\n catch (    Throwable e) {\n      if (++failures == attempts || !isRetryable.apply(e)) {\n        throwIfUnchecked(e);\n        throw new RuntimeException(e);\n      }\n      logger.info(e,\"Retrying transient error, attempt \" + failures);\n      try {\n        sleeper.sleep(Duration.millis(pow(2,failures) * 100));\n      }\n catch (      InterruptedException e2) {\n        Thread.currentThread().interrupt();\n        throwIfUnchecked(e);\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}\n", "nl": "Retries a unit of work in the face of transient errors. <p>Retrying is done a fixed number of times, with exponential backoff, if the exception that is thrown is deemed retryable by the predicate. If the error is not considered retryable, or if the thread is interrupted, or if the allowable number of attempts has been exhausted, the original exception is propagated through to the caller."}
{"code": "public int size(){\n  return n;\n}\n", "nl": "Returns the number of items in this queue."}
{"code": "public String toXML(Network network){\n  StringWriter writer=new StringWriter();\n  writeXML(network,writer);\n  writer.flush();\n  return writer.toString();\n}\n", "nl": "Covert the network into xml."}
{"code": "private String parseEntityAttribute(String fieldName){\n  Matcher m=_fnPattern.matcher(fieldName);\n  if (m.find()) {\n    return m.group(1);\n  }\n  return null;\n}\n", "nl": "check whether this field is one entity attribute or not"}
{"code": "void addScrapView(View scrap,int position,int viewType){\n  if (viewTypeCount == 1) {\n    currentScrapViews.put(position,scrap);\n  }\n else {\n    scrapViews[viewType].put(position,scrap);\n  }\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n    scrap.setAccessibilityDelegate(null);\n  }\n}\n", "nl": "Put a view into the ScrapViews list. These views are unordered."}
{"code": "public AStart(){\n}\n", "nl": "Construct the applet"}
{"code": "public static void dispose(){\n  disposeColors();\n  disposeImages();\n  disposeFonts();\n  disposeCursors();\n}\n", "nl": "Dispose of cached objects and their underlying OS resources. This should only be called when the cached objects are no longer needed (e.g. on application shutdown)."}
{"code": "protected int bends(Geo g1,Geo g2,Geo g3){\n  double bend=g1.crossNormalize(g2).distance(g3) - (Math.PI / 2.0);\n  if (Math.abs(bend) < .0001) {\n    return STRAIGHT;\n  }\n else {\n    if (bend < 0) {\n      return BENDS_LEFT;\n    }\n  }\n  return BENDS_RIGHT;\n}\n", "nl": "Method that determines which way the angle between the three points bends."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase TypesPackage.PRIMITIVE_TYPE__DECLARED_ELEMENT_TYPE:\n    return declaredElementType != null;\ncase TypesPackage.PRIMITIVE_TYPE__ASSIGNMENT_COMPATIBLE:\n  return assignmentCompatible != null;\ncase TypesPackage.PRIMITIVE_TYPE__AUTOBOXED_TYPE:\nreturn autoboxedType != null;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Description(summary=\"Create h2client.jar with only the remote JDBC implementation.\") public void jarClient(){\n  compile(true,true,false);\n  FileList files=files(\"temp\").exclude(\"temp/org/h2/build/*\").exclude(\"temp/org/h2/dev/*\").exclude(\"temp/org/h2/jaqu/*\").exclude(\"temp/org/h2/java/*\").exclude(\"temp/org/h2/jcr/*\").exclude(\"temp/org/h2/mode/*\").exclude(\"temp/org/h2/samples/*\").exclude(\"temp/org/h2/test/*\").exclude(\"*.bat\").exclude(\"*.sh\").exclude(\"*.txt\").exclude(\"*.DS_Store\");\n  files=excludeTestMetaInfFiles(files);\n  long kb=jar(\"bin/h2-client\" + getJarSuffix(),files,\"temp\");\n  if (kb < 350 || kb > 450) {\n    throw new RuntimeException(\"Expected file size 350 - 450 KB, got: \" + kb);\n  }\n}\n", "nl": "Create the h2client.jar. This only contains the remote JDBC implementation."}
{"code": "public Messages(String name){\n  this((Messages)null,name);\n}\n", "nl": "Creates a messages bundle by full name."}
{"code": "public void providesSingletonInScope(){\n  Binding.this.singletonInScope();\n  isProvidingSingletonInScope=true;\n}\n", "nl": "to provide a singleton using the binding's scope and reuse it inside the binding's scope"}
{"code": "public void dispose(){\n  m_table.getColumn(m_field).removeColumnListener(this);\n}\n", "nl": "Dispose of this metadata, freeing any resources and unregistering any listeners."}
{"code": "public void updateUI(){\n  super.updateUI();\n  if (myTree != null) {\n    myTree.updateUI();\n  }\n  LookAndFeel.installColorsAndFont(this,\"Tree.background\",\"Tree.foreground\",\"Tree.font\");\n}\n", "nl": "Overridden to message super and forward the method to the tree. Since the tree is not actually in the component hierarchy it will never receive this unless we forward it in this manner."}
{"code": "public ResourceNotificationException(String message){\n  super(message);\n}\n", "nl": "Creates a new <code>ResourceNotificationException</code> object"}
{"code": "public static double variance(double[] vector){\n  double sum=0, sumSquared=0;\n  if (vector.length <= 1) {\n    return 0;\n  }\n  for (int i=0; i < vector.length; i++) {\n    sum+=vector[i];\n    sumSquared+=(vector[i] * vector[i]);\n  }\n  double result=(sumSquared - (sum * sum / (double)vector.length)) / (double)(vector.length - 1);\n  if (result < 0) {\n    return 0;\n  }\n else {\n    return result;\n  }\n}\n", "nl": "Computes the variance for an array of doubles."}
{"code": "@Override public Class<? extends Task> taskClass(){\n  return IgniteSinkTask.class;\n}\n", "nl": "Obtains a sink task class to be instantiated for feeding data into grid."}
{"code": "public String createNode(final String path,final boolean watch,final boolean ephimeral){\n  String createdNodePath=null;\n  try {\n    final Stat nodeStat=zooKeeper.exists(path,watch);\n    if (nodeStat == null) {\n      createdNodePath=zooKeeper.create(path,new byte[0],Ids.OPEN_ACL_UNSAFE,(ephimeral ? CreateMode.EPHEMERAL_SEQUENTIAL : CreateMode.PERSISTENT));\n    }\n else {\n      createdNodePath=path;\n    }\n  }\n catch (  KeeperException|InterruptedException e) {\n    throw new IllegalStateException(e);\n  }\n  return createdNodePath;\n}\n", "nl": "Create a zookeeper node"}
{"code": "static ClassLoader findClassLoader() throws ConfigurationError {\n  SecuritySupport ss=SecuritySupport.getInstance();\n  ClassLoader context=ss.getContextClassLoader();\n  ClassLoader system=ss.getSystemClassLoader();\n  ClassLoader chain=system;\n  while (true) {\n    if (context == chain) {\n      ClassLoader current=ObjectFactory.class.getClassLoader();\n      chain=system;\n      while (true) {\n        if (current == chain) {\n          return system;\n        }\n        if (chain == null) {\n          break;\n        }\n        chain=ss.getParentClassLoader(chain);\n      }\n      return current;\n    }\n    if (chain == null) {\n      break;\n    }\n    chain=ss.getParentClassLoader(chain);\n  }\n  ;\n  return context;\n}\n", "nl": "Figure out which ClassLoader to use.  For JDK 1.2 and later use the context ClassLoader."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public boolean isCellEditable(EventObject anEvent){\n  if (!m_mField.isEditable(false))   return false;\n  log.fine(m_mField.getHeader());\n  if (anEvent instanceof MouseEvent && ((MouseEvent)anEvent).getClickCount() < CLICK_TO_START)   return false;\n  if (m_editor == null)   createEditor();\n  return true;\n}\n", "nl": "Ask the editor if it can start editing using anEvent. If editing can be started this method returns true. Previously called: MTable.isCellEditable"}
{"code": "public void applyAll(Collection<? extends IChange> changes) throws BadLocationException {\n  final Map<URI,List<IAtomicChange>> changesPerFile=organize(changes);\n  for (  URI currURI : changesPerFile.keySet()) {\n    final IXtextDocument document=getDocument(currURI);\n    applyAllInSameDocument(changesPerFile.get(currURI),document);\n  }\n}\n", "nl": "Applies all given changes."}
{"code": "public void beginApplyInterval(){\n  intervalStartMillis=System.currentTimeMillis();\n  endMillis=intervalStartMillis;\n  state=TaskState.apply;\n}\n", "nl": "Start an apply interval."}
{"code": "public void updateDataset(CandleDataset source,int seriesIndex,boolean newBar){\n  if (source == null) {\n    throw new IllegalArgumentException(\"Null source (CandleDataset).\");\n  }\n  for (int i=0; i < this.getSeriesCount(); i++) {\n    CandleSeries series=this.getSeries(i);\n    series.updateSeries(source.getSeries(seriesIndex),source.getSeries(seriesIndex).getItemCount() - 1,newBar);\n  }\n}\n", "nl": "Method updateDataset."}
{"code": "public int optInt(String key){\n  return this.optInt(key,0);\n}\n", "nl": "Get an optional int value associated with a key, or zero if there is no such key or if the value is not a number. If the value is a string, an attempt will be made to evaluate it as a number."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:30:28.318 -0500\",hash_original_method=\"FEDEC1668E99CC7AC8B63903F046C2E4\",hash_generated_method=\"270B33800028B49BD2EC75D7757AD67D\") @Override protected void onStartLoading(){\n  if (mCursor != null) {\n    deliverResult(mCursor);\n  }\n  if (takeContentChanged() || mCursor == null) {\n    forceLoad();\n  }\n}\n", "nl": "Starts an asynchronous load of the contacts list data. When the result is ready the callbacks will be called on the UI thread. If a previous load has been completed and is still valid the result may be passed to the callbacks immediately. Must be called from the UI thread"}
{"code": "public boolean sameAs(DiskStore other){\n  if (this.autoCompact != other.getAutoCompact()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_AUTOCOMPACT_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.autoCompact,other.getAutoCompact()}));\n  }\n  if (this.compactionThreshold != other.getCompactionThreshold()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_COMPACTIONTHRESHOLD_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.compactionThreshold,other.getCompactionThreshold()}));\n  }\n  if (this.allowForceCompaction != other.getAllowForceCompaction()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_ALLOWFORCECOMPACTION_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.allowForceCompaction,other.getAllowForceCompaction()}));\n  }\n  if (this.maxOplogSizeInBytes != other.getMaxOplogSize() * 1024 * 1024) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_MAXOPLOGSIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.maxOplogSizeInBytes / 1024 / 1024,other.getMaxOplogSize()}));\n  }\n  if (this.timeInterval != other.getTimeInterval()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_TIMEINTERVAL_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.timeInterval,other.getTimeInterval()}));\n  }\n  if (this.writeBufferSize != other.getWriteBufferSize()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_WRITEBUFFERSIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.writeBufferSize,other.getWriteBufferSize()}));\n  }\n  if (this.queueSize != other.getQueueSize()) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_QUEUESIZE_OF_0_IS_NOT_THE_SAME_THIS_1_OTHER_2.toLocalizedString(new Object[]{name,this.queueSize,other.getQueueSize()}));\n  }\n  if (!equal(this.diskDirs,other.getDiskDirs())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_DIRS_OF_0_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  if (!equal(this.diskDirSizes,other.getDiskDirSizes())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_DIR_SIZES_OF_0_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  if (!equal(getDiskUsageWarningPercentage(),other.getDiskUsageWarningPercentage())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_USAGE_WARN_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  if (!equal(getDiskUsageCriticalPercentage(),other.getDiskUsageCriticalPercentage())) {\n    throw new RuntimeException(LocalizedStrings.DiskStoreAttributesCreation_DISK_USAGE_CRITICAL_ARE_NOT_THE_SAME.toLocalizedString(name));\n  }\n  return true;\n}\n", "nl": "Returns whether or not this <code>DiskStoreCreation</code> is equivalent to another <code>DiskStore</code>."}
{"code": "public JsonWriter name(String name) throws IOException {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  beforeName();\n  string(name);\n  return this;\n}\n", "nl": "Encodes the property name."}
{"code": "protected void changeTimeBy(long amount){\n  changeTimeBy(amount,timeWrap,(amount >= 0 ? TimerStatus.FORWARD : TimerStatus.BACKWARD));\n}\n", "nl": "Call setTime with the amount given added to the current time. The amount should be negative if you are going backward through time. You need to make sure manageGraphics is called for the map to update. <p>"}
{"code": "public void testCreateRenameNoClose() throws Exception {\n  if (dual)   return;\n  create(igfs,paths(DIR,SUBDIR),null);\n  IgfsOutputStream os=null;\n  try {\n    os=igfs.create(FILE,true);\n    igfs.rename(FILE,FILE2);\n    os.close();\n  }\n  finally {\n    U.closeQuiet(os);\n  }\n}\n", "nl": "Test rename on the file when it was opened for write(create) and is not closed yet."}
{"code": "public boolean equals(Object other){\n  if (other == null)   return false;\n  if (getClass() != other.getClass()) {\n    return false;\n  }\n  HostPort that=(HostPort)other;\n  return port == that.port && host.equals(that.host);\n}\n", "nl": "returns true if the two objects are equals, false otherwise."}
{"code": "public static void ensureParentFolderHierarchyExists(IFolder folder){\n  IContainer parent=folder.getParent();\n  if (parent instanceof IFolder) {\n    ensureFolderHierarchyExists((IFolder)parent);\n  }\n}\n", "nl": "Ensures the given folder's parent hierarchy is created if they do not already exist."}
{"code": "private Trees(){\n  throw new UnsupportedOperationException();\n}\n", "nl": "Utility classes should not be instantiated."}
{"code": "private Element drawLine(DBIDRef iter){\n  SVGPath path=new SVGPath();\n  final SpatialComparable obj=relation.get(iter);\n  final int dims=proj.getVisibleDimensions();\n  boolean drawn=false;\n  int valid=0;\n  double prevpos=Double.NaN;\n  for (int i=0; i < dims; i++) {\n    final int d=proj.getDimForAxis(i);\n    double minPos=proj.fastProjectDataToRenderSpace(obj.getMin(d),i);\n    if (minPos != minPos) {\n      valid=0;\n      continue;\n    }\n    ++valid;\n    if (valid > 1) {\n      if (valid == 2) {\n        path.moveTo(getVisibleAxisX(d - 1),prevpos);\n      }\n      path.lineTo(getVisibleAxisX(d),minPos);\n      drawn=true;\n    }\n    prevpos=minPos;\n  }\n  valid=0;\n  for (int i=dims - 1; i >= 0; i--) {\n    final int d=proj.getDimForAxis(i);\n    double maxPos=proj.fastProjectDataToRenderSpace(obj.getMax(d),i);\n    if (maxPos != maxPos) {\n      valid=0;\n      continue;\n    }\n    ++valid;\n    if (valid > 1) {\n      if (valid == 2) {\n        path.moveTo(getVisibleAxisX(d + 1),prevpos);\n      }\n      path.lineTo(getVisibleAxisX(d),maxPos);\n      drawn=true;\n    }\n    prevpos=maxPos;\n  }\n  if (!drawn) {\n    return null;\n  }\n  return path.makeElement(svgp);\n}\n", "nl": "Draw a single line."}
{"code": "public void testExceptionWithEmpty() throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  try {\n    Object result=mapper.readValue(\"    \",Object.class);\n    fail(\"Expected an exception, but got result value: \" + result);\n  }\n catch (  Exception e) {\n    verifyException(e,EOFException.class,\"No content\");\n  }\n}\n", "nl": "Simple test to check behavior when end-of-stream is encountered without content. Should throw EOFException."}
{"code": "@Override public void dropUser(User user,boolean ignore) throws SQLException {\n  String sql=String.format(\"drop user %s\",user.getLogin());\n  try {\n    execute(sql);\n  }\n catch (  SQLException e) {\n    if (!ignore) {\n      throw e;\n    }\n else     if (logger.isDebugEnabled()) {\n      logger.debug(\"Drop user failed: \" + sql,e);\n    }\n  }\n}\n", "nl": "Drops user, ignoring errors if desired by caller."}
{"code": "public boolean loadSoundEffects(){\n  int attempts=3;\n  LoadSoundEffectReply reply=new LoadSoundEffectReply();\nsynchronized (reply) {\n    sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,reply,0);\n    while ((reply.mStatus == 1) && (attempts-- > 0)) {\n      try {\n        reply.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);\n      }\n catch (      InterruptedException e) {\n        Log.w(TAG,\"loadSoundEffects Interrupted while waiting sound pool loaded.\");\n      }\n    }\n  }\n  return (reply.mStatus == 0);\n}\n", "nl": "Loads samples into the soundpool. This method must be called at first when sound effects are enabled"}
{"code": "public static final int gcd(int p,int q){\n  if (q == 0) {\n    return p;\n  }\n  return gcd(q,p % q);\n}\n", "nl": "Computes the Greatest Common Devisor of integers p and q."}
{"code": "public static void sort(int[] keys,int[] values,int offset,int length){\n  hybridsort(keys,values,offset,offset + length - 1);\n}\n", "nl": "Sorts a range from the keys in an increasing order. Elements key[i] and values[i] are always swapped together in the corresponding arrays. <p> A mixture of several sorting algorithms is used: <p> A radix sort performs better on the numeric data we sort, but requires additional storage to perform the sorting. Therefore only the not-very-large parts produced by a quick sort are sorted with radix sort. An insertion sort is used to sort the smallest arrays, where the the overhead of the radix sort is also bigger"}
{"code": "public boolean isRegistered(ObjectName name){\n  return mbsInterceptor.isRegistered(name);\n}\n", "nl": "Checks whether an MBean, identified by its object name, is already registered with the MBean server."}
{"code": "private void startItemListItem(StringBuilder result,String rootId,String itemId){\n  result.append(\"<div class=\\\"subtree\\\">\");\n  result.append(\"<div class=\\\"alone \" + itemId + \"\\\" id=\\\"alone_\"+ rootId+ \":\"+ itemId+ \"\\\">\");\n}\n", "nl": "Called to start adding an item to an item list."}
{"code": "void write(ImageOutputStream ios) throws IOException {\n}\n", "nl": "Writes the data for this segment to the stream in valid JPEG format."}
{"code": "public PatternEveryExpr(){\n}\n", "nl": "Ctor - for use to create a pattern expression tree, without pattern child expression."}
{"code": "private boolean tryQueueCurrentBuffer(long elapsedWaiting){\n  if (currentBuffer.isEmpty())   return true;\n  if (isOpen && neverPubQueue.size() < neverPubCapacity) {\n    neverPubQueue.add(currentBuffer);\n    totalQueuedRecords.addAndGet(currentBuffer.sizeRecords());\n    totalQueuedBuffers.incrementAndGet();\n    onQueueBufferSuccess(currentBuffer,elapsedWaiting);\n    currentBuffer=new RecordBuffer<>(flow);\n    return true;\n  }\n else   if (elapsedWaiting > 0) {\n    onQueueBufferTimeout(currentBuffer,elapsedWaiting);\n    return false;\n  }\n else   return false;\n}\n", "nl": "Keep private. Call only when holding lock."}
{"code": "private void writeKeysWithPrefix(String prefix,String exclude){\n  for (  String key : keys) {\n    if (key.startsWith(prefix) && !key.startsWith(exclude)) {\n      ps.println(key + \"=\" + prop.getProperty(key));\n    }\n  }\n  ps.println();\n}\n", "nl": "writes all keys starting with the specified prefix and not starting with the exclude prefix in alphabetical order."}
{"code": "public ProtocolInfo(String name,Collection<Form> connectionForms,Collection<Form> sharingProfileForms){\n  this.name=name;\n  this.connectionForms=connectionForms;\n  this.sharingProfileForms=sharingProfileForms;\n}\n", "nl": "Creates a new ProtocolInfo having the given name and forms. The given collections of forms are used to describe the parameters for connections and sharing profiles respectively."}
{"code": "public Prepared prepare(String sql){\n  Prepared p=parse(sql);\n  p.prepare();\n  if (currentTokenType != END) {\n    throw getSyntaxError();\n  }\n  return p;\n}\n", "nl": "Parse the statement and prepare it for execution."}
{"code": "void analyze(boolean verbose){\n  if (verbose) {\n    if (traces.length > 1)     System.out.println(\"Combining \" + traces.length + \" traces.\");\n  }\n  final Tree tree0=getTree(0);\n  double[][] changed=new double[tree0.getNodeCount()][tree0.getNodeCount()];\n  double[] rateConditionalOnChange=new double[tree0.getNodeCount()];\n  boolean changesFound=false;\n  cladeSet=new CladeSet(tree0);\n  treeSet=new FrequencySet<String>();\n  treeSet.add(Tree.Utils.uniqueNewick(tree0,tree0.getRoot()));\n  final int reportRate=60;\n  for (  TreeTrace trace : traces) {\n    final int treeCount=trace.getTreeCount(burnin * trace.getStepSize());\n    final double stepSize=treeCount / (double)reportRate;\n    int counter=1;\n    if (verbose) {\n      System.out.println(\"Analyzing \" + treeCount + \" trees...\");\n      System.out.println(\"0              25             50             75            100\");\n      System.out.println(\"|--------------|--------------|--------------|--------------|\");\n      System.out.print(\"*\");\n    }\n    for (int i=1; i < treeCount; i++) {\n      Tree tree=trace.getTree(i,burnin * trace.getStepSize());\n      for (int j=0; j < tree.getNodeCount(); j++) {\n        if (tree.getNode(j) != tree.getRoot() && tree.getNodeAttribute(tree.getNode(j),\"changed\") != null) {\n          changesFound=true;\n          final Object o=tree.getNodeAttribute(tree.getNode(j),\"changed\");\n          if (o != null) {\n            boolean ch=getChanged(tree,j);\n            if (ch) {\n              rateConditionalOnChange[j]+=(Double)tree.getNodeAttribute(tree.getNode(j),\"rate\");\n            }\n            for (int k=0; k < tree.getNodeCount(); k++) {\n              if (tree.getNode(k) != tree.getRoot()) {\n                changed[j][k]+=(ch && getChanged(tree,k)) ? 1 : 0;\n              }\n            }\n          }\n        }\n      }\n      cladeSet.add(tree);\n      treeSet.add(Tree.Utils.uniqueNewick(tree,tree.getRoot()));\n      if (verbose && i >= (int)Math.round(counter * stepSize) && counter <= reportRate) {\n        System.out.print(\"*\");\n        System.out.flush();\n        counter+=1;\n      }\n    }\n    if (verbose) {\n      System.out.println(\"*\");\n    }\n  }\n  if (changesFound) {\n    for (int j=0; j < tree0.getNodeCount(); j++) {\n      System.out.println(j + \"\\t\" + rateConditionalOnChange[j]);\n    }\n    System.out.println();\n    for (int j=0; j < tree0.getNodeCount(); j++) {\n      for (int k=0; k < tree0.getNodeCount(); k++) {\n        System.out.print(changed[j][k] + \"\\t\");\n      }\n      System.out.println();\n    }\n  }\n}\n", "nl": "Actually analyzes the trace given the burnin"}
{"code": "public void logging(String msg1,String msg2,String msg3){\n  System.out.print(msg1);\n  System.out.print(\" \");\n  System.out.print(msg2);\n  System.out.print(\" \");\n  System.out.println(msg3);\n}\n", "nl": "Prints a log message."}
{"code": "public void initQueryStringHandlers(){\n  this.transport=new SimpleTargetedChain();\n  this.transport.setOption(\"qs.list\",\"org.apache.axis.transport.http.QSListHandler\");\n  this.transport.setOption(\"qs.method\",\"org.apache.axis.transport.http.QSMethodHandler\");\n  this.transport.setOption(\"qs.wsdl\",\"org.apache.axis.transport.http.QSWSDLHandler\");\n}\n", "nl": "Initialize a Handler for the transport defined in the Axis server config. This includes optionally filling in query string handlers."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:00:42.071 -0500\",hash_original_method=\"236CE70381CAE691CF8D03F3D0A7E2E8\",hash_generated_method=\"34048EFAD324F63AAF648818713681BB\") public static String toUpperCase(String string){\n  boolean changed=false;\n  char[] chars=string.toCharArray();\n  for (int i=0; i != chars.length; i++) {\n    char ch=chars[i];\n    if ('a' <= ch && 'z' >= ch) {\n      changed=true;\n      chars[i]=(char)(ch - 'a' + 'A');\n    }\n  }\n  if (changed) {\n    return new String(chars);\n  }\n  return string;\n}\n", "nl": "A locale independent version of toUpperCase."}
{"code": "HTMLForm(HTMLComponent htmlC,String action,String method,String encType){\n  this.htmlC=htmlC;\n  this.action=htmlC.convertURL(action);\n  this.encType=encType;\n  if (htmlC.getHTMLCallback() != null) {\n    int linkProps=htmlC.getHTMLCallback().getLinkProperties(htmlC,this.action);\n    if ((linkProps & HTMLCallback.LINK_FORBIDDEN) != 0) {\n      this.action=null;\n    }\n  }\n  this.isPostMethod=((method != null) && (method.equalsIgnoreCase(\"post\")));\n}\n", "nl": "Constructs the HTMLForm"}
{"code": "public CurlInterceptor(Loggable logger,long limit){\n  this.logger=logger;\n  this.limit=limit;\n}\n", "nl": "Interceptor responsible for printing curl logs"}
{"code": "@Override public String toString(){\n  return String.valueOf(value);\n}\n", "nl": "Returns the String value of this mutable."}
{"code": "public void unRegisterImpulseConstraint(ImpulseConstraint con){\n  collisionResponseRows-=((ImpulseConstraint)con).GetCollisionResponseRows();\n  collisions.remove(con);\n}\n", "nl": "Un-registers an impulse constraint with the constraint engine"}
{"code": "Index(Node<K,V> node,Index<K,V> down,Index<K,V> right){\n  this.node=node;\n  this.down=down;\n  this.right=right;\n}\n", "nl": "Creates index node with given values."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String rasterHeader=null;\n  String distributionType=null;\n  int numberOfClasses=-1;\n  String statsFileName=null;\n  int numCols, numRows;\n  int col, row;\n  double value;\n  List<Double> values=new ArrayList<>();\n  String str;\n  float progress=0;\n  int index;\n  int h;\n  FileWriter streamWriter=null;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      rasterHeader=args[i];\n    }\n else     if (i == 1) {\n      distributionType=args[i].toLowerCase();\n    }\n else     if (i == 2) {\n      if (!args[i].toLowerCase().equals(\"not specified\")) {\n        numberOfClasses=Integer.parseInt(args[i]);\n      }\n    }\n else     if (i == 3) {\n      statsFileName=args[i];\n    }\n  }\n  if ((rasterHeader == null) || (statsFileName == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  if ((!distributionType.equals(\"complete\")) & (numberOfClasses <= 0)) {\n    showFeedback(\"Specify the number of classes (should be a value larger then 0).\");\n    return;\n  }\n  try {\n    raster=new WhiteboxRaster(rasterHeader,\"r\");\n    numRows=raster.getNumberRows();\n    numCols=raster.getNumberColumns();\n    streamWriter=new FileWriter(statsFileName);\n    str=\"Distribution type: \" + distributionType + System.lineSeparator();\n    streamWriter.write(str);\nswitch (distributionType) {\ncase \"complete\":\n      values=SortGridValues(raster);\n    updateProgress(\"Writing output:\",0);\n  str=\"Value\" + \"\\t\" + \"Cum. Rel. Freq.\"+ System.lineSeparator();\nstreamWriter.write(str);\nfor (int i=0; i < values.size(); i++) {\nstr=values.get(i) + \"\\t\" + (((float)i + 1) / values.size())+ System.lineSeparator();\nstreamWriter.write(str);\nif (cancelOp) {\n  cancelOperation();\n  return;\n}\nprogress=(float)(100f * i / (values.size() - 1));\nupdateProgress(\"Writing output:\",(int)progress);\n}\nbreak;\ncase \"n classes with equal class width\":\nList<Integer> distri=new ArrayList<>();\nList<Double> upper=new ArrayList<>();\nfor (int i=1; i <= numberOfClasses; i++) {\ndistri.add(0);\nupper.add(raster.getMinimumValue() + i * (raster.getMaximumValue() - raster.getMinimumValue()) / numberOfClasses);\n}\nupdateProgress(\"Computing distribution:\",0);\nfor (row=0; row < numRows; row++) {\nfor (col=0; col < numCols; col++) {\nvalue=raster.getValue(row,col);\nif (value != raster.getNoDataValue()) {\nh=0;\nwhile (value > upper.get(h)) {\nh=h + 1;\n}\nif (h <= numberOfClasses) {\ndistri.set(h,distri.get(h) + 1);\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * row / (numRows - 1));\nupdateProgress(\"Computing distribution:\",(int)progress);\n}\nint sum=0;\nfloat cumu;\nfor (int i=0; i < numberOfClasses; i++) {\nsum=sum + distri.get(i);\n}\nupdateProgress(\"Writing output:\",0);\nstr=\"Value\" + \"\\t\" + \"Rel. Freq.\"+ \"\\t\"+ \"Cum. Rel. Freq.\"+ System.lineSeparator();\nstreamWriter.write(str);\nif (sum > 0) {\ncumu=0;\nfor (int i=0; i < numberOfClasses; i++) {\ncumu=cumu + (float)distri.get(i) / sum;\nstr=upper.get(i) + \"\\t\" + (float)distri.get(i) / sum + \"\\t\" + cumu + System.lineSeparator();\nstreamWriter.write(str);\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * i / numberOfClasses);\nupdateProgress(\"Writing output:\",(int)progress);\n}\n}\nbreak;\ncase \"n classes with equal class size\":\nvalues=SortGridValues(raster);\nupdateProgress(\"Writing output:\",0);\nstr=\"Cum. Rel. Freq.\" + \"\\t\" + \"Value\"+ System.lineSeparator();\nstreamWriter.write(str);\nfor (int i=1; i <= numberOfClasses; i++) {\nindex=(int)((float)i / numberOfClasses * values.size()) - 1;\nif (index < 0) {\nindex=0;\n}\nstr=((float)index + 1) / values.size() + \"\\t\" + values.get(index) + System.lineSeparator();\nstreamWriter.write(str);\nprogress=(float)(100f * i / numberOfClasses);\nupdateProgress(\"Writing output:\",(int)progress);\n}\nbreak;\n}\nraster.close();\nstreamWriter.close();\n}\n catch (Exception e) {\nshowFeedback(e.getMessage());\n}\n finally {\nupdateProgress(\"Progress: \",0);\namIActive=false;\nmyHost.pluginComplete();\n}\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public boolean isInBoundsX(float x){\n  if (isInBoundsLeft(x) && isInBoundsRight(x))   return true;\n else   return false;\n}\n", "nl": "BELOW METHODS FOR BOUNDS CHECK"}
{"code": "public T caseAnonymous_constraint_1_(Anonymous_constraint_1_ object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>Anonymous constraint 1</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public CProjectLoaderReporter(final ListenerProvider<IProjectListener> listeners){\n  m_listeners=listeners;\n}\n", "nl": "Creates a new reporter object."}
{"code": "public String[] queryUniqueIdentifiersForLuns(String arrayUniqueId) throws InvalidArgument, NotFound, InvalidSession, StorageFault, NotImplemented {\n  final String methodName=\"queryUniqueIdentifiersForLuns(): \";\n  log.info(methodName + \"Entry with arrayUniqueId[\" + arrayUniqueId+ \"]\");\n  sslUtil.checkHttpRequest(true,true);\n  SOSManager sosManager=contextManager.getSOSManager();\n  String[] ids=sosManager.queryUniqueIdentifiersForLuns(arrayUniqueId);\n  log.info(methodName + \"Exit returning ids of size[\" + ids.length+ \"]\");\n  return ids;\n}\n", "nl": "Returns unique identifiers for LUNs for the give array Id"}
{"code": "@Override public boolean onCreateOptionsMenu(Menu menu){\n  mOpsOptionsMenu=menu;\n  MenuInflater inflater=getMenuInflater();\n  inflater.inflate(R.menu.ops_options_menu,menu);\n  return true;\n}\n", "nl": "Inflates the Operations (\"Ops\") Option Menu."}
{"code": "protected PackageImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void fillAttributeSet(Set attrSet){\n  attrSet.add(\"lang\");\n}\n", "nl": "Fills the given set with the attribute names found in this selector."}
{"code": "public void addColumn(final String columnFamily,final String columnQualifier){\n  Set<String> columns=this.columnFamilies.get(columnFamily);\n  if (columns == null) {\n    columns=new HashSet<String>();\n  }\n  columns.add(columnQualifier);\n  this.columnFamilies.put(columnFamily,columns);\n}\n", "nl": "Add column family and column qualifier to be extracted from tuple"}
{"code": "public static Field<String> ofString(String name,String description){\n  return new Field<>(name,String.class,description);\n}\n", "nl": "Break down metrics by string. <p> Each unique string will allocate a new submetric. <b>Do not use user content as a field value</b> as field values are never reclaimed."}
{"code": "public OMPoint(double lat,double lon,int radius){\n  setRenderType(RENDERTYPE_LATLON);\n  set(lat,lon);\n  this.radius=radius;\n}\n", "nl": "Create an OMPoint at a lat/lon position, with the specified radius."}
{"code": "private void saveMicroAgents(final IScope scope,final IMacroAgent agent) throws GamaRuntimeException {\n  innerPopulations=new THashMap<String,List<SavedAgent>>();\n  for (  final IPopulation<? extends IAgent> microPop : agent.getMicroPopulations()) {\n    final List<SavedAgent> savedAgents=new ArrayList<SavedAgent>();\n    final Iterator<? extends IAgent> it=microPop.iterator();\n    while (it.hasNext()) {\n      savedAgents.add(new SavedAgent(scope,it.next()));\n    }\n    innerPopulations.put(microPop.getSpecies().getName(),savedAgents);\n  }\n}\n", "nl": "Recursively save micro-agents of an agent."}
{"code": "public GenerationResult(Shell parent,int style,IPath location,final IResource target){\n  super(parent,style);\n  this.location=location;\n  this.targetResource=target;\n  setText(\"EvoSuite Result\");\n}\n", "nl": "Create the dialog."}
{"code": "public void run(){\n  ActivationLibrary.deactivate(this,getID());\n}\n", "nl": "Thread to deactivate object. First attempts to make object inactive (via the inactive method).  If that fails (the object may still have pending/executing calls), then unexport the object forcibly."}
{"code": "private static a createImageLink(String AD_Language,String name,String js_command,boolean enabled,boolean pressed){\n  a img=new a(\"#\",createImage(AD_Language,name));\n  if (!pressed || !enabled)   img.setID(\"imgButtonLink\");\n else   img.setID(\"imgButtonPressedLink\");\n  if (js_command == null)   js_command=\"'Submit'\";\n  if (js_command.length() > 0 && enabled) {\n    if (js_command.startsWith(\"startPopup\"))     img.setOnClick(js_command);\n else     img.setOnClick(\"SubmitForm('\" + name + \"', \"+ js_command+ \",'toolbar');return false;\");\n  }\n  img.setClass(\"ToolbarButton\");\n  img.setOnMouseOver(\"window.status='\" + name + \"';return true;\");\n  img.setOnMouseOut(\"window.status='';return true;\");\n  img.setOnBlur(\"this.hideFocus=false\");\n  return img;\n}\n", "nl": "Create Image with name, id of button_name and set P_Command onClick"}
{"code": "public CassandraStatus(CassandraMode mode,boolean joined,boolean rpcRunning,boolean nativeTransportRunning,boolean gossipInitialized,boolean gossipRunning,String hostId,String endpoint,int tokenCount,String dataCenter,String rack,String version){\n  this.mode=mode;\n  this.joined=joined;\n  this.rpcRunning=rpcRunning;\n  this.nativeTransportRunning=nativeTransportRunning;\n  this.gossipInitialized=gossipInitialized;\n  this.gossipRunning=gossipRunning;\n  this.hostId=hostId;\n  this.endpoint=endpoint;\n  this.tokenCount=tokenCount;\n  this.dataCenter=dataCenter;\n  this.rack=rack;\n  this.version=version;\n}\n", "nl": "Constructs a CassandraStatus."}
{"code": "public void checkDataSource(Map<String,ModelEntity> modelEntities,List<String> messages,boolean addMissing) throws GenericEntityException {\n  genericDAO.checkDb(modelEntities,messages,addMissing);\n}\n", "nl": "Check the datasource to make sure the entity definitions are correct, optionally adding missing entities or fields on the server"}
{"code": "public static HashMap<String,String> string2HashMap(String paramString){\n  HashMap<String,String> params=new HashMap<>();\n  for (  String keyValue : paramString.split(\" *& *\")) {\n    String[] pairs=keyValue.split(\" *= *\",2);\n    params.put(pairs[0],pairs.length == 1 ? \"\" : pairs[1]);\n  }\n  return params;\n}\n", "nl": "Convert key=value type String to HashMap<String,String>"}
{"code": "@LargeTest public void testMediaVideoItemRenderingModes() throws Exception {\n  final String videoItemFileName=INPUT_FILE_PATH + \"H263_profile0_176x144_15fps_256kbps_AACLC_32kHz_128kbps_s_0_26.3gp\";\n  final int videoItemRenderingMode=MediaItem.RENDERING_MODE_BLACK_BORDER;\n  boolean flagForException=false;\n  final MediaVideoItem mediaVideoItem1=mVideoEditorHelper.createMediaItem(mVideoEditor,\"mediaVideoItem1\",videoItemFileName,videoItemRenderingMode);\n  mVideoEditor.addMediaItem(mediaVideoItem1);\n  mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_CROPPING);\n  assertEquals(\"MediaVideo Item rendering Mode\",MediaItem.RENDERING_MODE_CROPPING,mediaVideoItem1.getRenderingMode());\n  try {\n    mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_CROPPING + 911);\n  }\n catch (  IllegalArgumentException e) {\n    flagForException=true;\n  }\n  assertTrue(\"Media Item Invalid rendering Mode\",flagForException);\n  flagForException=false;\n  try {\n    mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_BLACK_BORDER - 11);\n  }\n catch (  IllegalArgumentException e) {\n    flagForException=true;\n  }\n  assertTrue(\"Media Item Invalid rendering Mode\",flagForException);\n  assertEquals(\"MediaVideo Item rendering Mode\",MediaItem.RENDERING_MODE_CROPPING,mediaVideoItem1.getRenderingMode());\n  mediaVideoItem1.setRenderingMode(MediaItem.RENDERING_MODE_STRETCH);\n  assertEquals(\"MediaVideo Item rendering Mode\",MediaItem.RENDERING_MODE_STRETCH,mediaVideoItem1.getRenderingMode());\n}\n", "nl": "To test creation of Media Video Item with Set and Get rendering Mode"}
{"code": "public void visitTree(JCTree tree){\n}\n", "nl": "Default member enter visitor method: do nothing"}
{"code": "private EventLogControlPanel createControls(){\n  EventLogControlPanel c=new EventLogControlPanel();\n  c.addHeading(\"connections\");\n  conUpCheck=c.addControl(\"up\");\n  conDownCheck=c.addControl(\"down\");\n  c.addHeading(\"messages\");\n  msgCreateCheck=c.addControl(\"created\");\n  msgTransferStartCheck=c.addControl(\"started relay\");\n  msgRelayCheck=c.addControl(\"relayed\");\n  msgDeliveredCheck=c.addControl(\"delivered\");\n  msgRemoveCheck=c.addControl(\"removed\");\n  msgDropCheck=c.addControl(\"dropped\");\n  msgAbortCheck=c.addControl(\"aborted\");\n  return c;\n}\n", "nl": "Creates a control panel for the log"}
{"code": "@Override public String type(){\n  return type;\n}\n", "nl": "Returns the type of document to get the term vector for."}
{"code": "public void test_getIterator$Ljava_text_AttributedCharacterIterator$AttributeII(){\n  String test=\"Test string\";\n  try {\n    Map<AttributedCharacterIterator.Attribute,String> hm=new HashMap<AttributedCharacterIterator.Attribute,String>();\n    AttributedCharacterIterator.Attribute[] aci=new AttributedCharacterIterator.Attribute[3];\n    aci[0]=new TestAttributedCharacterIteratorAttribute(\"att1\");\n    aci[1]=new TestAttributedCharacterIteratorAttribute(\"att2\");\n    aci[2]=new TestAttributedCharacterIteratorAttribute(\"att3\");\n    hm.put(aci[0],\"value1\");\n    hm.put(aci[1],\"value2\");\n    AttributedString attrString=new AttributedString(test);\n    attrString.addAttributes(hm,2,4);\n    AttributedCharacterIterator it=attrString.getIterator(aci,1,5);\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[0]) == null);\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[1]) == null);\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[2]) == null);\n    it.next();\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[0]).equals(\"value1\"));\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[1]).equals(\"value2\"));\n    assertTrue(\"Incorrect iteration on AttributedString\",it.getAttribute(aci[2]) == null);\n    try {\n      attrString.getIterator(aci,-1,5);\n      fail(\"IllegalArgumentException is not thrown.\");\n    }\n catch (    IllegalArgumentException iae) {\n    }\n    try {\n      attrString.getIterator(aci,6,5);\n      fail(\"IllegalArgumentException is not thrown.\");\n    }\n catch (    IllegalArgumentException iae) {\n    }\n    try {\n      attrString.getIterator(aci,3,2);\n      fail(\"IllegalArgumentException is not thrown.\");\n    }\n catch (    IllegalArgumentException iae) {\n    }\n  }\n catch (  Exception e) {\n    fail(\"Unexpected exceptiption \" + e.toString());\n  }\n}\n", "nl": "java.text.AttributedString#getIterator(AttributedCharacterIterator.Attribute[], int, int) Test of method java.text.AttributedString#getIterator(AttributedCharacterIterator.Attribute[], int, int)."}
{"code": "private void newplan(TransformationPlan plan){\n  if (plan.replaces(this.plan)) {\n    this.plan=plan;\n  }\n}\n", "nl": "Install a new plan iff it's more drastic than the existing plan"}
{"code": "private SmallContingencyTables buildSmallContingencyTables(){\n  Set<String> allLabelSet=new TreeSet<String>();\n  for (  SingleOutcome outcome : id2Outcome.getOutcomes()) {\n    allLabelSet.addAll(outcome.getLabels());\n  }\n  List<String> labelList=new ArrayList<String>(allLabelSet);\n  int numberOfLabels=labelList.size();\n  double counterIncreaseValue=1.0;\n  SmallContingencyTables smallContingencyTables=new SmallContingencyTables(labelList);\n  for (int allLabelsClassId=0; allLabelsClassId < numberOfLabels; allLabelsClassId++) {\n    for (    SingleOutcome outcome : id2Outcome.getOutcomes()) {\n      int localClassId=outcome.getReverseLabelMapping(labelList).get(allLabelsClassId);\n      double threshold=outcome.getBipartitionThreshold();\n      double goldValue;\n      double predictionValue;\n      if (localClassId == -1) {\n        goldValue=0.;\n        predictionValue=0.;\n      }\n else {\n        goldValue=outcome.getGoldstandard()[localClassId];\n        predictionValue=outcome.getPrediction()[localClassId];\n      }\n      if (goldValue >= threshold) {\n        if (predictionValue >= threshold) {\n          smallContingencyTables.addTruePositives(allLabelsClassId,counterIncreaseValue);\n        }\n else {\n          smallContingencyTables.addFalseNegatives(allLabelsClassId,counterIncreaseValue);\n        }\n      }\n else {\n        if (predictionValue >= threshold) {\n          smallContingencyTables.addFalsePositives(allLabelsClassId,counterIncreaseValue);\n        }\n else {\n          smallContingencyTables.addTrueNegatives(allLabelsClassId,counterIncreaseValue);\n        }\n      }\n    }\n  }\n  return smallContingencyTables;\n}\n", "nl": "build small contingency tables (a small contingency table for each label) from id2Outcome"}
{"code": "protected String doIt() throws Exception {\n  MRfQ rfq=new MRfQ(getCtx(),p_C_RfQ_ID,get_TrxName());\n  if (rfq.get_ID() == 0)   throw new IllegalArgumentException(\"No RfQ found\");\n  log.info(rfq.toString());\n  MRfQResponse[] responses=rfq.getResponses(true,true);\n  log.config(\"#Responses=\" + responses.length);\n  if (responses.length == 0)   throw new IllegalArgumentException(\"No completed RfQ Responses found\");\n  for (int i=0; i < responses.length; i++) {\n    MRfQResponse response=responses[i];\n    if (!response.isSelectedWinner())     continue;\n    MBPartner bp=new MBPartner(getCtx(),response.getC_BPartner_ID(),get_TrxName());\n    log.config(\"Winner=\" + bp);\n    MOrder order=new MOrder(getCtx(),0,get_TrxName());\n    order.setIsSOTrx(false);\n    if (p_C_DocType_ID != 0)     order.setC_DocTypeTarget_ID(p_C_DocType_ID);\n else     order.setC_DocTypeTarget_ID();\n    order.setBPartner(bp);\n    order.setC_BPartner_Location_ID(response.getC_BPartner_Location_ID());\n    order.setSalesRep_ID(rfq.getSalesRep_ID());\n    if (response.getDateWorkComplete() != null)     order.setDatePromised(response.getDateWorkComplete());\n else     if (rfq.getDateWorkComplete() != null)     order.setDatePromised(rfq.getDateWorkComplete());\n    order.saveEx();\n    MRfQResponseLine[] lines=response.getLines(false);\n    for (int j=0; j < lines.length; j++) {\n      MRfQResponseLine line=lines[j];\n      if (!line.isActive())       continue;\n      MRfQResponseLineQty[] qtys=line.getQtys(false);\n      for (int k=0; k < qtys.length; k++) {\n        MRfQResponseLineQty qty=qtys[k];\n        if (qty.getRfQLineQty().isActive() && qty.getRfQLineQty().isPurchaseQty()) {\n          MOrderLine ol=new MOrderLine(order);\n          ol.setM_Product_ID(line.getRfQLine().getM_Product_ID(),qty.getRfQLineQty().getC_UOM_ID());\n          ol.setDescription(line.getDescription());\n          ol.setQty(qty.getRfQLineQty().getQty());\n          BigDecimal price=qty.getNetAmt();\n          ol.setPrice();\n          ol.setPrice(price);\n          ol.saveEx();\n        }\n      }\n    }\n    response.setC_Order_ID(order.getC_Order_ID());\n    response.saveEx();\n    return order.getDocumentNo();\n  }\n  int noOrders=0;\n  for (int i=0; i < responses.length; i++) {\n    MRfQResponse response=responses[i];\n    MBPartner bp=null;\n    MOrder order=null;\n    MRfQResponseLine[] lines=response.getLines(false);\n    for (int j=0; j < lines.length; j++) {\n      MRfQResponseLine line=lines[j];\n      if (!line.isActive() || !line.isSelectedWinner())       continue;\n      if (bp == null || bp.getC_BPartner_ID() != response.getC_BPartner_ID()) {\n        bp=new MBPartner(getCtx(),response.getC_BPartner_ID(),get_TrxName());\n        order=null;\n      }\n      log.config(\"Line=\" + line + \", Winner=\"+ bp);\n      if (order == null) {\n        order=new MOrder(getCtx(),0,get_TrxName());\n        order.setIsSOTrx(false);\n        order.setC_DocTypeTarget_ID();\n        order.setBPartner(bp);\n        order.setC_BPartner_Location_ID(response.getC_BPartner_Location_ID());\n        order.setSalesRep_ID(rfq.getSalesRep_ID());\n        order.saveEx();\n        noOrders++;\n        addLog(0,null,null,order.getDocumentNo());\n      }\n      MRfQResponseLineQty[] qtys=line.getQtys(false);\n      for (int k=0; k < qtys.length; k++) {\n        MRfQResponseLineQty qty=qtys[k];\n        if (qty.getRfQLineQty().isActive() && qty.getRfQLineQty().isPurchaseQty()) {\n          MOrderLine ol=new MOrderLine(order);\n          ol.setM_Product_ID(line.getRfQLine().getM_Product_ID(),qty.getRfQLineQty().getC_UOM_ID());\n          ol.setDescription(line.getDescription());\n          ol.setQty(qty.getRfQLineQty().getQty());\n          BigDecimal price=qty.getNetAmt();\n          ol.setPrice();\n          ol.setPrice(price);\n          ol.saveEx();\n        }\n      }\n    }\n    if (order != null) {\n      response.setC_Order_ID(order.getC_Order_ID());\n      response.saveEx();\n    }\n  }\n  return \"#\" + noOrders;\n}\n", "nl": "Process. Create purchase order(s) for the resonse(s) and lines marked as  Selected Winner using the selected Purchase Quantity (in RfQ Line Quantity) .  If a Response is marked as Selected Winner, all lines are created  (and Selected Winner of other responses ignored).   If there is no response marked as Selected Winner, the lines are used."}
{"code": "public String commandTopic(String command){\n  if (command == null) {\n    command=\"+\";\n  }\n  return cmdTopic.replace(\"{COMMAND}\",command);\n}\n", "nl": "Get the MQTT topic for a command."}
{"code": "public static boolean hasExtension(String extension){\n  if (TextUtils.isEmpty(extension)) {\n    return false;\n  }\n  return extensionToMimeTypeMap.containsKey(extension);\n}\n", "nl": "Returns true if the given extension has a registered MIME type."}
{"code": "@Before public void onBefore(){\n  tut=new TransportUnitType(\"TUT\");\n  loc1=new Location(new LocationPK(\"AREA\",\"ASL\",\"X\",\"Y\",\"Z\"));\n  loc2=new Location(new LocationPK(\"ARE2\",\"ASL2\",\"X2\",\"Y2\",\"Z2\"));\n  product=new Product(\"tttt\");\n  entityManager.persist(product);\n  entityManager.persist(tut);\n  entityManager.persist(loc1);\n  entityManager.persist(loc2);\n  tu=new TransportUnit(\"TEST\");\n  tu.setTransportUnitType(tut);\n  tu.setActualLocation(loc1);\n  entityManager.persist(tu);\n  entityManager.flush();\n}\n", "nl": "Setup some test data."}
{"code": "public void beforeRerunningIndexCreationQuery(){\n}\n", "nl": "Asif : Called just before IndexManager executes the function rerunIndexCreationQuery. After this function gets invoked, IndexManager will iterate over all the indexes of the region making the data maps null & re running the index creation query on the region. The method of Index Manager gets executed from the clear function of the Region"}
{"code": "public float buffered(){\n  return totalSize > 0 ? Futures.getUnchecked(response).cache.cacheSize() / (float)totalSize : -1;\n}\n", "nl": "Returns the percentage that is buffered, or -1, if unknown"}
{"code": "@Override public boolean accept(File dir,String name){\n  return accept(new File(dir,name));\n}\n", "nl": "Returns true if the file in the given directory with the given name should be accepted."}
{"code": "public static void main(String... a) throws Exception {\n  TestBase.createCaller().init().test();\n}\n", "nl": "Run just this test."}
{"code": "public boolean isFieldPresent(String field){\n  return fields.containsKey(field);\n}\n", "nl": "Checks if the given field is present in this extension because not every field is mandatory (according to scim 2.0 spec)."}
{"code": "public static String mapToStr(Map<? extends Object,? extends Object> map){\n  if (map == null)   return null;\n  StringBuilder buf=new StringBuilder();\n  boolean first=true;\n  for (  Map.Entry<? extends Object,? extends Object> entry : map.entrySet()) {\n    Object key=entry.getKey();\n    Object value=entry.getValue();\n    if (!(key instanceof String) || !(value instanceof String))     continue;\n    String encodedName=null;\n    try {\n      encodedName=URLEncoder.encode((String)key,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      Debug.logError(e,module);\n    }\n    String encodedValue=null;\n    try {\n      encodedValue=URLEncoder.encode((String)value,\"UTF-8\");\n    }\n catch (    UnsupportedEncodingException e) {\n      Debug.logError(e,module);\n    }\n    if (first)     first=false;\n else     buf.append(\"|\");\n    buf.append(encodedName);\n    buf.append(\"=\");\n    buf.append(encodedValue);\n  }\n  return buf.toString();\n}\n", "nl": "Creates an encoded String from a Map of name/value pairs (MUST BE STRINGS!)"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:00:42.074 -0500\",hash_original_method=\"002C3CFFC816A38E005543BB54E228FD\",hash_generated_method=\"24D6A751F50FC61EC42FBA4D0FC608F4\") public static String toLowerCase(String string){\n  boolean changed=false;\n  char[] chars=string.toCharArray();\n  for (int i=0; i != chars.length; i++) {\n    char ch=chars[i];\n    if ('A' <= ch && 'Z' >= ch) {\n      changed=true;\n      chars[i]=(char)(ch - 'A' + 'a');\n    }\n  }\n  if (changed) {\n    return new String(chars);\n  }\n  return string;\n}\n", "nl": "A locale independent version of toLowerCase."}
{"code": "public String numberToWords(int num){\n  if (num == 0) {\n    return LESS_THAN_TWENTY[0];\n  }\n  int i=0;\n  StringBuilder res=new StringBuilder();\n  while (num > 0) {\n    if (num % 1000 != 0) {\n      res.insert(0,\" \");\n      res.insert(0,THOUSANDS[i]);\n      res.insert(0,helper(num % 1000));\n    }\n    num/=1000;\n    i++;\n  }\n  return res.toString().trim();\n}\n", "nl": "Math, String. Try to find the pattern first. The numbers less than 1000, e.g. xyz, can be x Hundred y\"ty\" z. The numbers larger than 1000, we need to add thousand or million or billion. Given a number num, we pronounce the least significant digits first. Then concat the result to the end to next three least significant digits. So the recurrence relation is: Next result of num = the pronunciation of least three digits + current result of num After that, remove those three digits from number. Stop when number is 0."}
{"code": "public boolean hasLat(){\n  return super.hasAttribute(LAT);\n}\n", "nl": "Returns whether it has the Latitude."}
{"code": "public void test_ConstructorIF(){\n  HashSet hs2=new HashSet(5,(float)0.5);\n  assertEquals(\"Created incorrect HashSet\",0,hs2.size());\n  try {\n    new HashSet(0,0);\n  }\n catch (  IllegalArgumentException e) {\n    return;\n  }\n  fail(\"Failed to throw IllegalArgumentException for initial load factor <= 0\");\n}\n", "nl": "java.util.HashSet#HashSet(int, float)"}
{"code": "private int emitCharMapArray(){\n  CharClasses cl=parser.getCharClasses();\n  if (cl.getMaxCharCode() < 256) {\n    emitCharMapArrayUnPacked();\n    return 0;\n  }\n  intervals=cl.getIntervals();\n  println(\"\");\n  println(\"  /** \");\n  println(\"   * Translates characters to character classes\");\n  println(\"   */\");\n  println(\"  private static final String ZZ_CMAP_PACKED = \");\n  int n=0;\n  print(\"    \\\"\");\n  int i=0, numPairs=0;\n  int count, value;\n  while (i < intervals.length) {\n    count=intervals[i].end - intervals[i].start + 1;\n    value=colMap[intervals[i].charClass];\n    while (count > 0xFFFF) {\n      printUC(0xFFFF);\n      printUC(value);\n      count-=0xFFFF;\n      numPairs++;\n      n++;\n    }\n    numPairs++;\n    printUC(count);\n    printUC(value);\n    if (i < intervals.length - 1) {\n      if (++n >= 10) {\n        println(\"\\\"+\");\n        print(\"    \\\"\");\n        n=0;\n      }\n    }\n    i++;\n  }\n  println(\"\\\";\");\n  println();\n  println(\"  /** \");\n  println(\"   * Translates characters to character classes\");\n  println(\"   */\");\n  println(\"  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);\");\n  println();\n  return numPairs;\n}\n", "nl": "Returns the number of elements in the packed char map array, or zero if the char map array will be not be packed. This will be more than intervals.length if the count for any of the values is more than 0xFFFF, since the number of char map array entries per value is ceil(count / 0xFFFF)"}
{"code": "public int size(){\n  return mSize;\n}\n", "nl": "Returns the number of key-value mappings that this SparseDoubleArray currently stores."}
{"code": "public void depends(int parent,int child){\n  dag.addNode(child);\n  dag.addNode(parent);\n  dag.addEdge(parent,child);\n}\n", "nl": "Adds a dependency relation ship between two variables that will be in the network. The integer value corresponds  the the index of the i'th  categorical variable, where the class target's value is the number of categorical variables."}
{"code": "public DiscreteTransfer(int[] tableValues){\n  this.tableValues=tableValues;\n  this.n=tableValues.length;\n}\n", "nl": "The input is an int array which will be used later to construct the lut data"}
{"code": "public static final float roundTo(float val,float prec){\n  return floor(val / prec + 0.5f) * prec;\n}\n", "nl": "Rounds a single precision value to the given precision."}
{"code": "public static <K,V>List<KeyValue<K,V>> readKeyValues(String topic,Properties consumerConfig,int maxMessages){\n  KafkaConsumer<K,V> consumer=new KafkaConsumer<>(consumerConfig);\n  consumer.subscribe(Collections.singletonList(topic));\n  int pollIntervalMs=100;\n  int maxTotalPollTimeMs=2000;\n  int totalPollTimeMs=0;\n  List<KeyValue<K,V>> consumedValues=new ArrayList<>();\n  while (totalPollTimeMs < maxTotalPollTimeMs && continueConsuming(consumedValues.size(),maxMessages)) {\n    totalPollTimeMs+=pollIntervalMs;\n    ConsumerRecords<K,V> records=consumer.poll(pollIntervalMs);\n    for (    ConsumerRecord<K,V> record : records) {\n      consumedValues.add(new KeyValue<>(record.key(),record.value()));\n    }\n  }\n  consumer.close();\n  return consumedValues;\n}\n", "nl": "Returns up to `maxMessages` by reading via the provided consumer (the topic(s) to read from are already configured in the consumer)."}
{"code": "private int segment(Object key){\n  return Math.abs(key.hashCode() % size);\n}\n", "nl": "This method performs the translation of the key hash code to the segment index within the list. Translation is done by acquiring the modulus of the hash and the list size."}
{"code": "private void handleStateLeaving(InetAddress endpoint){\n  Collection<Token> tokens=getTokensFor(endpoint);\n  if (logger.isDebugEnabled())   logger.debug(\"Node {} state leaving, tokens {}\",endpoint,tokens);\n  if (!tokenMetadata.isMember(endpoint)) {\n    logger.info(\"Node {} state jump to leaving\",endpoint);\n    tokenMetadata.updateNormalTokens(tokens,endpoint);\n  }\n else   if (!tokenMetadata.getTokens(endpoint).containsAll(tokens)) {\n    logger.warn(\"Node {} 'leaving' token mismatch. Long network partition?\",endpoint);\n    tokenMetadata.updateNormalTokens(tokens,endpoint);\n  }\n  tokenMetadata.addLeavingEndpoint(endpoint);\n  PendingRangeCalculatorService.instance.update();\n}\n", "nl": "Handle node preparing to leave the ring"}
{"code": "public MAttributeInstance(Properties ctx,int M_Attribute_ID,int M_AttributeSetInstance_ID,BigDecimal BDValue,String trxName){\n  super(ctx,0,trxName);\n  setM_Attribute_ID(M_Attribute_ID);\n  setM_AttributeSetInstance_ID(M_AttributeSetInstance_ID);\n  setValueNumber(BDValue);\n}\n", "nl": "Number Value Constructior"}
{"code": "@Override public boolean supportsPositionedUpdate(){\n  debugCodeCall(\"supportsPositionedUpdate\");\n  return true;\n}\n", "nl": "Returns whether positioned updates are supported."}
{"code": "@SuppressWarnings(\"unchecked\") private boolean prepareMapping(String index,Map<String,Object> defaultMappings){\n  boolean success=true;\n  for (  Map.Entry<String,Object> stringObjectEntry : defaultMappings.entrySet()) {\n    Map<String,Object> mapping=(Map<String,Object>)stringObjectEntry.getValue();\n    if (mapping == null) {\n      throw new RuntimeException(\"type mapping not defined\");\n    }\n    PutMappingRequestBuilder putMappingRequestBuilder=client.admin().indices().preparePutMapping().setIndices(index);\n    putMappingRequestBuilder.setType(stringObjectEntry.getKey());\n    putMappingRequestBuilder.setSource(mapping);\n    if (log.isLoggable(Level.FINE)) {\n      log.fine(\"Elasticsearch create mapping for index '\" + index + \" and type '\"+ stringObjectEntry.getKey()+ \"': \"+ mapping);\n    }\n    PutMappingResponse resp=putMappingRequestBuilder.execute().actionGet();\n    if (resp.isAcknowledged()) {\n      if (log.isLoggable(Level.FINE)) {\n        log.fine(\"Elasticsearch mapping for index '\" + index + \" and type '\"+ stringObjectEntry.getKey()+ \"' was acknowledged\");\n      }\n    }\n else {\n      success=false;\n      log.warning(\"Elasticsearch mapping creation was not acknowledged for index '\" + index + \" and type '\"+ stringObjectEntry.getKey()+ \"'\");\n    }\n  }\n  return success;\n}\n", "nl": "This method applies the supplied mapping to the index."}
{"code": "public void disableOcr(){\n  if (!ocrDisabled) {\n    excludeParser(TesseractOCRParser.class);\n    ocrDisabled=true;\n    pdfConfig.setExtractInlineImages(false);\n  }\n}\n", "nl": "Disable OCR. This method only has an effect if Tesseract is installed."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase DatatypePackage.DICTIONARY_PROPERTY_TYPE__KEY_TYPE:\n    return basicSetKeyType(null,msgs);\ncase DatatypePackage.DICTIONARY_PROPERTY_TYPE__VALUE_TYPE:\n  return basicSetValueType(null,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(String[] args){\n  (new Am()).run(args);\n}\n", "nl": "Command-line entry point."}
{"code": "public void removeAllHighlights(){\n  TextUI mapper=component.getUI();\n  if (getDrawsLayeredHighlights()) {\n    int len=highlights.size();\n    if (len != 0) {\n      int minX=0;\n      int minY=0;\n      int maxX=0;\n      int maxY=0;\n      int p0=-1;\n      int p1=-1;\n      for (int i=0; i < len; i++) {\n        HighlightInfo hi=highlights.elementAt(i);\n        if (hi instanceof LayeredHighlightInfo) {\n          LayeredHighlightInfo info=(LayeredHighlightInfo)hi;\n          minX=Math.min(minX,info.x);\n          minY=Math.min(minY,info.y);\n          maxX=Math.max(maxX,info.x + info.width);\n          maxY=Math.max(maxY,info.y + info.height);\n        }\n else {\n          if (p0 == -1) {\n            p0=hi.p0.getOffset();\n            p1=hi.p1.getOffset();\n          }\n else {\n            p0=Math.min(p0,hi.p0.getOffset());\n            p1=Math.max(p1,hi.p1.getOffset());\n          }\n        }\n      }\n      if (minX != maxX && minY != maxY) {\n        component.repaint(minX,minY,maxX - minX,maxY - minY);\n      }\n      if (p0 != -1) {\n        try {\n          safeDamageRange(p0,p1);\n        }\n catch (        BadLocationException e) {\n        }\n      }\n      highlights.removeAllElements();\n    }\n  }\n else   if (mapper != null) {\n    int len=highlights.size();\n    if (len != 0) {\n      int p0=Integer.MAX_VALUE;\n      int p1=0;\n      for (int i=0; i < len; i++) {\n        HighlightInfo info=highlights.elementAt(i);\n        p0=Math.min(p0,info.p0.getOffset());\n        p1=Math.max(p1,info.p1.getOffset());\n      }\n      try {\n        safeDamageRange(p0,p1);\n      }\n catch (      BadLocationException e) {\n      }\n      highlights.removeAllElements();\n    }\n  }\n}\n", "nl": "Removes all highlights."}
{"code": "public static void init(){\n  Properties p;\n  try {\n    p=System.getProperties();\n  }\n catch (  java.security.AccessControlException ace) {\n    p=new Properties();\n  }\n  init(p);\n}\n", "nl": "Initialize debugging from the system properties."}
{"code": "public Builder bySecond(Integer... seconds){\n  return bySecond(Arrays.asList(seconds));\n}\n", "nl": "Adds one or more BYSECOND rule parts."}
{"code": "public CakePHP3CustomizerPanel(){\n  initComponents();\n  init();\n}\n", "nl": "Creates new form CakePHP3CustomizerPanel"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public char first(){\n  pos=0;\n  return current();\n}\n", "nl": "Sets the position to getBeginIndex() and returns the character at that position."}
{"code": "@Benchmark public long test4_UsingKeySetAndForEach() throws IOException {\n  long i=0;\n  for (  Integer key : map.keySet()) {\n    i+=key + map.get(key);\n  }\n  return i;\n}\n", "nl": "4. Using keySet and foreach"}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase N4JSPackage.N4_FIELD_DECLARATION__DECLARED_TYPE_REF:\n    setDeclaredTypeRef((TypeRef)null);\n  return;\ncase N4JSPackage.N4_FIELD_DECLARATION__BOGUS_TYPE_REF:\nsetBogusTypeRef((TypeRef)null);\nreturn;\ncase N4JSPackage.N4_FIELD_DECLARATION__DECLARED_NAME:\nsetDeclaredName((LiteralOrComputedPropertyName)null);\nreturn;\ncase N4JSPackage.N4_FIELD_DECLARATION__DEFINED_FIELD:\nsetDefinedField((TField)null);\nreturn;\ncase N4JSPackage.N4_FIELD_DECLARATION__EXPRESSION:\nsetExpression((Expression)null);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private StringTextStore(String text){\n  super();\n  fText=text != null ? text : \"\";\n  fCopyLimit=fText.length() > SMALL_TEXT_LIMIT ? fText.length() / 2 : 0;\n}\n", "nl": "Create a text store with initial content."}
{"code": "public static double incompleteGammaP(double a,double x){\n  return incompleteGamma(x,a,lnGamma(a));\n}\n", "nl": "Incomplete Gamma function P(a,x) = 1-Q(a,x) (a cleanroom implementation of Numerical Recipes gammp(a,x); in Mathematica this function is 1-GammaRegularized)"}
{"code": "@Scheduled(fixedDelay=60000) public void controlHerdJmsMessageListener(){\n  try {\n    Boolean jmsMessageListenerEnabled=Boolean.valueOf(configurationHelper.getProperty(ConfigurationValue.JMS_LISTENER_ENABLED));\n    JmsListenerEndpointRegistry registry=ApplicationContextHolder.getApplicationContext().getBean(\"org.springframework.jms.config.internalJmsListenerEndpointRegistry\",JmsListenerEndpointRegistry.class);\n    MessageListenerContainer jmsMessageListenerContainer=registry.getListenerContainer(HerdJmsDestinationResolver.SQS_DESTINATION_HERD_INCOMING);\n    LOGGER.debug(\"controlHerdJmsMessageListener(): {}={} jmsMessageListenerContainer.isRunning()={}\",ConfigurationValue.JMS_LISTENER_ENABLED.getKey(),jmsMessageListenerEnabled,jmsMessageListenerContainer.isRunning());\n    if (!jmsMessageListenerEnabled && jmsMessageListenerContainer.isRunning()) {\n      LOGGER.info(\"controlHerdJmsMessageListener(): Stopping the herd JMS message listener ...\");\n      jmsMessageListenerContainer.stop();\n      LOGGER.info(\"controlHerdJmsMessageListener(): Done\");\n    }\n else     if (jmsMessageListenerEnabled && !jmsMessageListenerContainer.isRunning()) {\n      LOGGER.info(\"controlHerdJmsMessageListener(): Starting the herd JMS message listener ...\");\n      jmsMessageListenerContainer.start();\n      LOGGER.info(\"controlHerdJmsMessageListener(): Done\");\n    }\n  }\n catch (  Exception e) {\n    LOGGER.error(\"controlHerdJmsMessageListener(): Failed to control the herd Jms message listener service.\",e);\n  }\n}\n", "nl": "Periodically check the configuration and apply the action to the herd JMS message listener service, if needed."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-08-13 13:14:13.408 -0400\",hash_original_method=\"FC36FCA077BB9356BFDFCA10D99D0311\",hash_generated_method=\"2430FCC224E47ADC0C94FB89530AAC4A\") public AnnotationTypeMismatchException(Method element,String foundType){\n  super(\"The annotation element \" + element + \" doesn't match the type \"+ foundType);\n  this.element=element;\n  this.foundType=foundType;\n}\n", "nl": "Constructs an instance for the given type element and the type found."}
{"code": "public void startDrag(DragGestureEvent trigger,Cursor dragCursor,Transferable transferable,DragSourceListener dsl) throws InvalidDnDOperationException {\n  startDrag(trigger,dragCursor,null,null,transferable,dsl,null);\n}\n", "nl": "Start a drag, given the <code>DragGestureEvent</code> that initiated the drag, the initial <code>Cursor</code> to use, the <code>Transferable</code> subject data of the drag, and the <code>DragSourceListener</code>. <P>"}
{"code": "@SuppressWarnings(\"IfMayBeConditional\") public IgniteInternalFuture<?> dynamicStartCache(@Nullable CacheConfiguration ccfg,String cacheName,@Nullable NearCacheConfiguration nearCfg,CacheType cacheType,boolean failIfExists,boolean failIfNotStarted,boolean checkThreadTx){\n  if (checkThreadTx)   checkEmptyTransactions();\n  DynamicCacheDescriptor desc=registeredCaches.get(maskNull(cacheName));\n  DynamicCacheChangeRequest req=new DynamicCacheChangeRequest(cacheName,ctx.localNodeId());\n  req.failIfExists(failIfExists);\n  if (ccfg != null) {\n    try {\n      cloneCheckSerializable(ccfg);\n    }\n catch (    IgniteCheckedException e) {\n      return new GridFinishedFuture<>(e);\n    }\n    if (desc != null) {\n      if (failIfExists) {\n        return new GridFinishedFuture<>(new CacheExistsException(\"Failed to start cache \" + \"(a cache with the same name is already started): \" + cacheName));\n      }\n else {\n        CacheConfiguration descCfg=desc.cacheConfiguration();\n        if (nearCfg != null) {\n          if (CU.affinityNode(ctx.discovery().localNode(),descCfg.getNodeFilter())) {\n            if (descCfg.getNearConfiguration() != null)             return new GridFinishedFuture<>();\n else             return new GridFinishedFuture<>(new IgniteCheckedException(\"Failed to start near \" + \"cache (local node is an affinity node for cache): \" + cacheName));\n          }\n else           req.clientStartOnly(true);\n        }\n else         req.clientStartOnly(true);\n        req.deploymentId(desc.deploymentId());\n        req.startCacheConfiguration(descCfg);\n      }\n    }\n else {\n      req.deploymentId(IgniteUuid.randomUuid());\n      try {\n        CacheConfiguration cfg=new CacheConfiguration(ccfg);\n        CacheObjectContext cacheObjCtx=ctx.cacheObjects().contextForCache(cfg);\n        initialize(false,cfg,cacheObjCtx);\n        req.startCacheConfiguration(cfg);\n      }\n catch (      IgniteCheckedException e) {\n        return new GridFinishedFuture(e);\n      }\n    }\n  }\n else {\n    req.clientStartOnly(true);\n    if (desc != null)     ccfg=desc.cacheConfiguration();\n    if (ccfg == null) {\n      if (failIfNotStarted)       return new GridFinishedFuture<>(new CacheExistsException(\"Failed to start client cache \" + \"(a cache with the given name is not started): \" + cacheName));\n else       return new GridFinishedFuture<>();\n    }\n    req.deploymentId(desc.deploymentId());\n    req.startCacheConfiguration(ccfg);\n  }\n  if (ccfg.isSwapEnabled())   for (  ClusterNode n : ctx.discovery().allNodes())   if (!GridCacheUtils.clientNode(n) && !GridCacheUtils.isSwapEnabled(n))   return new GridFinishedFuture<>(new IgniteCheckedException(\"Failed to start cache \" + cacheName + \" with swap enabled: Remote Node with ID \"+ n.id().toString().toUpperCase()+ \" has not swap SPI configured\"));\n  if (nearCfg != null)   req.nearCacheConfiguration(nearCfg);\n  req.cacheType(cacheType);\n  return F.first(initiateCacheChanges(F.asList(req),failIfExists));\n}\n", "nl": "Dynamically starts cache."}
{"code": "private HtmlSelectOneMenu createFieldMenu(){\n  HtmlSelectOneMenu field=new HtmlSelectOneMenu();\n  List children=field.getChildren();\n  children.add(createSelectItem(\"Subject\"));\n  children.add(createSelectItem(\"Sender\"));\n  children.add(createSelectItem(\"Date\"));\n  children.add(createSelectItem(\"Priority\"));\n  children.add(createSelectItem(\"Status\"));\n  children.add(createSelectItem(\"To\"));\n  children.add(createSelectItem(\"Cc\"));\n  children.add(createSelectItem(\"To or Cc\"));\n  return field;\n}\n", "nl": "Creates the menu that allows the user to select a field."}
{"code": "public void close(){\nsynchronized (mDiskCacheLock) {\n    if (mDiskLruCache != null) {\n      try {\n        if (!mDiskLruCache.isClosed()) {\n          mDiskLruCache.close();\n        }\n      }\n catch (      Throwable e) {\n        LogUtils.e(e.getMessage(),e);\n      }\n      mDiskLruCache=null;\n    }\n  }\n}\n", "nl": "Closes the disk cache associated with this ImageCache object. Note that this includes disk access so this should not be executed on the main/UI thread."}
{"code": "private void init(){\n  customElements=new CustomElementCollection();\n  this.setExtension(customElements);\n}\n", "nl": "Common initialization code for new list entries."}
{"code": "public _ScheduleDays(){\n  super();\n}\n", "nl": "Constructs a _ScheduleDays with no flags initially set."}
{"code": "public int allocLow(int size,int addrAlignment){\n  for (MemoryChunk memoryChunk=low; memoryChunk != null; memoryChunk=memoryChunk.next) {\n    if (memoryChunk.isAvailable(size,addrAlignment)) {\n      return allocLow(memoryChunk,size,addrAlignment);\n    }\n  }\n  return 0;\n}\n", "nl": "Allocate a memory at the lowest address."}
{"code": "public double heapInit(){\n  return memory.getHeapMemoryUsage().getInit();\n}\n", "nl": "Returns the heap initial memory of the current JVM."}
{"code": "public final long size(){\n  int sum=0;\n  for (int i=0; i < this.sets.length; i++) {\n    sum+=this.sets[i].size();\n  }\n  return sum;\n}\n", "nl": "Returns the number of fingerprints in this set. Warning: The size is only accurate in single-threaded mode."}
{"code": "private static Location initLocation(GlowSession session,PlayerReader reader){\n  if (reader.hasPlayedBefore()) {\n    Location loc=reader.getLocation();\n    if (loc != null) {\n      return loc;\n    }\n  }\n  return session.getServer().getWorlds().get(0).getSpawnLocation();\n}\n", "nl": "Read the location from a PlayerReader for entity initialization. Will fall back to a reasonable default rather than returning null."}
{"code": "public CheckRef createCheckRef(){\n  CheckRefImpl checkRef=new CheckRefImpl();\n  return checkRef;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static <T1,T2,R>Supplier<R> partial2(final T1 t1,final T2 t2,final BiFunction<T1,T2,R> biFunc){\n  return null;\n}\n", "nl": "Returns a function with 2 arguments applied to the supplied BiFunction"}
{"code": "@Override protected void endBody() throws IOException {\n  PrintStream out=getPrintStream();\n  out.println(endBodyText);\n}\n", "nl": "Extra stuff printed at the end of the &lt;body&gt; element."}
{"code": "private void updateView(){\n  if (!hasEditor()) {\n    return;\n  }\n  ViewEditor editor=getEditor();\n  relationSetEditor.updateTable(editor.getBuiltinAnalysisPlugins());\n  relationSetEditor.selectRelations(editor.getDisplayRelations());\n}\n", "nl": "Update the view after a change in the model."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.CONSTRAINT_BODY___CONSTRAINT_EXPR_1:\n    return ((InternalEList<?>)getConstraintExpr_1()).basicRemove(otherEnd,msgs);\ncase UmplePackage.CONSTRAINT_BODY___ANONYMOUS_CONSTRAINT_BODY_11:\n  return ((InternalEList<?>)getAnonymous_constraintBody_1_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void unionRE(Nonterminal nt,RE re){\n  RE old=getRE(nt);\n  try {\n    setRE(nt,old.union(re));\n  }\n catch (  InterruptedException e) {\n    throw new RuntimeException();\n  }\n}\n", "nl": "Union the parameter regular expression with the existing regular expression mapped to the parameter nonterminal."}
{"code": "private void closeConnection(IConnection conn){\n  try {\n    if (conn != null && conn.isOpen())     conn.close();\n  }\n catch (  OdaException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Attempts to close given ODA connection."}
{"code": "public DefaultNominator(Agent parentAgent){\n  this.parentAgent=parentAgent;\n  logger=new Logger(classLogger,parentAgent.getLogger());\n  parentAgent.addStateChangeListener(this);\n}\n", "nl": "Creates a new instance of this nominator using <tt>parentAgent</tt> as a reference to the <tt>Agent</tt> instance that we should use to nominate pairs."}
{"code": "private void advance() throws IOException {\n  close();\n  if (it.hasNext()) {\n    current=it.next().getInput();\n  }\n}\n", "nl": "Closes the current reader and opens the next one, if any."}
{"code": "public static int uninstallSilent(Context context,String packageName,boolean isKeepData){\n  if (packageName == null || packageName.length() == 0) {\n    return DELETE_FAILED_INVALID_PACKAGE;\n  }\n  StringBuilder command=new StringBuilder().append(\"LD_LIBRARY_PATH=/vendor/lib:/system/lib pm uninstall\").append(isKeepData ? \" -k \" : \" \").append(packageName.replace(\" \",\"\\\\ \"));\n  ShellUtil.CommandResult commandResult=ShellUtil.execCommand(command.toString(),!isSystemApplication(context),true);\n  if (commandResult.successMsg != null && (commandResult.successMsg.contains(\"Success\") || commandResult.successMsg.contains(\"success\"))) {\n    return DELETE_SUCCEEDED;\n  }\n  Logger.e(new StringBuilder().append(\"uninstallSilent successMsg:\").append(commandResult.successMsg).append(\", ErrorMsg:\").append(commandResult.errorMsg).toString());\n  if (commandResult.errorMsg == null) {\n    return DELETE_FAILED_INTERNAL_ERROR;\n  }\n  if (commandResult.errorMsg.contains(\"Permission denied\")) {\n    return DELETE_FAILED_PERMISSION_DENIED;\n  }\n  return DELETE_FAILED_INTERNAL_ERROR;\n}\n", "nl": "uninstall package silent by root <ul> <strong>Attentions:</strong> <li>Don't call this on the ui thread, it may costs some times.</li> <li>You should add <strong>android.permission.DELETE_PACKAGES</strong> in manifest, so no need to request root permission, if you are system app.</li> </ul>"}
{"code": "@AfterClass public static void teardownAfterClass(){\n  MockStendlRPWorld.reset();\n}\n", "nl": "cleanup after tests"}
{"code": "public final void info(Object message){\n  if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {\n    log(SimpleLog.LOG_LEVEL_INFO,message,null);\n  }\n}\n", "nl": "Logs a message with  <code>org.apache.commons.logging.impl.SimpleLog.LOG_LEVEL_INFO</code>."}
{"code": "@Override public boolean execute(final Player player,final List<String> args){\n  return load(player,args);\n}\n", "nl": "Executes this script."}
{"code": "public boolean isClosingHtmlTag(){\n  return this.htmlTagIndex != -1 && (this.htmlTagIndex & JAVADOC_CLOSED_TAG) != 0;\n}\n", "nl": "Returns whether the text is a closing html tag or not."}
{"code": "protected void appendMove(Game game,int halfMoveNumber){\n  int currentRow=halfMoveNumber / 2;\n  if (halfMoveNumber % 2 != 0) {\n    movesTable.setText(currentRow,1,GameUtils.convertSanToUseUnicode(game.getMoveList().get(halfMoveNumber).toString(),false));\n  }\n else {\n    int moveNumber=currentRow + 1;\n    movesTable.appendRow(new String[]{String.valueOf(moveNumber) + \") \" + GameUtils.convertSanToUseUnicode(game.getMoveList().get(halfMoveNumber).toString(),true),\"\"});\n  }\n}\n", "nl": "Appends the move at the specified half move number to the movesTable."}
{"code": "public boolean isReversal(){\n  return m_IsReversal;\n}\n", "nl": "Is Reversal"}
{"code": "@Override public byte[] convertIndexToRGB(final byte[] data){\n  final byte[] newdata=new byte[3 * 256];\n  int inpLen=domain.length / 2;\n  int palLen=data.length / inpLen;\n  float[] inputs=new float[inpLen];\n  float[] operand;\n  int p=0, pp=0, tt;\n  for (int i=0, ii=Math.min(256,palLen); i < ii; i++) {\n    for (int j=0; j < inpLen; j++) {\n      inputs[j]=(data[p++] & 0xff) / 255f;\n    }\n    operand=colorMapper.getOperandFloat(inputs);\n    altCS.setColor(operand,operand.length);\n    tt=altCS.getColor().getRGB();\n    newdata[pp++]=(byte)((tt >> 16) & 0xff);\n    newdata[pp++]=(byte)((tt >> 8) & 0xff);\n    newdata[pp++]=(byte)(tt & 0xff);\n  }\n  return newdata;\n}\n", "nl": "create rgb index for color conversion"}
{"code": "private void createECOMConnection(CimConnectionInfo connectionInfo) throws Exception {\n  String hostAndPort=generateConnectionCacheKey(connectionInfo.getHost(),connectionInfo.getPort());\n  s_logger.info(\"Creating connection to ECOM provider on host/port {}\",hostAndPort);\n  try {\n    EcomConnection connection=new EcomConnection(connectionInfo,_listener,_configuration.getIndicationFilterMap());\n    connection.connect(_configuration.getSubscriptionsIdentifier(),_configuration.getDeleteStaleSubscriptionsOnConnect());\n    _connections.put(hostAndPort,connection);\n    connectionLastTouch.put(hostAndPort,System.currentTimeMillis());\n  }\n catch (  Exception e) {\n    throw new Exception(MessageFormatter.format(\"Failed creating connection to ECOM provider on host/port {}\",hostAndPort).getMessage(),e);\n  }\n}\n", "nl": "Creates a connection to an ECOM provider using the passed connection info."}
{"code": "private void updateProgress(int progress){\n  if (myHost != null && progress != previousProgress) {\n    myHost.updateProgress(progress);\n  }\n  previousProgress=progress;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "protected AbstractStoringPageFile(int pageSize){\n  this.emptyPages=new Stack<>();\n  this.nextPageID=0;\n  this.pageSize=pageSize;\n}\n", "nl": "Creates a new PageFile."}
{"code": "public RandomPartition(double proba){\n  this.proba=proba;\n  random=new Random();\n}\n", "nl": "Creates a new vertex filter."}
{"code": "protected NamedNodeMap createAttributes(){\n  return new ExtendedNamedNodeHashMap();\n}\n", "nl": "Creates the attribute list."}
{"code": "public ValidatorITCase(String name){\n  super(name);\n}\n", "nl": "Construct a new instance of this test case."}
{"code": "public Point(Point p){\n  this(p.x,p.y);\n}\n", "nl": "Constructs and initializes a point with the same location as the specified <code>Point</code> object."}
{"code": "public static void initialiseListOfSupportedEbookFormats(){\n  if (EBookFormat.getSupportedFormats() != null) {\n    return;\n  }\n  List<EBookFormat> supportedFormats=new LinkedList<EBookFormat>();\n  InputStream is=ConfigurationManager.getResourceAsStream(Constants.MIMETYPES_FILENAME);\n  assert is != null;\n  Scanner scanner=new Scanner(is);\n  String line;\n  try {\n    while (scanner.hasNextLine()) {\n      line=scanner.nextLine();\n      if (line.length() == 0 || line.charAt(0) == '#') {\n        continue;\n      }\n      Scanner lineScanner=new Scanner(line);\n      String formatType=null;\n      if (lineScanner.hasNext())       formatType=lineScanner.next();\n      String mimeType=null;\n      if (lineScanner.hasNext())       mimeType=lineScanner.next();\n      if (Helper.isNullOrEmpty(formatType) || Helper.isNullOrEmpty(mimeType)) {\n        logger.error(\"Invalid line in Mimetypes file '\" + line + \"'\");\n        continue;\n      }\n      supportedFormats.add(new EBookFormat(formatType,mimeType));\n    }\n    scanner.close();\n    is.close();\n  }\n catch (  Exception e) {\n  }\n  EBookFormat.setSupportedFormats(supportedFormats);\n}\n", "nl": "get the list of supported ebook formats. We use the function that can read from a user configuration file (if present), and if that is not present the default resource file"}
{"code": "public void readRawBinary(BinaryRawReader reader) throws BinaryObjectException {\n  affKey=BinaryUtils.readIgniteUuid(reader);\n  status=reader.readInt();\n  startOff=reader.readLong();\n  endOff=reader.readLong();\n}\n", "nl": "Reads fields from provided reader."}
{"code": "@Override public boolean markSupported(){\n  return false;\n}\n", "nl": "Since we do not support marking just yet, we return false."}
{"code": "@Override public String toString(){\n  return \"Cursor: \" + index;\n}\n", "nl": "Returns the string representation of this cursor."}
{"code": "public void removeThemeRefreshListener(ActionListener l){\n  if (themelisteners == null) {\n    return;\n  }\n  themelisteners.removeListener(l);\n}\n", "nl": "Removes a Theme refresh listener."}
{"code": "public JSONWriter object() throws JSONException {\n  if (this.mode == 'i') {\n    this.mode='o';\n  }\n  if (this.mode == 'o' || this.mode == 'a') {\n    this.append(\"{\");\n    this.push(new JSONObject());\n    this.comma=false;\n    return this;\n  }\n  throw new JSONException(\"Misplaced object.\");\n}\n", "nl": "Begin appending a new object. All keys and values until the balancing <code>endObject</code> will be appended to this object. The <code>endObject</code> method must be called to mark the object's end."}
{"code": "public void fillFieldValues(List<SynapseUpdateRule> ruleList){\n  OjaRule synapseRef=(OjaRule)ruleList.get(0);\n  if (!NetworkUtils.isConsistent(ruleList,OjaRule.class,\"getNormalizationFactor\")) {\n    tfNormalize.setText(SimbrainConstants.NULL_STRING);\n  }\n else {\n    tfNormalize.setText(Double.toString(synapseRef.getNormalizationFactor()));\n  }\n  if (!NetworkUtils.isConsistent(ruleList,OjaRule.class,\"getLearningRate\")) {\n    tfLearningRate.setText(SimbrainConstants.NULL_STRING);\n  }\n else {\n    tfLearningRate.setText(Double.toString(synapseRef.getLearningRate()));\n  }\n}\n", "nl": "Populate fields with current data."}
{"code": "void clear(){\n  zoneInfo.zoneChanged();\n}\n", "nl": "Prepare for zone change."}
{"code": "@SuppressWarnings({\"SimplifiableIfStatement\",\"IfMayBeConditional\"}) public void finish(){\n  boolean sync;\n  if (!F.isEmpty(dhtMap) || !F.isEmpty(nearMap))   sync=finish(dhtMap,nearMap);\n else   if (!commit && !F.isEmpty(tx.lockTransactionNodes()))   sync=rollbackLockTransactions(tx.lockTransactionNodes());\n else   sync=false;\n  markInitialized();\n  if (!sync)   onComplete();\n}\n", "nl": "Initializes future."}
{"code": "public static double pow(double x,double y){\n  final double lns[]=new double[2];\n  if (y == 0.0) {\n    return 1.0;\n  }\n  if (x != x) {\n    return x;\n  }\n  if (x == 0) {\n    long bits=Double.doubleToRawLongBits(x);\n    if ((bits & 0x8000000000000000L) != 0) {\n      long yi=(long)y;\n      if (y < 0 && y == yi && (yi & 1) == 1) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      if (y > 0 && y == yi && (yi & 1) == 1) {\n        return -0.0;\n      }\n    }\n    if (y < 0) {\n      return Double.POSITIVE_INFINITY;\n    }\n    if (y > 0) {\n      return 0.0;\n    }\n    return Double.NaN;\n  }\n  if (x == Double.POSITIVE_INFINITY) {\n    if (y != y) {\n      return y;\n    }\n    if (y < 0.0) {\n      return 0.0;\n    }\n else {\n      return Double.POSITIVE_INFINITY;\n    }\n  }\n  if (y == Double.POSITIVE_INFINITY) {\n    if (x * x == 1.0) {\n      return Double.NaN;\n    }\n    if (x * x > 1.0) {\n      return Double.POSITIVE_INFINITY;\n    }\n else {\n      return 0.0;\n    }\n  }\n  if (x == Double.NEGATIVE_INFINITY) {\n    if (y != y) {\n      return y;\n    }\n    if (y < 0) {\n      long yi=(long)y;\n      if (y == yi && (yi & 1) == 1) {\n        return -0.0;\n      }\n      return 0.0;\n    }\n    if (y > 0) {\n      long yi=(long)y;\n      if (y == yi && (yi & 1) == 1) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      return Double.POSITIVE_INFINITY;\n    }\n  }\n  if (y == Double.NEGATIVE_INFINITY) {\n    if (x * x == 1.0) {\n      return Double.NaN;\n    }\n    if (x * x < 1.0) {\n      return Double.POSITIVE_INFINITY;\n    }\n else {\n      return 0.0;\n    }\n  }\n  if (x < 0) {\n    if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n      return pow(-x,y);\n    }\n    if (y == (long)y) {\n      return ((long)y & 1) == 0 ? pow(-x,y) : -pow(-x,y);\n    }\n else {\n      return Double.NaN;\n    }\n  }\n  double ya;\n  double yb;\n  if (y < 8e298 && y > -8e298) {\n    double tmp1=y * HEX_40000000;\n    ya=y + tmp1 - tmp1;\n    yb=y - ya;\n  }\n else {\n    double tmp1=y * 9.31322574615478515625E-10;\n    double tmp2=tmp1 * 9.31322574615478515625E-10;\n    ya=(tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n    yb=y - ya;\n  }\n  final double lores=log(x,lns);\n  if (Double.isInfinite(lores)) {\n    return lores;\n  }\n  double lna=lns[0];\n  double lnb=lns[1];\n  double tmp1=lna * HEX_40000000;\n  double tmp2=lna + tmp1 - tmp1;\n  lnb+=lna - tmp2;\n  lna=tmp2;\n  final double aa=lna * ya;\n  final double ab=lna * yb + lnb * ya + lnb * yb;\n  lna=aa + ab;\n  lnb=-(lna - aa - ab);\n  double z=1.0 / 120.0;\n  z=z * lnb + (1.0 / 24.0);\n  z=z * lnb + (1.0 / 6.0);\n  z=z * lnb + 0.5;\n  z=z * lnb + 1.0;\n  z*=lnb;\n  final double result=exp(lna,z,null);\n  return result;\n}\n", "nl": "Power function.  Compute x^y."}
{"code": "public static Dcsn cs_qr(Dcs A,Dcss S){\n  double Rx[], Vx[], Ax[], x[], Beta[];\n  int i, k, p, n, vnz, p1, top, m2, len, col, rnz, s[], leftmost[], Ap[], Ai[], parent[], Rp[], Ri[], Vp[], Vi[], w[], pinv[], q[];\n  Dcs R, V;\n  Dcsn N;\n  if (!Dcs_util.CS_CSC(A) || S == null)   return (null);\n  n=A.n;\n  Ap=A.p;\n  Ai=A.i;\n  Ax=A.x;\n  q=S.q;\n  parent=S.parent;\n  pinv=S.pinv;\n  m2=S.m2;\n  vnz=S.lnz;\n  rnz=S.unz;\n  leftmost=S.leftmost;\n  w=new int[m2 + n];\n  x=new double[m2];\n  N=new Dcsn();\n  s=w;\n  int s_offset=m2;\n  for (k=0; k < m2; k++)   x[k]=0;\n  N.L=V=Dcs_util.cs_spalloc(m2,n,vnz,true,false);\n  N.U=R=Dcs_util.cs_spalloc(m2,n,rnz,true,false);\n  N.B=Beta=new double[n];\n  Rp=R.p;\n  Ri=R.i;\n  Rx=R.x;\n  Vp=V.p;\n  Vi=V.i;\n  Vx=V.x;\n  for (i=0; i < m2; i++)   w[i]=-1;\n  rnz=0;\n  vnz=0;\n  for (k=0; k < n; k++) {\n    Rp[k]=rnz;\n    Vp[k]=p1=vnz;\n    w[k]=k;\n    Vi[vnz++]=k;\n    top=n;\n    col=q != null ? q[k] : k;\n    for (p=Ap[col]; p < Ap[col + 1]; p++) {\n      i=leftmost[Ai[p]];\n      for (len=0; w[i] != k; i=parent[i]) {\n        s[s_offset + (len++)]=i;\n        w[i]=k;\n      }\n      while (len > 0)       s[s_offset + (--top)]=s[s_offset + (--len)];\n      i=pinv[Ai[p]];\n      x[i]=Ax[p];\n      if (i > k && w[i] < k) {\n        Vi[vnz++]=i;\n        w[i]=k;\n      }\n    }\n    for (p=top; p < n; p++) {\n      i=s[s_offset + p];\n      Dcs_happly.cs_happly(V,i,Beta[i],x);\n      Ri[rnz]=i;\n      Rx[rnz++]=x[i];\n      x[i]=0;\n      if (parent[i] == k)       vnz=Dcs_scatter.cs_scatter(V,i,0,w,null,k,V,vnz);\n    }\n    for (p=p1; p < vnz; p++) {\n      Vx[p]=x[Vi[p]];\n      x[Vi[p]]=0;\n    }\n    Ri[rnz]=k;\n    double[] beta=new double[1];\n    beta[0]=Beta[k];\n    Rx[rnz++]=Dcs_house.cs_house(Vx,p1,beta,vnz - p1);\n    Beta[k]=beta[0];\n  }\n  Rp[n]=rnz;\n  Vp[n]=vnz;\n  return N;\n}\n", "nl": "Sparse QR factorization of an m-by-n matrix A, A= Q*R"}
{"code": "public boolean isCellEditable(int row,int col){\n  return false;\n}\n", "nl": "Gets the cellEditable attribute of the PropertiesTableModel object"}
{"code": "public JSONArray optJSONArray(String key){\n  Object o=opt(key);\n  return o instanceof JSONArray ? (JSONArray)o : null;\n}\n", "nl": "Get an optional JSONArray associated with a key. It returns null if there is no such key, or if its value is not a JSONArray."}
{"code": "@org.hamcrest.Factory public static org.hamcrest.Matcher<Double> equalTo(final Double value){\n  return equalTo(value,10);\n}\n", "nl": "Creates a rounded equal matcher that checks double (near) equality."}
{"code": "public ChartViewer(JFreeChart chart){\n  this(chart,true);\n}\n", "nl": "Creates a new viewer to display the supplied chart in JavaFX."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-24 15:47:29.087 -0500\",hash_original_method=\"B33F4935D7EC88037EE2967518A095D3\",hash_generated_method=\"94868AEDB16628F241D8220AA3C50090\") @DSSpec(DSCat.IO) public static String sha512Hex(InputStream data) throws IOException {\n  return Hex.encodeHexString(sha512(data));\n}\n", "nl": "Calculates the SHA-512 digest and returns the value as a hex string. <p> Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0. </p>"}
{"code": "public VirtualMachineError(java.lang.String s){\n  super(s);\n}\n", "nl": "Constructs a VirtualMachineError with the specified detail message. s - the detail message."}
{"code": "public Response onCommand(POP3Session session,Request request){\n  if (session.getHandlerState() == POP3Session.TRANSACTION) {\n    stat(session);\n    return POP3Response.OK;\n  }\n else {\n    return POP3Response.ERR;\n  }\n}\n", "nl": "Handler method called upon receipt of a RSET command. Calls stat() to reset the mailbox."}
{"code": "public int serverDelivery(Object message,Object consumer,int deliveryCount) throws Exception {\n  ProtonServerSenderContext protonSender=serverSenders.get(consumer);\n  if (protonSender != null) {\n    return protonSender.deliverMessage(message,deliveryCount);\n  }\n  return 0;\n}\n", "nl": "The consumer object from the broker or the key used to store the sender"}
{"code": "public static void rollbackConnection(@Nullable Connection rsrc,@Nullable IgniteLogger log){\n  if (rsrc != null)   try {\n    rsrc.rollback();\n  }\n catch (  SQLException e) {\n    warn(log,\"Failed to rollback JDBC connection: \" + e.getMessage());\n  }\n}\n", "nl": "Rollbacks JDBC connection logging possible checked exception."}
{"code": "public void stop(int taskId){\n  this.readTasks.get(taskId).stop();\n}\n", "nl": "Stop the reader for a particular task."}
{"code": "public TypeEraseFilterFactory(Map<String,String> args){\n  super(args);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "nl": "Creates a new PorterStemFilterFactory"}
{"code": "protected void makeRegionData(DrawContext dc){\n  this.currentData=(RegionData)this.regionDataCache.getEntry(dc.getGlobe());\n  if (this.currentData == null) {\n    this.currentData=this.createCacheEntry(dc);\n    this.regionDataCache.addEntry(this.currentData);\n  }\n  if (dc.getFrameTimeStamp() != this.getCurrentData().getFrameNumber()) {\n    if (this.mustRegenerateData(dc)) {\n      this.doMakeRegionData(dc);\n      this.getCurrentData().restartTimer(dc);\n      this.getCurrentData().setGlobeStateKey(dc.getGlobe().getGlobeStateKey(dc));\n      this.getCurrentData().setVerticalExaggeration(dc.getVerticalExaggeration());\n    }\n    this.getCurrentData().setFrameNumber(dc.getFrameTimeStamp());\n  }\n}\n", "nl": "Produces the data used to determine whether this Region is active for the specified <code>DrawContext</code>. This attempts to re-use <code>RegionData</code> already been calculated this frame, or previously calculated <code>RegionData</code> that is still valid and has not expired. This method is called by <code>isActive</code> prior to determining if this Region is actually active."}
{"code": "@Override public boolean batchFinished(){\n  if (getInputFormat() == null) {\n    throw new IllegalStateException(\"No input instance format defined\");\n  }\n  if (m_Values == null) {\n    determineValues(getInputFormat());\n    setOutputFormat();\n  }\n  flushInput();\n  m_NewBatch=true;\n  m_FirstBatchDone=true;\n  return (numPendingOutput() != 0);\n}\n", "nl": "Signifies that this batch of input to the filter is finished. If the filter requires all instances prior to filtering, output() may now be called to retrieve the filtered instances."}
{"code": "@Override public T defaultCase(EObject object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>EObject</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch, but this is the last case anyway. <!-- end-user-doc -->"}
{"code": "@Override public void environmentConfigure(EnvironmentClassLoader loader) throws ConfigException {\n}\n", "nl": "Handles the case where the environment is configuring and registering beans"}
{"code": "@Override protected void mouseClicked(int par1,int par2,int par3) throws IOException {\n  if (par2 >= 36 && par2 <= height - 57)   if (par1 >= width / 2 + 140 || par1 <= width / 2 - 126)   altList.elementClicked(-1,false,0,0);\n  super.mouseClicked(par1,par2,par3);\n}\n", "nl": "Called when the mouse is clicked."}
{"code": "public void paint(Graphics g,Shape a){\n  Rectangle alloc=(a instanceof Rectangle) ? (Rectangle)a : a.getBounds();\n  tabBase=alloc.x;\n  Graphics2D g2d=(Graphics2D)g;\n  host=(RSyntaxTextArea)getContainer();\n  int ascent=host.getMaxAscent();\n  int fontHeight=host.getLineHeight();\n  int n=getViewCount();\n  int x=alloc.x + getLeftInset();\n  int y=alloc.y + getTopInset();\n  Rectangle clip=g.getClipBounds();\n  for (int i=0; i < n; i++) {\n    tempRect.x=x + getOffset(X_AXIS,i);\n    tempRect.y=y + getOffset(Y_AXIS,i);\n    tempRect.width=getSpan(X_AXIS,i);\n    tempRect.height=getSpan(Y_AXIS,i);\n    if (tempRect.intersects(clip)) {\n      View view=getView(i);\n      drawView(g2d,alloc,view,fontHeight,tempRect.y + ascent);\n    }\n  }\n}\n", "nl": "Paints the word-wrapped text."}
{"code": "@Override public final void wakeUp() throws AdeException {\n  super.wakeUp();\n  createUsageVariables();\n}\n", "nl": "Create variables for this class after deserialization."}
{"code": "public Term(String fld,String text){\n  this(fld,new BytesRef(text));\n}\n", "nl": "Constructs a Term with the given field and text. <p>Note that a null field or null text value results in undefined behavior for most Lucene APIs that accept a Term parameter."}
{"code": "HeapArrayOfDoublesQuickSelectSketch(final int nomEntries,final int lgResizeFactor,final float samplingProbability,final int numValues,final long seed){\n  super(numValues,seed);\n  nomEntries_=ceilingPowerOf2(nomEntries);\n  lgResizeFactor_=lgResizeFactor;\n  samplingProbability_=samplingProbability;\n  theta_=(long)(Long.MAX_VALUE * (double)samplingProbability);\n  final int startingCapacity=1 << startingSubMultiple(Integer.numberOfTrailingZeros(ceilingPowerOf2(nomEntries) * 2),ResizeFactor.getRF(lgResizeFactor),MIN_LG_ARR_LONGS);\n  keys_=new long[startingCapacity];\n  values_=new double[startingCapacity * numValues];\n  lgCurrentCapacity_=Integer.numberOfTrailingZeros(startingCapacity);\n  setRebuildThreshold();\n}\n", "nl": "This is to create an instance of a QuickSelectSketch with custom resize factor and sampling  probability"}
{"code": "public static void main(String[] args){\n  doMain(args);\n}\n", "nl": "Application entry point."}
{"code": "private static Class<?> toJavaType(DbColumn col){\n  boolean nullable=col.nullable();\n  boolean unsigned=col.unsigned();\nswitch (col.type()) {\ncase BIT:\ncase BOOLEAN:\n    return nullable ? Boolean.class : boolean.class;\ncase TINYINT:\n  return unsigned ? (nullable ? Short.class : short.class) : (nullable ? Byte.class : byte.class);\ncase SMALLINT:\nreturn unsigned ? (nullable ? Integer.class : int.class) : (nullable ? Short.class : short.class);\ncase INTEGER:\nreturn unsigned ? (nullable ? Long.class : long.class) : (nullable ? Integer.class : int.class);\ncase BIGINT:\nreturn nullable ? Long.class : long.class;\ncase REAL:\nreturn nullable ? Float.class : float.class;\ncase FLOAT:\ncase DOUBLE:\nreturn nullable ? Double.class : double.class;\ncase NUMERIC:\ncase DECIMAL:\nreturn BigDecimal.class;\ncase CHAR:\ncase VARCHAR:\ncase LONGVARCHAR:\ncase NCHAR:\ncase NVARCHAR:\ncase LONGNVARCHAR:\ncase CLOB:\ncase NCLOB:\ncase SQLXML:\nreturn String.class;\ncase DATE:\nreturn java.sql.Date.class;\ncase TIME:\nreturn java.sql.Time.class;\ncase TIMESTAMP:\nreturn java.sql.Timestamp.class;\ndefault :\nreturn Object.class;\n}\n}\n", "nl": "Convert JDBC data type to java type."}
{"code": "public Token createToken(){\n  Token token=tokenList[currentFreeToken];\n  token.text=null;\n  token.type=Token.NULL;\n  token.offset=-1;\n  token.setNextToken(null);\n  currentFreeToken++;\n  if (currentFreeToken == size)   augmentTokenList();\n  return token;\n}\n", "nl": "Returns a null token."}
{"code": "private static synchronized int increment(){\n  return cyclicCounter++;\n}\n", "nl": "The central method to increment the cyclic counter, synchronized to achieve a unique value for each subsequent call <p> there is no problem if the counter reaches the maximum counter value, defined by N_COUNTERS_CHARS, only the right number of bits are taken into account for generating the output"}
{"code": "public SSHFPRecord(Name name,int dclass,long ttl,int alg,int digestType,byte[] fingerprint){\n  super(name,Type.SSHFP,dclass,ttl);\n  this.alg=checkU8(\"alg\",alg);\n  this.digestType=checkU8(\"digestType\",digestType);\n  this.fingerprint=fingerprint;\n}\n", "nl": "Creates an SSHFP Record from the given data."}
{"code": "protected Control createDialogArea(Composite composite){\n  list=new List(composite,SWT.SINGLE | SWT.V_SCROLL | SWT.RESIZE);\n  setList();\n  list.addSelectionListener(new ShowDeclarationsSelectionListener(EditorUtil.getTLAEditorWithFocus()));\n  list.addKeyListener(new ShowDeclarationsKeyListener(this));\n  list.setSelection(0);\n  return list;\n}\n", "nl": "This is the method that puts the content into the popup's dialog area.  It puts an org.eclipse.swt.widgets.List (note that this isn't an ordinary Java List) there."}
{"code": "public HelloMinecraftLookAndFeel() throws ParseException {\n  this(DEFAULT_SETTINGS);\n}\n", "nl": "Creates a new instance of NimbusLookAndFeel"}
{"code": "private static Schema loadWsTrustSchema(){\n  try {\n    Schema wsTrustSchema=Util.loadXmlSchemaFromResource(ResponseUnmarshaller.class,WS_TRUST_1_3_SCHEMA);\n    return wsTrustSchema;\n  }\n catch (  IllegalArgumentException e) {\n    LoggerFactory.getLogger(SamlTokenImpl.class).error(String.format(\"Schema resource `%s' is missing.\",WS_TRUST_1_3_SCHEMA),e);\n    throw new RuntimeException(String.format(\"Schema resource `%s' is missing.\",WS_TRUST_1_3_SCHEMA),e);\n  }\ncatch (  SAXException e) {\n    LoggerFactory.getLogger(ResponseUnmarshaller.class).error(ERR_LOADING_WS_TRUST_SCHEMA,e);\n    throw new RuntimeException(ERR_LOADING_WS_TRUST_SCHEMA,e);\n  }\n}\n", "nl": "Loads WS-Trust schema file."}
{"code": "public TestProgressBar(Composite parent,int style){\n  super(parent,style);\n  colorSkipped=new Color(Display.getCurrent(),230,232,235);\n  colorPassed=new Color(Display.getCurrent(),198,242,177);\n  colorFailed=new Color(Display.getCurrent(),242,188,177);\n  colorError=new Color(Display.getCurrent(),242,188,177);\n  colorFixme=new Color(Display.getCurrent(),177,231,242);\n  addPaintListener(null);\n  addDisposeListener(null);\n}\n", "nl": "Create instance."}
{"code": "public DigesterOutputStream(MessageDigest md,boolean buffer){\n  this.md=md;\n  this.buffer=buffer;\n  if (buffer) {\n    bos=new UnsyncByteArrayOutputStream();\n  }\n}\n", "nl": "Creates a DigesterOutputStream."}
{"code": "public static String format(double[] v,int w,int d){\n  DecimalFormat format=new DecimalFormat();\n  format.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));\n  format.setMinimumIntegerDigits(1);\n  format.setMaximumFractionDigits(d);\n  format.setMinimumFractionDigits(d);\n  format.setGroupingUsed(false);\n  int width=w + 1;\n  StringBuilder msg=new StringBuilder();\n  msg.append('\\n');\n  for (int i=0; i < v.length; i++) {\n    String s=format.format(v[i]);\n    int padding=Math.max(1,width - s.length());\n    for (int k=0; k < padding; k++) {\n      msg.append(' ');\n    }\n    msg.append(s);\n  }\n  return msg.toString();\n}\n", "nl": "Returns a string representation of this vector."}
{"code": "private void writeQNameAttribute(java.lang.String namespace,java.lang.String attName,javax.xml.namespace.QName qname,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  java.lang.String attributeNamespace=qname.getNamespaceURI();\n  java.lang.String attributePrefix=xmlWriter.getPrefix(attributeNamespace);\n  if (attributePrefix == null) {\n    attributePrefix=registerPrefix(xmlWriter,attributeNamespace);\n  }\n  java.lang.String attributeValue;\n  if (attributePrefix.trim().length() > 0) {\n    attributeValue=attributePrefix + \":\" + qname.getLocalPart();\n  }\n else {\n    attributeValue=qname.getLocalPart();\n  }\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attributeValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attributeValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "@Deprecated public void showDoneButton(boolean showDone){\n  setProgressButtonEnabled(showDone);\n}\n", "nl": "Shows or hides Done button, replaced with setProgressButtonEnabled"}
{"code": "public void onReloadPreferences(){\n  SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(mContext);\n  boolean enableTapDetection=false;\n  if (!settings.getString(mContext.getString(R.string.pref_shortcut_single_tap_key),mContext.getString(R.string.pref_shortcut_single_tap_default)).equals(mContext.getString(R.string.shortcut_value_unassigned))) {\n    enableTapDetection=true;\n  }\n  if (!settings.getString(mContext.getString(R.string.pref_shortcut_double_tap_key),mContext.getString(R.string.pref_shortcut_double_tap_default)).equals(mContext.getString(R.string.shortcut_value_unassigned))) {\n    enableTapDetection=true;\n    mIntegratedTapDetector.setMaxDoubleTapSpacingNanos(DOUBLE_TAP_SPACING_NANOS);\n  }\n else {\n    mIntegratedTapDetector.setMaxDoubleTapSpacingNanos(0);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_lowest))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_HIGHEST);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_low))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_HIGH);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_medium))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_MEDIUM);\n  }\n  if (settings.getString(mContext.getString(R.string.pref_tap_sensitivity_key),mContext.getString(R.string.pref_tap_sensitivity_default)).equals(mContext.getString(R.string.tap_sensitivity_value_high))) {\n    mIntegratedTapDetector.setTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_LOW);\n  }\n  mIntegratedTapDetector.setDoubleTapDetectionQuality(IntegratedTapDetector.TAP_QUALITY_LOW);\n  if (enableTapDetection) {\n    mIntegratedTapDetector.start();\n  }\n else {\n    mIntegratedTapDetector.stop();\n  }\n}\n", "nl": "Enables tap detection if appropriate based on preferences."}
{"code": "protected void calcAngularBounds(NodeItem r){\n  if (m_prevRoot == null || !m_prevRoot.isValid() || r == m_prevRoot) {\n    m_prevRoot=r;\n    return;\n  }\n  NodeItem p=m_prevRoot;\n  while (true) {\n    NodeItem pp=(NodeItem)p.getParent();\n    if (pp == r) {\n      break;\n    }\n else     if (pp == null) {\n      m_prevRoot=r;\n      return;\n    }\n    p=pp;\n  }\n  double dt=0;\n  Iterator iter=sortedChildren(r);\n  while (iter.hasNext()) {\n    Node n=(Node)iter.next();\n    if (n == p)     break;\n    dt+=((Params)n.get(PARAMS)).width;\n  }\n  double rw=((Params)r.get(PARAMS)).width;\n  double pw=((Params)p.get(PARAMS)).width;\n  dt=-MathLib.TWO_PI * (dt + pw / 2) / rw;\n  m_theta1=dt + Math.atan2(p.getY() - r.getY(),p.getX() - r.getX());\n  m_theta2=m_theta1 + MathLib.TWO_PI;\n  m_prevRoot=r;\n}\n", "nl": "Calculates the angular bounds of the layout, attempting to preserve the angular orientation of the display across transitions."}
{"code": "public void validateNameString(String name){\n  if (StringUtils.isEmpty(name) || NullColumnValueGetter.getNullStr().equalsIgnoreCase(name)) {\n    throw APIException.badRequests.requiredParameterMissingOrEmpty(\"name\");\n  }\n}\n", "nl": "Fires APIException.badRequests.requiredParameterMissingOrEmpty if the given collection is empty"}
{"code": "private Node tryAppend(Node s,boolean haveData){\n  for (Node t=tail, p=t; ; ) {\n    Node n, u;\n    if (p == null && (p=head) == null) {\n      if (casHead(null,s))       return s;\n    }\n else     if (p.cannotPrecede(haveData))     return null;\n else     if ((n=p.next) != null)     p=p != t && t != (u=tail) ? (t=u) : (p != n) ? n : null;\n else     if (!p.casNext(null,s))     p=p.next;\n else {\n      if (p != t) {\n        while ((tail != t || !casTail(t,s)) && (t=tail) != null && (s=t.next) != null && (s=s.next) != null && s != t)         ;\n      }\n      return p;\n    }\n  }\n}\n", "nl": "Tries to append node s as tail."}
{"code": "public UnconditionalFlowInfo mitigateNullInfoOf(FlowInfo flowInfo){\n  if ((this.tagBits & NULL_FLAG_MASK) == 0) {\n    return flowInfo.unconditionalInits();\n  }\n  long m, m1, nm1, m2, nm2, m3, a2, a3, a4, s1, s2, ns2, s3, ns3, s4, ns4;\n  boolean newCopy=false;\n  UnconditionalFlowInfo source=flowInfo.unconditionalInits();\n  m1=(s1=source.nullBit1) & (s3=source.nullBit3) & (s4=source.nullBit4)& ((a2=this.nullBit2) | (a4=this.nullBit4));\n  m2=s1 & (s2=this.nullBit2) & (s3 ^ s4)& ((a3=this.nullBit3) | a4);\n  m3=s1 & (s2 & (ns3=~s3) & (ns4=~s4)& (a3 | a4) | (ns2=~s2) & s3 & ns4& (a2 | a4) | ns2 & ns3 & s4& (a2 | a3));\n  if ((m=(m1 | m2 | m3)) != 0) {\n    newCopy=true;\n    source=source.unconditionalCopy();\n    source.nullBit1&=~m;\n    source.nullBit2&=(nm1=~m1) & ((nm2=~m2) | a4);\n    source.nullBit3&=(nm1 | a2) & nm2;\n    source.nullBit4&=nm1 & nm2;\n    long x=~this.nullBit1 & a2 & a3& a4;\n    if (x != 0) {\n      source.nullBit1&=~x;\n      source.nullBit2|=x;\n      source.nullBit3|=x;\n      source.nullBit4|=x;\n    }\n  }\n  if (this.extra != null && source.extra != null) {\n    int length=this.extra[2].length, sourceLength=source.extra[0].length;\n    if (sourceLength < length) {\n      length=sourceLength;\n    }\n    for (int i=0; i < length; i++) {\n      m1=(s1=source.extra[1 + 1][i]) & (s3=source.extra[3 + 1][i]) & (s4=source.extra[4 + 1][i])& ((a2=this.extra[2 + 1][i]) | (a4=this.extra[4 + 1][i]));\n      m2=s1 & (s2=this.extra[2 + 1][i]) & (s3 ^ s4)& ((a3=this.extra[3 + 1][i]) | a4);\n      m3=s1 & (s2 & (ns3=~s3) & (ns4=~s4)& (a3 | a4) | (ns2=~s2) & s3 & ns4& (a2 | a4) | ns2 & ns3 & s4& (a2 | a3));\n      if ((m=(m1 | m2 | m3)) != 0) {\n        if (!newCopy) {\n          newCopy=true;\n          source=source.unconditionalCopy();\n        }\n        source.extra[1 + 1][i]&=~m;\n        source.extra[2 + 1][i]&=(nm1=~m1) & ((nm2=~m2) | a4);\n        source.extra[3 + 1][i]&=(nm1 | a2) & nm2;\n        source.extra[4 + 1][i]&=nm1 & nm2;\n      }\n    }\n  }\n  return source;\n}\n", "nl": "Mitigate the definite and protected info of flowInfo, depending on what this null info registry knows about potential assignments and messages sends involving locals. May return flowInfo unchanged, or a modified, fresh copy of flowInfo."}
{"code": "public void testCertificateFactory01() throws CertificateException {\n  if (!X509Support) {\n    fail(NotSupportMsg);\n    return;\n  }\n  for (int i=0; i < validValues.length; i++) {\n    CertificateFactory certF=CertificateFactory.getInstance(validValues[i]);\n    assertEquals(\"Incorrect type: \",validValues[i],certF.getType());\n  }\n}\n", "nl": "Test for <code>getInstance(String type)</code> method Assertion: returns CertificateFactory if type is X.509"}
{"code": "private void applyFonts(Composite composite){\n  Dialog.applyDialogFont(composite);\n  if (titleLabel != null) {\n    Font font=titleLabel.getFont();\n    FontData[] fontDatas=font.getFontData();\n    for (int i=0; i < fontDatas.length; i++) {\n      fontDatas[i].setStyle(SWT.BOLD);\n    }\n    titleFont=new Font(titleLabel.getDisplay(),fontDatas);\n    titleLabel.setFont(titleFont);\n  }\n  if (infoLabel != null) {\n    Font font=infoLabel.getFont();\n    FontData[] fontDatas=font.getFontData();\n    for (int i=0; i < fontDatas.length; i++) {\n      fontDatas[i].setHeight(fontDatas[i].getHeight() * 9 / 10);\n    }\n    infoFont=new Font(infoLabel.getDisplay(),fontDatas);\n    infoLabel.setFont(infoFont);\n  }\n}\n", "nl": "Apply any desired fonts to the specified composite and its children."}
{"code": "public static String toStringPretty(JsonElement jsonElt){\n  return toStringPretty(jsonElt,0);\n}\n", "nl": "Returns a pretty printed string of the given Json element."}
{"code": "protected void deleteLinksOnPort(NodePortTuple npt,String reason){\n  List<Link> eraseList=new ArrayList<Link>();\n  if (this.portLinks.containsKey(npt)) {\n    if (log.isTraceEnabled()) {\n      log.trace(\"handlePortStatus: Switch {} port #{} \" + \"removing links {}\",new Object[]{npt.getNodeId().toString(),npt.getPortId(),this.portLinks.get(npt)});\n    }\n    eraseList.addAll(this.portLinks.get(npt));\n    deleteLinks(eraseList,reason);\n  }\n}\n", "nl": "Delete links incident on a given switch port."}
{"code": "private Token parseSimpleToken(final Token token,int ch) throws IOException {\n  while (true) {\n    if (readEndOfLine(ch)) {\n      token.type=EORECORD;\n      break;\n    }\n else     if (isEndOfFile(ch)) {\n      token.type=EOF;\n      token.isReady=true;\n      break;\n    }\n else     if (isDelimiter(ch)) {\n      token.type=TOKEN;\n      break;\n    }\n else     if (isEscape(ch)) {\n      final int unescaped=readEscape();\n      if (unescaped == Constants.END_OF_STREAM) {\n        token.content.append((char)ch).append((char)in.getLastChar());\n      }\n else {\n        token.content.append((char)unescaped);\n      }\n      ch=in.read();\n    }\n else {\n      token.content.append((char)ch);\n      ch=in.read();\n    }\n  }\n  if (ignoreSurroundingSpaces) {\n    trimTrailingSpaces(token.content);\n  }\n  return token;\n}\n", "nl": "Parses a simple token. <p/> Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped delimiters (as \\, or \\;). The token is finished when one of the following conditions become true: <ul> <li>end of line has been reached (EORECORD)</li> <li>end of stream has been reached (EOF)</li> <li>an unescaped delimiter has been reached (TOKEN)</li> </ul>"}
{"code": "public void updateHeader(Header header){\n  if (header == null) {\n    return;\n  }\n  for (int i=0; i < this.headers.size(); i++) {\n    Header current=(Header)this.headers.get(i);\n    if (current.getName().equalsIgnoreCase(header.getName())) {\n      this.headers.set(i,header);\n      return;\n    }\n  }\n  this.headers.add(header);\n}\n", "nl": "Replaces the first occurence of the header with the same name. If no header with  the same name is found the given header is added to the end of the list."}
{"code": "public static <S,A extends Action>Map<S,A> initialPolicyVector(MarkovDecisionProcess<S,A> mdp){\n  Map<S,A> pi=new LinkedHashMap<S,A>();\n  List<A> actions=new ArrayList<A>();\n  for (  S s : mdp.states()) {\n    actions.clear();\n    actions.addAll(mdp.actions(s));\n    if (actions.size() > 0) {\n      pi.put(s,Util.selectRandomlyFromList(actions));\n    }\n  }\n  return pi;\n}\n", "nl": "Create a policy vector indexed by state, initially random."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col, x, y;\n  double z;\n  float progress=0;\n  int a;\n  double slopeX;\n  double slopeY;\n  double val;\n  int[] dX={1,1,1,0,-1,-1,-1,0};\n  int[] dY={-1,0,1,1,1,0,-1,-1};\n  double[] maskX={1,1,1,0,-1,-1,-1,0};\n  double[] maskY={1,0,-1,-1,-1,0,1,1};\n  int numPixelsInFilter;\n  boolean reflectAtBorders=false;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (int i=0; i < args.length; i++) {\n    if (i == 0) {\n      inputHeader=args[i];\n    }\n else     if (i == 1) {\n      outputHeader=args[i];\n    }\n else     if (i == 2) {\n      reflectAtBorders=Boolean.parseBoolean(args[i]);\n    }\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster inputFile=new WhiteboxRaster(inputHeader,\"r\");\n    inputFile.isReflectedAtEdges=reflectAtBorders;\n    int rows=inputFile.getNumberRows();\n    int cols=inputFile.getNumberColumns();\n    double noData=inputFile.getNoDataValue();\n    WhiteboxRaster outputFile=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    outputFile.setPreferredPalette(\"grey.pal\");\n    numPixelsInFilter=8;\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=inputFile.getValue(row,col);\n        if (z != noData) {\n          slopeX=0;\n          slopeY=0;\n          for (a=0; a < numPixelsInFilter; a++) {\n            x=col + dX[a];\n            y=row + dY[a];\n            val=inputFile.getValue(y,x);\n            if (val == noData) {\n              val=z;\n            }\n            slopeX+=val * maskX[a];\n            slopeY+=val * maskY[a];\n          }\n          val=Math.sqrt(slopeX * slopeX + slopeY * slopeY);\n          outputFile.setValue(row,col,val);\n        }\n else {\n          outputFile.setValue(row,col,noData);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (rows - 1));\n      updateProgress((int)progress);\n    }\n    outputFile.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    outputFile.addMetadataEntry(\"Created on \" + new Date());\n    inputFile.close();\n    outputFile.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public BooleanCondition must(Condition... conditions){\n  must=add(must,conditions);\n  return this;\n}\n", "nl": "Returns this with the specified mandatory conditions."}
{"code": "public static final String toBitString(double d[]){\n  StringBuilder sb=new StringBuilder(d.length);\n  for (  double b : d) {\n    sb.append((int)Math.round(b));\n  }\n  return sb.toString();\n}\n", "nl": "ToBitString - returns a String representation of d[]."}
{"code": "public void doStoreFront(HtmlPage storeFront) throws Exception {\n  HtmlSubmitInput button=null;\n  HtmlTableDataCell cell=null;\n  String description=null, moreButton=null;\n  Iterator iter=null;\n  boolean found=false;\n  int i;\n  assertNotNull(storeFront);\n  List cells=getAllElementsOfGivenClass(storeFront,null,HtmlTableDataCell.class), buttons=getAllElementsOfGivenClass(storeFront,null,HtmlSubmitInput.class);\n  for (i=0; i < carBundles.length; i++) {\n    iter=cells.iterator();\n    description=carBundles[i].getString(\"description\").trim();\n    while (iter.hasNext()) {\n      cell=(HtmlTableDataCell)iter.next();\n      if (-1 != cell.asText().indexOf(description)) {\n        if (LOGGER.isLoggable(Level.FINE)) {\n          LOGGER.fine(\"Found description \" + description + \".\");\n        }\n        found=true;\n        break;\n      }\n    }\n  }\n  assertTrue(\"Did not find description: \" + description,found);\n  iter=buttons.iterator();\n  moreButton=resources.getString(\"moreButton\").trim();\n  while (iter.hasNext()) {\n    button=(HtmlSubmitInput)iter.next();\n    assertTrue(-1 != button.asText().indexOf(moreButton));\n    if (LOGGER.isLoggable(Level.FINE)) {\n      LOGGER.fine(\"Button text of \" + moreButton + \" confirmed.\");\n    }\n    doCarDetail((HtmlPage)button.click());\n  }\n}\n", "nl": "<p>Assumptions: there are exactly four buttons on this page, one for each car model.</p> <p/> <p>Verify that all of the expected cars have their descriptions on the page.</p> <p/> <p>Verify that the text of the \"more\" button is properly localized.</p> <p/> <p>Press the button for each model and execute doCarDetail() on the result.</p>"}
{"code": "public void showMessage(String str){\n  ArgumentChecking.notNull(str,\"str\");\n  updateLabel(str,false,MESSAGE_FG_COLOR,MESSAGE_BG_COLOR);\n}\n", "nl": "It shows a message on the status label. The look of the status label is updated accordingly."}
{"code": "SavedState(Parcelable superState){\n  super(superState);\n}\n", "nl": "Called by onSaveInstanceState."}
{"code": "@Override public int hashCode(){\n  if (triple == null) {\n    return getDerivation().hashCode();\n  }\n else {\n    return triple.hashCode();\n  }\n}\n", "nl": "Two statements are the same as long as they represent the same triple. Derivation matters if and only if there is no triple."}
{"code": "public synchronized void store(THLEvent event,boolean commit) throws ReplicatorException, InterruptedException {\n  assertWritable();\n  long maxSeqno=diskLog.getMaxSeqno();\n  long eventSeqno=event.getSeqno();\n  short eventFragno=event.getFragno();\n  if (eventSeqno < maxSeqno) {\n    throw new LogConsistencyException(\"Attempt to write new log record with lower seqno value: current max seqno=\" + maxSeqno + \" attempted new seqno=\"+ eventSeqno);\n  }\n else   if (eventSeqno == maxSeqno && eventFragno <= lastFragno) {\n    throw new LogConsistencyException(\"Attempt to write new log record with equal or lower fragno: seqno=\" + eventSeqno + \" previous stored fragno=\"+ lastFragno+ \" attempted new fragno=\"+ eventFragno);\n  }\n  if (this.cursor == null) {\n    try {\n      LogFile lastFile=diskLog.openLastFile(false);\n      cursor=new LogCursor(lastFile,event.getSeqno());\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating new log cursor: thread=\" + Thread.currentThread() + \" file=\"+ lastFile.getFile().getName()+ \" seqno=\"+ event.getSeqno());\n      }\n    }\n catch (    ReplicatorException e) {\n      throw new THLException(\"Failed to open log last log file\",e);\n    }\n  }\n  LogFile dataFile=cursor.getLogFile();\n  if (logger.isDebugEnabled()) {\n    logger.debug(\"Using log file for writing: \" + dataFile.getFile().getName());\n  }\n  try {\n    if (dataFile.getLength() > logFileSize && event.getFragno() == 0) {\n      dataFile=diskLog.rotate(dataFile,event.getSeqno());\n      cursor.release();\n      cursor=new LogCursor(dataFile,event.getSeqno());\n    }\n    LogEventReplWriter eventWriter=new LogEventReplWriter(event,eventSerializer,doChecksum,dataFile.getFile());\n    LogRecord logRecord=eventWriter.write();\n    dataFile.writeRecord(logRecord,logFileSize);\n    diskLog.setMaxSeqno(event.getSeqno());\n    if (event.getLastFrag())     lastFragno=-1;\n else     lastFragno=event.getFragno();\n    if (commit) {\n      dataFile.flush();\n    }\n  }\n catch (  IOException e) {\n    throw new THLException(\"Error while writing to log file: name=\" + dataFile.getFile().getName(),e);\n  }\n}\n", "nl": "Store a THL event at the end of the log."}
{"code": "private String encodeAttributeValue(final String attributeValue){\n  if (attributeValue == null) {\n    return null;\n  }\n  int len=attributeValue.length();\n  boolean encode=false;\n  for (int pos=0; pos < len; pos++) {\n    char ch=attributeValue.charAt(pos);\n    if (ch == '<') {\n      encode=true;\n      break;\n    }\n else     if (ch == '>') {\n      encode=true;\n      break;\n    }\n else     if (ch == '\\\"') {\n      encode=true;\n      break;\n    }\n else     if (ch == '&') {\n      encode=true;\n      break;\n    }\n  }\n  if (encode) {\n    StringBuilder bf=new StringBuilder();\n    for (int pos=0; pos < len; pos++) {\n      char ch=attributeValue.charAt(pos);\n      if (ch == '<') {\n        bf.append(\"&lt;\");\n      }\n else       if (ch == '>') {\n        bf.append(\"&gt;\");\n      }\n else       if (ch == '\\\"') {\n        bf.append(\"&quot;\");\n      }\n else       if (ch == '&') {\n        bf.append(\"&amp;\");\n      }\n else {\n        bf.append(ch);\n      }\n    }\n    return bf.toString();\n  }\n  return attributeValue;\n}\n", "nl": "Encodes the given string in such a way that it no longer contains characters that have a special meaning in xml."}
{"code": "@Bean public ViewResolver jspViewResolver(){\n  InternalResourceViewResolver resolver=new InternalResourceViewResolver();\n  resolver.setPrefix(\"/WEB-INF/jsp/\");\n  resolver.setSuffix(\".jsp\");\n  return resolver;\n}\n", "nl": "Gets a JSP view resolver."}
{"code": "protected final void endOfInput(boolean streamCancelled) throws IOException {\n  if (cacheRequest != null) {\n    cacheBody.close();\n  }\n  httpEngine.release(streamCancelled);\n}\n", "nl": "Closes the cache entry and makes the socket available for reuse. This should be invoked when the end of the body has been reached."}
{"code": "public RevisionMetadata parseMetadataNodeList(String revId,NodeList nlEntries,ImmutableList<Revision> parents){\n  String author=\"None\";\n  DateTime date=new DateTime(0L);\n  String description=\"None\";\n  for (int i=0; i < nlEntries.getLength(); i++) {\n    Node currNode=nlEntries.item(i);\n    if (currNode.getNodeName().equals(\"author\")) {\n      author=currNode.getTextContent();\n    }\n    if (currNode.getNodeName().equals(\"date\")) {\n      date=ISODateTimeFormat.dateTime().parseDateTime(currNode.getTextContent());\n    }\n    if (currNode.getNodeName().equals(\"msg\")) {\n      description=currNode.getTextContent();\n    }\n  }\n  return RevisionMetadata.builder().id(revId).author(author).date(date).description(description).withParents(parents).build();\n}\n", "nl": "Helper function for parseMetadata"}
{"code": "@SuppressWarnings(\"unchecked\") public Set<S> children(){\n  return children;\n}\n", "nl": "Get the direct childnodes"}
{"code": "public h5 addElement(Element element){\n  addElementToRegistry(element);\n  return (this);\n}\n", "nl": "Adds an Element to the element."}
{"code": "public static long[] convertToLongArray(final byte[] vals){\n  checkSource(vals.length,8);\n  final long[] dest=new long[vals.length / 8];\n  convertToLongArrayInternal(vals,0,vals.length,dest,0);\n  return dest;\n}\n", "nl": "Converts <code>byte[]</code> to <code>long[]</code>, assuming big-endian byte order."}
{"code": "public java.util.ArrayList<TreeNode<E>> path(E e){\n  java.util.ArrayList<TreeNode<E>> list=new java.util.ArrayList<>();\n  TreeNode<E> current=root;\n  while (current != null) {\n    list.add(current);\n    if (e.compareTo(current.element) < 0) {\n      current=current.left;\n    }\n else     if (e.compareTo(current.element) > 0) {\n      current=current.right;\n    }\n else     break;\n  }\n  return list;\n}\n", "nl": "Return a path from the root leadting to the specified element"}
{"code": "private void firePEPListeners(String from,PEPEvent event){\n  PEPListener[] listeners=null;\nsynchronized (pepListeners) {\n    listeners=new PEPListener[pepListeners.size()];\n    pepListeners.toArray(listeners);\n  }\n  for (int i=0; i < listeners.length; i++) {\n    listeners[i].eventReceived(from,event);\n  }\n}\n", "nl": "Fires roster exchange listeners."}
{"code": "public MethodNode popEnclosingMethod(){\n  return enclosingMethods.removeFirst();\n}\n", "nl": "Pops a method from the enclosing methods stack."}
{"code": "private void readParameterAnnotations(final MethodVisitor mv,final Context context,int v,final boolean visible){\n  int i;\n  int n=b[v++] & 0xFF;\n  int synthetics=Type.getArgumentTypes(context.desc).length - n;\n  AnnotationVisitor av;\n  for (i=0; i < synthetics; ++i) {\n    av=mv.visitParameterAnnotation(i,\"Ljava/lang/Synthetic;\",false);\n    if (av != null) {\n      av.visitEnd();\n    }\n  }\n  char[] c=context.buffer;\n  for (; i < n + synthetics; ++i) {\n    int j=readUnsignedShort(v);\n    v+=2;\n    for (; j > 0; --j) {\n      av=mv.visitParameterAnnotation(i,readUTF8(v,c),visible);\n      v=readAnnotationValues(v + 2,c,true,av);\n    }\n  }\n}\n", "nl": "Reads parameter annotations and makes the given visitor visit them."}
{"code": "public StringLiteral createStringLiteral(){\n  StringLiteralImpl stringLiteral=new StringLiteralImpl();\n  return stringLiteral;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public SyntheticMethodBinding(MethodBinding overridenMethodToBridge,MethodBinding targetMethod,SourceTypeBinding declaringClass){\n  this.declaringClass=declaringClass;\n  this.selector=overridenMethodToBridge.selector;\n  this.modifiers=(targetMethod.modifiers | ClassFileConstants.AccBridge | ClassFileConstants.AccSynthetic) & ~(ClassFileConstants.AccSynchronized | ClassFileConstants.AccAbstract | ClassFileConstants.AccNative| ClassFileConstants.AccFinal| ExtraCompilerModifiers.AccGenericSignature);\n  this.tagBits|=(TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);\n  this.returnType=overridenMethodToBridge.returnType;\n  this.parameters=overridenMethodToBridge.parameters;\n  this.thrownExceptions=overridenMethodToBridge.thrownExceptions;\n  this.targetMethod=targetMethod;\n  this.purpose=SyntheticMethodBinding.BridgeMethod;\n  SyntheticMethodBinding[] knownAccessMethods=declaringClass.syntheticMethods();\n  int methodId=knownAccessMethods == null ? 0 : knownAccessMethods.length;\n  this.index=methodId;\n}\n", "nl": "Construct a bridge method"}
{"code": "public static void start(){\n  start(Thread.currentThread().getContextClassLoader());\n}\n", "nl": "Starts the current environment."}
{"code": "public ConnectionConfig(){\n  super();\n}\n", "nl": "Ctor for a functional Swing object with no prexisting adapter"}
{"code": "public AbstractMRMessage createInitPacket(){\n  return null;\n}\n", "nl": "Public Method to create an Initialization packet (SerialMessage) for this node. There are currently no Oak Tree boards that need an init message, so this returns null."}
{"code": "public Observable<String> exerciseZip(Observable<String> a,Observable<String> b){\n  return Observable.error(new RuntimeException(\"Not Implemented\"));\n}\n", "nl": "Combine 2 streams into pairs using zip. a -> \"one\", \"two\", \"red\", \"blue\" b -> \"fish\", \"fish\", \"fish\", \"fish\" output -> \"one fish\", \"two fish\", \"red fish\", \"blue fish\""}
{"code": "protected void tearDown(){\n}\n", "nl": "Tears down the fixture, for example, close a network connection. This method is called after a test is executed."}
{"code": "static String mapLibraryName(String libname){\n  String libSuffix;\n  if (VM.BuildForLinux || VM.BuildForSolaris) {\n    libSuffix=\".so\";\n  }\n else   if (VM.BuildForOsx) {\n    libSuffix=\".jnilib\";\n  }\n else {\n    libSuffix=\".a\";\n  }\n  return \"lib\" + libname + libSuffix;\n}\n", "nl": "Apply library prefixes and suffixes as necessary to libname to produce a full file name. For example, on linux \"rvm\" would become \"librvm.so\"."}
{"code": "public void removeActionListener(ActionListener a){\n  if (actionListeners == null) {\n    return;\n  }\n  actionListeners.removeListener(a);\n  if (!actionListeners.hasListeners()) {\n    actionListeners=null;\n  }\n}\n", "nl": "Removes an action listener"}
{"code": "@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){\n  updateSize();\n}\n", "nl": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0."}
{"code": "protected void sequence_FunctionFacet(ISerializationContext context,Facet semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: FunctionFacet returns Facet Constraint: ((key='function:' | key='->') expr=Expression)"}
{"code": "public static URL urlFromString(String location){\n  return urlFromString(location,null,true);\n}\n", "nl": "From a string description, attempt to generate a URL object. The string may point to an Internet location (e.g., http:// or ftp:// URL), a resource on the class path (resulting in a resource URL that points into the current classpath), or a file on the local filesystem (resulting in a file:// URL). The String will be checked in that order in an attempt to resolve it to a valid URL."}
{"code": "public static List<? extends Node> evaluateXPath(Document doc,String path) throws XPathExpressionException {\n  XPathFactory factory=XPathFactory.newInstance();\n  XPath xpath=factory.newXPath();\n  xpath.setNamespaceContext(new NamespaceResolver(doc));\n  XPathExpression expr=xpath.compile(path);\n  NodeList nodes=(NodeList)expr.evaluate(doc,XPathConstants.NODESET);\n  List<Node> nodelist=new ArrayList<Node>();\n  for (int i=0; i < nodes.getLength(); ++i) {\n    nodelist.add(nodes.item(i));\n  }\n  LOG.trace(String.format(\"Evaluated XPath: %s and found %s\",path,nodeListToString(nodelist)));\n  return nodelist;\n}\n", "nl": "Takes a Document and evaluates an XPath expression on it. All matching Nodes are returned as a List."}
{"code": "@HLEFunction(nid=0x8DB83FDC,version=150) public int sceNetAdhocctlGetPeerInfo(pspNetMacAddress macAddress,int size,TPointer peerInfoAddr){\n  checkInitialized();\n  int result=SceKernelErrors.ERROR_NET_ADHOC_NO_ENTRY;\n  if (sceNetAdhoc.isMyMacAddress(macAddress.macAddress)) {\n    SceNetAdhocctlPeerInfo peerInfo=new SceNetAdhocctlPeerInfo();\n    peerInfo.nickName=sceUtility.getSystemParamNickname();\n    peerInfo.macAddress=new pspNetMacAddress(Wlan.getMacAddress());\n    peerInfo.timestamp=getCurrentTimestamp();\n    peerInfo.write(peerInfoAddr);\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceNetAdhocctlGetPeerInfo for own MAC address, returning %s\",peerInfo));\n    }\n    result=0;\n  }\n else {\n    for (    AdhocctlPeer peer : peers) {\n      if (macAddress.equals(peer.macAddress)) {\n        SceNetAdhocctlPeerInfo peerInfo=new SceNetAdhocctlPeerInfo();\n        peerInfo.nickName=peer.nickName;\n        peerInfo.macAddress=new pspNetMacAddress(peer.macAddress);\n        peerInfo.timestamp=peer.timestamp;\n        peerInfo.write(peerInfoAddr);\n        if (log.isDebugEnabled()) {\n          log.debug(String.format(\"sceNetAdhocctlGetPeerInfo returning %s\",peerInfo));\n        }\n        result=0;\n        break;\n      }\n    }\n  }\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceNetAdhocctlGetPeerInfo returning 0x%08X\",result));\n    }\n  }\n  return result;\n}\n", "nl": "Get peer information"}
{"code": "public NodeSet(){\n  m_blocksize=32;\n  m_mapSize=0;\n}\n", "nl": "Create an empty nodelist."}
{"code": "public static void printUsage(final Options options,final OutputStream out){\n  final PrintWriter writer=new PrintWriter(out);\n  final HelpFormatter usageFormatter=new HelpFormatter();\n  usageFormatter.printUsage(writer,80,\"Usage: hadoop jar <jar name> \" + ReplicationJob.class.getName(),options);\n  writer.flush();\n}\n", "nl": "Print usage information to provided OutputStream."}
{"code": "public boolean contains(final int x){\n  int i=d;\n  while (i-- != 0)   if (!bits.getBoolean(hash(x,i)))   return false;\n  return true;\n}\n", "nl": "Checks whether the given integer is in this filter.  <P>Note that this method may return true on an integer that has not been added to the filter. This will happen with probability 2<sup>-<var>d</var></sup>, where <var>d</var> is the number of hash functions specified at creation time, if the number of the elements in the filter is less than <var>n</var>, the number of expected elements specified at creation time."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:54:55.108 -0500\",hash_original_method=\"6B2B571AE4F377CE25FA9B4608683BF5\",hash_generated_method=\"285A23FFDABA1DF6F6F9408346D12FBB\") public String encode(){\n  String retval=headerName + COLON;\n  if (optionTag != null)   retval+=SP + optionTag;\n  retval+=NEWLINE;\n  return retval;\n}\n", "nl": "Return canonical form of the header."}
{"code": "public void minx(int parseInt){\n  minx=parseInt;\n}\n", "nl": "Set the starting x number of the subjar file to create. Depends on the subjar zoom to figure out what that means."}
{"code": "public boolean IsPostPiEmpty(){\n  return this.postPi.isEmpty();\n}\n", "nl": "Checks if the post PI attribute list is empty."}
{"code": "@Override public boolean removeLastOccurrence(Object o){\n  throw new UnsupportedOperationException(ERROR_MSG);\n}\n", "nl": "Guaranteed to throw an exception and leave the table unmodified."}
{"code": "public Builder<KType,VType> putAll(Map<KType,VType> map){\n  for (  Map.Entry<KType,VType> entry : map.entrySet()) {\n    this.map.put(entry.getKey(),entry.getValue());\n  }\n  return this;\n}\n", "nl": "Puts all the entries in the map to the builder."}
{"code": "public static ByteBuffer wrap(byte[] bytes){\n  return ByteBuffer.wrap(bytes).order(DEFAULT_BYTE_ORDER);\n}\n", "nl": "Returns a ByteBuffer wrapping the given bytes and configured with the default byte order."}
{"code": "public void println(){\n  System.err.println(prefix + \":\");\n}\n", "nl": "print a blank line to stderr that is prefixed with the prefix."}
{"code": "public void authorizeComplete(String pin) throws FacebookException {\n  AccessToken token=this.connection.getOAuthAccessToken(pin);\n  setToken(token.getToken());\n  User user=this.connection.getMe();\n  this.userName=user.getId();\n  if (token.getExpires() != null) {\n    this.tokenExpiry=new Date(System.currentTimeMillis() + (token.getExpires() * 1000));\n  }\n  this.profileName=user.getName();\n  try {\n    this.page=\"\";\n    ResponseList<Account> accounts=this.connection.getAccounts();\n    this.pages=new ArrayList<>();\n    if (accounts != null) {\n      for (      Account account : accounts) {\n        this.page=account.getName();\n        this.pages.add(account.getName());\n      }\n    }\n  }\n catch (  Exception exception) {\n    log(exception);\n  }\n}\n", "nl": "Authorise a new account to be accessible by Bot."}
{"code": "public <T>void visit(final Class<? super T> type) throws HandleException {\n  checkArgument(type != null,\"Type to be visited cannot be null\");\n  if (LOGGER.isLoggable(Level.FINER)) {\n    LOGGER.finer(\"  Visit class: \" + type);\n  }\n  if (type.getPackage() != null && type.getPackage().getName().startsWith(JAVA_PACKAGE)) {\n    return;\n  }\n  handle(type);\n  handle(type.getDeclaredFields());\n  handle(type.getDeclaredMethods());\n  visit((Class<? super T>)type.getSuperclass());\n}\n", "nl": "Visits all fields, methods and super classes of the input class."}
{"code": "public static String encode(String str) throws RuntimeException {\n  byte[] bytes=str.getBytes();\n  byte[] encoded=encode(bytes);\n  try {\n    return new String(encoded,\"ASCII\");\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new RuntimeException(\"ASCII is not supported!\",e);\n  }\n}\n", "nl": "<p> Encodes a string. </p> <p> Before the string is encoded in Base64, it is converted in a binary sequence using the system default charset. </p>"}
{"code": "public void clearInputs(){\n  unCache();\n  for (  TransactionInput input : inputs) {\n    input.setParent(null);\n  }\n  inputs.clear();\n  this.length=this.unsafeBitcoinSerialize().length;\n}\n", "nl": "Removes all the inputs from this transaction. Note that this also invalidates the length attribute"}
{"code": "private void determineSyntaxAndEncoding(String absFileName,JarFile jarFile,String jspConfigPageEnc) throws JasperException, IOException {\n  isXml=false;\n  boolean isExternal=false;\n  boolean revert=false;\n  JspConfig jspConfig=ctxt.getOptions().getJspConfig();\n  JspProperty jspProperty=jspConfig.findJspProperty(absFileName);\n  if (jspProperty.isXml() != null) {\n    isXml=JspUtil.booleanValue(jspProperty.isXml());\n    isExternal=true;\n  }\n else   if (absFileName.endsWith(\".jspx\") || absFileName.endsWith(\".tagx\")) {\n    isXml=true;\n    isExternal=true;\n  }\n  if (isExternal && !isXml) {\n    sourceEnc=jspConfigPageEnc;\n    if (sourceEnc != null) {\n      return;\n    }\n    sourceEnc=\"ISO-8859-1\";\n  }\n else {\n    Object[] ret=XMLEncodingDetector.getEncoding(absFileName,jarFile,ctxt,err);\n    sourceEnc=(String)ret[0];\n    if (((Boolean)ret[1]).booleanValue()) {\n      isEncodingSpecifiedInProlog=true;\n    }\n    if (ret[2] != null && ((Boolean)ret[2]).booleanValue()) {\n      hasBom=true;\n    }\n    if (!isXml && sourceEnc.equalsIgnoreCase(\"utf-8\") && !hasBom) {\n      sourceEnc=\"ISO-8859-1\";\n      revert=true;\n    }\n  }\n  if (isXml) {\n    return;\n  }\n  JspReader jspReader=null;\n  try {\n    jspReader=new JspReader(ctxt,absFileName,sourceEnc,jarFile,err);\n  }\n catch (  FileNotFoundException ex) {\n    throw new JasperException(ex);\n  }\n  jspReader.setSingleFile(true);\n  Mark startMark=jspReader.mark();\n  if (!isExternal) {\n    jspReader.reset(startMark);\n    if (hasJspRoot(jspReader)) {\n      isXml=true;\n      if (revert)       sourceEnc=\"UTF-8\";\n      return;\n    }\n else {\n      isXml=false;\n    }\n  }\n  if (!hasBom) {\n    sourceEnc=jspConfigPageEnc;\n  }\n  if (sourceEnc == null) {\n    sourceEnc=getPageEncodingForJspSyntax(jspReader,startMark);\n    if (sourceEnc == null) {\n      sourceEnc=\"ISO-8859-1\";\n      isDefaultPageEncoding=true;\n    }\n  }\n}\n", "nl": "Determines the syntax (standard or XML) and page encoding properties for the given file, and stores them in the 'isXml' and 'sourceEnc' instance variables, respectively."}
{"code": "public FastAdapterDialog<Item> withTitle(@StringRes int titleRes){\n  setTitle(titleRes);\n  return this;\n}\n", "nl": "Set the title text for this dialog's window."}
{"code": "private String buildToolTip(final CTaggedGraphNodesContainerNode node){\n  final StringBuilder tooltip=new StringBuilder(\"<html>\");\n  boolean first=true;\n  for (  final NaviNode graphnode : node.getGraphNodes()) {\n    if (!first) {\n      tooltip.append(\"<br>\");\n    }\n    tooltip.append(CNodesDisplayString.getDisplayString(graphnode));\n    first=false;\n  }\n  return tooltip + \"</html>\";\n}\n", "nl": "Generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes."}
{"code": "private void stateData(){\n  Log.d(TAG,\"Santa is online.\");\n  updateNavigation();\n  scheduleUIUpdate();\n  long time=SantaPreferences.getCurrentTime();\n  AbstractLaunch launchSanta=mCardAdapter.getLauncher(CardAdapter.SANTA);\n  if (time > mFirstDeparture && time < OFFLINE_SANTA_FINALARRIVAL) {\n    enableTrackerMode(true);\n    if (mFlagSwitchOff) {\n      launchSanta.setState(AbstractLaunch.STATE_DISABLED);\n    }\n else     if (time > mFinalArrival) {\n      launchSanta.setState(AbstractLaunch.STATE_DISABLED);\n    }\n else {\n      launchSanta.setState(AbstractLaunch.STATE_READY);\n    }\n  }\n else   if (time < mFirstDeparture) {\n    startCountdown(mFirstDeparture);\n    launchSanta.setState(AbstractLaunch.STATE_LOCKED);\n  }\n else {\n    launchSanta.setState(AbstractLaunch.STATE_FINISHED);\n    stopCountdown();\n    enableTrackerMode(false);\n  }\n}\n", "nl": "Move to 'data' (online) state."}
{"code": "public final int type(){\n  return m_Type;\n}\n", "nl": "Returns the attribute's type as an integer."}
{"code": "public ProtomechBay(double space,int doors,int bayNumber){\n  totalSpace=space;\n  currentSpace=space;\n  this.doors=doors;\n  doorsNext=doors;\n  this.bayNumber=bayNumber;\n}\n", "nl": "Create a space for the given tonnage of troops. For this class, only the weight of the troops (and their equipment) are considered; if you'd like to think that they are stacked like lumber, be my guest."}
{"code": "@Override protected EClass eStaticClass(){\n  return GamlPackage.Literals.STATEMENT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@RequestMapping(value=\"podcasts_by_frequency\",method=RequestMethod.POST) public String updatePodcastsWithFrequency(@ModelAttribute(\"updatePodcastsByFrequencyForm\") UpdatePodcastsByFrequencyForm updatePodcastsByFrequencyForm,BindingResult bindingResult,ModelMap model){\n  if (bindingResult.hasErrors()) {\n    return \"redirect:/admin\";\n  }\n  LOG.debug(\"------ executing updatePodcastsWithFrequency -----\");\n  Integer podcastsUpdateFrequencyCode=updatePodcastsByFrequencyForm.getUpdateFrequency() != null ? updatePodcastsByFrequencyForm.getUpdateFrequency().getCode() : null;\n  if (podcastsUpdateFrequencyCode == null) {\n    Integer.valueOf(configBean.get(\"PODCAST_FREQUENCY_TYPE_TO_UPDATE\"));\n  }\n  Integer totalNumberOfPodcasts=null;\n  totalNumberOfPodcasts=readService.getNumberOfPodcastsWithUpdateFrequency(podcastsUpdateFrequencyCode);\n  Integer numberOfWorkerThreads=updatePodcastsByFrequencyForm.getNumberOfWorkingThreads();\n  if (numberOfWorkerThreads == null) {\n    numberOfWorkerThreads=Integer.valueOf(configBean.get(\"NO_WORKER_THREADS_FOR_UPDATE_ALL_PODCASTS\"));\n  }\n  if (numberOfWorkerThreads == null) {\n    numberOfWorkerThreads=DEFAULT_NO_WORKER_THREADS_FOR_UPDATE_ALL_PODCASTS;\n  }\n  Integer mod=totalNumberOfPodcasts % numberOfWorkerThreads;\n  Integer chunkSize=totalNumberOfPodcasts / numberOfWorkerThreads;\n  for (int i=0; i < numberOfWorkerThreads; i++) {\n    int startRow=i * chunkSize;\n    if (i == numberOfWorkerThreads - 1) {\n      chunkSize=chunkSize + mod;\n      LOG.debug(\"Thread[\" + i + \"] - [\"+ startRow+ \",\"+ chunkSize+ \"]\");\n      Future<String> future=batchUpdateService.updatePodcastsFromRange(startRow,chunkSize,podcastsUpdateFrequencyCode);\n    }\n else {\n      batchUpdateService.updatePodcastsFromRange(startRow,chunkSize,podcastsUpdateFrequencyCode);\n    }\n  }\n  return \"redirect:/admin/update/batch\";\n}\n", "nl": "UPDATE podcast by id or feed url"}
{"code": "public void removeListener(final SelectionListener listener1){\n  if (this.listener == listener1)   this.listener=null;\n}\n", "nl": "Remove listener."}
{"code": "public CompositePersistence(Persistence<O,A> primaryPersistence,Persistence<O,A> secondaryPersistence,List<? extends Persistence<O,A>> additionalPersistences){\n  validatePersistenceArguments(primaryPersistence,secondaryPersistence,additionalPersistences);\n  this.primaryPersistence=primaryPersistence;\n  this.secondaryPersistence=secondaryPersistence;\n  this.additionalPersistences=additionalPersistences;\n}\n", "nl": "Creates a CompositePersistence wrapping two or more backing persistences. <b>The collection itself will be persisted to the primary persistence.</b>"}
{"code": "public PKCS10 createCSRequest(Device device,KeyPair keyPair) throws KeyStoreException {\n  X500Name x500Name=createX500NameForDevice(device);\n  PKCS10 request=null;\n  try {\n    request=new PKCS10(keyPair.getPublic());\n    Signature signature=Signature.getInstance(\"MD5withRSA\");\n    signature.initSign(keyPair.getPrivate());\n    request.encodeAndSign(x500Name,signature);\n  }\n catch (  Exception e) {\n    throw new KeyStoreException(\"Unable to create CSR request\",e);\n  }\n  return request;\n}\n", "nl": "Creates a Certificate Signing Request and signs it with RSA private key"}
{"code": "public void syncAll(){\n  m_vmasvc.sync(m_nid,0L,0L,true);\n}\n", "nl": "sync. the memory pool to underlying memory device."}
{"code": "private void stripTimings(){\n  long limit=System.currentTimeMillis() - TIMING_TTL_MILLIS;\n  int endIndex=0;\n  for (; endIndex < myTimings.size(); endIndex++) {\n    if (myTimings.get(endIndex) > limit) {\n      break;\n    }\n  }\n  if (endIndex > 0) {\n    myTimings.remove(0,endIndex);\n  }\n}\n", "nl": "Removes old timings."}
{"code": "@Override public FileLock tryLock(long position,long size,boolean shared) throws IOException {\n  throw new IOException(\"Method is unsupported.\");\n}\n", "nl": "Unsupported method."}
{"code": "public UsageException(final String message){\n  super(message);\n}\n", "nl": "Creates a new UsageException."}
{"code": "public BasicEffect ground(Assignment grounding){\n  return this;\n}\n", "nl": "Returns itself."}
{"code": "public UDPMasterTerminal(){\n}\n", "nl": "Create an uninitialized UDP master connection."}
{"code": "public static void cropAll(String[] strings){\n  for (int i=0; i < strings.length; i++) {\n    String string=strings[i];\n    if (string != null) {\n      string=crop(strings[i]);\n    }\n    strings[i]=string;\n  }\n}\n", "nl": "Crops all elements of string array."}
{"code": "public void updateControllerConnections(IOFSwitchBackend sw,OFControllerRole role1,OFBsnControllerConnectionState state1,String uri1,OFControllerRole role2,OFBsnControllerConnectionState state2,String uri2){\n  OFBsnControllerConnection connection1=factory.buildBsnControllerConnection().setAuxiliaryId(OFAuxId.MAIN).setRole(role1).setState(state1).setUri(uri1).build();\n  OFBsnControllerConnection connection2=factory.buildBsnControllerConnection().setAuxiliaryId(OFAuxId.MAIN).setRole(role2).setState(state2).setUri(uri2).build();\n  List<OFBsnControllerConnection> connections=new ArrayList<OFBsnControllerConnection>();\n  connections.add(connection1);\n  connections.add(connection2);\n  OFBsnControllerConnectionsReply reply=factory.buildBsnControllerConnectionsReply().setConnections(connections).build();\n  sw.updateControllerConnections(reply);\n}\n", "nl": "Helper to load controller connection messages into a switch for testing."}
{"code": "@Override public void draw(){\n  background(0);\n  stereoPosition(cameraPositionX,cameraPositionY,cameraPositionZ,0f,0f,-1f,0f,1f,0f);\n}\n", "nl": "Processing draw function. Called before drawLeft and drawRight."}
{"code": "public URI(String scheme,String host,String path,String fragment) throws URISyntaxException {\n  this(scheme,null,host,-1,path,null,fragment);\n}\n", "nl": "Creates a new URI instance of the given unencoded component parts."}
{"code": "public Label(double... c){\n  this(coordToString(c),AbstractDrawer.DEFAULT_COLOR,c);\n}\n", "nl": "show coord itself"}
{"code": "private void scaleStmt(ColumnFormat cf) throws ParserException, IOException {\n  match(SCALE);\n  Token t=matchOne(scaleKeyWords);\n  cf.setScale(Scale.toScale(t.sval));\n  String scaleString=t.sval;\n  log(pdebug,\"Parsed: scale -> \" + scaleString);\n}\n", "nl": "scalestmt -> 'scale' scalespec scalespec -> <see above scaleTerminals array>"}
{"code": "public double predicted(){\n  return m_Predicted;\n}\n", "nl": "Gets the predicted class value."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:47.056 -0500\",hash_original_method=\"61478AA9F56747991020142C67580FB8\",hash_generated_method=\"F44C74B35137AEFCC17E0B0D490721CE\") @Override public synchronized void reset() throws IOException {\n  in.reset();\n}\n", "nl": "Resets this stream to the last marked location. This implementation resets the target stream."}
{"code": "public IteratorSpliterator(Iterator<? extends T> iterator,int characteristics){\n  this.collection=null;\n  this.it=iterator;\n  this.est=Long.MAX_VALUE;\n  this.characteristics=characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED);\n}\n", "nl": "Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics."}
{"code": "public static String[] toStringArray(Array array,String defaultValue){\n  String[] arr=new String[array.size()];\n  for (int i=0; i < arr.length; i++) {\n    arr[i]=Caster.toString(array.get(i + 1,defaultValue),defaultValue);\n  }\n  return arr;\n}\n", "nl": "cast a Object Array to a String Array"}
{"code": "protected Texture updateTextureWithSubImage(DrawContext dc,Rectangle rect){\n  Texture texture=this.getTexture(dc);\n  if (texture == null) {\n    String msg=Logging.getMessage(\"nullValue.TextureIsNull\");\n    Logging.logger().warning(msg);\n    return null;\n  }\n  if (!this.isUseMipMaps() || texture.isUsingAutoMipmapGeneration()) {\n    BufferedImage backingImage=(BufferedImage)this.rectPacker.getBackingStore();\n    BufferedImage subImage=backingImage.getSubimage(rect.x,rect.y,rect.width,rect.height);\n    GL gl=dc.getGL();\n    TextureData subTextureData=AWTTextureIO.newTextureData(gl.getGLProfile(),subImage,false);\n    texture.updateSubImage(gl,subTextureData,0,rect.x,rect.y);\n  }\n else {\n    BufferedImage backingImage=(BufferedImage)this.rectPacker.getBackingStore();\n    GL gl=dc.getGL();\n    texture.updateImage(gl,AWTTextureIO.newTextureData(gl.getGLProfile(),backingImage,this.isUseMipMaps()));\n    this.setTextureParameters(dc);\n  }\n  return texture;\n}\n", "nl": "Loads a sub-region of this texture atlas' backing image into its OpenGL texture. This does nothing and returns code <code>null</code> if this texture atlas' does not have an OpenGL texture."}
{"code": "public void rotateY(double degrees){\n  Transform3D other=new Transform3D();\n  other.rotY(degrees * Math.PI / 180);\n  transform(other);\n}\n", "nl": "Modifies the global model transform by rotating along the current Y axis the provided number of degrees."}
{"code": "public static long doubleToLong(double value){\n  return (long)(value / DEGREE_TOLERANCE);\n}\n", "nl": "Function used to convert an angle in degrees to its internal, fixed-precision long representation. Intended for library use only."}
{"code": "public @CheckReturnValue boolean containsProperty(T prop){\n  return map.keySet().contains(prop);\n}\n", "nl": "Return whether or not the set contains the given WarningProperty."}
{"code": "private CGlobalEdgeCommentSynchronizer(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "protected void assertAsCollection(Object collectionObject,int count){\n  Collection collection=DefaultTypeTransformation.asCollection(collectionObject);\n  assertTrue(\"Collection is not null\",collection != null);\n  assertEquals(\"Collection size\",count,collection.size());\n  assertIterator(\"collections iterator\",collection.iterator(),count);\n  assertIterator(\"InvokerHelper.asIterator\",InvokerHelper.asIterator(collectionObject),count);\n  assertIterator(\"InvokerHelper.asIterator(InvokerHelper.asCollection)\",InvokerHelper.asIterator(collection),count);\n  assertIterator(\"InvokerHelper.asIterator(InvokerHelper.asIterator)\",InvokerHelper.asIterator(InvokerHelper.asIterator(collectionObject)),count);\n}\n", "nl": "Asserts that the given object can be converted into a collection and iterator of the given size"}
{"code": "private void readResponseHeaders(State state,InnerState innerState,HttpResponse response) throws StopRequest {\n  Header header=response.getFirstHeader(\"Content-Disposition\");\n  if (header != null) {\n    innerState.mHeaderContentDisposition=header.getValue();\n  }\n  header=response.getFirstHeader(\"Content-Location\");\n  if (header != null) {\n    innerState.mHeaderContentLocation=header.getValue();\n  }\n  header=response.getFirstHeader(\"ETag\");\n  if (header != null) {\n    innerState.mHeaderETag=header.getValue();\n  }\n  String headerTransferEncoding=null;\n  header=response.getFirstHeader(\"Transfer-Encoding\");\n  if (header != null) {\n    headerTransferEncoding=header.getValue();\n  }\n  String headerContentType=null;\n  header=response.getFirstHeader(\"Content-Type\");\n  if (header != null) {\n    headerContentType=header.getValue();\n    if (!headerContentType.equals(\"application/vnd.android.obb\")) {\n      throw new StopRequest(DownloaderService.STATUS_FILE_DELIVERED_INCORRECTLY,\"file delivered with incorrect Mime type\");\n    }\n  }\n  if (headerTransferEncoding == null) {\n    header=response.getFirstHeader(\"Content-Length\");\n    if (header != null) {\n      innerState.mHeaderContentLength=header.getValue();\n      long contentLength=Long.parseLong(innerState.mHeaderContentLength);\n      if (contentLength != -1 && contentLength != mInfo.mTotalBytes) {\n        Log.e(Constants.TAG,\"Incorrect file size delivered.\");\n      }\n    }\n  }\n else {\n    if (Constants.LOGVV) {\n      Log.v(Constants.TAG,\"ignoring content-length because of xfer-encoding\");\n    }\n  }\n  if (Constants.LOGVV) {\n    Log.v(Constants.TAG,\"Content-Disposition: \" + innerState.mHeaderContentDisposition);\n    Log.v(Constants.TAG,\"Content-Length: \" + innerState.mHeaderContentLength);\n    Log.v(Constants.TAG,\"Content-Location: \" + innerState.mHeaderContentLocation);\n    Log.v(Constants.TAG,\"ETag: \" + innerState.mHeaderETag);\n    Log.v(Constants.TAG,\"Transfer-Encoding: \" + headerTransferEncoding);\n  }\n  boolean noSizeInfo=innerState.mHeaderContentLength == null && (headerTransferEncoding == null || !headerTransferEncoding.equalsIgnoreCase(\"chunked\"));\n  if (noSizeInfo) {\n    throw new StopRequest(DownloaderService.STATUS_HTTP_DATA_ERROR,\"can't know size of download, giving up\");\n  }\n}\n", "nl": "Read headers from the HTTP response and store them into local state."}
{"code": "public String readString(int length) throws IOException {\n  byte[] array=new byte[length];\n  readFully(array);\n  String s=new String(array);\n  return s.trim();\n}\n", "nl": "Constructs a string from the underlying input stream"}
{"code": "public TextOutputCallback(int messageType,String message){\n  if ((messageType != INFORMATION && messageType != WARNING && messageType != ERROR) || message == null || message.length() == 0)   throw new IllegalArgumentException();\n  this.messageType=messageType;\n  this.message=message;\n}\n", "nl": "Construct a TextOutputCallback with a message type and message to be displayed. <p>"}
{"code": "@DSSafe(DSCat.SAFE_OTHERS) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:32:41.939 -0500\",hash_original_method=\"24BC54E57520E50B51FEB9301490242D\",hash_generated_method=\"FAE9CEF2DB2F0021A995BEA229699877\") public JWebCoreJavaBridge(){\n  nativeConstructor();\n}\n", "nl": "Construct a new JWebCoreJavaBridge to interface with WebCore timers and cookies."}
{"code": "public boolean isCallableConstructor(){\n  final EObject parent=this.eContainer();\n  boolean _xifexpression=false;\n  if ((parent instanceof ContainerType<?>)) {\n    TMethod _callableCtor=((ContainerType<?>)parent).getCallableCtor();\n    _xifexpression=(_callableCtor == this);\n  }\n else {\n    _xifexpression=false;\n  }\n  return _xifexpression;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public final double min(){\n  double min=Double.POSITIVE_INFINITY;\n  double[][] fieldx=null;\n  double[] fieldxy=null;\n  final int width=this.width;\n  final int height=this.height;\n  final int length=this.length;\n  for (int x=0; x < width; x++) {\n    fieldx=field[x];\n    for (int y=0; y < height; y++) {\n      fieldxy=fieldx[y];\n      for (int z=0; z < length; z++)       if (min > fieldxy[z])       min=fieldxy[z];\n    }\n  }\n  return min;\n}\n", "nl": "Returns the minimum value stored in the grid"}
{"code": "public static Date round(final Date date,final int field){\n  if (date == null) {\n    throw new IllegalArgumentException(\"The date must not be null\");\n  }\n  final Calendar gval=Calendar.getInstance();\n  gval.setTime(date);\n  modify(gval,field,ModifyType.ROUND);\n  return gval.getTime();\n}\n", "nl": "<p>Rounds a date, leaving the field specified as the most significant field.</p> <p>For example, if you had the date-time of 28 Mar 2002 13:45:01.231, if this was passed with HOUR, it would return 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it would return 1 April 2002 0:00:00.000.</p> <p>For a date in a timezone that handles the change to daylight saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows. Suppose daylight saving time begins at 02:00 on March 30. Rounding a  date that crosses this time would produce the following values: </p> <ul> <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li> <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li> <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li> <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li> </ul>"}
{"code": "@Override protected AdminResponse createResponse(DistributionManager dm){\n  return SubRegionResponse.create(dm,this.getSender(),this.getRegion(dm.getSystem()));\n}\n", "nl": "Must return a proper response to this request."}
{"code": "public static void load(final NiFiProperties properties) throws IOException, ClassNotFoundException {\n  if (initialized.getAndSet(true)) {\n    throw new IllegalStateException(\"Extensions class loaders have already been loaded.\");\n  }\n  final ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader();\n  ClassLoader currentContextClassLoader=Thread.currentThread().getContextClassLoader();\n  final Map<String,ClassLoader> extensionDirectoryClassLoaderLookup=new LinkedHashMap<>();\n  final Map<String,ClassLoader> narIdClassLoaderLookup=new HashMap<>();\n  final File frameworkWorkingDirectory=properties.getFrameworkWorkingDirectory();\n  final File extensionsWorkingDirectory=properties.getExtensionsWorkingDirectory();\n  FileUtils.ensureDirectoryExistAndCanAccess(frameworkWorkingDirectory);\n  FileUtils.ensureDirectoryExistAndCanAccess(extensionsWorkingDirectory);\n  final List<File> narWorkingDirContents=new ArrayList<>();\n  final File[] frameworkWorkingDirContents=frameworkWorkingDirectory.listFiles();\n  if (frameworkWorkingDirContents != null) {\n    narWorkingDirContents.addAll(Arrays.asList(frameworkWorkingDirContents));\n  }\n  final File[] extensionsWorkingDirContents=extensionsWorkingDirectory.listFiles();\n  if (extensionsWorkingDirContents != null) {\n    narWorkingDirContents.addAll(Arrays.asList(extensionsWorkingDirContents));\n  }\n  if (!narWorkingDirContents.isEmpty()) {\n    final List<NarDetails> narDetails=new ArrayList<>();\n    for (    final File unpackedNar : narWorkingDirContents) {\n      final NarDetails narDetail=getNarDetails(unpackedNar);\n      if (narDetail.getNarId() == null) {\n        logger.warn(\"No NAR Id found. Skipping: \" + unpackedNar.getAbsolutePath());\n        continue;\n      }\n      narDetails.add(narDetail);\n    }\n    int narCount;\n    do {\n      narCount=narDetails.size();\n      for (final Iterator<NarDetails> narDetailsIter=narDetails.iterator(); narDetailsIter.hasNext(); ) {\n        final NarDetails narDetail=narDetailsIter.next();\n        final String narDependencies=narDetail.getNarDependencyId();\n        ClassLoader narClassLoader=null;\n        if (narDependencies == null) {\n          narClassLoader=createNarClassLoader(narDetail.getNarWorkingDirectory(),currentContextClassLoader);\n        }\n else         if (narIdClassLoaderLookup.containsKey(narDetail.getNarDependencyId())) {\n          narClassLoader=createNarClassLoader(narDetail.getNarWorkingDirectory(),narIdClassLoaderLookup.get(narDetail.getNarDependencyId()));\n        }\n        if (narClassLoader != null) {\n          extensionDirectoryClassLoaderLookup.put(narDetail.getNarWorkingDirectory().getCanonicalPath(),narClassLoader);\n          narIdClassLoaderLookup.put(narDetail.getNarId(),narClassLoader);\n          narDetailsIter.remove();\n        }\n      }\n    }\n while (narCount != narDetails.size());\n    for (    final NarDetails narDetail : narDetails) {\n      logger.warn(String.format(\"Unable to resolve required dependency '%s'. Skipping NAR %s\",narDetail.getNarDependencyId(),narDetail.getNarWorkingDirectory().getAbsolutePath()));\n    }\n  }\n  frameworkClassLoader.set(narIdClassLoaderLookup.get(FRAMEWORK_NAR_ID));\n  extensionClassLoaders.set(new LinkedHashMap<>(extensionDirectoryClassLoaderLookup));\n}\n", "nl": "Loads the extensions class loaders from the specified working directory. Loading is only performed during the initial invocation of load. Subsequent attempts will be ignored."}
{"code": "public CsvInfo(){\n}\n", "nl": "Instantiates a new instance."}
{"code": "public boolean isSummary(){\n  Object oo=get_Value(COLUMNNAME_IsSummary);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Summary Level."}
{"code": "public void execute() throws Exception {\n  startUp();\n  generateQueryId();\n  CloseableHttpAsyncClient client=getClient();\n  client.start();\n  Pair<String,InputStream> requestInput=getRequestInput();\n  try (InputStream is=requestInput.getRight()){\n    sentRequest=new Message(is,requestInput.getLeft());\n  }\n   AsyncHttpSender sender=new AsyncHttpSender(client);\n  sender.addHeader(HEADER_HASH_ALGO_ID,DEFAULT_DIGEST_ALGORITHM_ID);\n  requestInput=getRequestInput();\n  try (InputStream is=requestInput.getRight()){\n    for (    Entry<String,String> e : requestHeaders.entrySet()) {\n      sender.addHeader(e.getKey(),e.getValue());\n    }\n    if (\"post\".equalsIgnoreCase(httpMethod)) {\n      sender.doPost(new URI(url),is,CHUNKED_LENGTH,requestInput.getLeft());\n    }\n else {\n      sender.doGet(new URI(url));\n    }\n    sender.waitForResponse(DEFAULT_CLIENT_TIMEOUT);\n  }\n   try {\n    receivedResponse=new Message(sender.getResponseContent(),sender.getResponseContentType());\n    if (sentRequest != null && sentRequest.getSoap() != null && sentRequest.getSoap() instanceof SoapMessageImpl && ((SoapMessageImpl)sentRequest.getSoap()).isAsync() && !requestHeaders.containsKey(SoapUtils.X_IGNORE_ASYNC)) {\n      sentResponse=receivedResponse;\n    }\n  }\n  finally {\n    sender.close();\n    client.close();\n    closeDown();\n  }\n  if (failed) {\n    throw new Exception(\"Test failed in previous stage\");\n  }\n  log.debug(\"Validating SOAP message\\n{}\",receivedResponse.getSoap().getXml());\n  if (receivedResponse.isFault()) {\n    log.debug(\"Validating fault: {}, {}\",((SoapFault)receivedResponse.getSoap()).getCode(),((SoapFault)receivedResponse.getSoap()).getString());\n    validateFaultResponse(receivedResponse);\n    return;\n  }\n  if (!receivedResponse.isResponse()) {\n    throw new Exception(\"Received SOAP message is not a response\");\n  }\n  if (sentResponse != null && !checkConsistency(sentResponse,receivedResponse)) {\n    throw new Exception(\"Received response is not the same as sent response\");\n  }\n  log.debug(\"Validating normal response\");\n  validateNormalResponse(receivedResponse);\n}\n", "nl": "Performs the request and validates the response."}
{"code": "public boolean isInverted(){\n  return lng.isInverted();\n}\n", "nl": "Return true if lng_.lo() > lng_.hi(), i.e. the rectangle crosses the 180 degree latitude line."}
{"code": "private void validateLogicalShardId(final long logicalShardId){\n  if (logicalShardId < MIN_LOGICAL_SHARD_ID || logicalShardId > MAX_LOGICAL_SHARD_ID) {\n    throw new InvalidLogicalShardIdException(\"The logical shard ID set in Redis is less than \" + String.valueOf(MIN_LOGICAL_SHARD_ID) + \" or is greater than the supported maximum of \"+ String.valueOf(MAX_LOGICAL_SHARD_ID));\n  }\n}\n", "nl": "Check that the given logical shard ID is within the bounds that we allow. This is important to check, as otherwise when bit-shifting we may lose digits outside of the bits we care about, introducing possible collisions."}
{"code": "public boolean foo(String x,String y){\n  if (x != null)   return foo_bar0(x);\n else   if (y != null)   return foo_bar1(y);\n else   return false;\n}\n", "nl": "This private method has 4 branches"}
{"code": "public static void ensureOutputDirectory(final File directory){\n  if (!directory.exists()) {\n    if (!directory.mkdirs()) {\n      throw new NoTalkbackSlimException(ErrorType.DIRECTORY_NOT_CREATED,directory.getPath());\n    }\n  }\n else {\n    if (!directory.isDirectory()) {\n      throw new NoTalkbackSlimException(ErrorType.NOT_A_DIRECTORY,directory.getPath());\n    }\n  }\n}\n", "nl": "Test if the supplied directory is valid for the purposes of writing a SLIM result.  This means the directory either exists or does not exist and can be successfully created (which this method will do)."}
{"code": "private static void delete(File f){\n  if (f.isDirectory()) {\n    for (    File c : f.listFiles()) {\n      delete(c);\n    }\n  }\n  if (!f.delete()) {\n    PrintStream err=System.err;\n    err.println(\"Failed to delete file: \" + f);\n  }\n}\n", "nl": "Recursively deletes a file that may represent a directory."}
{"code": "public static void putShortLE(byte[] arr,long off,short val){\n  if (UNALIGNED)   UNSAFE.putShort(arr,off,Short.reverseBytes(val));\n else   putShortByByte(arr,off,val,false);\n}\n", "nl": "Stores short value into byte array assuming that value should be stored in little-endian byte order and native byte order is big-endian. Alignment aware."}
{"code": "public static void incNumWorkers(){\n  incNumWorkers(1);\n}\n", "nl": "Increments the number of workers by 1"}
{"code": "private void buildAddressSelectionPopUp(){\n  final CAddressSelectionDialog dlg=new CAddressSelectionDialog(m_parent,m_modules);\n  dlg.setVisible(true);\n  final INaviModule result=dlg.getSelectionResult();\n  final IAddress address=new CAddress(Long.parseLong(getText(),16));\n  ZyZoomHelpers.zoomToAddress(m_graph,address,result,true);\n}\n", "nl": "In the case of multiple modules zoom to address does not work therefore the user must select in which module to search."}
{"code": "public boolean isFinal(){\n  return ffinal;\n}\n", "nl": "Checks if is final."}
{"code": "protected void writeFormStreamData(OutputStream writer) throws IOException {\n  Set<String> keys=mParamKeyValues.keySet();\n  for (  String key : keys) {\n    List<Object> values=mParamKeyValues.getValues(key);\n    for (    Object value : values) {\n      if (!isCanceled()) {\n        if (value != null && value instanceof String) {\n          if (!(writer instanceof CounterOutputStream))           Logger.i(key + \"=\" + value);\n          writeFormString(writer,key,value.toString());\n        }\n else         if (value != null && value instanceof Binary) {\n          if (!(writer instanceof CounterOutputStream))           Logger.i(key + \" is Binary\");\n          writeFormBinary(writer,key,(Binary)value);\n        }\n        writer.write(\"\\r\\n\".getBytes());\n      }\n    }\n  }\n  writer.write((endBoundary).getBytes());\n}\n", "nl": "Send form data."}
{"code": "public static <E>Set<E> constrainedSet(Set<E> set,Constraint<? super E> constraint){\n  return new ConstrainedSet<E>(set,constraint);\n}\n", "nl": "Returns a constrained view of the specified set, using the specified constraint. Any operations that add new elements to the set will call the provided constraint. However, this method does not verify that existing elements satisfy the constraint. <p>The returned set is not serializable."}
{"code": "private void extractMessages(){\n  Intent lInvokingIntent=getIntent();\n  String lMsgInit=lInvokingIntent.getStringExtra(MSG_INIT);\n  if (lMsgInit != null) {\n    mMsgInit=lMsgInit;\n  }\n  String lMsgDetect=lInvokingIntent.getStringExtra(MSG_DETECT);\n  if (lMsgDetect != null) {\n    mMsgDetect=lMsgDetect;\n  }\n  String lMsgPlaylist=lInvokingIntent.getStringExtra(MSG_PLAYLIST);\n  if (lMsgPlaylist != null) {\n    mMsgPlaylist=lMsgPlaylist;\n  }\n  String lMsgToken=lInvokingIntent.getStringExtra(MSG_TOKEN);\n  if (lMsgToken != null) {\n    mMsgToken=lMsgToken;\n  }\n  String lMsgLoBand=lInvokingIntent.getStringExtra(MSG_LO_BAND);\n  if (lMsgLoBand != null) {\n    mMsgLowBand=lMsgLoBand;\n  }\n  String lMsgHiBand=lInvokingIntent.getStringExtra(MSG_HI_BAND);\n  if (lMsgHiBand != null) {\n    mMsgHiBand=lMsgHiBand;\n  }\n  String lMsgErrTitle=lInvokingIntent.getStringExtra(MSG_ERROR_TITLE);\n  if (lMsgErrTitle != null) {\n    mMsgErrorTitle=lMsgErrTitle;\n  }\n  String lMsgErrMsg=lInvokingIntent.getStringExtra(MSG_ERROR_MSG);\n  if (lMsgErrMsg != null) {\n    mMsgError=lMsgErrMsg;\n  }\n}\n", "nl": "Determine the messages to display during video load and initialization."}
{"code": "private CNameListGenerators(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public CCheckBox(Action a){\n  super(a);\n  init();\n}\n", "nl": "Creates a check box where properties are taken from the Action supplied."}
{"code": "public static ZyLabelContent buildContent(final INaviTextNode node){\n  Preconditions.checkNotNull(node,\"IE01700: Node argument can not be null\");\n  final ZyLabelContent content=new ZyLabelContent(null);\n  buildContent(content,node);\n  return content;\n}\n", "nl": "Builds the content of the text node."}
{"code": "protected void layoutSouth(DockWrapper base,int x,int y,int maxwidth,int maxheight){\n  for (Iterator iter=base.getDockedWrappers().iterator(); iter.hasNext(); ) {\n    DockWrapper dw=(DockWrapper)iter.next();\n    Dimension d=dw.getPreferredSize();\n    int w=min(d.width,maxwidth);\n    int h=min(d.height,maxheight);\n    dw.setBounds(x,y - h,w,h);\n    if (!dw.canOcclude()) {\n      updateBottom(backgroundBounds,y - h);\n    }\n    updateBottom(occludingBounds,y - h);\n    layoutSouth(dw,x,y - h,maxwidth,maxheight - h);\n    x+=w;\n    maxwidth-=w;\n  }\n}\n", "nl": "Layout north side."}
{"code": "public void lostOwnership(Clipboard clipboard,Transferable contents){\n}\n", "nl": "Required by the AbstractAction interface; does nothing."}
{"code": "public void cancel(){\n  mCancellationRequested.set(true);\n}\n", "nl": "Cancel operation"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:59:26.756 -0500\",hash_original_method=\"3F955D64051D380D89135CF7B70C1F05\",hash_generated_method=\"0EC25BC15D68F1E59DA0282A4EDDD537\") public void reqGetReconnectIntent(){\n  Message response=sendMessageSynchronously(REQ_GET_RECONNECT_INTENT);\n  if (DBG)   log(\"reqGetReconnectIntent\");\n}\n", "nl": "Request to get Pending ReconnectIntent to DC. Response RSP_GET_RECONNECT_INTENT when complete."}
{"code": "public void finished(){\n  m_printstream.flush();\n}\n", "nl": "Finalizes output file."}
{"code": "public String encode(){\n  return encode(new StringBuffer()).toString();\n}\n", "nl": "Get the encoded representation of this namevalue object. Added doublequote for encoding doublequoted values. Bug: RFC3261 stipulates that an opaque parameter in authenticate header has to be: opaque              =  \"opaque\" EQUAL quoted-string so returning just the name is not acceptable. (e.g. LinkSys phones are picky about this)"}
{"code": "private void computeSnaps(Collection segStrings,Collection snapPts){\n  for (Iterator i0=segStrings.iterator(); i0.hasNext(); ) {\n    NodedSegmentString ss=(NodedSegmentString)i0.next();\n    computeSnaps(ss,snapPts);\n  }\n}\n", "nl": "Computes nodes introduced as a result of snapping segments to snap points (hot pixels)"}
{"code": "public DotGraph(String graphname){\n  this.graphname=graphname;\n  this.isSubGraph=false;\n  this.nodes=new HashMap<String,DotGraphNode>(100);\n  this.drawElements=new LinkedList<Renderable>();\n  this.attributes=new LinkedList<DotGraphAttribute>();\n}\n", "nl": "Creates a new graph for drawing."}
{"code": "public static LayersBuilder with(Layer... layers){\n  return new LayersBuilder(Arrays.asList(layers));\n}\n", "nl": "Returns a new LayersBuilder with all the provided layers included."}
{"code": "@DSComment(\"Layout info\") @DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:31:46.937 -0500\",hash_original_method=\"E6336A158C939972C1CFCFE234B123CF\",hash_generated_method=\"77CD180C6E32DEBAEFF64B715469A756\") public void addRule(int verb,int anchor){\n  mRules[verb]=anchor;\n}\n", "nl": "Adds a layout rule to be interpreted by the RelativeLayout. Use this for verbs that take a target, such as a sibling (ALIGN_RIGHT) or a boolean value (VISIBLE)."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private Finalizer(Class<?> finalizableReferenceClass,ReferenceQueue<Object> queue,PhantomReference<Object> frqReference){\n  this.queue=queue;\n  this.finalizableReferenceClassReference=new WeakReference<Class<?>>(finalizableReferenceClass);\n  this.frqReference=frqReference;\n}\n", "nl": "Constructs a new finalizer thread."}
{"code": "void dispose(){\n  stroking=0;\n  if (!USE_CACHE_HARD_REF) {\n    hardRefArrayCaches=null;\n  }\n  if (dirty) {\n    this.nPCPathIterator.dispose();\n    this.nPQPathIterator.dispose();\n    this.dasher.dispose();\n    this.stroker.dispose();\n    dirty=false;\n  }\n}\n", "nl": "Disposes this renderer context: clean up before reusing this context"}
{"code": "@Override public String toString(){\n  StringBuilder result=new StringBuilder();\n  result.append(\"Token[\");\nswitch (ttype) {\ncase TT_EOF:\n    result.append(\"EOF\");\n  break;\ncase TT_EOL:\nresult.append(\"EOL\");\nbreak;\ncase TT_NUMBER:\nresult.append(\"n=\");\nresult.append(nval);\nbreak;\ncase TT_WORD:\nresult.append(sval);\nbreak;\ndefault :\nif (ttype == TT_UNKNOWN || tokenTypes[ttype] == TOKEN_QUOTE) {\nresult.append(sval);\n}\n else {\nresult.append('\\'');\nresult.append((char)ttype);\nresult.append('\\'');\n}\n}\nresult.append(\"], line \");\nresult.append(lineNumber);\nreturn result.toString();\n}\n", "nl": "Returns the state of this tokenizer in a readable format."}
{"code": "public ConstExpConstModel(Parameter N0Parameter,Parameter N1Parameter,Parameter growthRateParameter,Parameter timeParameter,Parameter epochParameter,boolean useNumericalIntegrator,Type units){\n  this(ConstExpConstModelParser.CONST_EXP_CONST_MODEL,N0Parameter,N1Parameter,growthRateParameter,timeParameter,epochParameter,useNumericalIntegrator,units);\n}\n", "nl": "Construct demographic model with default settings"}
{"code": "public void put(String key,File files[]) throws FileNotFoundException {\n  put(key,files,null,null);\n}\n", "nl": "Adds files array to the request."}
{"code": "public void testMoveRenameFileSourceAndDestinationMissingPartially() throws Exception {\n  create(igfsSecondary,paths(DIR,SUBDIR,DIR_NEW,SUBDIR_NEW),paths(FILE));\n  create(igfs,paths(DIR,DIR_NEW),null);\n  igfs.rename(FILE,FILE_NEW);\n  checkExist(igfs,SUBDIR,SUBDIR_NEW);\n  checkExist(igfs,igfsSecondary,FILE_NEW);\n  checkNotExist(igfs,igfsSecondary,FILE);\n}\n", "nl": "Test move and rename in case source and destination exist partially and the path being renamed is a file."}
{"code": "public static int encode(byte[] data,OutputStream out) throws IOException {\n  return encoder.encode(data,0,data.length,out);\n}\n", "nl": "Encode the byte data to base 64 writing it to the given output stream."}
{"code": "protected boolean parseNameTest(PsiBuilder builder){\n  if (builder.getTokenType() == XPathTokenTypes.STAR) {\n    return parseWildcard(builder);\n  }\n else   if (builder.getTokenType() == XPathTokenTypes.NCNAME) {\n    builder.advanceLexer();\n    if (builder.getTokenType() == XPathTokenTypes.COL) {\n      builder.advanceLexer();\n      if (builder.getTokenType() != XPathTokenTypes.STAR) {\n        if (builder.getTokenType() != XPathTokenTypes.NCNAME) {\n          builder.error(\"* or NCName expected\");\n        }\n else {\n          builder.advanceLexer();\n        }\n      }\n else {\n        builder.advanceLexer();\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "[37]    NameTest    ::=    '*' | NCName ':' '*' | QName"}
{"code": "private void deleteConfig(HttpServletRequest request,InstructionalOfferingConfigEditForm frm) throws Exception {\n  org.hibernate.Session hibSession=null;\n  Transaction tx=null;\n  try {\n    InstrOfferingConfigDAO iocDao=new InstrOfferingConfigDAO();\n    hibSession=iocDao.getSession();\n    tx=hibSession.beginTransaction();\n    Long configId=frm.getConfigId();\n    InstrOfferingConfig ioc=iocDao.get(configId);\n    InstructionalOffering io=ioc.getInstructionalOffering();\n    deleteSubpart(request,hibSession,ioc,new HashMap());\n    io.removeConfiguration(ioc);\n    io.computeLabels(hibSession);\n    if (!ioc.isUnlimitedEnrollment().booleanValue())     io.setLimit(new Integer(io.getLimit().intValue() - ioc.getLimit().intValue()));\n    ChangeLog.addChange(hibSession,sessionContext,io,io.getCourseName() + \" [\" + ioc.getName()+ \"]\",ChangeLog.Source.INSTR_CFG_EDIT,ChangeLog.Operation.DELETE,io.getControllingCourseOffering().getSubjectArea(),null);\n    Event.deleteFromEvents(hibSession,ioc);\n    Exam.deleteFromExams(hibSession,ioc);\n    hibSession.saveOrUpdate(io);\n    String className=ApplicationProperty.ExternalActionInstrOffrConfigChange.value();\n    ExternalInstrOffrConfigChangeAction configChangeAction=null;\n    if (className != null && className.trim().length() > 0) {\n      configChangeAction=(ExternalInstrOffrConfigChangeAction)(Class.forName(className).newInstance());\n      if (!configChangeAction.validateConfigChangeCanOccur(io,hibSession)) {\n        throw new Exception(\"Configuration change violates rules for Add On, rolling back the change.\");\n      }\n    }\n    hibSession.flush();\n    tx.commit();\n    hibSession.refresh(io);\n    if (configChangeAction != null) {\n      configChangeAction.performExternalInstrOffrConfigChangeAction(io,hibSession);\n    }\n  }\n catch (  Exception e) {\n    try {\n      if (tx != null && tx.isActive())       tx.rollback();\n    }\n catch (    Exception e1) {\n    }\n    Debug.error(e);\n    throw (e);\n  }\n}\n", "nl": "Deletes configuration and associated prefs"}
{"code": "private void loadProfile(String userId,String name){\n  final Intent userProfileIntent=new Intent(getActivity(),UserProfileActivity.class);\n  userProfileIntent.putExtra(AppConstants.Keys.USER_ID,userId);\n  userProfileIntent.putExtra(AppConstants.Keys.USER_NAME,name);\n  userProfileIntent.putExtra(AppConstants.Keys.SERVICE_SCREEN_TYPE,AppConstants.ServiceScreenType.PROFILE);\n  startActivity(userProfileIntent);\n}\n", "nl": "This loads the profile of the user"}
{"code": "int doFinal(byte[] input,int inputOffset,int inputLen,byte[] output,int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException {\n  return cipher.doFinal(input,inputOffset,inputLen,output,outputOffset);\n}\n", "nl": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. <p>The first <code>inputLen</code> bytes in the <code>input</code> buffer, starting at <code>inputOffset</code>, and any input bytes that may have been buffered during a previous <code>update</code> operation, are processed, with padding (if requested) being applied. The result is stored in the <code>output</code> buffer, starting at <code>outputOffset</code>. <p>The cipher is reset to its initial state (uninitialized) after this call."}
{"code": "public boolean isOverwriteMode(){\n  return !isInserting;\n}\n", "nl": "Tells whether the input is in overwrite or insert mode"}
{"code": "private void writeAttribute(java.lang.String prefix,java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (xmlWriter.getPrefix(namespace) == null) {\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  xmlWriter.writeAttribute(namespace,attName,attValue);\n}\n", "nl": "Util method to write an attribute with the ns prefix"}
{"code": "public javax.naming.Binding nextElement(){\n  try {\n    return next();\n  }\n catch (  NamingException ne) {\n    throw new NoSuchElementException();\n  }\n}\n", "nl": "Returns the next binding in the list."}
{"code": "public static void i(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_INFO) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.i(tag,msg);\n}\n", "nl": "Send an INFO log message"}
{"code": "public void cancel(){\n  cancelled=true;\n}\n", "nl": "Since cancel is async, it just means that we will eventually, and rather quickly, stop emitting values. We do this to follow the reactive streams specifications that cancel should mean that the observable eventually stops emitting items."}
{"code": "public void findAndInit(Object someObj){\n  super.findAndInit(someObj);\n  if (someObj instanceof MapBean || someObj instanceof InformationDelegator) {\n    drawingTool.findAndInit(someObj);\n  }\n  if (someObj instanceof MouseDelegator) {\n    setMouseDelegator((MouseDelegator)someObj);\n    drawingTool.findAndInit(someObj);\n  }\n  if (someObj instanceof OMGraphicDeleteTool) {\n    ((OMGraphicDeleteTool)someObj).findAndInit(getDrawingTool());\n  }\n}\n", "nl": "Called by findAndInit(Iterator) so subclasses can find objects, too."}
{"code": "public PaymentGatewayPayPoint(){\n  System.setProperty(\"java.protocol.handler.pkgs\",\"com.sun.net.ssl.internal.www.protocol\");\n  Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());\n  m_sCommerceID=AppConfig.getInstance().getProperty(\"payment.commerceid\");\n  AltEncrypter cypher=new AltEncrypter(\"cypherkey\" + AppConfig.getInstance().getProperty(\"payment.commerceid\"));\n  this.m_sCommercePassword=cypher.decrypt(AppConfig.getInstance().getProperty(\"payment.commercepassword\").substring(6));\n  m_bTestMode=AppConfig.getInstance().getBoolean(\"payment.testmode\");\n  m_sCurrency=(Locale.getDefault().getCountry().isEmpty()) ? Currency.getInstance(\"EUR\").getCurrencyCode() : Currency.getInstance(Locale.getDefault()).getCurrencyCode();\n}\n", "nl": "Creates a new instance of PaymentGatewaySECPay"}
{"code": "public void init() throws IOException {\n  mailbox.connect();\n  this.initialized=true;\n}\n", "nl": "Connects to Gmail and loads the base information required for the sync."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "@Override protected EClass eStaticClass(){\n  return TypeRefsPackage.Literals.TYPE_REF;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public final Exercise.Type type(){\n  return type;\n}\n", "nl": "Returns the exercise type"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col;\n  float progress=0;\n  double z, z2, zMin;\n  int x, y, a, b, i;\n  double h=0;\n  int whichCell;\n  double infVal=9999999;\n  int[] dX=new int[]{-1,-1,0,1,1,1,0,-1};\n  int[] dY=new int[]{0,-1,-1,-1,0,1,1,1};\n  int[] Gx=new int[]{1,1,0,1,1,1,0,1};\n  int[] Gy=new int[]{0,1,1,1,0,1,1,1};\n  double gridRes;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputHeader=args[0];\n  outputHeader=args[1];\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster image=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=image.getNumberRows();\n    int cols=image.getNumberColumns();\n    double noData=image.getNoDataValue();\n    gridRes=(image.getCellSizeX() + image.getCellSizeY()) / 2;\n    WhiteboxRaster outputImage=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,infVal);\n    outputImage.setPreferredPalette(\"spectrum.pal\");\n    WhiteboxRaster Rx=new WhiteboxRaster(outputHeader.replace(\".dep\",\"_temp1.dep\"),\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,0);\n    Rx.isTemporaryFile=true;\n    WhiteboxRaster Ry=new WhiteboxRaster(outputHeader.replace(\".dep\",\"_temp2.dep\"),\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,0);\n    Ry.isTemporaryFile=true;\n    double[] data;\n    for (row=0; row < rows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < cols; col++) {\n        if (data[col] != 0) {\n          outputImage.setValue(row,col,0);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (rows - 1));\n      updateProgress((int)progress);\n    }\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=outputImage.getValue(row,col);\n        if (z != 0) {\n          zMin=infVal;\n          whichCell=-1;\n          for (i=0; i <= 3; i++) {\n            x=col + dX[i];\n            y=row + dY[i];\n            z2=outputImage.getValue(y,x);\n            if (z2 != noData) {\nswitch (i) {\ncase 0:\n                h=2 * Rx.getValue(y,x) + 1;\n              break;\ncase 1:\n            h=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\n          break;\ncase 2:\n        h=2 * Ry.getValue(y,x) + 1;\n      break;\ncase 3:\n    h=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\n  break;\n}\nz2+=h;\nif (z2 < zMin) {\nzMin=z2;\nwhichCell=i;\n}\n}\n}\nif (zMin < z) {\noutputImage.setValue(row,col,zMin);\nx=col + dX[whichCell];\ny=row + dY[whichCell];\nRx.setValue(row,col,Rx.getValue(y,x) + Gx[whichCell]);\nRy.setValue(row,col,Ry.getValue(y,x) + Gy[whichCell]);\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * row / (rows - 1));\nupdateProgress((int)progress);\n}\nfor (row=rows - 1; row >= 0; row--) {\nfor (col=cols - 1; col >= 0; col--) {\nz=outputImage.getValue(row,col);\nif (z != 0) {\nzMin=infVal;\nwhichCell=-1;\nfor (i=4; i <= 7; i++) {\nx=col + dX[i];\ny=row + dY[i];\nz2=outputImage.getValue(y,x);\nif (z2 != noData) {\nswitch (i) {\ncase 5:\nh=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\nbreak;\ncase 4:\nh=2 * Rx.getValue(y,x) + 1;\nbreak;\ncase 6:\nh=2 * Ry.getValue(y,x) + 1;\nbreak;\ncase 7:\nh=2 * (Rx.getValue(y,x) + Ry.getValue(y,x) + 1);\nbreak;\n}\nz2+=h;\nif (z2 < zMin) {\nzMin=z2;\nwhichCell=i;\n}\n}\n}\nif (zMin < z) {\noutputImage.setValue(row,col,zMin);\nx=col + dX[whichCell];\ny=row + dY[whichCell];\nRx.setValue(row,col,Rx.getValue(y,x) + Gx[whichCell]);\nRy.setValue(row,col,Ry.getValue(y,x) + Gy[whichCell]);\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * (rows - 1 - row) / (rows - 1));\nupdateProgress((int)progress);\n}\nfor (row=0; row < rows; row++) {\nfor (col=0; col < cols; col++) {\nz=image.getValue(row,col);\nif (z != noData) {\nz=outputImage.getValue(row,col);\noutputImage.setValue(row,col,Math.sqrt(z) * gridRes);\n}\n else {\noutputImage.setValue(row,col,noData);\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(float)(100f * row / (rows - 1));\nupdateProgress((int)progress);\n}\noutputImage.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\noutputImage.addMetadataEntry(\"Created on \" + new Date());\nimage.close();\noutputImage.close();\nRx.close();\nRy.close();\nreturnData(outputHeader);\n}\n catch (OutOfMemoryError oe) {\nmyHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n}\ncatch (Exception e) {\nmyHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\nmyHost.logException(\"Error in \" + getDescriptiveName(),e);\n}\n finally {\nupdateProgress(\"Progress: \",0);\namIActive=false;\nmyHost.pluginComplete();\n}\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public JavaType constructSimpleType(Class<?> rawType,JavaType[] parameterTypes){\n  TypeVariable<?>[] typeVars=rawType.getTypeParameters();\n  if (typeVars.length != parameterTypes.length) {\n    throw new IllegalArgumentException(\"Parameter type mismatch for \" + rawType.getName() + \": expected \"+ typeVars.length+ \" parameters, was given \"+ parameterTypes.length);\n  }\n  String[] names=new String[typeVars.length];\n  for (int i=0, len=typeVars.length; i < len; ++i) {\n    names[i]=typeVars[i].getName();\n  }\n  JavaType resultType=new SimpleType(rawType,names,parameterTypes,null,null);\n  return resultType;\n}\n", "nl": "Method for constructing a type instance with specified parameterization."}
{"code": "@Override public void entityChanged(final Object property){\n  super.entityChanged(property);\n  if (property == Chest.PROP_OPEN) {\n    proceedChangedState(entity);\n    openChanged=true;\n  }\n}\n", "nl": "An entity was changed."}
{"code": "public DragGestureRecognizer createDefaultDragGestureRecognizer(Component c,int actions,DragGestureListener dgl){\n  return Toolkit.getDefaultToolkit().createDragGestureRecognizer(MouseDragGestureRecognizer.class,this,c,actions,dgl);\n}\n", "nl": "Creates a new <code>DragGestureRecognizer</code> that implements the default abstract subclass of <code>DragGestureRecognizer</code> for this <code>DragSource</code>, and sets the specified <code>Component</code> and <code>DragGestureListener</code> on the newly created object. For this <code>DragSource</code> the default is <code>MouseDragGestureRecognizer</code>. <P>"}
{"code": "public PipedReader(PipedWriter src) throws IOException {\n  this(src,DEFAULT_PIPE_SIZE);\n}\n", "nl": "Creates a <code>PipedReader</code> so that it is connected to the piped writer <code>src</code>. Data written to <code>src</code> will then be available as input from this stream."}
{"code": "public static File ensureLogDirectoryExists(){\n  if (mLogDirectory == null) {\n    return null;\n  }\n  if (!mLogDirectory.exists()) {\n    mLogDirectory.mkdirs();\n  }\n  return mLogDirectory;\n}\n", "nl": "Check if the log directory exists. Create it if it s not created"}
{"code": "public String stem(String s){\n  if (stem(s.toCharArray(),s.length()))   return toString();\n else   return s;\n}\n", "nl": "Stem a word provided as a String.  Returns the result as a String."}
{"code": "protected boolean err(){\n  return status != STATUS_OK;\n}\n", "nl": "Returns true if an error was encountered during reading/decoding"}
{"code": "public DeleteRequest parent(String parent){\n  if (routing == null) {\n    routing=parent;\n  }\n  return this;\n}\n", "nl": "Sets the parent id of this document. Will simply set the routing to this value, as it is only used for routing with delete requests."}
{"code": "public AndQueryBuilder add(QueryBuilder filterBuilder){\n  filters.add(filterBuilder);\n  return this;\n}\n", "nl": "Adds a filter to the list of filters to \"and\"."}
{"code": "public static boolean match(String s,String... sa){\n  for (  String st : sa) {\n    if (st.equalsIgnoreCase(s))     return true;\n  }\n  return false;\n}\n", "nl": "Checks if any of the strings from the given array matches the given string"}
{"code": "public static void text(double x,double y,String text){\n  if (text == null)   throw new NullPointerException();\n  offscreen.setFont(font);\n  FontMetrics metrics=offscreen.getFontMetrics();\n  double xs=scaleX(x);\n  double ys=scaleY(y);\n  int ws=metrics.stringWidth(text);\n  int hs=metrics.getDescent();\n  offscreen.drawString(text,(float)(xs - ws / 2.0),(float)(ys + hs));\n  draw();\n}\n", "nl": "Write the given text string in the current font, centered at (<em>x</em>, <em>y</em>)."}
{"code": "static void extractGenericsConnections(Map<String,GenericsType> connections,ClassNode type,ClassNode target){\n  if (target == null || type == target || !isUsingGenericsOrIsArrayUsingGenerics(target))   return;\n  if (type == null || type == UNKNOWN_PARAMETER_TYPE)   return;\n  if (type.isArray() && target.isArray()) {\n    extractGenericsConnections(connections,type.getComponentType(),target.getComponentType());\n  }\n else   if (target.isGenericsPlaceHolder() || type.equals(target) || !implementsInterfaceOrIsSubclassOf(type,target)) {\n    if (target.isGenericsPlaceHolder()) {\n      connections.put(target.getGenericsTypes()[0].getName(),new GenericsType(type));\n    }\n else {\n      extractGenericsConnections(connections,type.getGenericsTypes(),target.getGenericsTypes());\n    }\n  }\n else {\n    Map<String,ClassNode> genSpec=GenericsUtils.createGenericsSpec(type);\n    ClassNode superClass=getNextSuperClass(type,target);\n    if (superClass != null) {\n      ClassNode corrected;\n      if (missesGenericsTypes(type)) {\n        corrected=superClass.getPlainNodeReference();\n      }\n else {\n        corrected=GenericsUtils.correctToGenericsSpecRecurse(genSpec,superClass);\n      }\n      extractGenericsConnections(connections,corrected,target);\n    }\n else {\n      throw new GroovyBugError(\"The type \" + type + \" seems not to normally extend \"+ target+ \". Sorry, I cannot handle this.\");\n    }\n  }\n}\n", "nl": "use supplied type to make a connection from usage to declaration The method operates in two modes. * For type !instanceof target a structural compare will be done (for example Dummy&lt;T&gt; and List&lt;R&gt; to get T=R) * If type equals target, a structural match is done as well (for example Colection&lt;U&gt; and Collection&lt;E&gt; to get U=E) * otherwise we climb the hierarchy to find a case of type equals target to then execute the structural match, while applying possibly existing generics contexts on the way (for example for IntRange and Collection&lt;E&gt; to get E=Integer, since IntRange is an AbstractList&lt;Integer&gt;) Should the target not have any generics this method does nothing."}
{"code": "public FunctionInvocationTargetException(Throwable cause){\n  super(cause);\n}\n", "nl": "Construct an instance of FunctionInvocationTargetException"}
{"code": "private CharSequence formatDuration(long millis){\n  if (millis >= DateUtils.HOUR_IN_MILLIS) {\n    int hours=(int)TimeUnit.MILLISECONDS.toHours(millis + TimeUnit.MINUTES.toMillis(30));\n    return resources.getQuantityString(R.plurals.dl__duration_hours,hours,hours);\n  }\n else   if (millis >= DateUtils.MINUTE_IN_MILLIS) {\n    int minutes=(int)TimeUnit.MILLISECONDS.toMinutes(millis + TimeUnit.SECONDS.toMillis(30));\n    return resources.getQuantityString(R.plurals.dl__duration_minutes,minutes,minutes);\n  }\n else {\n    int seconds=(int)TimeUnit.MILLISECONDS.toSeconds(millis + 500);\n    return resources.getQuantityString(R.plurals.dl__duration_seconds,seconds,seconds);\n  }\n}\n", "nl": "Return given duration in a human-friendly format. For example, \"4 minutes\" or \"1 second\". Returns only largest meaningful unit of time, from seconds up to hours."}
{"code": "public double[][] rankedAttributes() throws Exception {\n  if (m_attributeRanking == null) {\n    throw new Exception(\"Ranking has not been performed\");\n  }\n  return m_attributeRanking;\n}\n", "nl": "get the final ranking of the attributes."}
{"code": "public void endAdding(GL10 gl){\n  checkState(STATE_ADDING,STATE_INITIALIZED);\n  gl.glBindTexture(GL10.GL_TEXTURE_2D,mTextureID);\n  GLUtils.texImage2D(GL10.GL_TEXTURE_2D,0,mBitmap,0);\n  mBitmap.recycle();\n  mBitmap=null;\n  mCanvas=null;\n}\n", "nl": "Call to end adding labels. Must be called before drawing starts."}
{"code": "public static void verifyVirtualPoolChangeForTechRefresh(VirtualPool srcVpool,VirtualPool tgtVpool){\n  String[] exclude=new String[]{PROTOCOLS,PROVISIONING_TYPE,ARRAY_INFO,DRIVE_TYPE,AUTO_TIER_POLICY_NAME,HOST_IO_LIMIT_IOPS,HOST_IO_LIMIT_BANDWIDTH,VMAX_COMPRESSION_ENABLED,MATCHED_POOLS,INVALID_MATCHED_POOLS,ASSIGNED_STORAGE_POOLS,LABEL,DESCRIPTION,STATUS,TAGS,CREATION_TIME,NON_DISRUPTIVE_EXPANSION};\n  if (!VirtualPoolChangeAnalyzer.analyzeChanges(srcVpool,tgtVpool,null,exclude,null).isEmpty()) {\n    throw APIException.badRequests.vPoolChangeNotValid(srcVpool.getId(),tgtVpool.getId());\n  }\n}\n", "nl": "Verifies the Vpool change for a tech refresh of a VPlex virtual volume. The Vpool should only specify a simple change such as the type of disk drive."}
{"code": "public DocumentQuery(URL feedUrl){\n  super(feedUrl);\n}\n", "nl": "Constructs a new query object that targets a feed.  The initial state of the query contains no parameters, meaning all entries in the feed would be returned if the query was executed immediately after construction."}
{"code": "static <T>List<T> cast(Iterable<T> iterable){\n  return (List<T>)iterable;\n}\n", "nl": "Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557"}
{"code": "private void addAttributesButtonsTo(JToolBar bar,DrawingEditor editor){\n  JButton b;\n  b=bar.add(new PickAttributesAction(editor));\n  b.setFocusable(false);\n  b=bar.add(new ApplyAttributesAction(editor));\n  b.setFocusable(false);\n  bar.addSeparator();\n  addColorButtonsTo(bar,editor);\n  bar.addSeparator();\n  addStrokeButtonsTo(bar,editor);\n  bar.addSeparator();\n  ButtonFactory.addFontButtonsTo(bar,editor);\n}\n", "nl": "Creates toolbar buttons and adds them to the specified JToolBar"}
{"code": "@Override public boolean equals(Object o){\n  if (o instanceof ChannelInfo) {\n    ChannelInfo other=(ChannelInfo)o;\n    if (this.channelId != null) {\n      if (this.channelId.equals(other.channelId))       return true;\n    }\n else     if (this.channelName != null && this.channelNumber != null) {\n      return this.channelName.equals(other.channelName) && this.channelNumber.equals(other.channelNumber) && this.majorNumber == other.majorNumber && this.minorNumber == other.minorNumber;\n    }\n    Log.d(Util.T,\"Could not compare channel values, no data to compare against\");\n    Log.d(Util.T,\"This channel info: \\n\" + this.rawData.toString());\n    Log.d(Util.T,\"Other channel info: \\n\" + other.rawData.toString());\n    return false;\n  }\n  return super.equals(o);\n}\n", "nl": "Compares two ChannelInfo objects."}
{"code": "static public String format(byte[] p){\n  return jmri.util.StringUtil.hexStringFromBytes(p);\n}\n", "nl": "Convert NMRA packet to a readable form"}
{"code": "private void closeConnectionQuietly(){\n  if (connection != null) {\n    try {\n      connection.disconnect();\n    }\n catch (    Exception e) {\n      Log.e(TAG,\"Unexpected error while disconnecting\",e);\n    }\n    connection=null;\n  }\n}\n", "nl": "Closes the current connection quietly, if there is one."}
{"code": "public void updateEllipse(float latPoint,float lonPoint,float majorAxisSpan,float minorAxisSpan,int units,float rotationAngle,LinkProperties properties,int graphicUpdateMask) throws IOException {\n  writeGraphicGestureHeader(graphicUpdateMask);\n  LinkEllipse.write(latPoint,lonPoint,majorAxisSpan,minorAxisSpan,units,rotationAngle,properties,link.dos);\n}\n", "nl": "Write an ellipse in the response."}
{"code": "@Override public void addTemporaryTopic(final TemporaryTopic temp){\n  if (ActiveMQRASessionFactoryImpl.trace) {\n    ActiveMQRALogger.LOGGER.trace(\"addTemporaryTopic(\" + temp + \")\");\n  }\nsynchronized (tempTopics) {\n    tempTopics.add(temp);\n  }\n}\n", "nl": "Add temporary topic"}
{"code": "@operator(value=ZERO,concept={IConcept.EQUATION,IConcept.MATH},doc=@doc(\"An internal placeholder function\")) public static Double f(final IScope scope,final IExpression var){\n  return Double.NaN;\n}\n", "nl": "Placeholder for zero-order equations. The expression on the right allows to pass the variable directly (maybe useful one day)."}
{"code": "private void exportExcel(){\n  RModel model=table.getRModel();\n  if (model == null) {\n    return;\n  }\n  try {\n    RModelExcelExporter exporter=new RModelExcelExporter((RModel)model);\n    exporter.export(null,null);\n  }\n catch (  Exception e) {\n    ADialog.error(0,this,\"Error\",e.getLocalizedMessage());\n    if (CLogMgt.isLevelFinest())     e.printStackTrace();\n  }\n}\n", "nl": "Export to Excel"}
{"code": "@Override public void onReceivedError(WebView view,int errorCode,String description,String failingUrl){\n  if (!isCurrentlyLoading) {\n    return;\n  }\n  LOG.d(TAG,\"CordovaWebViewClient.onReceivedError: Error code=%s Description=%s URL=%s\",errorCode,description,failingUrl);\n  if (errorCode == WebViewClient.ERROR_UNSUPPORTED_SCHEME) {\n    parentEngine.client.clearLoadTimeoutTimer();\n    if (view.canGoBack()) {\n      view.goBack();\n      return;\n    }\n else {\n      super.onReceivedError(view,errorCode,description,failingUrl);\n    }\n  }\n  parentEngine.client.onReceivedError(errorCode,description,failingUrl);\n}\n", "nl": "Report an error to the host application. These errors are unrecoverable (i.e. the main resource is unavailable). The errorCode parameter corresponds to one of the ERROR_* constants."}
{"code": "static final public boolean parseBoolean(int what){\n  return (what != 0);\n}\n", "nl": "<p>Convert an integer to a boolean. Because of how Java handles upgrading numbers, this will also cover byte and char (as they will upgrade to an int without any sort of explicit cast).</p> <p>The preprocessor will convert boolean(what) to parseBoolean(what).</p>"}
{"code": "public void onSurfaceDestroyed(){\n  if (DEBUG)   Log.v(TAG,\"onSurfaceDestroyed:\");\n  if (mDrawer != null) {\n    mDrawer.release();\n    mDrawer=null;\n  }\n  if (mSTexture != null) {\n    mSTexture.release();\n    mSTexture=null;\n  }\n  release();\n}\n", "nl": "when GLSurface context is soon destroyed"}
{"code": "public SequenceIndex(){\n  mBins=new TreeMap<>();\n  mLinearIndex=new long[5];\n}\n", "nl": "Construct a default SequenceIndex"}
{"code": "private void sequenceCommand(CommandRequest request,ServerSessionContext session,CompletableFuture<CommandResponse> future){\n  if (request.sequence() > session.nextRequestSequence()) {\n    session.registerRequest(request.sequence(),null);\n  }\n else {\n    applyCommand(request,session,future);\n  }\n}\n", "nl": "Sequences the given command to the log."}
{"code": "public cudaChannelFormatDesc(){\n}\n", "nl": "Creates an uninitialized cudaChannelFormatDesc"}
{"code": "public boolean isSelected(ButtonModel m){\n  return (m == selection);\n}\n", "nl": "Returns whether a <code>ButtonModel</code> is selected."}
{"code": "private boolean scheduleNext(){\n  final String tag=\"Scheduled session[\" + taskid + \"]\";\n  try {\n    LOG.finer(tag + \": scheduling next session for \" + delayBeforeNext+ \"ms\");\n    if (cancelled || !notifyStateChange(SCHEDULED,\"scan-scheduled\")) {\n      LOG.finer(tag + \" stopped: do not reschedule\");\n      return false;\n    }\n    final SessionTask nextTask=new SessionTask(delayBeforeNext);\n    if (!scheduleSession(nextTask,delayBeforeNext))     return false;\n    LOG.finer(tag + \": next session successfully scheduled\");\n  }\n catch (  Exception x) {\n    if (LOG.isLoggable(Level.FINEST)) {\n      LOG.log(Level.FINEST,tag + \" failed to schedule next session: \" + x,x);\n    }\n else     if (LOG.isLoggable(Level.FINE)) {\n      LOG.fine(tag + \" failed to schedule next session: \" + x);\n    }\n  }\n  return true;\n}\n", "nl": "Schedule an identical task for next iteration."}
{"code": "public Process exec(String prog,String[] envp) throws java.io.IOException {\n  return exec(prog,envp,null);\n}\n", "nl": "Execute prog in a separate platform process The new process uses the environment provided in envp"}
{"code": "@Override public void put(byte[] tableKey,StreamSource rowSource,Result<Boolean> result){\n  putImpl(tableKey,rowSource,PutType.PUT,result);\n}\n", "nl": "Puts the row for replication. Put is only called for the owning servers. Each owner and its backups get a copy."}
{"code": "public static void changeToTheme(Activity activity){\n  activity.finish();\n  activity.startActivity(new Intent(activity,activity.getClass()));\n}\n", "nl": "Set the theme of the Activity, and restart it by creating a new Activity of the same type."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public byte[] serialize(){\n  byte[] payloadData=null;\n  if (payload != null) {\n    payload.setParent(this);\n    payloadData=payload.serialize();\n  }\n  this.length=(short)(8 + ((payloadData == null) ? 0 : payloadData.length));\n  byte[] data=new byte[this.length];\n  ByteBuffer bb=ByteBuffer.wrap(data);\n  bb.putShort((short)this.sourcePort.getPort());\n  bb.putShort((short)this.destinationPort.getPort());\n  bb.putShort(this.length);\n  bb.putShort(this.checksum);\n  if (payloadData != null)   bb.put(payloadData);\n  if (this.parent != null && this.parent instanceof IPv4)   ((IPv4)this.parent).setProtocol(IpProtocol.UDP);\n  if (this.checksum == 0) {\n    bb.rewind();\n    int accumulation=0;\n    if (this.parent != null && this.parent instanceof IPv4) {\n      IPv4 ipv4=(IPv4)this.parent;\n      accumulation+=((ipv4.getSourceAddress().getInt() >> 16) & 0xffff) + (ipv4.getSourceAddress().getInt() & 0xffff);\n      accumulation+=((ipv4.getDestinationAddress().getInt() >> 16) & 0xffff) + (ipv4.getDestinationAddress().getInt() & 0xffff);\n      accumulation+=ipv4.getProtocol().getIpProtocolNumber() & 0xff;\n      accumulation+=this.length & 0xffff;\n    }\n    for (int i=0; i < this.length / 2; ++i) {\n      accumulation+=0xffff & bb.getShort();\n    }\n    if (this.length % 2 > 0) {\n      accumulation+=(bb.get() & 0xff) << 8;\n    }\n    accumulation=((accumulation >> 16) & 0xffff) + (accumulation & 0xffff);\n    this.checksum=(short)(~accumulation & 0xffff);\n    bb.putShort(6,this.checksum);\n  }\n  return data;\n}\n", "nl": "Serializes the packet. Will compute and set the following fields if they are set to specific values at the time serialize is called: -checksum : 0 -length : 0"}
{"code": "public String toString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(toString(getClass()));\n  buffer.append(\"[UseDefault=\");\n  buffer.append(isUseDefault());\n  buffer.append(\", UseLocaleFormat=\");\n  buffer.append(useLocaleFormat);\n  if (pattern != null) {\n    buffer.append(\", Pattern=\");\n    buffer.append(pattern);\n  }\n  if (locale != null) {\n    buffer.append(\", Locale=\");\n    buffer.append(locale);\n  }\n  buffer.append(']');\n  return buffer.toString();\n}\n", "nl": "Provide a String representation of this number converter."}
{"code": "public static boolean isCompleted(Operation op){\n  return (null == op || null == op.getCompletion());\n}\n", "nl": "Returns true if operation still needs to be completed."}
{"code": "public void firePropertyChange(java.beans.PropertyChangeEvent propertyChangeEvent){\n  if (propertyChangeEvent == null) {\n    String msg=Logging.getMessage(\"nullValue.PropertyChangeEventIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  this.getChangeSupport().firePropertyChange(propertyChangeEvent);\n}\n", "nl": "Fire a property change event."}
{"code": "void add(RuleRec rec){\n  list.add(rec);\n}\n", "nl": "Added a RuleRec to the Rule record list."}
{"code": "protected void pack(){\n  Component component=getComponent();\n  if (component instanceof Window) {\n    ((Window)component).pack();\n  }\n}\n", "nl": "Causes the <code>Popup</code> to be sized to fit the preferred size of the <code>Component</code> it contains."}
{"code": "public ManagerServiceImpl(final GenericDAO<Manager,Long> genericDao){\n  super(genericDao);\n}\n", "nl": "Create service to manage the administrative of web shop"}
{"code": "private void updateProgress(int progress){\n  if (myHost != null && progress != previousProgress) {\n    myHost.updateProgress(progress);\n  }\n  previousProgress=progress;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public Tradingdays findTradingdaysByDateRange(final ZonedDateTime startDate,final ZonedDateTime endDate) throws PersistentModelException {\n  return m_tradingdayHome.findTradingdaysByDateRange(startDate,endDate);\n}\n", "nl": "Method findTradingdaysByDateRange."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:43.033 -0500\",hash_original_method=\"ECD2E5721BC163A0054AA741832C3882\",hash_generated_method=\"14A5AF88A2506E99D7DB3789702FBF82\") private static void modifyFieldIfSet(final Field field,final TypedProperties properties,final String propertyName){\n  if (field.getType() == java.lang.String.class) {\n    int stringInfo=properties.getStringInfo(propertyName);\nswitch (stringInfo) {\ncase TypedProperties.STRING_SET:\n      break;\ncase TypedProperties.STRING_NULL:\n    try {\n      field.set(null,null);\n    }\n catch (    IllegalAccessException ex) {\n      throw new IllegalArgumentException(\"Cannot set field for \" + propertyName,ex);\n    }\n  return;\ncase TypedProperties.STRING_NOT_SET:\nreturn;\ncase TypedProperties.STRING_TYPE_MISMATCH:\nthrow new IllegalArgumentException(\"Type of \" + propertyName + \" \"+ \" does not match field type (\"+ field.getType()+ \")\");\ndefault :\nthrow new IllegalStateException(\"Unexpected getStringInfo(\" + propertyName + \") return value \"+ stringInfo);\n}\n}\nObject value=properties.get(propertyName);\nif (value != null) {\nif (!fieldTypeMatches(field,value.getClass())) {\nthrow new IllegalArgumentException(\"Type of \" + propertyName + \" (\"+ value.getClass()+ \") \"+ \" does not match field type (\"+ field.getType()+ \")\");\n}\ntry {\nfield.set(null,value);\n}\n catch (IllegalAccessException ex) {\nthrow new IllegalArgumentException(\"Cannot set field for \" + propertyName,ex);\n}\n}\n}\n", "nl": "Looks up the property that corresponds to the field, and sets the field's value if the types match."}
{"code": "public OptionsBean obtenerTiposInformesCombo(Entidad entidad) throws RPAdminException {\n  MultiEntityContextHolder.setEntity(entidad.getIdentificador());\n  OptionsBean options=new OptionsBean();\n  ResourceBundle rs=ResourceBundle.getBundle(\"ieci.tecdoc.sgm.rpadmin.manager.tipoInforme\");\n  Enumeration keys=rs.getKeys();\n  while (keys.hasMoreElements()) {\n    OptionBean option=new OptionBean();\n    String key=keys.nextElement().toString();\n    String value=rs.getString(key);\n    option.setCodigo(key);\n    option.setDescripcion(value);\n    options.add(option);\n  }\n  return options;\n}\n", "nl": "Obtiene los tipos de perfiles de informes y los devuelve en un bean"}
{"code": "public IteratorSpliterator(Iterator<? extends T> iterator,long size,int characteristics){\n  this.collection=null;\n  this.it=iterator;\n  this.est=size;\n  this.characteristics=(characteristics & Spliterator.CONCURRENT) == 0 ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED : characteristics;\n}\n", "nl": "Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics."}
{"code": "public KMLPolygonImpl(KMLTraversalContext tc,KMLPlacemark placemark,KMLAbstractGeometry geom){\n  if (tc == null) {\n    String msg=Logging.getMessage(\"nullValue.TraversalContextIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  if (placemark == null) {\n    String msg=Logging.getMessage(\"nullValue.ParentIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  this.parent=placemark;\n  KMLPolygon polygon=(KMLPolygon)geom;\n  this.setAltitudeMode(WorldWind.CLAMP_TO_GROUND);\n  String altMode=polygon.getAltitudeMode();\n  if (!WWUtil.isEmpty(altMode)) {\n    if (\"relativeToGround\".equals(altMode))     this.setAltitudeMode(WorldWind.RELATIVE_TO_GROUND);\n else     if (\"absolute\".equals(altMode))     this.setAltitudeMode(WorldWind.ABSOLUTE);\n  }\n  KMLLinearRing outerBoundary=polygon.getOuterBoundary();\n  if (outerBoundary != null) {\n    Position.PositionList coords=outerBoundary.getCoordinates();\n    if (coords != null && coords.list != null)     this.setOuterBoundary(outerBoundary.getCoordinates().list);\n  }\n  Iterable<? extends KMLLinearRing> innerBoundaries=polygon.getInnerBoundaries();\n  if (innerBoundaries != null) {\n    for (    KMLLinearRing ring : innerBoundaries) {\n      Position.PositionList coords=ring.getCoordinates();\n      if (coords != null && coords.list != null)       this.addInnerBoundary(ring.getCoordinates().list);\n    }\n  }\n  if (placemark.getName() != null)   this.setValue(AVKey.DISPLAY_NAME,placemark.getName());\n  if (placemark.getDescription() != null)   this.setValue(AVKey.DESCRIPTION,placemark.getDescription());\n  if (placemark.getSnippetText() != null)   this.setValue(AVKey.SHORT_DESCRIPTION,placemark.getSnippetText());\n  this.setValue(AVKey.CONTEXT,this.parent);\n}\n", "nl": "Create an instance."}
{"code": "private void fillBuf() throws IOException {\n  int result=in.read(buf,0,buf.length);\n  if (result == -1) {\n    throw new EOFException();\n  }\n  pos=0;\n  end=result;\n}\n", "nl": "Reads new input data into the buffer. Call only with pos == end or end == -1, depending on the desired outcome if the function throws."}
{"code": "public SpecialInvokeExpr newSpecialInvokeExpr(Local base,SootMethodRef method,Value arg){\n  return new JSpecialInvokeExpr(base,method,Arrays.asList(new Value[]{arg}));\n}\n", "nl": "Constructs a NewSpecialInvokeExpr(Local base, SootMethodRef method, List of Immediate) grammar chunk."}
{"code": "public Builder(String headVar){\n  this.headVar=headVar;\n  table=new HashMap<Assignment,CategoricalTable.Builder>();\n}\n", "nl": "Constructs a new conditional categorical table with the given variable name."}
{"code": "@Override public int removeAllByHostHashes(final Set<String> hosthashes){\n  for (  String h : hosthashes) {\n    if (this.hostHash.equals(h)) {\n      int s=this.size();\n      this.clear();\n      return s;\n    }\n  }\n  return 0;\n}\n", "nl": "delete all urls which are stored for given host hashes"}
{"code": "public RESTLoginCommandImpl(final ShoppingCartCommandRegistry registry,final CustomerService customerService,final ShopService shopService,final PriceService priceService,final PricingPolicyProvider pricingPolicyProvider,final ProductService productService,final CartRepository cartRepository){\n  super(registry,customerService,shopService,priceService,pricingPolicyProvider,productService);\n  this.cartRepository=cartRepository;\n}\n", "nl": "Construct command."}
{"code": "public File configFile(String path){\n  return dataFile(CONFIG_DIR + \"/\" + path);\n}\n", "nl": "Constructs an absolute path to a file within the config folder of the data dir."}
{"code": "public ImageCacheParams(File rootDirectory,int maxCacheSizeInBytes){\n  diskCacheDir=rootDirectory;\n  memCacheSize=maxCacheSizeInBytes;\n}\n", "nl": "Create a set of image cache parameters that can be provided to"}
{"code": "public boolean shouldRemoteUiBeVisible(int state,int idleReason) throws TransientNetworkDisconnectionException, NoConnectionException {\nswitch (state) {\ncase MediaStatus.PLAYER_STATE_PLAYING:\ncase MediaStatus.PLAYER_STATE_PAUSED:\ncase MediaStatus.PLAYER_STATE_BUFFERING:\n    return true;\ncase MediaStatus.PLAYER_STATE_IDLE:\n  if (!isRemoteStreamLive()) {\n    return false;\n  }\nreturn idleReason == MediaStatus.IDLE_REASON_CANCELED;\ndefault :\nbreak;\n}\nreturn false;\n}\n", "nl": "A helper method to determine if, given a player state and an idle reason (if the state is idle) will warrant having a UI for remote presentation of the remote content."}
{"code": "@Ignore public void testIngestTemplateThreaded(){\n  File temp=null;\n  try {\n    temp=File.createTempFile(\"testFile2\",\"csv\");\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n    fail();\n  }\n  ByteBuffer data=sourceBuffer.asReadOnlyBuffer();\n  Pipe linesRing=new Pipe(linesRingConfig);\n  Pipe fieldsRing=new Pipe(fieldsRingConfig);\n  Pipe flatFileRing=new Pipe(flatFileRingConfig);\n  GraphManager gm=new GraphManager();\n  LineSplitterByteBufferStage lineSplitter=new LineSplitterByteBufferStage(gm,data,linesRing);\n  FieldSplitterStage fieldSplitter=new FieldSplitterStage(gm,linesRing,fieldsRing);\n  MetaMessagesToCSVStage csvBuilderStage=new MetaMessagesToCSVStage(gm,fieldsRing,flatFileRing);\n  FileChannel outputFileChannel;\n  try {\n    outputFileChannel=new RandomAccessFile(temp,\"rws\").getChannel();\n  }\n catch (  FileNotFoundException e1) {\n    throw new RuntimeException(e1);\n  }\n  FileWriteStage fileWriter=new FileWriteStage(gm,flatFileRing,outputFileChannel);\n  StageScheduler ss=new ThreadPerStageScheduler(gm);\n  ss.startup();\n  boolean ok=ss.awaitTermination(10,TimeUnit.SECONDS);\n  assertEquals(\"File size does not match:\" + temp.getAbsolutePath(),sourceBuffer.remaining(),temp.length());\n  byte[] expected=new byte[sourceBuffer.remaining()];\n  byte[] rebuilt=new byte[sourceBuffer.remaining()];\n  try {\n    InputStream testStream=SmallCSVParseTest.class.getResourceAsStream(TEST_FILE);\n    testStream.read(expected);\n    testStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail();\n  }\n  try {\n    InputStream builtStream=new FileInputStream(temp);\n    builtStream.read(rebuilt);\n    builtStream.close();\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    fail();\n  }\n}\n", "nl": "This is the example you are looking for TODO: AAA, this test is broken and needs to be fixed ASAP, part of the stage migration."}
{"code": "public T caseTClass(TClass object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>TClass</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public static JSONArray toJSONArray(JSONTokener x) throws JSONException {\n  return toJSONArray(rowToJSONArray(x),x);\n}\n", "nl": "Produce a JSONArray of JSONObjects from a comma delimited text string, using the first row as a source of names."}
{"code": "public boolean connect(){\n  try {\n    mService.clientConnect(mClientIf,mDevice.getAddress(),false);\n    return true;\n  }\n catch (  RemoteException e) {\n    Log.e(TAG,\"\",e);\n    return false;\n  }\n}\n", "nl": "Connect back to remote device. <p>This method is used to re-connect to a remote device after the connection has been dropped. If the device is not in range, the re-connection will be triggered once the device is back in range."}
{"code": "public static boolean injectIterationCount(double iterations,boolean condition){\n  return injectBranchProbability(1. - 1. / iterations,condition);\n}\n", "nl": "Injects an average iteration count of a loop into the probability information of a loop exit condition. The iteration count specifies how often the condition is checked, i.e. in for and while loops it is one more than the body iteration count, and in do-while loops it is equal to the body iteration count. The iteration count must be >= 1.0. Example usage (it specifies that the expected iteration count of the loop condition is 500, so the iteration count of the loop body is 499): <code> for (int i = 0; injectIterationCount(500, i < array.length); i++) { // ... } </code>"}
{"code": "public FilterExprIterator(){\n  super(null);\n}\n", "nl": "Create a FilterExprIterator object."}
{"code": "private static String createLibraryPrefix(){\n  OSType osType=calculateOS();\nswitch (osType) {\ncase ANDROID:\ncase APPLE:\ncase LINUX:\ncase SUN:\n    return \"lib\";\ncase WINDOWS:\n  return \"\";\ndefault :\nbreak;\n}\nreturn \"\";\n}\n", "nl": "Returns the prefix for dynamically linked libraries on the current OS. That is, returns <code>\"lib\"</code> on Apple,  Linux and Sun, and the empty String on Windows."}
{"code": "public static void showException(final Throwable exception){\n  final Dialog dialog=new Dialog();\n  dialog.setTitle(ResourceManager.getLabel(ResourceManager.EXCEPTION));\n  final String msg=exception.getMessage();\n  final String className=exception.getClass().getName();\n  final boolean noMessage=msg == null || msg.trim().length() == 0;\n  dialog.getMessageArea().setTitle(noMessage ? className : msg).setText(noMessage ? \"\" : className).setIcon(Display.getCurrent().getSystemImage(SWT.ICON_ERROR)).setException(exception);\n  dialog.getFooterArea().setExpanded(true);\n  dialog.setButtonType(OpalDialogType.CLOSE);\n  dialog.show();\n}\n", "nl": "Display a dialog box with an exception"}
{"code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  journalWriter.flush();\n}\n", "nl": "Force buffered operations to the filesystem."}
{"code": "public Graph search(){\n  this.logger.log(\"info\",\"Starting Fast Adjacency Search.\");\n  Graph graph=new EdgeListGraphSingleConnections(test.getVariables());\n  sepsets=new SepsetMap();\n  sepsets.setReturnEmptyIfNotSet(true);\n  int _depth=depth;\n  if (_depth == -1) {\n    _depth=1000;\n  }\n  Map<Node,Set<Node>> adjacencies=new ConcurrentSkipListMap<>();\n  List<Node> nodes=graph.getNodes();\n  for (  Node node : nodes) {\n    adjacencies.put(node,new HashSet<Node>());\n  }\n  double alpha=test.getAlpha();\n  for (double _alpha=0.9; _alpha > alpha; _alpha/=2.0) {\n    System.out.println(\"_alpha = \" + _alpha);\n    searchAtDepth0(nodes,test,adjacencies);\n    test.setAlpha(_alpha);\n    boolean didIt=false;\n    for (int d=didIt ? 1 : 0; d <= _depth; d++) {\n      boolean more;\n      more=searchAtDepth(nodes,test,adjacencies,d);\n      if (!more) {\n        break;\n      }\n    }\n  }\n  test.setAlpha(alpha);\n  if (verbose) {\n    out.println(\"Finished with search, constructing Graph...\");\n  }\n  for (int i=0; i < nodes.size(); i++) {\n    for (int j=i + 1; j < nodes.size(); j++) {\n      Node x=nodes.get(i);\n      Node y=nodes.get(j);\n      if (adjacencies.get(x).contains(y)) {\n        graph.addUndirectedEdge(x,y);\n      }\n    }\n  }\n  if (verbose) {\n    out.println(\"Finished constructing Graph.\");\n  }\n  if (verbose) {\n    this.logger.log(\"info\",\"Finishing Fast Adjacency Search.\");\n  }\n  return graph;\n}\n", "nl": "Discovers all adjacencies in data.  The procedure is to remove edges in the graph which connect pairs of variables which are independent conditional on some other set of variables in the graph (the \"sepset\"). These are removed in tiers.  First, edges which are independent conditional on zero other variables are removed, then edges which are independent conditional on one other variable are removed, then two, then three, and so on, until no more edges can be removed from the graph.  The edges which remain in the graph after this procedure are the adjacencies in the data."}
{"code": "public final ADFContext push(ADFContext obj){\n  if (onStack == stack.length) {\n    ADFContext[] newstack=new ADFContext[stack.length * 2];\n    System.arraycopy(stack,0,newstack,0,stack.length);\n    stack=newstack;\n  }\n  stack[onStack++]=obj;\n  return obj;\n}\n", "nl": "Pushes an ADFContext onto the main stack.  The best way to get an ADFContext to push onto the stack is with get(). Returns obj."}
{"code": "void modCenter(int modulus){\n  mod(modulus);\n  for (int j=0; j < coeffs.length; j++) {\n    while (coeffs[j] < modulus / 2) {\n      coeffs[j]+=modulus;\n    }\n    while (coeffs[j] >= modulus / 2) {\n      coeffs[j]-=modulus;\n    }\n  }\n}\n", "nl": "Reduces all coefficients to the interval [-modulus/2, modulus/2)"}
{"code": "public Gateway createGateway(){\n  GatewayImpl gateway=new GatewayImpl();\n  return gateway;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void printStatusMessages(AbstractTestSuiteChromosome<? extends ExecutableChromosome> suite,int coveredBranches,double fitness){\n  if (coveredBranches > maxCoveredBranches) {\n    maxCoveredBranches=coveredBranches;\n    logger.info(\"(Branches) Best individual covers \" + coveredBranches + \"/\"+ (totalBranches * 2)+ \" branches\");\n    logger.info(\"Fitness: \" + fitness + \", size: \"+ suite.size()+ \", length: \"+ suite.totalLengthOfTestCases());\n  }\n  if (fitness < bestFitness) {\n    logger.info(\"(Fitness) Best individual covers \" + coveredBranches + \"/\"+ (totalBranches * 2)+ \" branches\");\n    bestFitness=fitness;\n    logger.info(\"Fitness: \" + fitness + \", size: \"+ suite.size()+ \", length: \"+ suite.totalLengthOfTestCases());\n  }\n}\n", "nl": "Some useful debug information"}
{"code": "public boolean isBuilt(){\n  return _built;\n}\n", "nl": "Used to determine if this train has been built."}
{"code": "public ConditionalRoute createConditionalRoute(){\n  ConditionalRouteImpl conditionalRoute=new ConditionalRouteImpl();\n  return conditionalRoute;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public String toString(){\n  return \"TerminalFactory for type \" + type + \" from provider \"+ provider.getName();\n}\n", "nl": "Returns a string representation of this TerminalFactory."}
{"code": "public UnitName createUnitName(){\n  UnitNameImpl unitName=new UnitNameImpl();\n  return unitName;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected String doIt() throws Exception {\n  log.info(\"M_Product_ID=\" + p_M_Product_ID);\n  if (p_M_Product_ID == 0)   throw new AdempiereUserError(\"@NotFound@: @M_Product_ID@ = \" + p_M_Product_ID);\n  MProduct product=MProduct.get(getCtx(),p_M_Product_ID);\n  if (product.get_ID() != p_M_Product_ID)   throw new AdempiereUserError(\"@NotFound@: @M_Product_ID@ = \" + p_M_Product_ID);\n  if (MCostDetail.processProduct(product,get_TrxName()))   return \"@OK@\";\n  return \"@Error@\";\n}\n", "nl": "Perform process."}
{"code": "void visitSubroutine(final Label JSR,final long id,final int nbSubroutines){\n  Label stack=this;\n  while (stack != null) {\n    Label l=stack;\n    stack=l.next;\n    l.next=null;\n    if (JSR != null) {\n      if ((l.status & VISITED2) != 0) {\n        continue;\n      }\n      l.status|=VISITED2;\n      if ((l.status & RET) != 0) {\n        if (!l.inSameSubroutine(JSR)) {\n          Edge e=new Edge();\n          e.info=l.inputStackTop;\n          e.successor=JSR.successors.successor;\n          e.next=l.successors;\n          l.successors=e;\n        }\n      }\n    }\n else {\n      if (l.inSubroutine(id)) {\n        continue;\n      }\n      l.addToSubroutine(id,nbSubroutines);\n    }\n    Edge e=l.successors;\n    while (e != null) {\n      if ((l.status & Label.JSR) == 0 || e != l.successors.next) {\n        if (e.successor.next == null) {\n          e.successor.next=stack;\n          stack=e.successor;\n        }\n      }\n      e=e.next;\n    }\n  }\n}\n", "nl": "Finds the basic blocks that belong to a given subroutine, and marks these blocks as belonging to this subroutine. This method follows the control flow graph to find all the blocks that are reachable from the current block WITHOUT following any JSR target."}
{"code": "public Complex cos(){\n  return new Complex(Math.cos(re) * Math.cosh(im),-Math.sin(re) * Math.sinh(im));\n}\n", "nl": "Returns the complex cosine of this complex number."}
{"code": "public void close() throws SQLException {\n  this.closed=true;\n  for (  Connection c : this.serverConnections.values()) {\n    try {\n      c.close();\n    }\n catch (    SQLException ex) {\n    }\n  }\n}\n", "nl": "Close this connection proxy which entails closing all open connections to MySQL servers."}
{"code": "public String plus(Object value){\n  return this.theString + value;\n}\n", "nl": "Fairly simple method used for the plus (+) base concatenation in Groovy."}
{"code": "public String showAttributes(){\n  DataSortedTableModel model;\n  ListSelectorDialog dialog;\n  int i;\n  JList list;\n  String name;\n  int result;\n  if (!isPanelSelected()) {\n    return null;\n  }\n  list=new JList(getCurrentPanel().getAttributes());\n  dialog=new ListSelectorDialog(getParentFrame(),list);\n  result=dialog.showDialog();\n  if (result == ListSelectorDialog.APPROVE_OPTION) {\n    model=(DataSortedTableModel)getCurrentPanel().getTable().getModel();\n    name=list.getSelectedValue().toString();\n    i=model.getAttributeColumn(name);\n    JTableHelper.scrollToVisible(getCurrentPanel().getTable(),0,i);\n    getCurrentPanel().getTable().setSelectedColumn(i);\n    return name;\n  }\n else {\n    return null;\n  }\n}\n", "nl": "displays all the attributes, returns the selected item or NULL if canceled"}
{"code": "@Override public void mouseReleased(MouseEvent event){\n  if (event.getSource() == getComponentDecreaseSpinnerButton()) {\n    decreaseTimer.stop();\n  }\n else {\n    increaseTimer.stop();\n  }\n}\n", "nl": "mouseReleased, This will be called when the spinner button is released."}
{"code": "private static String thresholdsToString(String[] thresholdArray){\n  String result=null;\n  if (thresholdArray.length > 0) {\n    result=thresholdArray[0];\n    for (int i=1; i < thresholdArray.length; i++) {\n      result+=\"; \";\n      result+=thresholdArray[i];\n    }\n  }\n  return result;\n}\n", "nl": "Converts a given array of strings into a single string with the array elements  separated by a semi-colon."}
{"code": "public boolean willOpenInForeground(TabLaunchType type,boolean isNewTabIncognito){\n  if (type == TabLaunchType.FROM_RESTORE)   return false;\n  return type != TabLaunchType.FROM_LONGPRESS_BACKGROUND || (!mTabModelSelector.isIncognitoSelected() && isNewTabIncognito);\n}\n", "nl": "Determine if a launch type will result in the tab being opened in the foreground."}
{"code": "@Override public void messageSent(final NextFilter nextFilter,final IoSession session,final WriteRequest writeRequest) throws Exception {\n  if (writeRequest.getMessage() != null && writeRequest.getMessage() instanceof ProxyHandshakeIoBuffer) {\n    return;\n  }\n  nextFilter.messageSent(session,writeRequest);\n}\n", "nl": "Filter handshake related messages from reaching the messageSent callbacks of  downstream filters."}
{"code": "protected void writeTableComment(Table table,StringBuilder ddl){\n  printComment(\"-----------------------------------------------------------------------\",ddl);\n  printComment(getFullyQualifiedTableNameShorten(table),ddl);\n  printComment(\"-----------------------------------------------------------------------\",ddl);\n  println(ddl);\n}\n", "nl": "Outputs a comment for the table."}
{"code": "@DSComment(\"constructor\") @DSSafe(DSCat.SAFE_OTHERS) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:23.158 -0500\",hash_original_method=\"3CB703BA4BBEFDD58F8198A538C651FA\",hash_generated_method=\"CF855BD0B8B8C8AFFCD8B68DE31A2318\") public SparseIntArray(){\n  this(10);\n}\n", "nl": "Creates a new SparseIntArray containing no mappings."}
{"code": "public void clearUnused(){\n  Log log=getLog();\n  try {\n    if (session == null)     session=new StorageScopeEngine(factory,log,new StorageScopeCleaner[]{new FileStorageScopeCleaner(Scope.SCOPE_SESSION,null),new DatasourceStorageScopeCleaner(Scope.SCOPE_SESSION,null)});\n    if (client == null)     client=new StorageScopeEngine(factory,log,new StorageScopeCleaner[]{new FileStorageScopeCleaner(Scope.SCOPE_CLIENT,null),new DatasourceStorageScopeCleaner(Scope.SCOPE_CLIENT,null)});\n    storeUnusedStorageScope(factory,Scope.SCOPE_CLIENT);\n    storeUnusedStorageScope(factory,Scope.SCOPE_SESSION);\n    clearUnusedMemoryScope(factory,Scope.SCOPE_CLIENT);\n    clearUnusedMemoryScope(factory,Scope.SCOPE_SESSION);\n    session.clean();\n    client.clean();\n    clearUnusedApplications(factory);\n  }\n catch (  Throwable t) {\n    error(t);\n  }\n}\n", "nl": "remove all unused scope objects"}
{"code": "void seed(){\n  for (int j=0; j <= sentLen - 1; j++) {\n    if (pGrammar.hasRuleForSpan(j,j,input.distance(j,j))) {\n      if (null == pGrammar.getTrieRoot()) {\n        throw new RuntimeException(\"trie root is null\");\n      }\n      addDotItem(pGrammar.getTrieRoot(),j,j,null,null,new SourcePath());\n    }\n  }\n}\n", "nl": "Add initial dot items: dot-items pointer to the root of the grammar trie."}
{"code": "@SuppressWarnings(\"unchecked\") public static <T>Matcher<T> any(){\n  return Any.ANY;\n}\n", "nl": "Returns a wildcard matcher."}
{"code": "public static void scaleM(double[] m,int mOffset,double x,double y,double z){\n  for (int i=0; i < 4; i++) {\n    int mi=mOffset + i;\n    m[mi]*=x;\n    m[4 + mi]*=y;\n    m[8 + mi]*=z;\n  }\n}\n", "nl": "Scales matrix m in place by sx, sy, and sz"}
{"code": "private static byte[] readClass(final InputStream is) throws IOException {\n  if (is == null) {\n    throw new IOException(\"Class not found\");\n  }\n  byte[] b=new byte[is.available()];\n  int len=0;\n  while (true) {\n    int n=is.read(b,len,b.length - len);\n    if (n == -1) {\n      if (len < b.length) {\n        byte[] c=new byte[len];\n        System.arraycopy(b,0,c,0,len);\n        b=c;\n      }\n      return b;\n    }\n    len+=n;\n    if (len == b.length) {\n      int last=is.read();\n      if (last < 0) {\n        return b;\n      }\n      byte[] c=new byte[b.length + 1000];\n      System.arraycopy(b,0,c,0,len);\n      c[len++]=(byte)last;\n      b=c;\n    }\n  }\n}\n", "nl": "Reads the bytecode of a class."}
{"code": "public GridCacheVersion mappedVersion(int idx){\n  return mappedVers == null ? null : mappedVers[idx];\n}\n", "nl": "Returns DHT candidate version for acquired near lock on DHT node."}
{"code": "private String addStyleName(String style){\n  if (styleNameMapping == null) {\n    return style;\n  }\n  StringBuilder sb=null;\n  for (int counter=style.length() - 1; counter >= 0; counter--) {\n    if (!isValidCharacter(style.charAt(counter))) {\n      if (sb == null) {\n        sb=new StringBuilder(style);\n      }\n      sb.setCharAt(counter,'a');\n    }\n  }\n  String mappedName=(sb != null) ? sb.toString() : style;\n  while (styleNameMapping.get(mappedName) != null) {\n    mappedName=mappedName + 'x';\n  }\n  styleNameMapping.put(style,mappedName);\n  return mappedName;\n}\n", "nl": "Adds the style named <code>style</code> to the style mapping. This returns the name that should be used when outputting. CSS does not allow the full Unicode set to be used as a style name."}
{"code": "private Organization validateForOnBehalfUserCreation(String organizationId,String password,PlatformUser currentUser) throws ObjectNotFoundException, OperationNotPermittedException {\n  ArgumentValidator.notNull(\"organizationId\",organizationId);\n  ArgumentValidator.notNull(\"password\",password);\n  Organization customer=new Organization();\n  customer.setOrganizationId(organizationId);\n  customer=(Organization)dm.getReferenceByBusinessKey(customer);\n  if (!currentUser.getOrganization().isActingOnBehalf(customer)) {\n    OperationNotPermittedException onpe=new OperationNotPermittedException();\n    logger.logWarn(Log4jLogger.SYSTEM_LOG,onpe,LogMessageIdentifier.WARN_USER_CREATE_CUSTOMER_FAILED,currentUser.getUserId(),currentUser.getOrganization().getOrganizationId(),customer.getOrganizationId());\n    throw onpe;\n  }\n  return customer;\n}\n", "nl": "Validates that the preconditions for the creation of a on-behalf user are met."}
{"code": "public long nextLong(){\n  return org.evosuite.runtime.Random.nextLong();\n}\n", "nl": "Replacement function for nextLong"}
{"code": "public static boolean deleteFileWithBackup(Path file,String datasource){\n  String fn=file.toAbsolutePath().toString();\n  if (!fn.startsWith(datasource)) {\n    LOGGER.warn(\"could not delete file '\" + fn + \"': datasource '\"+ datasource+ \"' does not match\");\n    return false;\n  }\n  if (Files.isDirectory(file)) {\n    LOGGER.warn(\"could not delete file '\" + fn + \"': file is a directory!\");\n    return false;\n  }\n  fn=fn.replace(datasource,datasource + FileSystems.getDefault().getSeparator() + Constants.BACKUP_FOLDER);\n  try {\n    Path backup=Paths.get(fn);\n    if (!Files.exists(backup.getParent())) {\n      Files.createDirectories(backup.getParent());\n    }\n    Files.deleteIfExists(backup);\n    return moveFileSafe(file,backup);\n  }\n catch (  IOException e) {\n    LOGGER.warn(\"Could not delete file: \" + e.getMessage());\n    return false;\n  }\n}\n", "nl": "<b>PHYSICALLY</b> deletes a file by moving it to datasource backup folder<br> DS\\.backup\\&lt;filename&gt;<br> maintaining its originating directory"}
{"code": "public static byte[] internalize(Name name){\n  return internalize(name.getByteArray(),name.getByteOffset(),name.getByteLength());\n}\n", "nl": "Return internal representation of given name, converting '/' to '.'."}
{"code": "@Override public String toString(){\n  if (length == 0) {\n    return \"FacetLabel: []\";\n  }\n  String[] parts=new String[length];\n  System.arraycopy(components,0,parts,0,length);\n  return \"FacetLabel: \" + Arrays.toString(parts);\n}\n", "nl": "Returns a string representation of the path."}
{"code": "protected void init(){\n  if (initialized)   return;\n  Map<String,Class<? extends FXGNode>> elementNodes=new HashMap<String,Class<? extends FXGNode>>(DEFAULT_FXG_1_0_NODES.size() + 4);\n  elementNodes.putAll(DEFAULT_FXG_1_0_NODES);\n  elementNodesByURI=new HashMap<String,Map<String,Class<? extends FXGNode>>>(1);\n  elementNodesByURI.put(FXG_NAMESPACE,elementNodes);\n  HashSet<String> skippedElements=new HashSet<String>(1);\n  skippedElements.add(FXG_PRIVATE_ELEMENT);\n  skippedElementsByURI=new HashMap<String,Set<String>>(1);\n  skippedElementsByURI.put(FXG_NAMESPACE,skippedElements);\n  initialized=true;\n}\n", "nl": "initializes the version handler with FXG 2.0 specific information"}
{"code": "public final double calculateTreeLogLikelihood(Tree tree){\n  int[] n=new int[size];\n  int nTips=tree.getExternalNodeCount();\n  preCalculation(tree);\n  int index=size - 1;\n  double t=t(index);\n  double g=g(index,x0,t);\n  double logP=Math.log(g);\n  for (int i=0; i < tree.getInternalNodeCount(); i++) {\n    double x=tree.getNodeHeight(tree.getInternalNode(i));\n    index=index(x);\n    double contrib=Math.log(birth(birthChanges ? index : 0) * g(index,x,t(index)));\n    logP+=contrib;\n    t=t(index);\n    g=g(index,x,t);\n  }\n  for (int i=0; i < nTips; i++) {\n    double y=tree.getNodeHeight(tree.getExternalNode(i));\n    index=index(y);\n    double contrib=Math.log(psi(samplingChanges ? index : 0)) - Math.log(g(index,y,t(index)));\n    ;\n    logP+=contrib;\n  }\n  for (int j=0; j < size - 1; j++) {\n    double contrib=0;\n    double time=t(j + 1);\n    n[j]=lineageCountAtTime(time,tree);\n    if (n[j] > 0) {\n      contrib+=n[j] * Math.log(g(j,time,t(j)));\n    }\n    logP+=contrib;\n  }\n  return logP;\n}\n", "nl": "Generic likelihood calculation"}
{"code": "public Boolean sismember(final byte[] key,final byte[] member){\n  checkIsInMulti();\n  client.sismember(key,member);\n  return client.getIntegerReply() == 1;\n}\n", "nl": "Return 1 if member is a member of the set stored at key, otherwise 0 is returned. <p> Time complexity O(1)"}
{"code": "Type attribTree(JCTree tree,Env<AttrContext> env,ResultInfo resultInfo){\n  Env<AttrContext> prevEnv=this.env;\n  ResultInfo prevResult=this.resultInfo;\n  try {\n    this.env=env;\n    this.resultInfo=resultInfo;\n    tree.accept(this);\n    if (tree == breakTree && resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n      throw new BreakAttr(copyEnv(env));\n    }\n    return result;\n  }\n catch (  CompletionFailure ex) {\n    tree.type=syms.errType;\n    return chk.completionError(tree.pos(),ex);\n  }\n finally {\n    this.env=prevEnv;\n    this.resultInfo=prevResult;\n  }\n}\n", "nl": "Visitor method: attribute a tree, catching any completion failure exceptions. Return the tree's type."}
{"code": "@Override public void initialize(){\n  super.initialize();\n  DefaultLookup.setDefaultLookup(new SynthDefaultLookup());\n  setStyleFactory(factory);\n  KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(_handler);\n}\n", "nl": "Called by UIManager when this look and feel is installed."}
{"code": "private float spacing(WrapMotionEvent event){\n  float x=event.getX(0) - event.getX(1);\n  float y=event.getY(0) - event.getY(1);\n  return FloatMath.sqrt(x * x + y * y);\n}\n", "nl": "Determine the space between the first two fingers"}
{"code": "protected void parseHeaderLine(String line) throws IOException {\n  int len=2;\n  int n=line.indexOf(\": \");\n  if (n == -1) {\n    len=1;\n    n=line.indexOf(':');\n    if (n == -1)     return;\n  }\n  String key=line.substring(0,n);\n  String val=line.substring(n + len);\n  List<String> list=headers.get(key);\n  if (list != null) {\n    list.add(val);\n  }\n else {\n    list=new ArrayList<String>();\n    list.add(val);\n    headers.put(key,list);\n  }\n}\n", "nl": "Reads one response header line and adds it to the headers map."}
{"code": "public MediaSize(float x,float y,int units){\n  super(x,y,units);\n  if (x > y) {\n    throw new IllegalArgumentException(\"X dimension > Y dimension\");\n  }\n  sizeVector.add(this);\n}\n", "nl": "Construct a new media size attribute from the given floating-point values."}
{"code": "public void fill(int rgb){\n  g.fill(rgb);\n}\n", "nl": "Set the fill to either a grayscale value or an ARGB int."}
{"code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (obj instanceof AnnotationMember) {\n    AnnotationMember that=(AnnotationMember)obj;\n    if (name.equals(that.name) && tag == that.tag) {\n      if (tag == ARRAY) {\n        return equalArrayValue(that.value);\n      }\n else       if (tag == ERROR) {\n        return false;\n      }\n else {\n        return value.equals(that.value);\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if the specified object represents equal element (equivalent name-value pair). <br> A special case is the contained Throwable value; it is considered transcendent so no other element would be equal."}
{"code": "private void init(final AttributeSet attrs,final int defStyleAttr,final int defStyleRes){\n  final TypedArray attributes=getContext().obtainStyledAttributes(attrs,R.styleable.DotIndicator,defStyleAttr,defStyleRes);\n  final int defaultSelectedDotDiameterPx=DimensionHelper.dpToPx(getContext(),DEFAULT_SELECTED_DOT_DIAMETER_DP);\n  final int defaultUnselectedDotDiameterPx=DimensionHelper.dpToPx(getContext(),DEFAULT_UNSELECTED_DOT_DIAMETER_DP);\n  final int defaultSpacingBetweenDotsPx=DimensionHelper.dpToPx(getContext(),DEFAULT_SPACING_BETWEEN_DOTS_DP);\n  numberOfDots=attributes.getInt(R.styleable.DotIndicator_numberOfDots,DEFAULT_NUMBER_OF_DOTS);\n  selectedDotIndex=attributes.getInt(R.styleable.DotIndicator_selectedDotIndex,DEFAULT_SELECTED_DOT_INDEX);\n  unselectedDotDiameterPx=attributes.getDimensionPixelSize(R.styleable.DotIndicator_unselectedDotDiameter,defaultUnselectedDotDiameterPx);\n  selectedDotDiameterPx=attributes.getDimensionPixelSize(R.styleable.DotIndicator_selectedDotDiameter,defaultSelectedDotDiameterPx);\n  unselectedDotColor=attributes.getColor(R.styleable.DotIndicator_unselectedDotColor,DEFAULT_UNSELECTED_DOT_COLOR);\n  selectedDotColor=attributes.getColor(R.styleable.DotIndicator_selectedDotColor,DEFAULT_SELECTED_DOT_COLOR);\n  spacingBetweenDotsPx=attributes.getDimensionPixelSize(R.styleable.DotIndicator_spacingBetweenDots,defaultSpacingBetweenDotsPx);\n  dotTransitionDuration=attributes.getDimensionPixelSize(R.styleable.DotIndicator_dotTransitionDuration,DEFAULT_DOT_TRANSITION_DURATION_MS);\n  attributes.recycle();\n  setLayoutParams(new LayoutParams(MATCH_PARENT,MATCH_PARENT));\n  setGravity(Gravity.CENTER);\n  reflectParametersInView();\n}\n", "nl": "Initialises the member variables of this DotIndicator and creates the UI. This method should only be invoked during construction."}
{"code": "public void block(){\n  lock.writeLock();\n}\n", "nl": "Blocks current thread till all activities left \"busy\" state and prevents them from further entering to \"busy\" state."}
{"code": "@Override public boolean appendTasks(ImageToProcess img,Set<TaskImageContainer> tasks){\n  int countImageRefs=numPropagatedImageReferences(img,tasks);\n  if (img != null) {\n    incrementSemaphoreReferenceCount(img,countImageRefs);\n  }\n  incrementTaskDone(tasks);\n  scheduleTasks(tasks);\n  return true;\n}\n", "nl": "Spawns dependent tasks from internal implementation of a set of tasks. If a dependent task does NOT require the image reference, it should be passed a null pointer as an image reference. In general, this method should be called after the task has completed its own computations, but before it has released its own image reference (via the releaseSemaphoreReference call)."}
{"code": "Account(){\n  id=0;\n  balance=0;\n  annualInterestRate=0;\n  dateCreated=new Date();\n}\n", "nl": "Creates a default account"}
{"code": "private void createLogoutEvent(Session session){\n  if (session.getUserToken() != null && session.getUserToken().length() == 0) {\n    GatheredEvent event=new GatheredEvent();\n    event.setActor(session.getPlatformUserId());\n    event.setType(EventType.PLATFORM_EVENT);\n    event.setEventId(PlatformEventIdentifier.USER_LOGOUT_FROM_SERVICE);\n    event.setOccurrenceTime(System.currentTimeMillis());\n    event.setSubscriptionTKey(session.getSubscriptionTKey().longValue());\n    try {\n      evtMgmt.recordEvent(event);\n    }\n catch (    DuplicateEventException e) {\n      logger.logDebug(e.getMessage());\n    }\n  }\n}\n", "nl": "Creates a logout event for the given session. A logout event is only generated in case the user token is not set anymore, what means that the user has really logged in earlier"}
{"code": "public void clear(){\n  ref.length=0;\n}\n", "nl": "Reset this builder to the empty state."}
{"code": "public static TupleSchema of(String name,TupleSlot... slots){\n  checkNotNull(name,\"name must not be null\");\n  checkNotNull(slots,\"slots must not be null\");\n  Map<String,Integer> slotLookup=IntStream.range(0,slots.length).collect(null,null,null);\n  checkArgument(slots.length == slotLookup.size(),\"Slot names are not unique\");\n  return new TupleSchema(name,slots,slotLookup);\n}\n", "nl": "Create a TupleSchema having the supplied TupleSlots."}
{"code": "boolean isPrivileged(){\n  return isPrivileged;\n}\n", "nl": "Returns true if this context is privileged."}
{"code": "public Iterable<FunctionImport> build(FactoryLookup lookup){\n  List<FunctionImport> builder=new ArrayList<>();\n  for (  FunctionImportImpl.Builder functionImportBuilder : functionImportBuilders) {\n    EntitySet entitySet=lookup.getEntitySet(functionImportBuilder.getEntitySetName());\n    Function function=lookup.getFunction(functionImportBuilder.getFunctionName());\n    if (entitySet == null && function.isBound()) {\n      throw new IllegalArgumentException(\"Could not find EntitySet with name: \" + functionImportBuilder.getEntitySetName());\n    }\n    functionImportBuilder.setEntitySet(entitySet);\n    functionImportBuilder.setFunction(function);\n    builder.add(functionImportBuilder.build());\n  }\n  return Collections.unmodifiableList(builder);\n}\n", "nl": "Returns built function imports using passed lookup for searching entity sets and functions for appropriate function import."}
{"code": "public boolean isEnabled(){\n  if (source instanceof Component) {\n    return ((Component)source).isEnabled();\n  }\n else   if (source instanceof MenuItem) {\n    return ((MenuItem)source).isEnabled();\n  }\n else {\n    return true;\n  }\n}\n", "nl": "Determine if the object is enabled."}
{"code": "@SuppressWarnings(\"unchecked\") public ClusterUpdateSettingsRequest transientSettings(Map source){\n  try {\n    XContentBuilder builder=XContentFactory.contentBuilder(XContentType.JSON);\n    builder.map(source);\n    transientSettings(builder.string());\n  }\n catch (  IOException e) {\n    throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\",e);\n  }\n  return this;\n}\n", "nl": "Sets the transient settings to be updated. They will not survive a full cluster restart"}
{"code": "private void layoutComponents(){\n  setLayout(new GridBagLayout());\n  setBorder(new CompoundBorder(new TitledBorder(DISPLAY_NAME),new EmptyBorder(6,6,6,6)));\n  setToolTipText(DESCRIPTION);\n  GridBagConstraints c=new GridBagConstraints();\n  c.anchor=GridBagConstraints.WEST;\n  c.fill=GridBagConstraints.HORIZONTAL;\n  c.gridheight=1;\n  c.gridwidth=GridBagConstraints.RELATIVE;\n  c.insets=LABEL_INSETS;\n  c.gridx=0;\n  c.gridy=0;\n  c.weightx=0.33f;\n  c.weighty=0;\n  add(new JLabel(\"Minimum value\"),c);\n  c.insets=FIELD_INSETS;\n  c.gridx=1;\n  c.weightx=0.66f;\n  add(minimumValue,c);\n  c.insets=LABEL_INSETS;\n  c.gridx=0;\n  c.gridy++;\n  c.weightx=0.33f;\n  add(new JLabel(\"Maximum value\"),c);\n  c.insets=FIELD_INSETS;\n  c.gridx=1;\n  c.weightx=0.66f;\n  add(maximumValue,c);\n  c.anchor=GridBagConstraints.NORTHWEST;\n  c.fill=GridBagConstraints.BOTH;\n  c.gridwidth=GridBagConstraints.REMAINDER;\n  c.insets=EMPTY_INSETS;\n  c.gridx=0;\n  c.gridy++;\n  c.weightx=1.0f;\n  c.weighty=1.0f;\n  add(Box.createGlue(),c);\n}\n", "nl": "Layout components."}
{"code": "public int addMultiNewarray(CtClass clazz,int[] dimensions){\n  int len=dimensions.length;\n  for (int i=0; i < len; ++i)   addIconst(dimensions[i]);\n  growStack(len);\n  return addMultiNewarray(clazz,len);\n}\n", "nl": "Appends MULTINEWARRAY."}
{"code": "public int transcribe(IPoint[] hull,int offset){\n  int idx=offset;\n  int sz=points.size();\n  for (int i=0; i < sz; i++) {\n    hull[idx++]=points.get(i);\n  }\n  return idx;\n}\n", "nl": "Fill array with points starting at given offset."}
{"code": "public void editTracks(){\n  List<Track> trackSelection=getRootController().getSelectedTracks();\n  if (!trackSelection.isEmpty()) {\n    boolean[] edit={true};\n    if (trackSelection.size() > 1) {\n      String alertHeader=\"Are you sure you want to edit multiple files?\";\n      Alert alert=createAlert(\"\",alertHeader,\"\",AlertType.CONFIRMATION);\n      Optional<ButtonType> result=alert.showAndWait();\n      result.ifPresent(null);\n    }\n    if (edit[0]) {\n      if (editStage == null) {\n        editStage=initStage(EDIT_LAYOUT,\"Edit\");\n        ((EditController)controllers.get(EDIT_LAYOUT)).setStage(editStage);\n      }\n      showStage(editStage);\n      LOG.debug(\"Showing edit stage\");\n    }\n  }\n}\n", "nl": "Shows the edit window. If the size of track selection is greater than 1, an <tt>Alert</tt> is opened asking for a confirmation of the user."}
{"code": "public ReadMemoryReply(final int packetId,final int errorCode,final IAddress address,final byte[] data){\n  super(packetId,errorCode);\n  if (success()) {\n    Preconditions.checkNotNull(address,\"IE01066: Address argument can not be null\");\n    Preconditions.checkNotNull(data,\"IE01067: Data argument can not be null\");\n  }\n else {\n    if (address != null) {\n      throw new IllegalArgumentException(\"IE01068: Address argument must be null\");\n    }\n    if (data != null) {\n      throw new IllegalArgumentException(\"IE01069: Data argument must be null\");\n    }\n  }\n  startAddress=address;\n  memoryData=data == null ? null : data.clone();\n}\n", "nl": "Creates a new Read Memory reply."}
{"code": "public static CompileStates instance(Context context){\n  CompileStates instance=context.get(compileStatesKey);\n  if (instance == null) {\n    instance=new CompileStates(context);\n  }\n  return instance;\n}\n", "nl": "Get the CompileStates instance for this context."}
{"code": "@Override public void stateChanged(ChangeEvent e){\n  if (e.getSource() == this.acceptCheckBox) {\n    this.acceptButton.setEnabled(this.acceptCheckBox.isSelected());\n  }\n}\n", "nl": "Listens to changes of the check box, enables the accept button when the check box is active."}
{"code": "public void addPoint(Vector3 point1,Vector3 controlPoint,Vector3 point2){\n  mPoint1=point1;\n  mControlPoint=controlPoint;\n  mPoint2=point2;\n}\n", "nl": "Add a Curve"}
{"code": "@Override public void sendErrorStatus(String errorStatus) throws IOException {\n  this.sendMessage(OPERATIONS + \": \" + errorStatus+ \"\\n\");\n}\n", "nl": "constructs an error message and sends it to the client. The error message will be <ul> <li> OPERATIONS: </li> <li> the error string </li> <li> \"\\n\" </li> </ul>"}
{"code": "private boolean selectID(int nodeID,boolean show){\n  if (m_root == null)   return false;\n  log.config(\"NodeID=\" + nodeID + \", Show=\"+ show+ \", root=\"+ m_root);\n  MTreeNode node=m_root.findNode(nodeID);\n  if (node != null) {\n    TreePath treePath=new TreePath(node.getPath());\n    log.config(\"Node=\" + node + \", Path=\"+ treePath.toString());\n    tree.setSelectionPath(treePath);\n    if (show) {\n      tree.makeVisible(treePath);\n      tree.scrollPathToVisible(treePath);\n    }\n    return true;\n  }\n  log.info(\"Node not found; ID=\" + nodeID);\n  return false;\n}\n", "nl": "Select ID in Tree"}
{"code": "public ProductTypeServiceImpl(final GenericDAO<ProductType,Long> productTypeDao){\n  super(productTypeDao);\n}\n", "nl": "Construct service."}
{"code": "public int size(){\n  return data.size();\n}\n", "nl": "Returns the number of observations used in this test."}
{"code": "@Override public void createUntamperedRequest(){\n  CollisionDJBX33A DJBX33A=new CollisionDJBX33A();\n  String untampered=UtilHashDoS.generateUntampered(DJBX33A,optionNumberAttributes.getValue(),optionUseNamespaces.isOn());\n  String soapMessage=this.getOptionTextAreaSoapMessage().getValue();\n  String soapMessageFinal=this.getOptionTextAreaSoapMessage().replacePlaceholderWithPayload(soapMessage,untampered);\n  Map<String,String> httpHeaderMap=new HashMap<String,String>();\n  for (  Map.Entry<String,String> entry : getOriginalRequestHeaderFields().entrySet()) {\n    httpHeaderMap.put(entry.getKey(),entry.getValue());\n  }\n  this.setUntamperedRequestObject(httpHeaderMap,getOriginalRequest().getEndpoint(),soapMessageFinal);\n}\n", "nl": "custom untampered request needed for prevention of false positives based on effect of XML Attribute Count Attack"}
{"code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  requestWindowFeature(Window.FEATURE_NO_TITLE);\n  setContentView(R.layout.main);\n  mHanler=new Handler();\n  setVolumeControlStream(AudioManager.STREAM_VOICE_CALL);\n  if (!Engine.getInstance().isStarted()) {\n    startActivityForResult(new Intent(this,ScreenSplash.class),Main.RC_SPLASH);\n    return;\n  }\n  Bundle bundle=savedInstanceState;\n  if (bundle == null) {\n    Intent intent=getIntent();\n    bundle=intent == null ? null : intent.getExtras();\n  }\n  if (bundle != null && bundle.getInt(\"action\",Main.ACTION_NONE) != Main.ACTION_NONE) {\n    handleAction(bundle);\n  }\n else   if (mScreenService != null) {\n    mScreenService.show(ScreenHome.class);\n  }\n}\n", "nl": "Called when the activity is first created."}
{"code": "public static String readInputStream(InputStream in) throws IOException {\n  BufferedReader br=new BufferedReader(new InputStreamReader(in));\n  char[] buffer=new char[INITIAL_READ_BUFFER_SIZE];\n  StringBuilder sb=new StringBuilder();\n  int readCount;\n  while ((readCount=br.read(buffer)) != -1) {\n    sb.append(buffer,0,readCount);\n  }\n  return sb.toString();\n}\n", "nl": "Read a string from an input stream."}
{"code": "@Override public ClusterSearchShardsRequest indices(String... indices){\n  if (indices == null) {\n    throw new IllegalArgumentException(\"indices must not be null\");\n  }\n else {\n    for (int i=0; i < indices.length; i++) {\n      if (indices[i] == null) {\n        throw new IllegalArgumentException(\"indices[\" + i + \"] must not be null\");\n      }\n    }\n  }\n  this.indices=indices;\n  return this;\n}\n", "nl": "Sets the indices the search will be executed on."}
{"code": "@Override protected DeLiCluEntry createRootEntry(){\n  return new DeLiCluDirectoryEntry(0,null,false,true);\n}\n", "nl": "Creates an entry representing the root node."}
{"code": "public final void close(){\n  try {\n    this.dataOut.flush();\n    if (this.trace) {\n      this.traceDataOut.flush();\n    }\n  }\n catch (  IOException ignore) {\n  }\n  try {\n    outStream.close();\n    if (this.trace) {\n      this.traceOutStream.close();\n    }\n  }\n catch (  IOException ex) {\n    throw new GemFireIOException(LocalizedStrings.StatArchiveWriter_COULD_NOT_CLOSE_STATARCHIVER_FILE.toLocalizedString(),ex);\n  }\n  if (getSampleCount() == 0) {\n    deleteFileIfPossible(new File(getArchiveName()));\n  }\n}\n", "nl": "Closes the statArchiver by flushing its data to disk a closing its output stream."}
{"code": "public static void createAllTables(SQLiteDatabase db,boolean ifNotExists){\n  RecommendEntityDao.createTable(db,ifNotExists);\n}\n", "nl": "Creates underlying database table using DAOs."}
{"code": "public ContentDispositionHeader createContentDispositionHeader(String contentDisposition) throws ParseException {\n  if (contentDisposition == null)   throw new NullPointerException(\"null arg contentDisposition\");\n  ContentDisposition c=new ContentDisposition();\n  c.setDispositionType(contentDisposition);\n  return c;\n}\n", "nl": "Creates a new ContentDispositionHeader based on the newly supplied contentDisposition value."}
{"code": "public int encodeBase64Partial(int bits,int outputBytes,byte[] buffer,int outPtr){\n  buffer[outPtr++]=_base64ToAsciiB[(bits >> 18) & 0x3F];\n  buffer[outPtr++]=_base64ToAsciiB[(bits >> 12) & 0x3F];\n  if (_usesPadding) {\n    byte pb=(byte)_paddingChar;\n    buffer[outPtr++]=(outputBytes == 2) ? _base64ToAsciiB[(bits >> 6) & 0x3F] : pb;\n    buffer[outPtr++]=pb;\n  }\n else {\n    if (outputBytes == 2) {\n      buffer[outPtr++]=_base64ToAsciiB[(bits >> 6) & 0x3F];\n    }\n  }\n  return outPtr;\n}\n", "nl": "Method that outputs partial chunk (which only encodes one or two bytes of data). Data given is still aligned same as if it as full data; that is, missing data is at the \"right end\" (LSB) of int."}
{"code": "public final boolean isProxy(){\n  return flags[PROXY_TICKET_FLAG];\n}\n", "nl": "Determines is this ticket is a proxy-ticket."}
{"code": "public OracleException(String message,Throwable cause,int errorCode){\n  super(message,cause);\n  this.errorCode=errorCode;\n}\n", "nl": "Constructs an <code>OracleException</code> with a given message, cause, error code, and error prefix."}
{"code": "public HandlerSubscriber(EventExecutor executor){\n  this(executor,DEFAULT_LOW_WATERMARK,DEFAULT_HIGH_WATERMARK);\n}\n", "nl": "Create a new handler subscriber with the default low and high watermarks. The supplied executor must be the same event loop as the event loop that this handler is eventually registered with, if not, an exception will be thrown when the handler is registered."}
{"code": "protected Intersection findClosestIntersection(LatLonPoint latLon){\n  Intersection inter=(Intersection)interQuadTree.get(latLon.getY(),latLon.getX());\n  if (inter == null)   logger.warning(\"no intersection at \" + latLon);\n  return inter;\n}\n", "nl": "Look in intersection Quad Tree for closest intersection to point at specified latitude and longitude. <p>"}
{"code": "public void addSpokenFlag(int flag){\n  final int flags=mMetadata.getInt(KEY_METADATA_SPEECH_FLAGS,0);\n  mMetadata.putInt(KEY_METADATA_SPEECH_FLAGS,flags | flag);\n}\n", "nl": "Adds a spoken feedback flag to this utterance's metadata."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:20.434 -0500\",hash_original_method=\"A949ED7F371D2CEC2724714D98F74A81\",hash_generated_method=\"A35FEC8DECEC7FCDFB70A09E65B2BE34\") protected SIPTransactionStack(StackMessageFactory messageFactory){\n  this();\n  this.sipMessageFactory=messageFactory;\n}\n", "nl": "Construcor for the stack. Registers the request and response factories for the stack."}
{"code": "private static Result<?> decodeVariableHeader(ByteBuf buffer,MqttFixedHeader mqttFixedHeader){\nswitch (mqttFixedHeader.messageType()) {\ncase CONNECT:\n    return decodeConnectionVariableHeader(buffer);\ncase CONNACK:\n  return decodeConnAckVariableHeader(buffer);\ncase SUBSCRIBE:\ncase UNSUBSCRIBE:\ncase SUBACK:\ncase UNSUBACK:\ncase PUBACK:\ncase PUBREC:\ncase PUBCOMP:\ncase PUBREL:\nreturn decodePacketIdVariableHeader(buffer);\ncase PUBLISH:\nreturn decodePublishVariableHeader(buffer,mqttFixedHeader);\ndefault :\nreturn new Result<>(null,0);\n}\n}\n", "nl": "Decodes the variable header (if any)"}
{"code": "public String multivalEncode(String value){\n  return value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\",\",\"\\\\\\\\,\");\n}\n", "nl": "Encodes a string value according to the conventions for supporting multiple values for a parameter (commas and backslashes are escaped)."}
{"code": "public UrlModuleSourceProvider(Iterable<URI> privilegedUris,Iterable<URI> fallbackUris,UrlConnectionExpiryCalculator urlConnectionExpiryCalculator,UrlConnectionSecurityDomainProvider urlConnectionSecurityDomainProvider){\n  this.privilegedUris=privilegedUris;\n  this.fallbackUris=fallbackUris;\n  this.urlConnectionExpiryCalculator=urlConnectionExpiryCalculator;\n  this.urlConnectionSecurityDomainProvider=urlConnectionSecurityDomainProvider;\n}\n", "nl": "Creates a new module script provider that loads modules against a set of privileged and fallback URIs. It will use the specified heuristic cache expiry calculator and security domain provider."}
{"code": "public void test_getInstanceLjava_lang_StringLjava_lang_String() throws NoSuchAlgorithmException, NoSuchProviderException, IllegalArgumentException, KeyManagementException {\n  try {\n    SSLContext.getInstance(null,mProv.getName());\n    fail(\"NoSuchAlgorithmException or NullPointerException should be thrown \" + \"(protocol is null)\");\n  }\n catch (  NoSuchAlgorithmException e) {\n  }\ncatch (  NullPointerException e) {\n  }\n  for (int i=0; i < invalidValues.length; i++) {\n    try {\n      SSLContext.getInstance(invalidValues[i],mProv.getName());\n      fail(\"NoSuchAlgorithmException must be thrown (protocol: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    NoSuchAlgorithmException e) {\n    }\n  }\n  String prov=null;\n  for (int i=0; i < validValues.length; i++) {\n    try {\n      SSLContext.getInstance(validValues[i],prov);\n      fail(\"IllegalArgumentException must be thrown when provider is null (protocol: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    IllegalArgumentException e) {\n    }\n    try {\n      SSLContext.getInstance(validValues[i],\"\");\n      fail(\"IllegalArgumentException must be thrown when provider is empty (protocol: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    IllegalArgumentException e) {\n    }\n  }\n  for (int i=0; i < validValues.length; i++) {\n    for (int j=1; j < invalidValues.length; j++) {\n      try {\n        SSLContext.getInstance(validValues[i],invalidValues[j]);\n        fail(\"NoSuchProviderException must be thrown (protocol: \".concat(invalidValues[i]).concat(\" provider: \").concat(invalidValues[j]).concat(\")\"));\n      }\n catch (      NoSuchProviderException e) {\n      }\n    }\n  }\n  SSLContext sslC;\n  for (int i=0; i < validValues.length; i++) {\n    sslC=SSLContext.getInstance(validValues[i],mProv.getName());\n    assertTrue(\"Not instanceof SSLContext object\",sslC instanceof SSLContext);\n    assertEquals(\"Incorrect protocol\",sslC.getProtocol(),validValues[i]);\n    assertEquals(\"Incorrect provider\",sslC.getProvider().getName(),mProv.getName());\n    checkSSLContext(sslC);\n  }\n}\n", "nl": "Test for <code>getInstance(String protocol, String provider)</code> method Assertions: throws NullPointerException when protocol is null; throws NoSuchAlgorithmException when protocol is not correct; throws IllegalArgumentException when provider is null or empty; throws NoSuchProviderException when provider is available; returns SSLContext object"}
{"code": "public WrappedByteBuffer putLong(long v){\n  _autoExpand(8);\n  _buf.putLong(v);\n  return this;\n}\n", "nl": "Puts an eight-byte long into the buffer at the current position."}
{"code": "private void verifyMigrationDone(String version){\n  CoordinatorClient coordinator=getCoordinator();\n  Assert.assertEquals(MigrationStatus.DONE,coordinator.getMigrationStatus());\n  String checkpoint=getCheckpoint(version);\n  Assert.assertNull(checkpoint);\n}\n", "nl": "Verify if migration checkpoint information is cleared after migration done"}
{"code": "public RepaintManager(ImageRenderer r){\n  renderer=r;\n}\n", "nl": "Creates a new repaint manager."}
{"code": "public void testMaxNegZero(){\n  byte aBytes[]={45,91,3,-15,35,26,3,91};\n  int aSign=-1;\n  byte rBytes[]={0};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=BigInteger.ZERO;\n  BigInteger result=aNumber.max(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertTrue(\"incorrect sign\",result.signum() == 0);\n}\n", "nl": "max(BigInteger val). max of negative and ZERO."}
{"code": "static int[] convertMidTerms(int[] k){\n  int[] res=new int[3];\n  if (k.length == 1) {\n    res[0]=k[0];\n  }\n else {\n    if (k.length != 3) {\n      throw new IllegalArgumentException(\"Only Trinomials and pentanomials supported\");\n    }\n    if (k[0] < k[1] && k[0] < k[2]) {\n      res[0]=k[0];\n      if (k[1] < k[2]) {\n        res[1]=k[1];\n        res[2]=k[2];\n      }\n else {\n        res[1]=k[2];\n        res[2]=k[1];\n      }\n    }\n else     if (k[1] < k[2]) {\n      res[0]=k[1];\n      if (k[0] < k[2]) {\n        res[1]=k[0];\n        res[2]=k[2];\n      }\n else {\n        res[1]=k[2];\n        res[2]=k[0];\n      }\n    }\n else {\n      res[0]=k[2];\n      if (k[0] < k[1]) {\n        res[1]=k[0];\n        res[2]=k[1];\n      }\n else {\n        res[1]=k[1];\n        res[2]=k[0];\n      }\n    }\n  }\n  return res;\n}\n", "nl": "Returns a sorted array of middle terms of the reduction polynomial."}
{"code": "public boolean isBufferDirty(){\n  return true;\n}\n", "nl": "Checks whether the image buffer should be repainted."}
{"code": "public int fetchInteger(int tag) throws BerException {\n  int result=0;\n  final int backup=next;\n  try {\n    if (fetchTag() != tag) {\n      throw new BerException();\n    }\n    result=fetchIntegerValue();\n  }\n catch (  BerException e) {\n    next=backup;\n    throw e;\n  }\n  return result;\n}\n", "nl": "Fetch an integer with the specified tag."}
{"code": "protected void drawImage(int x,int y,int w,int h,String image){\n  Image img=loadImage(image);\n  if (img != null) {\n    g.drawImage(img,x,y,w,h,null);\n  }\n}\n", "nl": "Draws an image for the given parameters."}
{"code": "@UnpreemptibleNoWarn(\"The caller is prepared to lose control when it allocates a lock\") static void growLocks(int id){\n  int spineId=id >> LOG_LOCK_CHUNK_SIZE;\n  if (spineId >= LOCK_SPINE_SIZE) {\n    VM.sysFail(\"Cannot grow lock array greater than maximum possible index\");\n  }\n  for (int i=chunksAllocated; i <= spineId; i++) {\n    if (locks[i] != null) {\n      continue;\n    }\n    Lock[] newChunk=new Lock[LOCK_CHUNK_SIZE];\n    lockAllocationMutex.lock();\n    if (locks[i] == null) {\n      locks[i]=newChunk;\n      chunksAllocated++;\n    }\n    lockAllocationMutex.unlock();\n  }\n}\n", "nl": "Grow the locks table by allocating a new spine chunk."}
{"code": "public PLCubicPanorama(){\n  super();\n}\n", "nl": "init methods"}
{"code": "public GetResponseMessage(GetResponseMessage other){\n  if (other.isSetHeader()) {\n    this.header=new AsyncMessageHeader(other.header);\n  }\n  if (other.isSetValues()) {\n    List<VersionedValue> __this__values=new ArrayList<VersionedValue>();\n    for (    VersionedValue other_element : other.values) {\n      __this__values.add(new VersionedValue(other_element));\n    }\n    this.values=__this__values;\n  }\n  if (other.isSetError()) {\n    this.error=new SyncError(other.error);\n  }\n}\n", "nl": "Performs a deep copy on <i>other</i>."}
{"code": "public static String printDateTime(LocalDateTime datetime){\n  return dfISO8601.print(datetime);\n}\n", "nl": "Prints the given datetime as a string."}
{"code": "@Override public SignatureLibraryRelease parse() throws IOException {\n  final SignatureLibraryRelease release=new SignatureLibraryRelease(this.getSignatureLibrary(),this.getReleaseVersionNumber());\n  final Model model1=new Model(SIGNALP_SIGNATURE_NAME1,SIGNALP_SIGNATURE_NAME1,null,null);\n  final Signature.Builder builder1=new Signature.Builder(SIGNALP_SIGNATURE_NAME1);\n  final Signature signature1=builder1.name(SIGNALP_SIGNATURE_NAME1).model(model1).signatureLibraryRelease(release).build();\n  release.addSignature(signature1);\n  final Model model2=new Model(SIGNALP_SIGNATURE_NAME2,SIGNALP_SIGNATURE_NAME2,null,null);\n  final Signature.Builder builder2=new Signature.Builder(SIGNALP_SIGNATURE_NAME2);\n  final Signature signature2=builder2.name(SIGNALP_SIGNATURE_NAME2).model(model2).signatureLibraryRelease(release).build();\n  release.addSignature(signature2);\n  return release;\n}\n", "nl": "This is rather badly named as there is nothing to parse... <p/> However, the point is that it returns a SignatureLibraryRelease for SignalP, containing two Signature objects called \"SignalP-TM\" and \"SignalP-noTM\"."}
{"code": "public Frame(int locals,int stack){\n  this.locals=new Type[locals];\n  this.stack=new Type[stack];\n}\n", "nl": "Create a new frame with the specified local variable table size, and max stack size"}
{"code": "public void enlarge(double scale){\n  double latMargin=scale * (lat2 - lat1);\n  double lngMargin=scale * (lng2 - lng1);\n  lat1-=latMargin;\n  lat2+=latMargin;\n  lng1-=lngMargin;\n  lng2+=lngMargin;\n}\n", "nl": "e.g. scale=0.1 means increase the size by 10% on all sides."}
{"code": "public void exportCode(JavaClass source,JavaClass target) throws Exception {\n  ExportAnalyzer analyzer=new ExportAnalyzer(source,target);\n  CodeEnhancer visitor=new CodeEnhancer(source,this);\n  visitor.analyze(analyzer,false);\n  visitor.update();\n}\n", "nl": "Exports code."}
{"code": "protected void drawFollow(Graphics g,Point2D[] pts,boolean reverse){\n  LinkedList points=new LinkedList();\n  if (reverse) {\n    for (int i=pts.length - 1; i >= 0; i--)     points.add(pts[i]);\n  }\n else {\n    for (int i=0; i < pts.length; i++)     points.add(pts[i]);\n  }\n  LinkedList polysegment=new LinkedList();\n  int l, x1, y1, x2, y2;\n  String c;\n  Point2D p1, p2;\n  double angle;\n  for (int i=0; i < text.length(); i++) {\n    c=text.substring(i,i + 1);\n    l=metrics.stringWidth(c);\n    if (points.isEmpty())     break;\n    LineUtil.retrievePoints(l,points,polysegment);\n    p1=(Point2D)polysegment.getFirst();\n    x1=(int)p1.getX();\n    y1=(int)p1.getY();\n    p2=(Point2D)polysegment.getLast();\n    x2=(int)p2.getX();\n    y2=(int)p2.getY();\n    angle=Math.atan2(y2 - y1,x2 - x1);\n    drawAngledString(g,c,x1,y1,angle);\n  }\n}\n", "nl": "Draws the text character per character to follow the polyline"}
{"code": "public TacticalGraphicSymbol(String sidc){\n  super();\n  init(sidc);\n}\n", "nl": "Constructs a new symbol with no position."}
{"code": "public static TestDiagnosticLine fromDiagnosticFileLine(String diagnosticLine){\n  final String trimmedLine=diagnosticLine.trim();\n  if (trimmedLine.startsWith(\"#\") || trimmedLine.isEmpty()) {\n    return new TestDiagnosticLine(\"\",-1,diagnosticLine,EMPTY);\n  }\n  TestDiagnostic diagnostic=fromDiagnosticFileString(diagnosticLine);\n  return new TestDiagnosticLine(\"\",diagnostic.getLineNumber(),diagnosticLine,Arrays.asList(diagnostic));\n}\n", "nl": "Convert a line in a DiagnosticFile to a TestDiagnosticLine"}
{"code": "public void appendTextString(byte[] textString){\n  if (null == textString) {\n    throw new NullPointerException(\"Text-string is null.\");\n  }\n  if (null == mData) {\n    mData=new byte[textString.length];\n    System.arraycopy(textString,0,mData,0,textString.length);\n  }\n else {\n    ByteArrayOutputStream newTextString=new ByteArrayOutputStream();\n    try {\n      newTextString.write(mData);\n      newTextString.write(textString);\n    }\n catch (    IOException e) {\n      e.printStackTrace();\n      throw new NullPointerException(\"appendTextString: failed when write a new Text-string\");\n    }\n    mData=newTextString.toByteArray();\n  }\n}\n", "nl": "Append to Text-string."}
{"code": "public PoolingByteArrayOutputStream(ByteArrayPool pool){\n  this(pool,DEFAULT_SIZE);\n}\n", "nl": "Constructs a new PoolingByteArrayOutputStream with a default size. If more bytes are written to this instance, the underlying byte array will expand."}
{"code": "private void updateAlias(JLabel label,Alias alias){\n  if (alias != null) {\n    label.setText(alias.getName());\n    String icon=alias.getIconName();\n    if (icon != null) {\n      label.setIcon(mSettingsManager.getImageIcon(icon,SettingsManager.DEFAULT_ICON_SIZE));\n    }\n else {\n      label.setIcon(null);\n    }\n  }\n else {\n    label.setText(\"\");\n    label.setIcon(null);\n  }\n}\n", "nl": "Updates the alias label with text and icon from the alias.  Note: this  does not occur on the Swing event thread -- wrap any calls to this method with an event thread call."}
{"code": "public boolean verifyReader(){\n  return this.verifyReader;\n}\n", "nl": "<p> Returns if the CSVReader will verify the reader before each read. </p> <p> By default the value is true which is the functionality for version 3.0. If set to false the reader is always assumed ready to read - this is the functionality for version 2.4 and before. </p> <p> The reason this method was needed was that certain types of Readers would return false for its ready() method until a read was done (namely readers created using Channels). This caused opencsv not to read from those readers. </p>"}
{"code": "private static void launchDebugger(String dmlScriptStr,String fnameOptConfig,Map<String,String> argVals,boolean parsePyDML) throws ParseException, IOException, DMLRuntimeException, DMLDebuggerException, LanguageException, HopsException, LopsException {\n  DMLDebuggerProgramInfo dbprog=new DMLDebuggerProgramInfo();\n  DMLConfig conf=DMLConfig.readConfigurationFile(fnameOptConfig);\n  ConfigurationManager.setGlobalConfig(conf);\n  AParserWrapper parser=AParserWrapper.createParser(parsePyDML);\n  DMLProgram prog=parser.parse(DML_FILE_PATH_ANTLR_PARSER,dmlScriptStr,argVals);\n  DMLTranslator dmlt=new DMLTranslator(prog);\n  dmlt.liveVariableAnalysis(prog);\n  dmlt.validateParseTree(prog);\n  dmlt.constructHops(prog);\n  dmlt.rewriteHopsDAG(prog);\n  dmlt.constructLops(prog);\n  dbprog.rtprog=prog.getRuntimeProgram(conf);\n  try {\n    initHadoopExecution(conf);\n    DMLDebugger SystemMLdb=new DMLDebugger(dbprog,dmlScriptStr);\n    SystemMLdb.runSystemMLDebugger();\n  }\n  finally {\n    cleanupHadoopExecution(conf);\n  }\n}\n", "nl": "launchDebugger: Launcher for DML debugger. This method should be called after  execution and debug properties have been correctly set, and customized parameters  have been put into _argVals"}
{"code": "public static VMRequest highFraction(float frac){\n  if (VM.HEAP_LAYOUT_64BIT) {\n    return common64Bit(true);\n  }\n  return new VMRequest(REQUEST_FRACTION,Address.zero(),Extent.zero(),frac,true);\n}\n", "nl": "A request for a fraction of available memory, optionally requesting the highest available."}
{"code": "@Override public String toString(){\n  StringBuffer text=new StringBuffer();\n  if (m_trainInstances == null) {\n    text.append(\"CFS subset evaluator has not been built yet\\n\");\n  }\n else {\n    text.append(\"\\tCFS Subset Evaluator\\n\");\n    if (m_missingSeparate) {\n      text.append(\"\\tTreating missing values as a separate value\\n\");\n    }\n    if (m_locallyPredictive) {\n      text.append(\"\\tIncluding locally predictive attributes\\n\");\n    }\n  }\n  return text.toString();\n}\n", "nl": "returns a string describing CFS"}
{"code": "private void unwrapData() throws IgniteCheckedException, SSLException {\n  if (log.isDebugEnabled())   log.debug(\"Unwrapping received data: \" + ses);\n  inNetBuf.flip();\n  SSLEngineResult res=unwrap0();\n  inNetBuf.compact();\n  checkStatus(res);\n  renegotiateIfNeeded(res);\n}\n", "nl": "Unwraps user data to the application buffer."}
{"code": "public static ceylon.language.meta.declaration.Module findLoadedModule(String name,String version){\n  com.redhat.ceylon.model.typechecker.model.Module module=moduleManager.findLoadedModule(name,version);\n  return module != null ? getOrCreateMetamodel(null,module,null,true) : null;\n}\n", "nl": "Used by c.l.meta.modules.find, which accepts null"}
{"code": "public void endBoolean(boolean value){\n}\n", "nl": "Indicates the end of a boolean literal (<code>true</code> or <code>false</code>) in the JSON input. This method will be called after reading the last character of the literal."}
{"code": "public static Organization toVendor(VOOrganization voOrganization) throws ValidationException {\n  validateVendorMandatoryFields(voOrganization);\n  return toCustomer(voOrganization);\n}\n", "nl": "Updates the fields in the Supplier or Technology Provider Organization object to reflect the changes performed in the value object. Creates a new Vendor Organization (Supplier or Technology Provider) object and fills the fields with the corresponding fields from the given value object. For vendors, email contact, phone, url, name and address are mandatory; for customers not."}
{"code": "public UnaryOperator createUnaryOperatorFromString(EDataType eDataType,String initialValue){\n  UnaryOperator result=UnaryOperator.get(initialValue);\n  if (result == null)   throw new IllegalArgumentException(\"The value '\" + initialValue + \"' is not a valid enumerator of '\"+ eDataType.getName()+ \"'\");\n  return result;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public final void updateCursorBoxOnScreen(final int[] rectParams,final int outlineColor){\n  if (options.getDisplayView() != Display.SINGLE_PAGE) {\n    return;\n  }\n  pages.updateCursorBoxOnScreen(rectParams,outlineColor,getPageNumber(),x_size,y_size);\n}\n", "nl": "update rectangle we draw to highlight an area - See Viewer example for example code showing current usage. This method takes an int array containing the x,y,w,h params of  the rectangle we wish to update. It also takes an int outLineColor which is the rgb value of a Color object."}
{"code": "public boolean isCritical(){\n  return criticality;\n}\n", "nl": "Determines the control's criticality."}
{"code": "public JCTree.JCCompilationUnit parse(JavaFileObject filename){\n  JavaFileObject prev=log.useSource(filename);\n  try {\n    JCTree.JCCompilationUnit t=parse(filename,readSource(filename));\n    if (t.endPositions != null)     log.setEndPosTable(filename,t.endPositions);\n    return t;\n  }\n  finally {\n    log.useSource(prev);\n  }\n}\n", "nl": "Parse contents of file."}
{"code": "public static double[] toDoubleArray(final long[] array){\n  double[] values=new double[array.length];\n  for (int i=0; i < array.length; i++)   values[i]=array[i];\n  return values;\n}\n", "nl": "Converts an array of long primitives to an array of doubles."}
{"code": "@Override public String convertToString(EDataType eDataType,Object instanceValue){\nswitch (eDataType.getClassifierID()) {\ncase DomPackage.TAG_DEFINITION:\n    return convertTagDefinitionToString(eDataType,instanceValue);\ndefault :\n  throw new IllegalArgumentException(\"The datatype '\" + eDataType.getName() + \"' is not a valid classifier\");\n}\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public CSVWriter(Writer writer,char separator,char quotechar){\n  this(writer,separator,quotechar,DEFAULT_ESCAPE_CHARACTER);\n}\n", "nl": "Constructs CSVWriter with supplied separator and quote char."}
{"code": "String formatRomanDigit(int level,int digit){\n  String result=\"\";\n  if (digit == 9) {\n    result=result + romanChars[level][0];\n    result=result + romanChars[level + 1][0];\n    return result;\n  }\n else   if (digit == 4) {\n    result=result + romanChars[level][0];\n    result=result + romanChars[level][1];\n    return result;\n  }\n else   if (digit >= 5) {\n    result=result + romanChars[level][1];\n    digit-=5;\n  }\n  for (int i=0; i < digit; i++) {\n    result=result + romanChars[level][0];\n  }\n  return result;\n}\n", "nl": "Converts the item number into a roman numeral"}
{"code": "public CProjectContainer(final IDatabase database,final INaviProject project){\n  m_database=Preconditions.checkNotNull(database,\"IE01785: database argument can not be null\");\n  m_project=Preconditions.checkNotNull(project,\"IE01786: project argument can not be null\");\n  m_addressSpace=null;\n  m_provider=new ProjectTraceProvider(m_project);\n  m_debuggerProvider=new DebuggerProvider(new ProjectTargetSettings(m_project));\n  if (m_project.isLoaded()) {\n    updateProjectDebuggers();\n  }\n  m_project.addListener(m_listener);\n  if (m_project.isLoaded()) {\n    for (    final INaviAddressSpace addressSpace : m_project.getContent().getAddressSpaces()) {\n      initializeAddressSpaceListeners(addressSpace);\n    }\n  }\n}\n", "nl": "Creates a new project container object."}
{"code": "public VNXeCommandResult createConsistencyGroup(ConsistencyGroupCreateParam createParam){\n  _url=URL_CREATE;\n  return postRequestSync(createParam);\n}\n", "nl": "Create consistency group"}
{"code": "public static String doThrustCheck(MovePath md,Client client){\n  StringBuffer nagReport=new StringBuffer();\n  List<TargetRoll> psrList=new ArrayList<TargetRoll>();\n  if (client.getGame().useVectorMove()) {\n    return nagReport.toString();\n  }\n  final Entity entity=md.getEntity();\n  if (!(entity instanceof Aero)) {\n    return nagReport.toString();\n  }\n  EntityMovementType overallMoveType=EntityMovementType.MOVE_NONE;\n  Aero a=(Aero)entity;\n  PilotingRollData rollTarget;\n  overallMoveType=md.getLastStepMovementType();\n  int thrustUsed=0;\n  int j=0;\n  for (final Enumeration<MoveStep> i=md.getSteps(); i.hasMoreElements(); ) {\n    final MoveStep step=i.nextElement();\n    j++;\n    if ((step.getDistance() == 0) && (md.length() != j)) {\n      thrustUsed+=step.getMp();\n    }\n else {\n      if ((step.getDistance() == 0) && (md.length() == j)) {\n        thrustUsed+=step.getMp();\n      }\n      rollTarget=a.checkThrustSI(thrustUsed,overallMoveType);\n      checkNag(rollTarget,nagReport,psrList);\n      int hits=entity.getCrew().getHits();\n      int health=6 - hits;\n      if (thrustUsed > (2 * health)) {\n        int targetroll=2 + (thrustUsed - (2 * health)) + (2 * hits);\n        nagReport.append(Messages.getString(\"MovementDisplay.addNag\",new Object[]{Integer.toString(targetroll),\"Thrust exceeded twice pilot's health in single hex\"}));\n      }\n      thrustUsed=0;\n    }\n  }\n  return nagReport.toString();\n}\n", "nl": "Checks to see if piloting skill rolls are needed for excessive use of thrust."}
{"code": "public IterationWrapper(Iteration<? extends E,? extends X> iter){\n  assert iter != null;\n  wrappedIter=iter;\n}\n", "nl": "Creates a new IterationWrapper that operates on the supplied Iteration."}
{"code": "public void testReservePassiveAvailabilityChange() throws Throwable {\n  createServers(3);\n  CopycatServer passive=createServer(nextMember(Member.Type.PASSIVE));\n  passive.join(members.stream().map(null).collect(Collectors.toList())).thenRun(null);\n  CopycatServer reserve=createServer(nextMember(Member.Type.RESERVE));\n  reserve.join(members.stream().map(null).collect(Collectors.toList())).thenRun(null);\n  await(10000,2);\n  reserve.cluster().member(passive.cluster().member().address()).onStatusChange(null);\n  passive.shutdown().thenRun(null);\n  await(10000,2);\n}\n", "nl": "Tests detecting an availability change of a passive member on a reserve member."}
{"code": "public void stop(){\n  if (isRunning()) {\n    unscheduleSelf(this);\n  }\n}\n", "nl": "<p>Stops the animation. This method has no effect if the animation is not running.</p>"}
{"code": "public double slopeStdErr(){\n  return Math.sqrt(svar1);\n}\n", "nl": "Returns the standard error of the estimate for the slope."}
{"code": "private static XYDataset createDataset(){\n  TimeSeries s1=new TimeSeries(\"L&G European Index Trust\");\n  s1.add(new Month(2,2001),181.8);\n  s1.add(new Month(3,2001),167.3);\n  s1.add(new Month(4,2001),153.8);\n  s1.add(new Month(5,2001),167.6);\n  s1.add(new Month(6,2001),158.8);\n  s1.add(new Month(7,2001),148.3);\n  s1.add(new Month(8,2001),153.9);\n  s1.add(new Month(9,2001),142.7);\n  s1.add(new Month(10,2001),123.2);\n  s1.add(new Month(11,2001),131.8);\n  s1.add(new Month(12,2001),139.6);\n  s1.add(new Month(1,2002),142.9);\n  s1.add(new Month(2,2002),138.7);\n  s1.add(new Month(3,2002),137.3);\n  s1.add(new Month(4,2002),143.9);\n  s1.add(new Month(5,2002),139.8);\n  s1.add(new Month(6,2002),137.0);\n  s1.add(new Month(7,2002),132.8);\n  TimeSeries s2=new TimeSeries(\"L&G UK Index Trust\");\n  s2.add(new Month(2,2001),129.6);\n  s2.add(new Month(3,2001),123.2);\n  s2.add(new Month(4,2001),117.2);\n  s2.add(new Month(5,2001),124.1);\n  s2.add(new Month(6,2001),122.6);\n  s2.add(new Month(7,2001),119.2);\n  s2.add(new Month(8,2001),116.5);\n  s2.add(new Month(9,2001),112.7);\n  s2.add(new Month(10,2001),101.5);\n  s2.add(new Month(11,2001),106.1);\n  s2.add(new Month(12,2001),110.3);\n  s2.add(new Month(1,2002),111.7);\n  s2.add(new Month(2,2002),111.0);\n  s2.add(new Month(3,2002),109.6);\n  s2.add(new Month(4,2002),113.2);\n  s2.add(new Month(5,2002),111.6);\n  s2.add(new Month(6,2002),108.8);\n  s2.add(new Month(7,2002),101.6);\n  TimeSeriesCollection dataset=new TimeSeriesCollection();\n  dataset.addSeries(s1);\n  dataset.addSeries(s2);\n  return dataset;\n}\n", "nl": "Creates a dataset, consisting of two series of monthly data."}
{"code": "public void globalInit() throws Exception {\n  computeRotationTime();\n  InterProcessLock lock=null;\n  try {\n    lock=_coordinator.getLock(DISTRIBUTED_KEY_TOKEN_LOCK);\n    lock.acquire();\n    if (!doesConfigExist()) {\n      TokenKeysBundle bundle=TokenKeysBundle.createNewTokenKeysBundle();\n      createOrUpdateBundle(bundle);\n      updateCachedTokenKeys(bundle);\n    }\n else {\n      updateCachedKeys();\n      _log.debug(\"Token keys configuration exists, loaded keys\");\n      _log.debug(\"Current token key {}\",_cachedTokenKeysBundle.getCurrentKeyEntry());\n    }\n    keyRotationExecutor.scheduleWithFixedDelay(new KeyRotationThread(),0,_keyRotationIntervalInMsecs,TimeUnit.MILLISECONDS);\n  }\n catch (  Exception ex) {\n    _log.error(\"Exception during initialization of TokenKeyGenerator\",ex);\n  }\n finally {\n    try {\n      if (lock != null) {\n        lock.release();\n      }\n    }\n catch (    Exception ex) {\n      _log.error(\"Could not release the lock during TokenKeyGenerator.init()\");\n      throw ex;\n    }\n  }\n}\n", "nl": "Initialization method to be called by authsvc. It will create the key configuration if it doesn't exist on first startup. Else it will just load the cache."}
{"code": "public Builder addInClause(String fieldName,Collection<String> itemNames,Occurance occurance){\n  if (itemNames.size() == 1) {\n    return addFieldClause(fieldName,itemNames.iterator().next(),occurance);\n  }\n  Query.Builder inClause=Query.Builder.create(occurance);\n  for (  String itemName : itemNames) {\n    inClause.addFieldClause(fieldName,itemName,Occurance.SHOULD_OCCUR);\n  }\n  return addClause(inClause.build());\n}\n", "nl": "Add a clause with the given occurance which matches a property with at least one of several specified values (analogous to a SQL \"IN\" or \"NOT IN\" statements)."}
{"code": "private void injectForBroadcastReceiver(SootField brField,SootField intentField){\n  SootMethod onReceive=Scene.v().getMethod(\"<android.content.BroadcastReceiver: void onReceive(android.content.Context,android.content.Intent)>\");\n  logger.info(\"Adding onReceive call in Harness for Field {}\",brField);\n  Local compLocal=Jimple.v().newLocal(\"_$injectinterapp_comp_local_\" + localID++,brField.getType());\n  Harness.v().addLocalToMain(compLocal);\n  Local intentLocal=Jimple.v().newLocal(\"_$injectinterapp_intent_local_\" + localID++,intentField.getType());\n  Harness.v().addLocalToMain(intentLocal);\n  Stmt compLocalAssign=Jimple.v().newAssignStmt(compLocal,Jimple.v().newStaticFieldRef(brField.makeRef()));\n  Harness.v().addStmtToEndOfMainLoop(compLocalAssign);\n  Stmt intentAssign=Jimple.v().newAssignStmt(intentLocal,Jimple.v().newStaticFieldRef(intentField.makeRef()));\n  Harness.v().addStmtToEndOfMainLoop(intentAssign);\n  Local contextLocal=Jimple.v().newLocal(\"_$injectinterapp_content_local_\" + localID++,intentField.getType());\n  Harness.v().addLocalToMain(contextLocal);\n  SootField contextField=Scene.v().getSootClass(\"droidsafe.runtime.DroidSafeAndroidRuntime\").getFieldByName(\"context\");\n  Stmt contextAssign=Jimple.v().newAssignStmt(contextLocal,Jimple.v().newStaticFieldRef(contextField.makeRef()));\n  Harness.v().addStmtToEndOfMainLoop(contextAssign);\n  List<Value> args=new LinkedList<Value>();\n  args.add(contextLocal);\n  args.add(intentLocal);\n  Stmt onReceiveCall=Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(compLocal,onReceive.makeRef(),args));\n  Harness.v().addStmtToEndOfMainLoop(onReceiveCall);\n  RCFG.v().ignoreInvokeForOutputEvents(onReceiveCall);\n}\n", "nl": "Inject source flow into broadcast receiver field by injecting a call to onReceiver with the created Intent."}
{"code": "public boolean hasActiveEvent(){\n  return activeEvent;\n}\n", "nl": "Returns true if there is an active event"}
{"code": "private static boolean caselessCompare(char a,char b){\n  return Character.toLowerCase(a) == Character.toLowerCase(b);\n}\n", "nl": "Compares two characters whilst ignoring case."}
{"code": "public static void clickToolbarCollapseButton(){\n  onView(withContentDescription(\"Collapse\")).perform(click());\n}\n", "nl": "Clicks the arrow button in the toolbar when its function is collapsing a view. For instance, collapse the search view in the toolbar."}
{"code": "public static JsonValue parse(Reader reader) throws IOException {\n  if (reader == null) {\n    throw new NullPointerException(\"reader is null\");\n  }\n  return new JsonParser(reader).parse();\n}\n", "nl": "Reads the entire input stream from the given reader and parses it as JSON. The input must contain a valid JSON value, optionally padded with whitespace. <p> Characters are read in chunks and buffered internally, therefore wrapping an existing reader in an additional <code>BufferedReader</code> does <strong>not</strong> improve reading performance. </p>"}
{"code": "public static Map<String,Object> sendMail(DispatchContext ctx,Map<String,? extends Object> context){\n  Delegator delegator=ctx.getDelegator();\n  String communicationEventId=(String)context.get(\"communicationEventId\");\n  String orderId=(String)context.get(\"orderId\");\n  Locale locale=(Locale)context.get(\"locale\");\n  if (communicationEventId != null) {\n    Debug.logInfo(\"SendMail Running, for communicationEventId : \" + communicationEventId,module);\n  }\n  Map<String,Object> results=ServiceUtil.returnSuccess();\n  String subject=(String)context.get(\"subject\");\n  subject=FlexibleStringExpander.expandString(subject,context);\n  String partyId=(String)context.get(\"partyId\");\n  String body=(String)context.get(\"body\");\n  List<Map<String,Object>> bodyParts=UtilGenerics.checkList(context.get(\"bodyParts\"));\n  GenericValue userLogin=(GenericValue)context.get(\"userLogin\");\n  results.put(\"communicationEventId\",communicationEventId);\n  results.put(\"partyId\",partyId);\n  results.put(\"subject\",subject);\n  if (UtilValidate.isNotEmpty(orderId)) {\n    results.put(\"orderId\",orderId);\n  }\n  if (UtilValidate.isNotEmpty(body)) {\n    body=FlexibleStringExpander.expandString(body,context);\n    results.put(\"body\",body);\n  }\n  if (UtilValidate.isNotEmpty(bodyParts)) {\n    results.put(\"bodyParts\",bodyParts);\n  }\n  results.put(\"userLogin\",userLogin);\n  String sendTo=(String)context.get(\"sendTo\");\n  String sendCc=(String)context.get(\"sendCc\");\n  String sendBcc=(String)context.get(\"sendBcc\");\n  String redirectAddress=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.notifications.redirectTo\",delegator);\n  if (UtilValidate.isNotEmpty(redirectAddress)) {\n    String originalRecipients=\" [To: \" + sendTo + \", Cc: \"+ sendCc+ \", Bcc: \"+ sendBcc+ \"]\";\n    subject+=originalRecipients;\n    sendTo=redirectAddress;\n    sendCc=null;\n    sendBcc=null;\n    if (subject.length() > 255) {\n      subject=subject.substring(0,255);\n    }\n  }\n  String sendFrom=(String)context.get(\"sendFrom\");\n  String sendType=(String)context.get(\"sendType\");\n  String port=(String)context.get(\"port\");\n  String socketFactoryClass=(String)context.get(\"socketFactoryClass\");\n  String socketFactoryPort=(String)context.get(\"socketFactoryPort\");\n  String socketFactoryFallback=(String)context.get(\"socketFactoryFallback\");\n  String sendVia=(String)context.get(\"sendVia\");\n  String authUser=(String)context.get(\"authUser\");\n  String authPass=(String)context.get(\"authPass\");\n  String messageId=(String)context.get(\"messageId\");\n  String contentType=(String)context.get(\"contentType\");\n  Boolean sendPartial=(Boolean)context.get(\"sendPartial\");\n  Boolean isStartTLSEnabled=(Boolean)context.get(\"startTLSEnabled\");\n  boolean useSmtpAuth=false;\n  if (sendType == null || sendType.equals(\"mail.smtp.host\")) {\n    sendType=\"mail.smtp.host\";\n    if (UtilValidate.isEmpty(sendVia)) {\n      sendVia=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.relay.host\",\"localhost\",delegator);\n    }\n    if (UtilValidate.isEmpty(authUser)) {\n      authUser=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.auth.user\",delegator);\n    }\n    if (UtilValidate.isEmpty(authPass)) {\n      authPass=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.auth.password\",delegator);\n    }\n    if (UtilValidate.isNotEmpty(authUser)) {\n      useSmtpAuth=true;\n    }\n    if (UtilValidate.isEmpty(port)) {\n      port=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.port\",delegator);\n    }\n    if (UtilValidate.isEmpty(socketFactoryPort)) {\n      socketFactoryPort=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.socketFactory.port\",delegator);\n    }\n    if (UtilValidate.isEmpty(socketFactoryClass)) {\n      socketFactoryClass=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.socketFactory.class\",delegator);\n    }\n    if (UtilValidate.isEmpty(socketFactoryFallback)) {\n      socketFactoryFallback=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.smtp.socketFactory.fallback\",\"false\",delegator);\n    }\n    if (sendPartial == null) {\n      sendPartial=EntityUtilProperties.propertyValueEqualsIgnoreCase(\"general.properties\",\"mail.smtp.sendpartial\",\"true\",delegator) ? true : false;\n    }\n    if (isStartTLSEnabled == null) {\n      isStartTLSEnabled=EntityUtilProperties.propertyValueEqualsIgnoreCase(\"general.properties\",\"mail.smtp.starttls.enable\",\"true\",delegator);\n    }\n  }\n else   if (sendVia == null) {\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendMissingParameterSendVia\",locale));\n  }\n  if (contentType == null) {\n    contentType=\"text/html\";\n  }\n  if (UtilValidate.isNotEmpty(bodyParts)) {\n    contentType=\"multipart/mixed\";\n  }\n  results.put(\"contentType\",contentType);\n  Session session;\n  MimeMessage mail;\n  try {\n    Properties props=System.getProperties();\n    props.put(sendType,sendVia);\n    if (UtilValidate.isNotEmpty(port)) {\n      props.put(\"mail.smtp.port\",port);\n    }\n    if (UtilValidate.isNotEmpty(socketFactoryPort)) {\n      props.put(\"mail.smtp.socketFactory.port\",socketFactoryPort);\n    }\n    if (UtilValidate.isNotEmpty(socketFactoryClass)) {\n      props.put(\"mail.smtp.socketFactory.class\",socketFactoryClass);\n      Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());\n    }\n    if (UtilValidate.isNotEmpty(socketFactoryFallback)) {\n      props.put(\"mail.smtp.socketFactory.fallback\",socketFactoryFallback);\n    }\n    if (useSmtpAuth) {\n      props.put(\"mail.smtp.auth\",\"true\");\n    }\n    if (sendPartial != null) {\n      props.put(\"mail.smtp.sendpartial\",sendPartial ? \"true\" : \"false\");\n    }\n    if (isStartTLSEnabled) {\n      props.put(\"mail.smtp.starttls.enable\",\"true\");\n    }\n    session=Session.getInstance(props);\n    boolean debug=EntityUtilProperties.propertyValueEqualsIgnoreCase(\"general.properties\",\"mail.debug.on\",\"Y\",delegator);\n    session.setDebug(debug);\n    mail=new MimeMessage(session);\n    if (messageId != null) {\n      mail.setHeader(\"In-Reply-To\",messageId);\n      mail.setHeader(\"References\",messageId);\n    }\n    mail.setFrom(new InternetAddress(sendFrom));\n    mail.setSubject(subject,\"UTF-8\");\n    mail.setHeader(\"X-Mailer\",\"Apache OFBiz, The Apache Open For Business Project\");\n    mail.setSentDate(new Date());\n    mail.addRecipients(Message.RecipientType.TO,sendTo);\n    if (UtilValidate.isNotEmpty(sendCc)) {\n      mail.addRecipients(Message.RecipientType.CC,sendCc);\n    }\n    if (UtilValidate.isNotEmpty(sendBcc)) {\n      mail.addRecipients(Message.RecipientType.BCC,sendBcc);\n    }\n    if (UtilValidate.isNotEmpty(bodyParts)) {\n      MimeMultipart mp=new MimeMultipart();\n      Debug.logInfo(bodyParts.size() + \" multiparts found\",module);\n      for (      Map<String,Object> bodyPart : bodyParts) {\n        Object bodyPartContent=bodyPart.get(\"content\");\n        MimeBodyPart mbp=new MimeBodyPart();\n        if (bodyPartContent instanceof String) {\n          Debug.logInfo(\"part of type: \" + bodyPart.get(\"type\") + \" and size: \"+ bodyPart.get(\"content\").toString().length(),module);\n          mbp.setText((String)bodyPartContent,\"UTF-8\",((String)bodyPart.get(\"type\")).substring(5));\n        }\n else         if (bodyPartContent instanceof byte[]) {\n          ByteArrayDataSource bads=new ByteArrayDataSource((byte[])bodyPartContent,(String)bodyPart.get(\"type\"));\n          Debug.logInfo(\"part of type: \" + bodyPart.get(\"type\") + \" and size: \"+ ((byte[])bodyPartContent).length,module);\n          mbp.setDataHandler(new DataHandler(bads));\n        }\n else         if (bodyPartContent instanceof DataHandler) {\n          mbp.setDataHandler((DataHandler)bodyPartContent);\n        }\n else {\n          mbp.setDataHandler(new DataHandler(bodyPartContent,(String)bodyPart.get(\"type\")));\n        }\n        String fileName=(String)bodyPart.get(\"filename\");\n        if (fileName != null) {\n          mbp.setFileName(fileName);\n        }\n        mp.addBodyPart(mbp);\n      }\n      mail.setContent(mp);\n      mail.saveChanges();\n    }\n else {\n      if (contentType.startsWith(\"text\")) {\n        mail.setText(body,\"UTF-8\",contentType.substring(5));\n      }\n else {\n        mail.setContent(body,contentType);\n      }\n      mail.saveChanges();\n    }\n  }\n catch (  MessagingException e) {\n    Debug.logError(e,\"MessagingException when creating message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    Debug.logError(\"Email message that could not be created to [\" + sendTo + \"] had context: \"+ context,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendMessagingException\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n  }\ncatch (  IOException e) {\n    Debug.logError(e,\"IOExcepton when creating message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    Debug.logError(\"Email message that could not be created to [\" + sendTo + \"] had context: \"+ context,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendIOException\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n  }\n  String mailEnabled=EntityUtilProperties.getPropertyValue(\"general.properties\",\"mail.notifications.enabled\",\"N\",delegator);\n  if (!\"Y\".equalsIgnoreCase(mailEnabled)) {\n    Debug.logImportant(\"Mail notifications disabled in general.properties; mail with subject [\" + subject + \"] not sent to addressee [\"+ sendTo+ \"]\",module);\n    Debug.logVerbose(\"What would have been sent, the addressee: \" + sendTo + \" subject: \"+ subject+ \" context: \"+ context,module);\n    results.put(\"messageWrapper\",new MimeMessageWrapper(session,mail));\n    return results;\n  }\n  Transport trans=null;\n  try {\n    trans=session.getTransport(\"smtp\");\n    if (!useSmtpAuth) {\n      trans.connect();\n    }\n else {\n      trans.connect(sendVia,authUser,authPass);\n    }\n    trans.sendMessage(mail,mail.getAllRecipients());\n    results.put(\"messageWrapper\",new MimeMessageWrapper(session,mail));\n    results.put(\"messageId\",mail.getMessageID());\n    trans.close();\n  }\n catch (  SendFailedException e) {\n    Debug.logError(e,\"[ADDRERR] Address error when sending message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    List<SMTPAddressFailedException> failedAddresses=new LinkedList<SMTPAddressFailedException>();\n    Exception nestedException=null;\n    while ((nestedException=e.getNextException()) != null && nestedException instanceof MessagingException) {\n      if (nestedException instanceof SMTPAddressFailedException) {\n        SMTPAddressFailedException safe=(SMTPAddressFailedException)nestedException;\n        Debug.logError(\"Failed to send message to [\" + safe.getAddress() + \"], return code [\"+ safe.getReturnCode()+ \"], return message [\"+ safe.getMessage()+ \"]\",module);\n        failedAddresses.add(safe);\n        break;\n      }\n    }\n    Boolean sendFailureNotification=(Boolean)context.get(\"sendFailureNotification\");\n    if (sendFailureNotification == null || sendFailureNotification) {\n      sendFailureNotification(ctx,context,mail,failedAddresses);\n      results.put(\"messageWrapper\",new MimeMessageWrapper(session,mail));\n      try {\n        results.put(\"messageId\",mail.getMessageID());\n        trans.close();\n      }\n catch (      MessagingException e1) {\n        Debug.logError(e1,module);\n      }\n    }\n else {\n      return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendAddressError\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n    }\n  }\ncatch (  MessagingException e) {\n    Debug.logError(e,\"[CON] Connection error when sending message to [\" + sendTo + \"] from [\"+ sendFrom+ \"] cc [\"+ sendCc+ \"] bcc [\"+ sendBcc+ \"] subject [\"+ subject+ \"]\",module);\n    Debug.logError(\"Email message that could not be sent to [\" + sendTo + \"] had context: \"+ context,module);\n    return ServiceUtil.returnError(UtilProperties.getMessage(resource,\"CommonEmailSendConnectionError\",UtilMisc.toMap(\"sendTo\",sendTo,\"sendFrom\",sendFrom,\"sendCc\",sendCc,\"sendBcc\",sendBcc,\"subject\",subject),locale));\n  }\n  return results;\n}\n", "nl": "Basic JavaMail Service"}
{"code": "public void appendBytes(byte[] bs,int start,int len){\n  elems=ArrayUtils.ensureCapacity(elems,length + len);\n  System.arraycopy(bs,start,elems,length,len);\n  length+=len;\n}\n", "nl": "Append `len' bytes from byte array, starting at given `start' offset."}
{"code": "private void startScrolling(){\n  if (!isScrollingPerformed) {\n    isScrollingPerformed=true;\n    notifyScrollingListenersAboutStart();\n  }\n}\n", "nl": "Starts scrolling"}
{"code": "public void onProgressData(byte[] responseBody){\n  Log.d(LOG_TAG,\"onProgressData(byte[]) was not overriden, but callback was received\");\n}\n", "nl": "Fired when the request progress, override to handle in your own code"}
{"code": "public void writeAttribute(String name,String value,String prefix) throws Exception {\n  if (last != Tag.START) {\n    throw new NodeException(\"Start element required\");\n  }\n  write(' ');\n  write(name,prefix);\n  write('=');\n  write('\"');\n  escape(value);\n  write('\"');\n}\n", "nl": "This is used to write a name value attribute pair. If the last tag written was not a start tag then this throws an exception. All attribute values written are enclosed in double quotes."}
{"code": "private Border createNonRolloverToggleBorder(){\n  UIDefaults table=UIManager.getLookAndFeelDefaults();\n  return new CompoundBorder(new BasicBorders.RadioButtonBorder(table.getColor(\"ToggleButton.shadow\"),table.getColor(\"ToggleButton.darkShadow\"),table.getColor(\"ToggleButton.light\"),table.getColor(\"ToggleButton.highlight\")),new BasicBorders.RolloverMarginBorder());\n}\n", "nl": "Creates a non rollover border for Toggle buttons in the toolbar."}
{"code": "public int toReal(){\n  return _real;\n}\n", "nl": "Returns the real value."}
{"code": "private void addParsedAsAnnotations(final JCas jCas,final int offset,final Parse parsed){\n  final String type=parsed.getType();\n  if (OpenNLPParser.PHRASE_TYPES.contains(type)) {\n    final Span span=parsed.getSpan();\n    final PhraseChunk phraseChunk=new PhraseChunk(jCas);\n    phraseChunk.setBegin(offset + span.getStart());\n    phraseChunk.setEnd(offset + span.getEnd());\n    phraseChunk.setChunkType(parsed.getType());\n    addToJCasIndex(phraseChunk);\n  }\n  Arrays.stream(parsed.getChildren()).forEach(null);\n}\n", "nl": "Adds the parsed as annotations."}
{"code": "public static boolean isLocalContentUri(Uri uri){\n  final String scheme=getSchemeOrNull(uri);\n  return FrescoUri.LOCAL_CONTENT_SCHEME.equals(scheme);\n}\n", "nl": "Check if uri represents local content"}
{"code": "public XPathSubsetContentSelector(ContentManager cm,XBLOMContentElement content,Element bound,String selector){\n  super(cm,content,bound);\n  parseSelector(selector);\n}\n", "nl": "Creates a new XPathSubsetContentSelector object."}
{"code": "protected RestClient newPortalClient(){\n  URI baseUri=URI.create(String.format(\"%s://%s:%s\",protocol,host,portalPort));\n  return new RestClient(baseUri,this);\n}\n", "nl": "Creates the RestClient for the portal. This is provided here so Testcases are able to override the base implementation."}
{"code": "public int mainInit(final String[] args,final OutputStream out,final PrintStream err){\n  if (mCli == null) {\n    throw new RuntimeException(\"Incorrectly configured module\");\n  }\n  return mCli.mainInit(args,out,err);\n}\n", "nl": "Main init for running this module"}
{"code": "public Matrix sample_X(Matrix Z){\n  Matrix P_X=prob_X(Z);\n  return MatrixUtils.sample(P_X,m_R);\n}\n", "nl": "Sample Visible - returns X ~ P(X|Z). A bias column is assumed to be included."}
{"code": "public void reportTable(HSSFWorkbook book,LinkedList<ReportTO> data,HSSFSheet sheet,int fila){\n  HSSFRow row;\n  HSSFFont font=book.createFont();\n  font.setFontHeightInPoints((short)10);\n  font.setFontName(HSSFFont.FONT_ARIAL);\n  HSSFRichTextString text;\n  Iterator<ReportTO> itRep=data.iterator();\n  Boolean newRow=false;\n  sheet.setColumnWidth((short)0,(short)(13 * 256));\n  sheet.setColumnWidth((short)1,(short)(60 * 256));\n  for (int i=2; i < (cols); i++) {\n    sheet.setColumnWidth((short)i,(short)(15 * 256));\n  }\n  HSSFCellStyle cellStyle=book.createCellStyle();\n  HSSFCellStyle cellStyleD=book.createCellStyle();\n  HSSFCellStyle cellStyleN=book.createCellStyle();\n  while (itRep.hasNext()) {\n    short col=0;\n    ReportTO rpt=itRep.next();\n    if (!newRow) {\n      cellStyle=book.createCellStyle();\n      cellStyleD=book.createCellStyle();\n      cellStyleN=book.createCellStyle();\n    }\n    newRow=false;\n    if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"T\")) {\n      row=sheet.createRow(fila++);\n      HSSFFont fontT=book.createFont();\n      fontT.setFontHeightInPoints((short)12);\n      fontT.setFontName(HSSFFont.FONT_ARIAL);\n      fontT.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);\n      HSSFCellStyle cellStyleT=book.createCellStyle();\n      cellStyleT.setWrapText(true);\n      cellStyleT.setAlignment(HSSFCellStyle.ALIGN_CENTER);\n      cellStyleT.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyleT.setFont(fontT);\n      Region region=new Region(fila - 1,(short)0,fila - 1,endRegion);\n      sheet.addMergedRegion(region);\n      text=new HSSFRichTextString(rpt.getDescription());\n      HSSFCell cellT=row.createCell(col);\n      cellT.setCellStyle(cellStyleT);\n      cellT.setCellValue(text);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"L\")) {\n      cellStyle.setWrapText(true);\n      cellStyle.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyle.setBottomBorderColor((short)8);\n      cellStyleD.setWrapText(true);\n      cellStyleD.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyleD.setBottomBorderColor((short)8);\n      cellStyleN.setWrapText(true);\n      cellStyleN.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyleN.setBottomBorderColor((short)8);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"X\")) {\n      cellStyle.setWrapText(true);\n      cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyle.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyle.setBottomBorderColor((short)8);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"Z\")) {\n      cellStyle.setWrapText(true);\n      cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyle.setBorderTop(HSSFCellStyle.BORDER_DOUBLE);\n      cellStyle.setBottomBorderColor((short)8);\n      row=sheet.createRow(fila++);\n      ReportTO rptD=new ReportTO();\n      putRow(cellStyle,cellStyleD,cellStyleN,sheet,row,fila,rptD);\n      cellStyle=book.createCellStyle();\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"D\")) {\n      cellStyleD.setWrapText(true);\n      cellStyleD.setVerticalAlignment(HSSFCellStyle.VERTICAL_TOP);\n      cellStyleD.setBorderTop(HSSFCellStyle.BORDER_MEDIUM);\n      cellStyleD.setBottomBorderColor((short)8);\n      newRow=true;\n    }\n else     if (rpt.getReportlinestyle() != null && rpt.getReportlinestyle().equals(\"S\")) {\n      row=sheet.createRow(fila++);\n      newRow=true;\n    }\n else     if (rpt.getTablevel() != null && rpt.getTablevel() > 0) {\n      row=sheet.createRow(fila++);\n      String jerarchy=\"\";\n      for (int i=1; i <= rpt.getTablevel(); i++) {\n        jerarchy=jerarchy + \"   \";\n      }\n      Region region=new Region(fila - 1,(short)0,fila - 1,endRegion);\n      sheet.addMergedRegion(region);\n      text=new HSSFRichTextString(jerarchy + rpt.getDescription());\n      HSSFCell cellJ=row.createCell(col);\n      cellJ.setCellValue(text);\n      newRow=true;\n    }\n else {\n      row=sheet.createRow(fila++);\n      putRow(cellStyle,cellStyleD,cellStyleN,sheet,row,fila,rpt);\n    }\n  }\n}\n", "nl": "llena los datos del reporte - fill report data"}
{"code": "public static Bitmap drawableToBitmap(Drawable drawable){\n  int width=drawable.getIntrinsicWidth();\n  int height=drawable.getIntrinsicHeight();\n  Bitmap bitmap=Bitmap.createBitmap(width,height,drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);\n  Canvas canvas=new Canvas(bitmap);\n  drawable.setBounds(0,0,width,height);\n  drawable.draw(canvas);\n  return bitmap;\n}\n", "nl": "convert drawable to bitmap"}
{"code": "public XObject operate(XObject left,XObject right) throws javax.xml.transform.TransformerException {\n  return new XNumber(left.num() % right.num());\n}\n", "nl": "Apply the operation to two operands, and return the result."}
{"code": "public static void isTrue(boolean val){\n  if (!val)   throw new IllegalArgumentException(\"Must be true\");\n}\n", "nl": "Validates that the value is true"}
{"code": "private String pad(int n){\n  return n < 10 ? \"0\" + n : n + \"\";\n}\n", "nl": "Return n as padded string"}
{"code": "public static String toJSONString(Collection collection){\n  final StringWriter writer=new StringWriter();\n  try {\n    writeJSONString(collection,writer);\n    return writer.toString();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Convert a list to JSON text. The result is a JSON array.  If this list is also a JSONAware, JSONAware specific behaviours will be omitted at this top level."}
{"code": "protected Map<String,Object> itemToEntityResponse(String root_url){\n  return super.toEntityResponse(root_url);\n}\n", "nl": "Calls the superclass entity response not aggregated to this response."}
{"code": "private void drawDiscete(DiscreteUncertainObject uo,MarkerLibrary ml,int cnum,double size){\n  final int e=uo.getNumberSamples();\n  final double ssize=size * Math.sqrt(e);\n  for (int i=0; i < e; i++) {\n    final NumberVector s=uo.getSample(i);\n    if (s == null) {\n      continue;\n    }\n    double[] v=proj.fastProjectDataToRenderSpace(s);\n    if (v[0] != v[0] || v[1] != v[1]) {\n      continue;\n    }\n    ml.useMarker(svgp,layer,v[0],v[1],cnum,uo.getWeight(i) * ssize);\n  }\n}\n", "nl": "Visualize a discrete uncertain object"}
{"code": "private void checkSetup(){\nsynchronized (TransactionManagerImp.class) {\n    txmgr_=TransactionManagerImp.getTransactionManager();\n    if (txmgr_ == null) {\n      UserTransactionService uts=new UserTransactionServiceImp();\n      uts.init();\n      txmgr_=TransactionManagerImp.getTransactionManager();\n    }\n  }\n}\n", "nl": "Referenceable mechanism requires later setup of txmgr_, otherwise binding into JNDI already requires that TM is running."}
{"code": "public void writeExif(Bitmap bmap,String exifOutFileName) throws FileNotFoundException, IOException {\n  if (bmap == null || exifOutFileName == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=null;\n  try {\n    s=getExifWriterStream(exifOutFileName);\n    bmap.compress(Bitmap.CompressFormat.JPEG,90,s);\n    s.flush();\n  }\n catch (  IOException e) {\n    closeSilently(s);\n    throw e;\n  }\n  s.close();\n}\n", "nl": "Writes the tags from this ExifInterface object into a jpeg compressed bitmap, removing prior exif tags."}
{"code": "protected void sendPrepare(final String statementText) throws SQLException, IOException {\n  final XdrOutputStream xdrOut=getXdrOut();\n  xdrOut.writeInt(WireProtocolConstants.op_prepare_statement);\n  xdrOut.writeInt(getTransaction().getHandle());\n  xdrOut.writeInt(getHandle());\n  xdrOut.writeInt(getDatabase().getConnectionDialect());\n  xdrOut.writeString(statementText,getDatabase().getEncoding());\n  xdrOut.writeBuffer(getStatementInfoRequestItems());\n  xdrOut.writeInt(getDefaultSqlInfoSize());\n}\n", "nl": "Sends the statement prepare to the connection."}
{"code": "private void writeNetBuffer() throws IgniteCheckedException {\n  try {\n    ch.write(outNetBuf);\n  }\n catch (  IOException e) {\n    throw new IgniteCheckedException(\"Failed to write byte to socket.\",e);\n  }\n}\n", "nl": "Copies data from out net buffer and passes it to the underlying chain."}
{"code": "public Vector2f interpolate(Vector2f finalVec,float changeAmnt){\n  this.x=(1 - changeAmnt) * this.x + changeAmnt * finalVec.x;\n  this.y=(1 - changeAmnt) * this.y + changeAmnt * finalVec.y;\n  return this;\n}\n", "nl": "Sets this vector to the interpolation by changeAmnt from this to the finalVec this=(1-changeAmnt)*this + changeAmnt * finalVec"}
{"code": "public Compactor minorIndex(long index){\n  this.minorIndex=Math.max(this.minorIndex,index);\n  Segment segment=segments.segment(minorIndex);\n  if (segment != null) {\n    compactIndex=segment.firstIndex();\n  }\n  return this;\n}\n", "nl": "Sets the maximum compaction index for minor compaction."}
{"code": "public static BatchStatus createCreatedStatus(){\n  BatchStatus retval=new BatchStatus();\n  retval.setCode(HttpURLConnection.HTTP_CREATED);\n  retval.setReason(\"Created\");\n  return retval;\n}\n", "nl": "Creates a Success status object."}
{"code": "public final static NameValuePair parseNameValuePair(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=BasicHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  ParserCursor cursor=new ParserCursor(0,value.length());\n  return parser.parseNameValuePair(buffer,cursor);\n}\n", "nl": "Parses a name-value-pair with the given parser."}
{"code": "public void dismissSuggestions(){\n  if (mSuggestionsListView.getVisibility() == VISIBLE) {\n    mSuggestionsListView.setVisibility(GONE);\n  }\n}\n", "nl": "Dismiss the suggestions list."}
{"code": "private static boolean tagExists(final String tagTitle,final List<JSONObject> tags) throws JSONException {\n  for (  final JSONObject tag : tags) {\n    if (tag.getString(Tag.TAG_TITLE).equals(tagTitle)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Determines whether the specified tag title exists in the specified tags."}
{"code": "public Second(){\n  this(new Date());\n}\n", "nl": "Constructs a new Second, based on the system date/time."}
{"code": "private void launchReport(KeyNamePair pp){\n  MPrintFormat pf=MPrintFormat.get(Env.getCtx(),pp.getKey(),false);\n  launchReport(pf);\n}\n", "nl": "Launch Report"}
{"code": "public static Class<?> loadClassWithout(ClassLoader loader,String className) throws ClassNotFoundException {\n  MBEANSERVER_LOGGER.logp(Level.FINEST,DefaultLoaderRepository.class.getName(),\"loadClassWithout\",className);\n  return load(loader,className);\n}\n", "nl": "Go through the list of class loaders but exclude the given class loader, then try to load the requested class. The method will stop as soon as the class is found. If the class is not found the method will throw a <CODE>ClassNotFoundException</CODE> exception."}
{"code": "@Override public void mark(int readlimit){\n}\n", "nl": "Marks the current position in this stream. Setting a mark is not supported in this class; this implementation does nothing."}
{"code": "public void removeGenClass(SootClass clz){\n  genClasses.remove(clz.getName());\n}\n", "nl": "Remove a class from the list of gen classes."}
{"code": "public boolean isMultipleAssignmentDeclaration(){\n  return getLeftExpression() instanceof TupleExpression;\n}\n", "nl": "This method tells you if this declaration is a multiple assignment declaration, which  has the form \"def (x, y) = ...\" in Groovy. If this method returns true, then the left hand side is an ArgumentListExpression. Do not call \"getVariableExpression()\" on this  object if this method returns true, instead use \"getLeftExpression()\"."}
{"code": "public Bindings addOptComponent(String property,Class<? extends IValidatable> clazz,JToggleButton c){\n  return addOptComponent(property,clazz,c,false);\n}\n", "nl": "Add an optional (nullable) Java Bean component of type clazz."}
{"code": "public LUDecomposition lu(){\n  return new LUDecomposition(this);\n}\n", "nl": "LU Decomposition"}
{"code": "public static void addCombinerRecipe(ItemStack input,ItemStack output){\n  try {\n    Class recipeClass=Class.forName(\"mekanism.common.recipe.RecipeHandler\");\n    Method m=recipeClass.getMethod(\"addCombinerRecipe\",ItemStack.class,ItemStack.class);\n    m.invoke(null,input,output);\n  }\n catch (  Exception e) {\n    System.err.println(\"Error while adding recipe: \" + e.getMessage());\n  }\n}\n", "nl": "Add a Combiner recipe."}
{"code": "static void forceSetFactory2(LayoutInflater inflater,LayoutInflater.Factory2 factory){\n  if (!sCheckedField) {\n    try {\n      sLayoutInflaterFactory2Field=LayoutInflater.class.getDeclaredField(\"mFactory2\");\n      sLayoutInflaterFactory2Field.setAccessible(true);\n    }\n catch (    NoSuchFieldException e) {\n      Log.e(TAG,\"forceSetFactory2 Could not find field 'mFactory2' on class \" + LayoutInflater.class.getName() + \"; inflation may have unexpected results.\",e);\n    }\n    sCheckedField=true;\n  }\n  if (sLayoutInflaterFactory2Field != null) {\n    try {\n      sLayoutInflaterFactory2Field.set(inflater,factory);\n    }\n catch (    IllegalAccessException e) {\n      Log.e(TAG,\"forceSetFactory2 could not set the Factory2 on LayoutInflater \" + inflater + \"; inflation may have unexpected results.\",e);\n    }\n  }\n}\n", "nl": "For APIs >= 11 && < 21, there was a framework bug that prevented a LayoutInflater's Factory2 from being merged properly if set after a cloneInContext from a LayoutInflater that already had a Factory2 registered. We work around that bug here. If we can't we log an error."}
{"code": "public static XmlJmapper readAtRuntime(String xmlPath) throws MalformedURLException, IOException {\n  return toXmlJmapper(xmlPath,loadResource(xmlPath));\n}\n", "nl": "This method loads the xml file relative to xmlPath parameter. Read method is used for the xml manipulation at runtime."}
{"code": "protected double computeEyeDistance(DrawContext dc,ShapeData shapeData){\n  double minDistance=Double.MAX_VALUE;\n  Vec4 eyePoint=dc.getView().getEyePoint();\n  for (  Vec4 point : shapeData.getOuterBoundaryInfo().capVertices) {\n    double d=point.add3(shapeData.getReferencePoint()).distanceTo3(eyePoint);\n    if (d < minDistance)     minDistance=d;\n  }\n  return minDistance;\n}\n", "nl": "Computes the minimum distance between this shape and the eye point."}
{"code": "private <T extends DataObject>void updateInactiveField(Class<T> clazz,List<URI> keyList){\n  DbClient dbClient=getDbClient();\n  log.info(\"update inactive field for class: {}\",clazz.getSimpleName());\n  T object;\n  for (  URI key : keyList) {\n    try {\n      object=clazz.newInstance();\n      object.setId(key);\n      object.setInactive(false);\n    }\n catch (    Exception e) {\n      log.error(\"create new object of class({}) failed. e=\",clazz.getSimpleName(),e);\n      throw new IllegalStateException(e);\n    }\n    dbClient.updateAndReindexObject(object);\n    log.info(\"Update the inactive field of object(cf={}, id={}) to false\",object.getClass().getName(),object.getId());\n  }\n}\n", "nl": "Update the missed setting of \"inactive field\" for all data object"}
{"code": "public int compareTo(Object other){\n  if (!(other instanceof Resource)) {\n    throw new SwcException.NotAResource(other.getClass().getName());\n  }\n  Resource r=(Resource)other;\n  return getName().compareTo(r.getName());\n}\n", "nl": "delegates to a comparison of names."}
{"code": "public static void main(String[] args) throws InterruptedException {\n  Counter counter;\n  final int total=10000;\n  Thread[] threads=new Thread[total];\n  for (  Method method : Method.values()) {\n    counter=new Counter();\n    for (int i=0; i < threads.length; i++) {\n      threads[i]=new Thread(new Incrementer(counter,method));\n      threads[i].start();\n    }\n    for (int i=0; i < threads.length; i++) {\n      threads[i].join();\n    }\nswitch (method) {\ncase TwoStatements:\ncase OneStatement:\n      if (counter.total >= total) {\n        System.out.format(\"unlikely event: method %s: total: %d%n\",method,counter.total);\n      }\n    break;\ncase SynchronizedMethod:\ncase SynchronizedBlock:\ncase Semaphore:\ncase SemaphoreTry:\ncase Lock:\n  assert counter.total == total;\nbreak;\ncase AtomicInteger:\nassert counter.atomicTotal.get() == total;\nbreak;\n}\n}\nCounter.reentrantOuter();\nCounter.reentrantOuterBlock();\nCounter.reentrantOuterLock();\n}\n", "nl": "Increments a counter `total` times with different methods in multiple threads and checks if the result is correct (shoul equal `total`)."}
{"code": "public void reset(ActionMapping mapping,HttpServletRequest request){\n  puid=null;\n  op=null;\n  name=null;\n  canLookup=false;\n}\n", "nl": "Method reset"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:58:53.642 -0500\",hash_original_method=\"8F0255C2E086694196AF7CFC36B7EF43\",hash_generated_method=\"7E35C8E7189C135682BC48CACE7EFA68\") public boolean isMinInfoReady(){\n  return mIsMinInfoReady;\n}\n", "nl": "Check if subscription data has been assigned to mMin return true if MIN info is ready; false otherwise."}
{"code": "public Name(byte[] encoding) throws IOException {\n  DerInputStream in=new DerInputStream(encoding);\n  if (in.getEndOffset() != encoding.length) {\n    throw new IOException(\"Wrong content length\");\n  }\n  ASN1.decode(in);\n  this.rdn=(List<List<AttributeTypeAndValue>>)in.content;\n}\n", "nl": "Creates new <code>Name</code> instance from its DER encoding"}
{"code": "public double[][] distributionsForInstances(Instances insts) throws Exception {\n  if (getClassifier() instanceof BatchPredictor) {\n    Instances filteredInsts=Filter.useFilter(insts,m_Filter);\n    if (filteredInsts.numInstances() != insts.numInstances()) {\n      throw new WekaException(\"FilteredClassifier: filter has returned more/less instances than required.\");\n    }\n    return ((BatchPredictor)getClassifier()).distributionsForInstances(filteredInsts);\n  }\n else {\n    double[][] result=new double[insts.numInstances()][insts.numClasses()];\n    for (int i=0; i < insts.numInstances(); i++) {\n      result[i]=distributionForInstance(insts.instance(i));\n    }\n    return result;\n  }\n}\n", "nl": "Batch scoring method. Calls the appropriate method for the base learner if it implements BatchPredictor. Otherwise it simply calls the distributionForInstance() method repeatedly."}
{"code": "@Override public UserProjectObject copy(){\n  return new UserProjectObject(this);\n}\n", "nl": "This method was generated by MyBatis Generator. This method corresponds to the database table user_project"}
{"code": "public void addLogListener(LogListener l){\n  super.addLogListener(l);\n  for (  DatasetProvider provider : m_Providers)   provider.addLogListener(l);\n}\n", "nl": "Adds the log listener to use."}
{"code": "public static void closeSilently(Closeable out){\n  if (out != null) {\n    try {\n      trace(\"closeSilently\",null,out);\n      out.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Close an output stream without throwing an exception."}
{"code": "BitMatrix buildFunctionPattern(){\n  int dimension=getDimensionForVersion();\n  BitMatrix bitMatrix=new BitMatrix(dimension);\n  bitMatrix.setRegion(0,0,9,9);\n  bitMatrix.setRegion(dimension - 8,0,8,9);\n  bitMatrix.setRegion(0,dimension - 8,9,8);\n  int max=alignmentPatternCenters.length;\n  for (int x=0; x < max; x++) {\n    int i=alignmentPatternCenters[x] - 2;\n    for (int y=0; y < max; y++) {\n      if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {\n        continue;\n      }\n      bitMatrix.setRegion(alignmentPatternCenters[y] - 2,i,5,5);\n    }\n  }\n  bitMatrix.setRegion(6,9,1,dimension - 17);\n  bitMatrix.setRegion(9,6,dimension - 17,1);\n  if (versionNumber > 6) {\n    bitMatrix.setRegion(dimension - 11,0,3,6);\n    bitMatrix.setRegion(0,dimension - 11,6,3);\n  }\n  return bitMatrix;\n}\n", "nl": "See ISO 18004:2006 Annex E"}
{"code": "public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof VolumeDataset)) {\n    return false;\n  }\n  VolumeDataset that=(VolumeDataset)obj;\n  if (!this.xPosition.equals(that.xPosition)) {\n    return false;\n  }\n  return ObjectUtilities.equal(this.data,that.data);\n}\n", "nl": "Tests this instance for equality with an arbitrary object."}
{"code": "public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  doGet(request,response);\n}\n", "nl": "Process the HTTP Post request to simplify we reuse the doGet functionality"}
{"code": "public static <U extends Key<?>>KeyMatcher<U> keyEquals(U compareTo){\n  return new KeyMatcher<U>(compareTo);\n}\n", "nl": "Create a KeyMatcher that matches Keys that equal the given key."}
{"code": "public OverScroller(Context context,Interpolator interpolator,float bounceCoefficientX,float bounceCoefficientY){\n  this(context,interpolator,true);\n}\n", "nl": "Creates an OverScroller with flywheel enabled."}
{"code": "@Override public void execute() throws MojoExecutionException {\n  getLog().debug(\"Creating output directory \\\"\" + outputDirectory + \"\\\".\");\n  java.nio.file.Path outputDirectoryPath=Paths.get(outputDirectory.toURI());\n  if (!Files.exists(outputDirectoryPath)) {\n    try {\n      Files.createDirectories(outputDirectoryPath);\n    }\n catch (    IOException e) {\n      throw new MojoExecutionException(\"Unable to create directory for output path \\\"\" + outputDirectoryPath + \"\\\".\",e);\n    }\n  }\n  Swagger swagger=getSwagger();\n  ModelClassFinder modelClassFinder=new ModelClassFinder(getLog(),modelJavaPackage,modelErrorClassName);\n  RestControllerProcessor restControllerProcessor=new RestControllerProcessor(getLog(),swagger,restJavaPackage,tagPatternParameter,modelClassFinder.getModelErrorClass());\n  XsdParser xsdParser=null;\n  if (xsdName != null) {\n    xsdParser=new XsdParser(xsdName);\n  }\n  new DefinitionGenerator(getLog(),swagger,restControllerProcessor.getExampleClassNames(),modelClassFinder.getModelClasses(),xsdParser);\n  createYamlFile(swagger);\n}\n", "nl": "The main execution method for this Mojo."}
{"code": "public ActionErrors validate(ActionMapping mapping,HttpServletRequest request){\n  ActionErrors errors=new ActionErrors();\n  if (nivelAcceso < 0) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_REQUIRED,Messages.getString(Constants.ETIQUETA_NIVEL_ACCESO,request.getLocale())));\n  }\n  if ((nivelAcceso == NivelAcceso.RESTRINGIDO) && StringUtils.isBlank(idLCA)) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_REQUIRED,Messages.getString(Constants.ETIQUETA_LISTA_CONTROL_ACCESO,request.getLocale())));\n  }\n  return errors;\n}\n", "nl": "Valida el formulario"}
{"code": "@Override public Object readReply(Class expectedClass) throws Throwable {\n  int tag=read();\n  if (tag == 'R')   return readObject(expectedClass);\n else   if (tag == 'F') {\n    HashMap map=(HashMap)readObject(HashMap.class);\n    throw prepareFault(map);\n  }\n else {\n    StringBuilder sb=new StringBuilder();\n    sb.append((char)tag);\n    try {\n      int ch;\n      while ((ch=read()) >= 0) {\n        sb.append((char)ch);\n      }\n    }\n catch (    IOException e) {\n      log.log(Level.FINE,e.toString(),e);\n    }\n    throw error(\"expected hessian reply at \" + codeName(tag) + \"\\n\"+ sb);\n  }\n}\n", "nl": "Reads a reply as an object. If the reply has a fault, throws the exception."}
{"code": "@POST @Path(\"send\") @Consumes(MediaType.APPLICATION_JSON) public Response sendMail(EmailBeanDto emailBean){\n  File tempDir=null;\n  try {\n    MimeMessage message=new MimeMessage(sessionHolder.getMailSession());\n    Multipart contentPart=new MimeMultipart();\n    MimeBodyPart bodyPart=new MimeBodyPart();\n    bodyPart.setText(emailBean.getBody(),\"UTF-8\",getSubType(emailBean.getMimeType()));\n    contentPart.addBodyPart(bodyPart);\n    if (emailBean.getAttachments() != null) {\n      tempDir=Files.createTempDir();\n      for (      AttachmentDto attachmentDto : emailBean.getAttachments()) {\n        byte[] attachmentContent=Base64.getDecoder().decode(attachmentDto.getContent());\n        File attachmentFile=new File(tempDir,attachmentDto.getFileName());\n        Files.write(attachmentContent,attachmentFile);\n        MimeBodyPart attachmentPart=new MimeBodyPart();\n        attachmentPart.attachFile(attachmentFile);\n        attachmentPart.setContentID(\"<\" + attachmentDto.getContentId() + \">\");\n        contentPart.addBodyPart(attachmentPart);\n      }\n    }\n    message.setContent(contentPart);\n    message.setSubject(emailBean.getSubject(),\"UTF-8\");\n    message.setFrom(new InternetAddress(emailBean.getFrom(),true));\n    message.addRecipients(Message.RecipientType.TO,InternetAddress.parse(emailBean.getTo()));\n    if (emailBean.getReplyTo() != null) {\n      message.setReplyTo(InternetAddress.parse(emailBean.getReplyTo()));\n    }\n    LOG.info(\"Sending from {} to {} with subject {}\",emailBean.getFrom(),emailBean.getTo(),emailBean.getSubject());\n    Transport.send(message);\n    LOG.debug(\"Mail send\");\n  }\n catch (  MessagingException|IOException e) {\n    LOG.error(e.getLocalizedMessage());\n    throw new WebApplicationException(e);\n  }\n finally {\n    if (tempDir != null) {\n      try {\n        FileUtils.deleteDirectory(tempDir);\n      }\n catch (      IOException exception) {\n        LOG.error(exception.getMessage());\n      }\n    }\n  }\n  return Response.ok().build();\n}\n", "nl": "Send mail message. If you need to send more than one copy of email, then write needed receivers to EmailBean using setTo() method."}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "static String checkNotNullOrBlank(String value,String errorMessage,Object... args){\n  checkNotNull(value,errorMessage,args);\n  String trimmed=value.trim();\n  if (trimmed.isEmpty()) {\n    throw new IllegalArgumentException(String.format(errorMessage,args));\n  }\n  return trimmed;\n}\n", "nl": "Ensures that a String is not null and contains at least one non-whitespace char."}
{"code": "public boolean hasTrait(String ns,String ln){\n  return false;\n}\n", "nl": "Returns whether the given trait is available on this element."}
{"code": "@Override public synchronized void acceptTrainingSet(TrainingSetEvent e){\n  try {\n    m_Saver=makeCopy();\n  }\n catch (  Exception ex) {\n    if (m_logger != null) {\n      m_logger.statusMessage(statusMessagePrefix() + \"ERROR (See log for details)\");\n      m_logger.logMessage(\"[Saver] \" + statusMessagePrefix() + \" unable to copy saver. \"+ ex.getMessage());\n    }\n  }\n  passEnvOnToSaver();\n  m_fileName=sanitizeFilename(e.getTrainingSet().relationName());\n  m_dataSet=e.getTrainingSet();\n  if (e.isStructureOnly() && m_isDBSaver && ((DatabaseSaver)m_SaverTemplate).getRelationForTableName()) {\n    ((DatabaseSaver)m_Saver).setTableName(m_fileName);\n  }\n  if (!e.isStructureOnly()) {\n    if (!m_isDBSaver) {\n      try {\n        m_Saver.setDirAndPrefix(m_fileName,\"_training_\" + e.getSetNumber() + \"_of_\"+ e.getMaxSetNumber());\n      }\n catch (      Exception ex) {\n        System.out.println(ex);\n      }\n    }\n else {\n      ((DatabaseSaver)m_Saver).setRelationForTableName(false);\n      String setName=((DatabaseSaver)m_Saver).getTableName();\n      setName=setName.replaceFirst(\"_[tT][rR][aA][iI][nN][iI][nN][gG]_[0-9]+_[oO][fF]_[0-9]+\",\"\");\n      ((DatabaseSaver)m_Saver).setTableName(setName + \"_training_\" + e.getSetNumber()+ \"_of_\"+ e.getMaxSetNumber());\n    }\n    saveBatch();\n    System.out.println(\"... training set \" + e.getSetNumber() + \" of \"+ e.getMaxSetNumber()+ \" for relation \"+ m_fileName+ \" saved.\");\n  }\n}\n", "nl": "Method reacts to a training set event and starts the writing process in batch mode"}
{"code": "public boolean contains(final short[] a){\n  int i=d, l=a.length;\n  long bits[]=this.bits;\n  while (i-- != 0)   if (!get(bits,hash(a,l,i)))   return false;\n  return true;\n}\n", "nl": "Checks whether the given short array is in this filter."}
{"code": "public int hashCode(){\n  return 83 + start + 7 * end + (negated ? 1 : 0);\n}\n", "nl": "<p>Gets a hashCode compatible with the equals method.</p>"}
{"code": "@BeforeClass public static void beforeClass(){\n  PlayerTestHelper.generateNPCRPClasses();\n  MockStendlRPWorld.get();\n}\n", "nl": "Setup before running tests in this test class"}
{"code": "public void requestDestroyed(ServletRequestEvent event){\n  try {\n    ServletRequest request=event.getServletRequest();\n    for (Enumeration e=request.getAttributeNames(); e.hasMoreElements(); ) {\n      String beanName=(String)e.nextElement();\n      handleAttributeEvent(beanName,request.getAttribute(beanName),ELUtils.Scope.REQUEST);\n    }\n    WebConfiguration config=WebConfiguration.getInstance(event.getServletContext());\n    if (config.isOptionEnabled(WebConfiguration.BooleanWebContextInitParameter.EnableAgressiveSessionDirtying)) {\n      syncSessionScopedBeans(request);\n    }\n    boolean distributable=config.isOptionEnabled(EnableDistributable);\n    if (distributable) {\n      HttpSession session=((HttpServletRequest)request).getSession(false);\n      if (session != null && session.getAttribute(ACTIVE_VIEW_MAPS) != null) {\n        session.setAttribute(ACTIVE_VIEW_MAPS,session.getAttribute(ACTIVE_VIEW_MAPS));\n      }\n    }\n  }\n catch (  Throwable t) {\n    FacesContext context=new InitFacesContext(event.getServletContext());\n    ExceptionQueuedEventContext eventContext=new ExceptionQueuedEventContext(context,t);\n    context.getApplication().publishEvent(context,ExceptionQueuedEvent.class,eventContext);\n    context.getExceptionHandler().handle();\n  }\n finally {\n    ApplicationAssociate.setCurrentInstance(null);\n  }\n}\n", "nl": "The request is about to go out of scope of the web application."}
{"code": "public void testFailoverAutoFallBack() throws Exception {\n  Set<String> downedHosts=new HashSet<String>();\n  downedHosts.add(HOST_1);\n  downedHosts.add(HOST_3);\n  Properties props=new Properties();\n  props.setProperty(\"retriesAllDown\",\"2\");\n  props.setProperty(\"queriesBeforeRetryMaster\",\"10\");\n  props.setProperty(\"secondsBeforeRetryMaster\",\"1\");\n  for (  boolean autoCommit : new boolean[]{true,false}) {\n    Connection testConn=getUnreliableFailoverConnection(new String[]{HOST_1,HOST_2,HOST_3},props,downedHosts);\n    Statement testStmt=null;\n    try {\n      testConn.setAutoCommit(autoCommit);\n      assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      testStmt=testConn.createStatement();\n      assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n      UnreliableSocketFactory.dontDownHost(HOST_1);\n      UnreliableSocketFactory.dontDownHost(HOST_3);\n      long startTime=System.currentTimeMillis();\n      boolean hostSwitched=false;\n      do {\n        assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n        if (autoCommit) {\n          if (!hostSwitched && UnreliableSocketFactory.getHostFromLastConnection().equals(HOST_1_OK)) {\n            hostSwitched=true;\n          }\n          if (hostSwitched) {\n            assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n          }\n else {\n            assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n          }\n        }\n else {\n          assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n        }\n        try {\n          Thread.sleep(100);\n        }\n catch (        InterruptedException e) {\n        }\n      }\n while (System.currentTimeMillis() - startTime < 2000);\n      UnreliableSocketFactory.downHost(HOST_2);\n      if (autoCommit) {\n        assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      }\n else {\n        assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n        assertSQLException(testStmt,\"SELECT 1\",COMM_LINK_ERR_PATTERN);\n        assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      }\n      assertConnectionsHistory(HOST_2_OK,HOST_1_OK);\n    }\n  finally {\n      if (testStmt != null) {\n        testStmt.close();\n      }\n      if (testConn != null) {\n        testConn.close();\n      }\n    }\n  }\n  props.setProperty(\"queriesBeforeRetryMaster\",\"0\");\n  props.setProperty(\"secondsBeforeRetryMaster\",\"0\");\n  for (  boolean autoCommit : new boolean[]{true,false}) {\n    Connection testConn=getUnreliableFailoverConnection(new String[]{HOST_1,HOST_2,HOST_3},props,downedHosts);\n    Statement testStmt=null;\n    try {\n      testConn.setAutoCommit(autoCommit);\n      assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      testStmt=testConn.createStatement();\n      assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n      UnreliableSocketFactory.dontDownHost(HOST_1);\n      UnreliableSocketFactory.dontDownHost(HOST_3);\n      for (int i=0; i < 55; i++) {\n        assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n        assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      }\n      UnreliableSocketFactory.downHost(HOST_2);\n      assertEquals(HOST_2_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      assertSQLException(testStmt,\"SELECT 1\",COMM_LINK_ERR_PATTERN);\n      assertEquals(HOST_3_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      testStmt=testConn.createStatement();\n      assertSingleValueQuery(testStmt,\"SELECT 1\",1L);\n      UnreliableSocketFactory.dontDownHost(HOST_2);\n      UnreliableSocketFactory.downHost(HOST_3);\n      assertEquals(HOST_3_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      assertSQLException(testStmt,\"SELECT 1\",COMM_LINK_ERR_PATTERN);\n      assertEquals(HOST_1_OK,UnreliableSocketFactory.getHostFromLastConnection());\n      assertConnectionsHistory(HOST_2_OK,HOST_3_OK,HOST_1_OK);\n    }\n  finally {\n      if (testStmt != null) {\n        testStmt.close();\n      }\n      if (testConn != null) {\n        testConn.close();\n      }\n    }\n  }\n}\n", "nl": "Tests the automatic fall back to primary host in a failover connection using three hosts and the following sequence of events: + 1.st part: - [\\HOST_1 : /HOST_2 : \\HOST_3] --> HOST_2 - [/HOST_1 : /HOST_2 : /HOST_3] --> no_change vs HOST_1 (auto fall back) - [/HOST_1 : \\HOST_2 : /HOST_3] --> HOST_1 vs no_change + 2.nd part: - [\\HOST_1 : /HOST_2 : \\HOST_3] --> HOST_2 - [/HOST_1 : /HOST_2 : /HOST_3] --> no_change - [/HOST_1 : \\HOST_2 : /HOST_3] --> HOST_3 - [/HOST_1 : /HOST_2 : \\HOST_3] --> HOST_1 - /HOST_2 & \\HOST_3 The automatic fall back only happens at transaction boundaries and at least 'queriesBeforeRetryMaster' or 'secondsBeforeRetryMaster' is greater than 0. [Legend: \"/HOST_n\" --> HOST_n up; \"\\HOST_n\" --> HOST_n down]"}
{"code": "@Deprecated public static GamaRuntimeException error(final String s){\n  return error(s,GAMA.getRuntimeScope());\n}\n", "nl": "This method is deprecated. Use the equivalent method that passes the scope"}
{"code": "public Class load(String type) throws Exception {\n  ClassLoader loader=getClassLoader();\n  if (loader == null) {\n    loader=getCallerClassLoader();\n  }\n  return loader.loadClass(type);\n}\n", "nl": "This method is used to acquire the class of the specified name. Loading is performed by the thread context class loader as this will ensure that the class loading strategy can be changed as requirements dictate. Typically the thread context class loader can handle all serialization requirements."}
{"code": "private double euclideanDistance(DoubleArrayListWritable v1,DoubleArrayListWritable v2,int dim){\n  double distance=0.0;\n  for (int i=0; i < dim; i++) {\n    distance+=math.pow(v1.get(i).get() - v2.get(i).get(),2);\n  }\n  return math.sqrt(distance);\n}\n", "nl": "Calculates the Euclidean distance between two vectors of doubles"}
{"code": "private List<FacetResult> facetsWithSearch() throws IOException {\n  DirectoryReader indexReader=DirectoryReader.open(indexDir);\n  IndexSearcher searcher=new IndexSearcher(indexReader);\n  TaxonomyReader taxoReader=new DirectoryTaxonomyReader(taxoDir);\n  FacetsCollector fc=new FacetsCollector();\n  FacetsCollector.search(searcher,new MatchAllDocsQuery(),10,fc);\n  List<FacetResult> results=new ArrayList<>();\n  Facets facets=new FastTaxonomyFacetCounts(taxoReader,config,fc);\n  results.add(facets.getTopChildren(10,\"Author\"));\n  results.add(facets.getTopChildren(10,\"Publish Date\"));\n  indexReader.close();\n  taxoReader.close();\n  return results;\n}\n", "nl": "User runs a query and counts facets."}
{"code": "public boolean wasAtRest(){\n  return mWasAtRest;\n}\n", "nl": "Check if the spring was at rest in the prior iteration. This is used for ensuring the ending callbacks are fired as the spring comes to a rest."}
{"code": "protected CIMObjectPath createSubscription(CimFilterInfo filterInfo) throws WBEMException, ConnectionManagerException {\n  CIMObjectPath filterPath;\n  if (filterInfo instanceof CimManagedFilterInfo) {\n    filterPath=createFilter((CimManagedFilterInfo)filterInfo);\n  }\n else {\n    filterPath=getInstance(CimConstants.CIM_FILTER_NAME,filterInfo.getName()).getObjectPath();\n  }\n  s_logger.trace(\"filterPath :{}\",filterPath);\n  CIMProperty<?> filterProp=new CIMProperty<CIMObjectPath>(CimConstants.SUBSCRIPTION_PROP_FILTER,new CIMDataType(CimConstants.CIM_FILTER_NAME),filterPath);\n  CIMProperty<?> handlerProp=new CIMProperty<CIMObjectPath>(CimConstants.SUBSCRIPTION_PROP_HANDLER,new CIMDataType(CimConstants.CIM_HANDLER_NAME),getHandler());\n  s_logger.trace(\"filterProp :{}\",filterProp);\n  s_logger.trace(\"handlerProp :{}\",handlerProp);\n  CIMProperty<?>[] subscriptionProperties=new CIMProperty[]{filterProp,handlerProp};\n  CIMObjectPath subscriptionPath=createInstance(CimConstants.CIM_SUBSCRIPTION_NAME,subscriptionProperties);\n  _subscriptionPaths.add(subscriptionPath);\n  s_logger.trace(\"subscriptionPath :{}\",subscriptionPath);\n  return subscriptionPath;\n}\n", "nl": "Creates an indication subscription in the CIMOM for the given filter."}
{"code": "private void updatePopulation(int[] ids){\n  List<Integer> archivedIds=new ArrayList<Integer>();\n  for (  int id : ids) {\n    archivedIds.add(id);\n  }\n  solutions.keySet().retainAll(archivedIds);\n}\n", "nl": "Updates the population, retaining only those solutions with the specified identifiers."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private void initializeSparseSlider(){\n  sparsitySlider.setMajorTickSpacing(10);\n  sparsitySlider.setMinorTickSpacing(2);\n  sparsitySlider.setPaintTicks(true);\n  Hashtable<Integer,JLabel> labelTable2=new Hashtable<Integer,JLabel>();\n  labelTable2.put(new Integer(0),new JLabel(\"0%\"));\n  labelTable2.put(new Integer(100),new JLabel(\"100%\"));\n  sparsitySlider.setLabelTable(labelTable2);\n  sparsitySlider.setPaintLabels(true);\n}\n", "nl": "Initializes the sparse slider."}
{"code": "public boolean isStereo(){\n  return (channelMode != 3);\n}\n", "nl": "Whether stereo playback mode is used"}
{"code": "@Override public Overlay buildOverlay(MapView map,Style defaultStyle,Styler styler,KmlPlacemark kmlPlacemark,KmlDocument kmlDocument){\n  Marker marker=new Marker(map);\n  marker.setTitle(kmlPlacemark.mName);\n  marker.setSnippet(kmlPlacemark.mDescription);\n  marker.setSubDescription(kmlPlacemark.getExtendedDataAsText());\n  marker.setPosition(getPosition());\n  marker.setRelatedObject(this);\n  if (styler == null) {\n    applyDefaultStyling(marker,defaultStyle,kmlPlacemark,kmlDocument,map);\n  }\n else   styler.onPoint(marker,kmlPlacemark,this);\n  return marker;\n}\n", "nl": "Build the corresponding Marker overlay"}
{"code": "public static boolean startsWithIgnoreCase(String searchIn,String searchFor){\n  return startsWithIgnoreCase(searchIn,0,searchFor);\n}\n", "nl": "Determines whether or not the string 'searchIn' contains the string 'searchFor', dis-regarding case. Shorthand for a String.regionMatch(...)"}
{"code": "public void removeListener(ColorMapListener listener){\n  if (listener == null)   return;\n  listeners.remove(listener);\n}\n", "nl": "Remove a color map listener"}
{"code": "public T adwordsId(String value){\n  setString(ADWORDS_ID,value);\n  return (T)this;\n}\n", "nl": "<div class=\"ind\"> <p> Optional. </p> <p>Specifies the Google AdWords Id.</p> <table border=\"1\"> <tbody> <tr> <th>Parameter</th> <th>Value Type</th> <th>Default Value</th> <th>Max Length</th> <th>Supported Hit Types</th> </tr> <tr> <td><code>gclid</code></td> <td>text</td> <td><span class=\"none\">None</span> </td> <td><span class=\"none\">None</span> </td> <td>all</td> </tr> </tbody> </table> <div> Example value: <code>CL6Q-OXyqKUCFcgK2goddQuoHg</code><br> Example usage: <code>gclid=CL6Q-OXyqKUCFcgK2goddQuoHg</code> </div> </div>"}
{"code": "@HLEUnimplemented @HLEFunction(nid=0x9E8AAF8D,version=271) public int sceUsbCamGetZoom(TPointer32 zoomAddr){\n  zoomAddr.setValue(zoom);\n  return 0;\n}\n", "nl": "Gets the current zoom."}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase MappingPackage.OPERATION_SOURCE__OPERATION:\n    if (resolve)     return getOperation();\n  return basicGetOperation();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static boolean screenshot(Activity activity,String filePath){\n  View decorView=activity.getWindow().getDecorView();\n  decorView.setDrawingCacheEnabled(true);\n  decorView.buildDrawingCache();\n  Bitmap bitmap=decorView.getDrawingCache();\n  File imagePath=new File(filePath);\n  FileOutputStream fos=null;\n  try {\n    fos=new FileOutputStream(imagePath);\n    bitmap.compress(Bitmap.CompressFormat.JPEG,100,fos);\n    fos.flush();\n    return true;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n finally {\n    try {\n      fos.close();\n      if (null != bitmap) {\n        bitmap.recycle();\n        bitmap=null;\n      }\n    }\n catch (    Exception e) {\n    }\n    decorView.destroyDrawingCache();\n    decorView.setDrawingCacheEnabled(false);\n  }\n  return false;\n}\n", "nl": "take a screenshot"}
{"code": "private Counter<String> computeGradient(List<Datum> dataset,Counter<String> weights,int batchSize){\n  Counter<String> gradient=new ClassicCounter<String>(weights.keySet().size());\n  for (  Datum datum : dataset) {\n    double sum=0;\n    for (    String feature : datum.vX.keySet()) {\n      sum+=weights.getCount(feature) * datum.vX.getCount(feature);\n    }\n    double expSum, derivativeIncrement;\n    if (datum.label == Label.NEGATIVE) {\n      expSum=Math.exp(sum);\n      derivativeIncrement=1.0 / (1.0 + (1.0 / expSum));\n    }\n else {\n      expSum=Math.exp(-sum);\n      derivativeIncrement=-1.0 / (1.0 + (1.0 / expSum));\n    }\n    for (    String feature : datum.vX.keySet()) {\n      double g=datum.vX.getCount(feature) * derivativeIncrement;\n      gradient.incrementCount(feature,g);\n    }\n  }\n  if (this.l2Regularization && dataset.size() > 0) {\n    final Set<String> features=new HashSet<String>(weights.keySet());\n    features.addAll(gradient.keySet());\n    final double dataFraction=dataset.size() / ((double)2 * xi * tuneSetSize);\n    final double scaledSigmaSquared=sigmaSq / dataFraction;\n    for (    String key : features) {\n      double x=weights.getCount(key);\n      gradient.incrementCount(key,x / scaledSigmaSquared);\n    }\n  }\n  return gradient;\n}\n", "nl": "Compute the gradient for the specified set of PRO samples."}
{"code": "public void testSizingWithWidthConstraint(){\n  RectangleConstraint constraint=new RectangleConstraint(10.0,new Range(10.0,10.0),LengthConstraintType.FIXED,0.0,new Range(0.0,0.0),LengthConstraintType.NONE);\n  BlockContainer container=new BlockContainer(new BorderArrangement());\n  BufferedImage image=new BufferedImage(200,100,BufferedImage.TYPE_INT_RGB);\n  Graphics2D g2=image.createGraphics();\n  container.add(new EmptyBlock(5.0,6.0));\n  Size2D size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(6.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(15.0,16.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(7.0,20.0));\n  container.add(new EmptyBlock(8.0,45.6),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(5.4,3.2),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(14.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(45.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0));\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.TOP);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.LEFT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(12.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(65.6,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3));\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(77.9,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(77.9,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(21.0,12.3),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(10.0,20.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(12.3,45.6),RectangleEdge.BOTTOM);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(77.9,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(14.0,size.height,EPSILON);\n  container.clear();\n  container.add(new EmptyBlock(1.0,2.0),RectangleEdge.TOP);\n  container.add(new EmptyBlock(3.0,4.0),RectangleEdge.BOTTOM);\n  container.add(new EmptyBlock(5.0,6.0),RectangleEdge.LEFT);\n  container.add(new EmptyBlock(7.0,8.0),RectangleEdge.RIGHT);\n  container.add(new EmptyBlock(9.0,10.0));\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(16.0,size.height,EPSILON);\n  container.clear();\n  size=container.arrange(g2,constraint);\n  assertEquals(10.0,size.width,EPSILON);\n  assertEquals(0.0,size.height,EPSILON);\n}\n", "nl": "Run some checks on sizing when there is a fixed width constraint."}
{"code": "private void receivedFollowerOrSubscriberCount(FollowerInfo followerInfo){\n  if (followerInfo.requestError) {\n    return;\n  }\n  StreamInfo streamInfo=api.getStreamInfo(followerInfo.stream,null);\n  boolean changed=false;\n  if (followerInfo.type == Follower.Type.SUBSCRIBER) {\n    changed=streamInfo.setSubscriberCount(followerInfo.total);\n  }\n else   if (followerInfo.type == Follower.Type.FOLLOWER) {\n    changed=streamInfo.setFollowerCount(followerInfo.total);\n  }\n  if (changed && streamInfo.isValid()) {\n    streamStatusWriter.streamStatus(streamInfo);\n  }\n}\n", "nl": "Set follower/subscriber count in StreamInfo and send to Stream Status Writer."}
{"code": "public FrameSlot findOrAddFrameSlot(Object identifier,FrameSlotKind kind){\n  FrameSlot result=findFrameSlot(identifier);\n  if (result != null) {\n    return result;\n  }\n  return addFrameSlot(identifier,kind);\n}\n", "nl": "Finds an existing slot or creates new one. This is a slow operation."}
{"code": "private static boolean isValidVersionNumber(final String version){\n  if (version == null) {\n    return false;\n  }\n  final String[] parts=version.split(\"\\\\.\");\n  if (parts.length != 3) {\n    return false;\n  }\n  for (  final String part : parts) {\n    if (!Convert.isDecString(part)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Checks whether a given version string is a valid version string."}
{"code": "@ObjectiveCName(\"isInAppNotificationsEnabled\") public boolean isInAppNotificationsEnabled(){\n  return modules.getSettingsModule().isInAppEnabled();\n}\n", "nl": "Is in-app notifications enabled"}
{"code": "@Override public void intervalAdded(ListDataEvent event){\n  calculatePositionArray();\n  setPreferredSize(calculatePreferredSize());\n}\n", "nl": "Listen for items being added to the model."}
{"code": "public static MaterialColor fromInt(@ColorInt int color){\n  return new MaterialColor(color);\n}\n", "nl": "Create a MaterialColor from the provided color value."}
{"code": "public void shouldHandleThrowingFutureCallable(){\n  assertThrows(null,ExecutionException.class,IllegalArgumentException.class);\n  assertThrows(null,ExecutionException.class,IllegalArgumentException.class);\n  assertThrows(null,ExecutionException.class,IllegalArgumentException.class);\n}\n", "nl": "Assert handles a callable that throws instead of returning a future."}
{"code": "public CategoricalColumn(){\n  super(ColumnType.CATEGORICAL);\n}\n", "nl": "Instantiates a new categorical column."}
{"code": "@MethodDesc(description=\"Starts the replicator service\",usage=\"start\") public void start(boolean forceOffline) throws Exception {\n  try {\n    handleEventSynchronous(new StartEvent());\n    if (sm.getState().getName().equals(\"OFFLINE:NORMAL\")) {\n      boolean autoEnabled=new Boolean(properties.getBoolean(ReplicatorConf.AUTO_ENABLE));\n      if (!forceOffline && autoEnabled) {\n        logger.info(\"Replicator auto-enabling is engaged; going online automatically\");\n        online();\n      }\n    }\n  }\n catch (  Exception e) {\n    logger.error(\"Start operation failed\",e);\n    throw new Exception(\"Start operation failed: \" + e.getMessage());\n  }\n  this.doneLatch=new CountDownLatch(1);\n}\n", "nl": "Start Replicator Node Manager JMX service."}
{"code": "Alerter(AlertService service,int timeout,AtomicInteger jobCounter){\n  this.service=service;\n  this.timeout=timeout;\n  this.jobCounter=jobCounter;\n}\n", "nl": "Creates a new Alerter object."}
{"code": "private void removeAnyCallbacks(){\n  if (mPerformSearchRunnable != null) {\n    mHandler.removeCallbacks(mPerformSearchRunnable);\n  }\n}\n", "nl": "Removes any pending callbacks(if any) from the handler"}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase EipPackage.GATEWAY__NAME:\n    return getName();\ncase EipPackage.GATEWAY__TO_CHANNELS:\n  return getToChannels();\ncase EipPackage.GATEWAY__FROM_CHANNELS:\nreturn getFromChannels();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "static void appendDate(StringBuilder buff,long dateValue){\n  int y=DateTimeUtils.yearFromDateValue(dateValue);\n  int m=DateTimeUtils.monthFromDateValue(dateValue);\n  int d=DateTimeUtils.dayFromDateValue(dateValue);\n  if (y > 0 && y < 10000) {\n    StringUtils.appendZeroPadded(buff,4,y);\n  }\n else {\n    buff.append(y);\n  }\n  buff.append('-');\n  StringUtils.appendZeroPadded(buff,2,m);\n  buff.append('-');\n  StringUtils.appendZeroPadded(buff,2,d);\n}\n", "nl": "Append a date to the string builder."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:54.006 -0400\",hash_original_method=\"FFD73B06BFF281953B16F54803697DC3\",hash_generated_method=\"9914BD0B75BD9C1F8FA2F0E0462B401B\") protected FalseFileFilter(){\n}\n", "nl": "Restrictive consructor."}
{"code": "@Inline public static boolean fits(Word val,int bits){\n  Word o=val.rsha(bits - 1);\n  return (o.isZero() || o.isMax());\n}\n", "nl": "Finds out whether a given signed value can be represented in a given number of bits."}
{"code": "public static Map<String,Object> removeDuplicateScrumRevision(DispatchContext ctx,Map<String,? extends Object> context){\n  Delegator delegator=ctx.getDelegator();\n  LocalDispatcher dispatcher=ctx.getDispatcher();\n  String repositoryRoot=(String)context.get(\"repositoryRoot\");\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  try {\n    List<EntityCondition> exprsAnd=FastList.newInstance();\n    String revisionLink=repositoryRoot.substring(repositoryRoot.lastIndexOf(\"svn/\") + 4,repositoryRoot.length()) + \"&revision=\";\n    exprsAnd.add(EntityCondition.makeCondition(\"workEffortContentTypeId\",EntityOperator.EQUALS,\"TASK_SUB_INFO\"));\n    exprsAnd.add(EntityCondition.makeCondition(\"contentTypeId\",EntityOperator.EQUALS,\"DOCUMENT\"));\n    exprsAnd.add(EntityCondition.makeCondition(\"drObjectInfo\",EntityOperator.LIKE,revisionLink + \"%\"));\n    List<GenericValue> workEffortDataResourceList=EntityQuery.use(delegator).from(\"WorkEffortAndContentDataResource\").where(exprsAnd).queryList();\n    if (UtilValidate.isNotEmpty(workEffortDataResourceList)) {\n      Debug.logInfo(\"Total Content Size ============== >>>>>>>>>>> \" + workEffortDataResourceList.size(),module);\n      Set<String> keys=FastSet.newInstance();\n      Set<GenericValue> exclusions=FastSet.newInstance();\n      for (      GenericValue workEffort : workEffortDataResourceList) {\n        String drObjectInfo=workEffort.getString(\"drObjectInfo\");\n        if (keys.contains(drObjectInfo)) {\n          exclusions.add(workEffort);\n        }\n else {\n          keys.add(drObjectInfo);\n        }\n      }\n      Debug.logInfo(\"Remove size ============== >>>>>>>>>>> \" + exclusions.size(),module);\n      if (UtilValidate.isNotEmpty(exclusions)) {\n        for (        GenericValue contentResourceMap : exclusions) {\n          Debug.logInfo(\"Remove contentId ============== >>>>>>>>>>> \" + contentResourceMap.getString(\"contentId\"),module);\n          GenericValue dataResourceMap=EntityQuery.use(delegator).from(\"DataResource\").where(\"dataResourceId\",contentResourceMap.getString(\"dataResourceId\")).queryOne();\n          GenericValue contentMap=EntityQuery.use(delegator).from(\"Content\").where(\"contentId\",contentResourceMap.getString(\"contentId\")).queryOne();\n          contentMap.removeRelated(\"WorkEffortContent\");\n          contentMap.removeRelated(\"ContentRole\");\n          contentMap.remove();\n          dataResourceMap.removeRelated(\"DataResourceRole\");\n          dataResourceMap.remove();\n        }\n      }\n    }\n  }\n catch (  GenericEntityException entityEx) {\n    entityEx.printStackTrace();\n    return ServiceUtil.returnError(entityEx.getMessage());\n  }\n  return result;\n}\n", "nl": "removeDuplicateScrumRevision <p> Use for remove duplicate scrum revision"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private void checkCapture(GenericClassType genericClassType,ReferenceType paramType,ReferenceType actualArgType,List<TypedOperation> genericOperations){\n  InstantiatedType finalType=genericClassType.instantiate(actualArgType);\n  InstantiatedType instantiatedType=sourceType.instantiate(paramType);\n  Substitution<ReferenceType> substitution=instantiatedType.getTypeSubstitution();\n  for (  TypedOperation op : genericOperations) {\n    InstantiatedType argumentType=getArgumentType(op).apply(substitution);\n    InstantiatedType convertedArgumentType=argumentType.applyCaptureConversion();\n    List<TypeVariable> arguments=convertedArgumentType.getTypeParameters();\n    if (arguments.size() > 0) {\n      Substitution<ReferenceType> wcSubst=Substitution.forArgs(arguments,actualArgType);\n      convertedArgumentType=convertedArgumentType.apply(wcSubst);\n    }\n    if (op.hasWildcardTypes()) {\n      assertEquals(\"should be instantiated type for method \" + op.getName() + \" argument.\",finalType,convertedArgumentType);\n    }\n else {\n      assertEquals(\"should not be converted \" + op.getName(),argumentType,convertedArgumentType);\n    }\n  }\n}\n", "nl": "Checks the capture conversion over a set of types with wildcard (given as the input types to operations). Checks that the conversion followed by the substitution for the capture variable result in the class type instantiated by the actual argument type."}
{"code": "public static synchronized LogStream switchLog(final File newLog){\n  if (sLogStream != null) {\n    userLog(\"Switching logfile to:\" + newLog.getAbsolutePath());\n    final File file=sLogStream.file();\n    if (newLog.equals(file)) {\n      return sLogStream;\n    }\n    sLogStream.removeLog();\n  }\n  if (!newLog.getParentFile().exists()) {\n    if (!newLog.getParentFile().mkdirs()) {\n      throw new RuntimeException(\"Unable to create directory for log file.\");\n    }\n  }\n  sLogStream=new LogFile(newLog);\n  sLogClosed=false;\n  logEnvironment();\n  return sLogStream;\n}\n", "nl": "Switch the log to a (usually) different output file."}
{"code": "protected SimState(MersenneTwisterFast random,Schedule schedule){\n  this(0,random,schedule);\n}\n", "nl": "Creates a SimState with the given random number generator and schedule, and sets the seed to a bogus value (0).  This should only be used by SimState  subclasses which need to use an existing random number generator and schedule."}
{"code": "public void addEditor(){\n  removeEditor();\n  editor=comboBox.getEditor().getEditorComponent();\n  if (editor != null) {\n    configureEditor();\n    comboBox.add(editor);\n    if (comboBox.isFocusOwner()) {\n      editor.requestFocusInWindow();\n    }\n  }\n}\n", "nl": "This public method is implementation specific and should be private. do not call or override. To implement a specific editor create a custom <code>ComboBoxEditor</code>"}
{"code": "public void init(int value){\n  if (value == -1) {\n    throw new IllegalArgumentException(\"IntConstant cannot be initialized with a value of -1\");\n  }\nsynchronized (this) {\n    if (this.value != -1) {\n      throw new IllegalStateException(\"IntConstant already initialized!\");\n    }\n    this.value=value;\n  }\n}\n", "nl": "Initializes the constant. This method can only be called once."}
{"code": "public StAndrewsSimulation(long seed){\n  super(seed);\n}\n", "nl": "Create a new StAndrewsSimulation with the given randomization seed."}
{"code": "public AuthenticationNotSupportedException(){\n  super();\n}\n", "nl": "Constructs a new instance of AuthenticationNotSupportedException all name resolution fields and explanation initialized to null."}
{"code": "public synchronized void addMemberAsync(Contact contact){\n  notifyMemberJoined(contact);\n}\n", "nl": "Adds a member to this group. TODO: more docs on async callbacks."}
{"code": "public Record(){\n  super();\n  setEntity(new Entity(TYPE_ID));\n  getEntity().initDefaultValues(getTypeFactory());\n}\n", "nl": "Creates an empty asset"}
{"code": "@Override protected void makeCastlingMove(Move move){\n  FischerRandomUtils.makeCastlingMove(this,move,initialKingFile,initialShortRookFile,initialLongRookFile);\n}\n", "nl": "Overridden to handle special FR castling rules."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:29:52.081 -0500\",hash_original_method=\"0309B89A8A5C20FB439CB65AA9DE3FAA\",hash_generated_method=\"0309B89A8A5C20FB439CB65AA9DE3FAA\") void enforceSealed(){\n  if (!isSealed()) {\n    throw new IllegalStateException(\"Cannot perform this \" + \"action on a not sealed instance.\");\n  }\n}\n", "nl": "Enforces that this instance is sealed."}
{"code": "public void unload(){\n  GLES20.glDeleteShader(mVShaderHandle);\n  GLES20.glDeleteShader(mFShaderHandle);\n  GLES20.glDeleteProgram(mProgram);\n}\n", "nl": "Unloads and deletes references to the shader program"}
{"code": "default <T>T newInstance(Class<T> concreteClass){\n  try {\n    return concreteClass.newInstance();\n  }\n catch (  Exception ex) {\n    throw new UncheckedException(ex);\n  }\n}\n", "nl": "Called to construct actor."}
{"code": "@Override public boolean createFrom(final IScope scope,final List<Map<String,Object>> inits,final Integer max,final Object input,final Arguments init,final CreateStatement statement){\n  final GamaGridFile file=(GamaGridFile)input;\n  final int num=max == null ? file.length(scope) : CmnFastMath.min(file.length(scope),max);\n  for (int i=0; i < num; i++) {\n    final IShape g=file.get(scope,i);\n    final Map map=g.getOrCreateAttributes();\n    map.put(IKeyword.SHAPE,g);\n    statement.fillWithUserInit(scope,map);\n    inits.add(map);\n  }\n  return true;\n}\n", "nl": "Method createFrom() Method used to read initial values and attributes from a GRID file."}
{"code": "protected void processFiles(String ext,boolean recursive,File outDir,serverObjects post,File[] inFiles,List<File> processedFiles,Map<String,Throwable> failures) throws IOException {\n  for (  File inFile : inFiles) {\n    if (inFile.isDirectory()) {\n      if (recursive) {\n        File subDir=new File(outDir,inFile.getName());\n        subDir.mkdirs();\n        processFiles(ext,recursive,subDir,post,inFile.listFiles(),processedFiles,failures);\n      }\n    }\n else {\n      processedFiles.add(inFile);\n      processFile(ext,outDir,post,failures,inFile);\n    }\n  }\n}\n", "nl": "Process inFiles and update processedFiles list and failures map. All parameters must not be null."}
{"code": "private void languageComboChanged(){\n  String langName=(String)languageCombo.getSelectedItem();\n  Language language=Language.getLanguage(langName);\n  Language.setLoginLanguage(language);\n  Env.setContext(m_ctx,Env.LANGUAGE,language.getAD_Language());\n  Locale loc=language.getLocale();\n  Locale.setDefault(loc);\n  this.setLocale(loc);\n  res=ResourceBundle.getBundle(RESOURCE,loc);\n  this.setTitle(res.getString(\"Login\"));\n  hostLabel.setText(res.getString(\"Host\"));\n  userLabel.setText(res.getString(\"User\"));\n  userLabel.setToolTipText(res.getString(\"EnterUser\"));\n  passwordLabel.setText(res.getString(\"Password\"));\n  passwordLabel.setToolTipText(res.getString(\"EnterPassword\"));\n  languageLabel.setText(res.getString(\"Language\"));\n  languageLabel.setToolTipText(res.getString(\"SelectLanguage\"));\n  roleLabel.setText(res.getString(\"Role\"));\n  clientLabel.setText(res.getString(\"Client\"));\n  orgLabel.setText(res.getString(\"Organization\"));\n  dateLabel.setText(res.getString(\"Date\"));\n  warehouseLabel.setText(res.getString(\"Warehouse\"));\n  printerLabel.setText(res.getString(\"Printer\"));\n  defaultPanel.setToolTipText(res.getString(\"Defaults\"));\n  connectionPanel.setToolTipText(res.getString(\"Connection\"));\n  txt_NotConnected=res.getString(\"NotConnected\");\n  txt_NoDatabase=res.getString(\"DatabaseNotFound\");\n  txt_UserPwdError=res.getString(\"UserPwdError\");\n  txt_RoleError=res.getString(\"RoleNotFound\");\n  txt_LoggedIn=res.getString(\"Authorized\");\n  loginTabPane.setTitleAt(0,res.getString(\"Connection\"));\n  loginTabPane.setTitleAt(1,res.getString(\"Defaults\"));\n  confirmPanel.getOKButton().setToolTipText(res.getString(\"Ok\"));\n  confirmPanel.getCancelButton().setToolTipText(res.getString(\"Cancel\"));\n  dateField.setFormat();\n  dateField.setValue(new Timestamp(System.currentTimeMillis()));\n  if (m_connectionOK) {\n    this.setTitle(hostField.getDisplay());\n    statusBar.setStatusLine(txt_LoggedIn);\n  }\n else {\n    this.setTitle(res.getString(\"Login\"));\n    statusBar.setStatusLine(txt_NotConnected,true);\n  }\n}\n", "nl": "Change Language"}
{"code": "@Override protected void prepare(){\n  AD_User_ID=Env.getAD_User_ID(getCtx());\n  p_Record_ID=getRecord_ID();\n  for (  ProcessInfoParameter para : getParameter()) {\n    String name=para.getParameterName();\n    if (para.getParameter() == null)     ;\n else     if (name.equals(\"WM_Area_Type_ID\")) {\n      p_WM_Area_Type_ID=para.getParameterAsInt();\n    }\n else     if (name.equals(\"WM_Section_Type_ID\")) {\n      p_WM_Section_Type_ID=para.getParameterAsInt();\n    }\n else     if (name.equals(\"DeliveryRule\")) {\n      p_DeliveryRule=(String)para.getParameter();\n    }\n else     if (name.equals(\"DocAction\")) {\n      p_DocAction=(String)para.getParameter();\n    }\n else     if (name.equals(\"C_DocType_ID\")) {\n      p_C_DocType_ID=para.getParameterAsInt();\n    }\n else     if (name.equals(\"M_Locator_ID\")) {\n      p_M_Locator_ID=para.getParameterAsInt();\n      m_locator=new MLocator(getCtx(),p_M_Locator_ID,get_TrxName());\n    }\n else     if (name.equals(\"IsPrintPickList\")) {\n      p_IsPrintPickList=\"Y\".equals(para.getParameter());\n    }\n else     if (name.equals(\"IsCreateSupply\")) {\n      p_IsCreateSupply=\"Y\".equals(para.getParameter());\n    }\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n}\n", "nl": "Get Parameters"}
{"code": "private void buildSpellTables(){\n  try {\n    final SpellGroupsXMLLoader loader=new SpellGroupsXMLLoader(new URI(\"/data/conf/spells.xml\"));\n    List<DefaultSpell> loadedDefaultSpells=loader.load();\n    for (    DefaultSpell defaultSpell : loadedDefaultSpells) {\n      addSpell(defaultSpell);\n    }\n  }\n catch (  Exception e) {\n    LOGGER.error(\"spells.xml could not be loaded\",e);\n  }\n}\n", "nl": "builds the spell tables"}
{"code": "public LogEventReplReader(LogRecord logRecord,Serializer serializer,boolean checkCRC) throws ReplicatorException {\n  this.logRecord=logRecord;\n  this.serializer=serializer;\n  this.checkCRC=checkCRC;\n  try {\n    load();\n  }\n catch (  IOException e) {\n    throw new THLException(\"I/O error while loading log record header: offset=\" + logRecord.getOffset(),e);\n  }\n}\n", "nl": "Instantiate the reader and load header information."}
{"code": "public static IndexKeyRange bounded(IndexRowType indexRowType,IndexBound lo,boolean loInclusive,IndexBound hi,boolean hiInclusive){\n  if (lo == null || hi == null) {\n    throw new IllegalArgumentException(\"IndexBound arguments must not be null\");\n  }\n  return new IndexKeyRange(indexRowType,lo,loInclusive,hi,hiInclusive,IndexKind.CONVENTIONAL);\n}\n", "nl": "Describes a range of keys between lo and hi. The bounds are inclusive or not depending on loInclusive and hiInclusive. lo and hi must both be non-null. There are constraints on the bounds: - The ColumnSelectors for lo and hi must select for the same columns. - The selected columns must be leading columns of the index."}
{"code": "@Override public void updateRef(int columnIndex,Ref x) throws SQLException {\n  throw unsupported(\"ref\");\n}\n", "nl": "[Not supported]"}
{"code": "public NavigationModel(String id){\n  super(id);\n}\n", "nl": "Construct a new emtpy NavigationModel with the specified ID."}
{"code": "@NotNull default B append(double d) throws BufferOverflowException {\n  BytesInternal.append((StreamingDataOutput)this,d);\n  return (B)this;\n}\n", "nl": "Append a double in decimal notation"}
{"code": "@Entrypoint @UnpreemptibleNoWarn static void deliverHardwareException(int trapCode,Word trapInfo){\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"delivering hardware exception\");\n  RVMThread myThread=RVMThread.getCurrentThread();\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"we have a thread = \",Magic.objectAsAddress(myThread));\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"it's in state = \",myThread.getExecStatus());\n  AbstractRegisters exceptionRegisters=myThread.getExceptionRegisters();\n  if (VM.verboseSignalHandling)   VM.sysWriteln(\"we have exception registers = \",Magic.objectAsAddress(exceptionRegisters));\n  if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) && myThread.getStack().length < (StackFrameLayout.getMaxStackSize() >> LOG_BYTES_IN_ADDRESS) && !myThread.hasNativeStackFrame()) {\n    if (trapCode == TRAP_JNI_STACK) {\n      RVMThread.resizeCurrentStack(myThread.getStackLength() + StackFrameLayout.getJNIStackGrowthSize(),exceptionRegisters);\n    }\n else {\n      RVMThread.resizeCurrentStack(myThread.getStackLength() + StackFrameLayout.getStackGrowthSize(),exceptionRegisters);\n    }\n    if (VM.VerifyAssertions)     VM._assert(exceptionRegisters.getInUse());\n    exceptionRegisters.setInUse(false);\n    Magic.restoreHardwareExceptionState(exceptionRegisters);\n    if (VM.VerifyAssertions)     VM._assert(NOT_REACHED);\n  }\n  if (canForceGC()) {\n    System.gc();\n  }\n  if (!VM.sysFailInProgress()) {\n    Address fp=exceptionRegisters.getInnermostFramePointer();\n    int compiledMethodId=Magic.getCompiledMethodID(fp);\n    if (compiledMethodId != StackFrameLayout.getInvisibleMethodID()) {\n      CompiledMethod compiledMethod=CompiledMethods.getCompiledMethod(compiledMethodId);\n      Address ip=exceptionRegisters.getInnermostInstructionAddress();\n      Offset instructionOffset=compiledMethod.getInstructionOffset(ip);\n      if (compiledMethod.isWithinUninterruptibleCode(instructionOffset)) {\nswitch (trapCode) {\ncase TRAP_NULL_POINTER:\n          VM.sysWriteln(\"\\nFatal error: NullPointerException within uninterruptible region.\");\n        break;\ncase TRAP_ARRAY_BOUNDS:\n      VM.sysWriteln(\"\\nFatal error: ArrayIndexOutOfBoundsException within uninterruptible region (index was \",trapInfo.toInt(),\").\");\n    break;\ncase TRAP_DIVIDE_BY_ZERO:\n  VM.sysWriteln(\"\\nFatal error: DivideByZero within uninterruptible region.\");\nbreak;\ncase TRAP_STACK_OVERFLOW:\ncase TRAP_JNI_STACK:\nVM.sysWriteln(\"\\nFatal error: StackOverflowError within uninterruptible region.\");\nbreak;\ncase TRAP_CHECKCAST:\nVM.sysWriteln(\"\\nFatal error: ClassCastException within uninterruptible region.\");\nbreak;\ncase TRAP_MUST_IMPLEMENT:\nVM.sysWriteln(\"\\nFatal error: IncompatibleClassChangeError within uninterruptible region.\");\nbreak;\ncase TRAP_STORE_CHECK:\nVM.sysWriteln(\"\\nFatal error: ArrayStoreException within uninterruptible region.\");\nbreak;\ncase TRAP_UNREACHABLE_BYTECODE:\nVM.sysWriteln(\"\\nFatal error: Reached a bytecode that was determined to be unreachable within uninterruptible region.\");\nbreak;\ndefault :\nVM.sysWriteln(\"\\nFatal error: Unknown hardware trap within uninterruptible region.\");\nbreak;\n}\nVM.sysWriteln(\"trapCode = \",trapCode);\nVM.sysWriteln(\"trapInfo = \",trapInfo.toAddress());\nVM.sysFail(\"Exiting virtual machine due to uninterruptibility violation.\");\n}\n}\n}\nThrowable exceptionObject;\nswitch (trapCode) {\ncase TRAP_NULL_POINTER:\nexceptionObject=new java.lang.NullPointerException();\nbreak;\ncase TRAP_ARRAY_BOUNDS:\nexceptionObject=new java.lang.ArrayIndexOutOfBoundsException(trapInfo.toInt());\nbreak;\ncase TRAP_DIVIDE_BY_ZERO:\nexceptionObject=new java.lang.ArithmeticException();\nbreak;\ncase TRAP_STACK_OVERFLOW:\ncase TRAP_JNI_STACK:\nexceptionObject=new java.lang.StackOverflowError();\nbreak;\ncase TRAP_CHECKCAST:\nexceptionObject=new java.lang.ClassCastException();\nbreak;\ncase TRAP_MUST_IMPLEMENT:\nexceptionObject=new java.lang.IncompatibleClassChangeError();\nbreak;\ncase TRAP_STORE_CHECK:\nexceptionObject=new java.lang.ArrayStoreException();\nbreak;\ncase TRAP_UNREACHABLE_BYTECODE:\nexceptionObject=new java.lang.InternalError(UNREACHABLE_BC_MESSAGE);\nbreak;\ndefault :\nexceptionObject=new java.lang.UnknownError();\nRVMThread.traceback(\"UNKNOWN ERROR\");\nbreak;\n}\nVM.disableGC();\ndeliverException(exceptionObject,exceptionRegisters);\n}\n", "nl": "Deliver a hardware exception to current java thread. <p> Does not return. (stack is unwound, starting at trap site, and execution resumes in a catch block somewhere up the stack) /or/  execution resumes at instruction following trap (for TRAP_STACK_OVERFLOW) <p> Note:     Control reaches here by the actions of an external \"C\" signal handler which saves the register state of the trap site into the \"exceptionRegisters\" field of the current Thread object. The signal handler also inserts a &lt;hardware trap&gt; frame onto the stack immediately above this frame, for use by HardwareTrapGCMapIterator during garbage collection."}
{"code": "public static BigInteger[] transformRawSignature(byte[] raw) throws IOException {\n  BigInteger[] output=new BigInteger[2];\n  output[0]=new BigInteger(1,Arrays.copyOfRange(raw,0,32));\n  output[1]=new BigInteger(1,Arrays.copyOfRange(raw,32,64));\n  return output;\n}\n", "nl": "From byte[] to Big Integers r,s UAF_ALG_SIGN_SECP256K1_ECDSA_SHA256_RAW 0x05 An ECDSA signature on the secp256k1 curve which must have raw R and S buffers, encoded in big-endian order. I.e.[R (32 bytes), S (32 bytes)]"}
{"code": "public static void println(Object self,Object value){\n  if (self instanceof Writer) {\n    final PrintWriter pw=new GroovyPrintWriter((Writer)self);\n    pw.println(value);\n  }\n else {\n    System.out.println(InvokerHelper.toString(value));\n  }\n}\n", "nl": "Print a value formatted Groovy style (followed by a newline) to self if it is a Writer, otherwise to the standard output stream."}
{"code": "protected void checkProcessorVersion(Hashtable h){\n  if (null == h)   h=new Hashtable();\n  try {\n    final String XALAN1_VERSION_CLASS=\"org.apache.xalan.xslt.XSLProcessorVersion\";\n    Class clazz=ObjectFactory.findProviderClass(XALAN1_VERSION_CLASS,ObjectFactory.findClassLoader(),true);\n    StringBuffer buf=new StringBuffer();\n    Field f=clazz.getField(\"PRODUCT\");\n    buf.append(f.get(null));\n    buf.append(';');\n    f=clazz.getField(\"LANGUAGE\");\n    buf.append(f.get(null));\n    buf.append(';');\n    f=clazz.getField(\"S_VERSION\");\n    buf.append(f.get(null));\n    buf.append(';');\n    h.put(VERSION + \"xalan1\",buf.toString());\n  }\n catch (  Exception e1) {\n    h.put(VERSION + \"xalan1\",CLASS_NOTPRESENT);\n  }\n  try {\n    final String XALAN2_VERSION_CLASS=\"org.apache.xalan.processor.XSLProcessorVersion\";\n    Class clazz=ObjectFactory.findProviderClass(XALAN2_VERSION_CLASS,ObjectFactory.findClassLoader(),true);\n    StringBuffer buf=new StringBuffer();\n    Field f=clazz.getField(\"S_VERSION\");\n    buf.append(f.get(null));\n    h.put(VERSION + \"xalan2x\",buf.toString());\n  }\n catch (  Exception e2) {\n    h.put(VERSION + \"xalan2x\",CLASS_NOTPRESENT);\n  }\n  try {\n    final String XALAN2_2_VERSION_CLASS=\"org.apache.xalan.Version\";\n    final String XALAN2_2_VERSION_METHOD=\"getVersion\";\n    final Class noArgs[]=new Class[0];\n    Class clazz=ObjectFactory.findProviderClass(XALAN2_2_VERSION_CLASS,ObjectFactory.findClassLoader(),true);\n    Method method=clazz.getMethod(XALAN2_2_VERSION_METHOD,noArgs);\n    Object returnValue=method.invoke(null,new Object[0]);\n    h.put(VERSION + \"xalan2_2\",(String)returnValue);\n  }\n catch (  Exception e2) {\n    h.put(VERSION + \"xalan2_2\",CLASS_NOTPRESENT);\n  }\n}\n", "nl": "Report product version information from Xalan-J. Looks for version info in xalan.jar from Xalan-J products."}
{"code": "public void deinstall(JEditorPane c){\n  c.removeCaretListener(inputAttributeUpdater);\n  c.removePropertyChangeListener(inputAttributeUpdater);\n  currentRun=null;\n  currentParagraph=null;\n}\n", "nl": "Called when the kit is being removed from the JEditorPane.  This is used to unregister any listeners that were attached."}
{"code": "public void dismissAndSwitch(){\n  final int numIcons=mIcons.length;\n  RecentTag tag=null;\n  for (int i=0; i < numIcons; i++) {\n    if (mIcons[i].getVisibility() != View.VISIBLE) {\n      break;\n    }\n    if (i == 0 || mIcons[i].hasFocus()) {\n      tag=(RecentTag)mIcons[i].getTag();\n      if (mIcons[i].hasFocus()) {\n        break;\n      }\n    }\n  }\n  if (tag != null) {\n    switchTo(tag);\n  }\n  dismiss();\n}\n", "nl": "Dismiss the dialog and switch to the selected application."}
{"code": "public byte toReal(){\n  return _real;\n}\n", "nl": "Returns the real value."}
{"code": "public void updateParameterInfo(@NotNull final PyArgumentList arglist,@NotNull final UpdateParameterInfoContext context){\n  if (context.getParameterOwner() != arglist) {\n    context.removeHint();\n    return;\n  }\n  List<PyExpression> flat_args=PyUtil.flattenedParensAndLists(arglist.getArguments());\n  int alleged_cursor_offset=context.getOffset();\n  final TextRange argListTextRange=arglist.getTextRange();\n  if (!argListTextRange.contains(alleged_cursor_offset) && arglist.getText().endsWith(\")\")) {\n    context.removeHint();\n    return;\n  }\n  PsiFile file=context.getFile();\n  CharSequence chars=file.getViewProvider().getContents();\n  int offset=-1;\n  for (  PyExpression arg : flat_args) {\n    TextRange range=arg.getTextRange();\n    int left=CharArrayUtil.shiftBackward(chars,range.getStartOffset() - 1,\" \\t\\r\\n\");\n    int right=CharArrayUtil.shiftForwardCarefully(chars,range.getEndOffset(),\" \\t\\r\\n\");\n    if (arg.getParent() instanceof PyListLiteralExpression || arg.getParent() instanceof PyTupleExpression) {\n      right=CharArrayUtil.shiftForward(chars,range.getEndOffset(),\" \\t\\r\\n])\");\n    }\n    if (left <= alleged_cursor_offset && right >= alleged_cursor_offset) {\n      offset=range.getStartOffset();\n      break;\n    }\n  }\n  context.setCurrentParameter(offset);\n}\n", "nl": "<b>Note: instead of parameter index, we directly store parameter's offset for later use.</b><br/> We cannot store an index since we cannot determine what is an argument until we actually map arguments to parameters. This is because a tuple in arguments may be a whole argument or map to a tuple parameter."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:13.915 -0500\",hash_original_method=\"E54E1790034E06C2564EA8F8D322C604\",hash_generated_method=\"4A4D6596F1AA464E59CD29757B0A54BF\") @Deprecated public SslError(int error,SslCertificate certificate){\n  this(error,certificate,\"\");\n}\n", "nl": "Creates a new SslError object using the supplied error and certificate. The URL will be set to the empty string."}
{"code": "private static boolean hasXMPHeader(byte[] data){\n  if (data.length < XMP_HEADER_SIZE) {\n    return false;\n  }\n  try {\n    byte[] header=new byte[XMP_HEADER_SIZE];\n    System.arraycopy(data,0,header,0,XMP_HEADER_SIZE);\n    if (new String(header,\"UTF-8\").equals(XMP_HEADER)) {\n      return true;\n    }\n  }\n catch (  UnsupportedEncodingException e) {\n    return false;\n  }\n  return false;\n}\n", "nl": "Checks whether the byte array has XMP header. The XMP section contains a fixed length header XMP_HEADER."}
{"code": "public ButtonFactory(ResourceBundle rb,ActionMap am){\n  super(rb);\n  actions=am;\n}\n", "nl": "Creates a new button factory"}
{"code": "private void updateRangesFields(){\n  fRanges=(mask & ~(1 << 31));\n  fContextual=((mask & (1 << 31)) != 0);\n  if (fContextual) {\n    fRanges=(mask & ~(1 << 31));\n    fDefaultContextIndex=key;\n  }\n else {\n    fRanges=mask;\n    fSingleRangeIndex=key;\n  }\n}\n", "nl": "Updates all private serialized fields for object to be correctly serialized according to the serialized form of this class mentioned in the documentation."}
{"code": "public void startCountdown(int sec){\n  mCountdownView.startCountDown(sec);\n}\n", "nl": "Starts the countdown timer."}
{"code": "public long readLongFromXML(Element node) throws Exception {\n  if (DEBUG) {\n    trace(new Throwable(),node.getAttribute(ATT_NAME));\n  }\n  m_CurrentNode=node;\n  return ((Long)getPrimitive(node)).longValue();\n}\n", "nl": "builds the primitive from the given DOM node."}
{"code": "public static ZeroConfService create(String type,String name,int port,int weight,int priority,HashMap<String,String> properties){\n  ZeroConfService s;\n  if (ZeroConfService.services().containsKey(ZeroConfService.key(type,name))) {\n    s=ZeroConfService.services().get(ZeroConfService.key(type,name));\n    log.debug(\"Using existing ZeroConfService {}\",s.key());\n  }\n else {\n    properties.put(\"version\",jmri.Version.name());\n    properties.put(\"jmri\",jmri.Version.getCanonicalVersion());\n    properties.put(\"node\",NodeIdentity.identity());\n    s=new ZeroConfService(ServiceInfo.create(type,name,port,weight,priority,properties));\n    log.debug(\"Creating new ZeroConfService {} with properties {}\",s.key(),properties);\n  }\n  return s;\n}\n", "nl": "Create a ZeroConfService. The property <i>version</i> is added or replaced with the current JMRI version as its value. The property <i>jmri</i> is added or replaced with the JMRI major.minor.test version string as its value. <p> If a service with the same key as the new service is already published, the original service is returned unmodified."}
{"code": "public void cancelChallanReceiptOnCreation(final ReceiptHeader receiptHeader){\n  final ReceiptHeader receiptHeaderToBeCancelled=receiptHeaderService.findById(receiptHeader.getReceiptHeader().getId(),false);\n  receiptHeaderToBeCancelled.setStatus(collectionsUtil.getStatusForModuleAndCode(CollectionConstants.MODULE_NAME_RECEIPTHEADER,CollectionConstants.RECEIPT_STATUS_CODE_CANCELLED));\n  receiptHeaderService.persist(receiptHeaderToBeCancelled);\n}\n", "nl": "This method cancels the receipt against a challan. The reason for cancellation is set and the staus is changed to CANCELLED."}
{"code": "public static double nextDouble(double value,boolean increment){\n  return increment ? nextDouble(value) : previousDouble(value);\n}\n", "nl": "Returns the double value which is closest to the specified double but either larger or smaller as specified."}
{"code": "private void checkSourceVersionCompatibility(Source source,Log log){\n  SourceVersion procSourceVersion=processor.getSupportedSourceVersion();\n  if (procSourceVersion.compareTo(Source.toSourceVersion(source)) < 0) {\n    log.warning(\"proc.processor.incompatible.source.version\",procSourceVersion,Wrappers.unwrapProcessorClass(processor).getName(),source.name);\n  }\n}\n", "nl": "Checks whether or not a processor's source version is compatible with the compilation source version.  The processor's source version needs to be greater than or equal to the source version of the compile."}
{"code": "void openPolicy(String filename) throws FileNotFoundException, PolicyParser.ParsingException, KeyStoreException, CertificateException, InstantiationException, MalformedURLException, IOException, NoSuchAlgorithmException, IllegalAccessException, NoSuchMethodException, UnrecoverableKeyException, NoSuchProviderException, ClassNotFoundException, PropertyExpander.ExpandException, InvocationTargetException {\n  newWarning=false;\n  policyEntries=new Vector<PolicyEntry>();\n  parser=new PolicyParser();\n  warnings=new Vector<String>();\n  setPolicyFileName(null);\n  clearKeyStoreInfo();\n  if (filename == null) {\n    modified=false;\n    return;\n  }\n  setPolicyFileName(filename);\n  parser.read(new FileReader(filename));\n  openKeyStore(parser.getKeyStoreUrl(),parser.getKeyStoreType(),parser.getKeyStoreProvider(),parser.getStorePassURL());\n  Enumeration<PolicyParser.GrantEntry> enum_=parser.grantElements();\n  while (enum_.hasMoreElements()) {\n    PolicyParser.GrantEntry ge=enum_.nextElement();\n    if (ge.signedBy != null) {\n      String signers[]=parseSigners(ge.signedBy);\n      for (int i=0; i < signers.length; i++) {\n        PublicKey pubKey=getPublicKeyAlias(signers[i]);\n        if (pubKey == null) {\n          newWarning=true;\n          MessageFormat form=new MessageFormat(getMessage(\"Warning.A.public.key.for.alias.signers.i.does.not.exist.Make.sure.a.KeyStore.is.properly.configured.\"));\n          Object[] source={signers[i]};\n          warnings.addElement(form.format(source));\n        }\n      }\n    }\n    ListIterator<PolicyParser.PrincipalEntry> prinList=ge.principals.listIterator(0);\n    while (prinList.hasNext()) {\n      PolicyParser.PrincipalEntry pe=prinList.next();\n      try {\n        verifyPrincipal(pe.getPrincipalClass(),pe.getPrincipalName());\n      }\n catch (      ClassNotFoundException fnfe) {\n        newWarning=true;\n        MessageFormat form=new MessageFormat(getMessage(\"Warning.Class.not.found.class\"));\n        Object[] source={pe.getPrincipalClass()};\n        warnings.addElement(form.format(source));\n      }\n    }\n    Enumeration<PolicyParser.PermissionEntry> perms=ge.permissionElements();\n    while (perms.hasMoreElements()) {\n      PolicyParser.PermissionEntry pe=perms.nextElement();\n      try {\n        verifyPermission(pe.permission,pe.name,pe.action);\n      }\n catch (      ClassNotFoundException fnfe) {\n        newWarning=true;\n        MessageFormat form=new MessageFormat(getMessage(\"Warning.Class.not.found.class\"));\n        Object[] source={pe.permission};\n        warnings.addElement(form.format(source));\n      }\ncatch (      InvocationTargetException ite) {\n        newWarning=true;\n        MessageFormat form=new MessageFormat(getMessage(\"Warning.Invalid.argument.s.for.constructor.arg\"));\n        Object[] source={pe.permission};\n        warnings.addElement(form.format(source));\n      }\n      if (pe.signedBy != null) {\n        String signers[]=parseSigners(pe.signedBy);\n        for (int i=0; i < signers.length; i++) {\n          PublicKey pubKey=getPublicKeyAlias(signers[i]);\n          if (pubKey == null) {\n            newWarning=true;\n            MessageFormat form=new MessageFormat(getMessage(\"Warning.A.public.key.for.alias.signers.i.does.not.exist.Make.sure.a.KeyStore.is.properly.configured.\"));\n            Object[] source={signers[i]};\n            warnings.addElement(form.format(source));\n          }\n        }\n      }\n    }\n    PolicyEntry pEntry=new PolicyEntry(this,ge);\n    policyEntries.addElement(pEntry);\n  }\n  modified=false;\n}\n", "nl": "Open and read a policy file"}
{"code": "private T[] ensureCapacity(int minCapacity){\n  if (tmp.length < minCapacity) {\n    int newSize=minCapacity;\n    newSize|=newSize >> 1;\n    newSize|=newSize >> 2;\n    newSize|=newSize >> 4;\n    newSize|=newSize >> 8;\n    newSize|=newSize >> 16;\n    newSize++;\n    if (newSize < 0)     newSize=minCapacity;\n else     newSize=Math.min(newSize,a.length >>> 1);\n    @SuppressWarnings({\"unchecked\",\"UnnecessaryLocalVariable\"}) T[] newArray=(T[])new Object[newSize];\n    tmp=newArray;\n  }\n  return tmp;\n}\n", "nl": "Ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary.  The size increases exponentially to ensure amortized linear time complexity."}
{"code": "public static short[] toShortArray(int[] array){\n  short[] result=new short[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=(short)array[i];\n  }\n  return result;\n}\n", "nl": "Coverts given ints array to array of shorts."}
{"code": "public void deleteThreadVars() throws IOException {\n  print(\"deleteThreadVars\",null);\n}\n", "nl": "Description of the Method"}
{"code": "public static void main(String[] args){\n  try {\n    File testF=new File(new File(System.getProperty(\"user.dir\")),\"testOut.zip\");\n    OutputZipper oz=new OutputZipper(testF);\n    oz.zipit(\"Here is some test text to be zipped\",\"testzip\");\n    oz.zipit(\"Here is a second entry to be zipped\",\"testzip2\");\n    oz.finished();\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n    System.err.println(ex.getMessage());\n  }\n}\n", "nl": "Main method for testing this class"}
{"code": "public void createOffspring(Turkanian parent){\n  if (parent.energy <= birthEnergy) {\n    return;\n  }\n  Turkanian offspring=new Turkanian(this,parent.x,parent.y);\n  parent.energy-=birthEnergy;\n  offspring.energy=0;\n  agents.add(offspring);\n  agentGrid.setObjectLocation(offspring,offspring.x,offspring.y);\n  schedule.scheduleOnce(offspring);\n}\n", "nl": "Create offspring of the current agent and add them to the grid in the same cell."}
{"code": "public static <T>Supplier<T> prevNoDupSupplier(final Cursor cursor,ByteArrayConverter<T> converter){\n  DatabaseEntry key=new DatabaseEntry();\n  DatabaseEntry data=new DatabaseEntry();\n  return null;\n}\n", "nl": "Supplies previous key, ignore duplicates, produce the key value, NOT the associated data."}
{"code": "private static void enableObjectAddressRemapper(){\n  Magic.setObjectAddressRemapper(BootImageObjectAddressRemapper.getInstance());\n}\n", "nl": "Begin recording objects referenced by RVM classes during loading/resolution/instantiation.  These references will be converted to bootimage addresses when those objects are copied into bootimage."}
{"code": "public void transformNode(int node) throws TransformerException {\n  setExtensionsTable(getStylesheet());\nsynchronized (m_serializationHandler) {\n    m_hasBeenReset=false;\n    XPathContext xctxt=getXPathContext();\n    DTM dtm=xctxt.getDTM(node);\n    try {\n      pushGlobalVars(node);\n      StylesheetRoot stylesheet=this.getStylesheet();\n      int n=stylesheet.getGlobalImportCount();\n      for (int i=0; i < n; i++) {\n        StylesheetComposed imported=stylesheet.getGlobalImport(i);\n        int includedCount=imported.getIncludeCountComposed();\n        for (int j=-1; j < includedCount; j++) {\n          Stylesheet included=imported.getIncludeComposed(j);\n          included.runtimeInit(this);\n          for (ElemTemplateElement child=included.getFirstChildElem(); child != null; child=child.getNextSiblingElem()) {\n            child.runtimeInit(this);\n          }\n        }\n      }\n      DTMIterator dtmIter=new org.apache.xpath.axes.SelfIteratorNoPredicate();\n      dtmIter.setRoot(node,xctxt);\n      xctxt.pushContextNodeList(dtmIter);\n      try {\n        this.applyTemplateToNode(null,null,node);\n      }\n  finally {\n        xctxt.popContextNodeList();\n      }\n      if (null != m_serializationHandler) {\n        m_serializationHandler.endDocument();\n      }\n    }\n catch (    Exception se) {\n      while (se instanceof org.apache.xml.utils.WrappedRuntimeException) {\n        Exception e=((org.apache.xml.utils.WrappedRuntimeException)se).getException();\n        if (null != e)         se=e;\n      }\n      if (null != m_serializationHandler) {\n        try {\n          if (se instanceof org.xml.sax.SAXParseException)           m_serializationHandler.fatalError((org.xml.sax.SAXParseException)se);\n else           if (se instanceof TransformerException) {\n            TransformerException te=((TransformerException)se);\n            SAXSourceLocator sl=new SAXSourceLocator(te.getLocator());\n            m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(te.getMessage(),sl,te));\n          }\n else {\n            m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(se.getMessage(),new SAXSourceLocator(),se));\n          }\n        }\n catch (        Exception e) {\n        }\n      }\n      if (se instanceof TransformerException) {\n        m_errorHandler.fatalError((TransformerException)se);\n      }\n else       if (se instanceof org.xml.sax.SAXParseException) {\n        m_errorHandler.fatalError(new TransformerException(se.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)se),se));\n      }\n else {\n        m_errorHandler.fatalError(new TransformerException(se));\n      }\n    }\n finally {\n      this.reset();\n    }\n  }\n}\n", "nl": "Process the source node to the output result, if the processor supports the \"http://xml.org/trax/features/dom/input\" feature. %REVIEW% Do we need a Node version of this?"}
{"code": "@Override protected RdKNNEntry createRootEntry(){\n  return new RdKNNDirectoryEntry(0,null,Double.NaN);\n}\n", "nl": "Creates an entry representing the root node."}
{"code": "public static byte[] readBytes(Path self) throws IOException {\n  return Files.readAllBytes(self);\n}\n", "nl": "Reads the content of the file into a byte array."}
{"code": "public void showURLInBrowser(final URL url){\n  try {\n    if (Desktop.isDesktopSupported())     try {\n      Desktop.getDesktop().browse(url.toURI());\n      return;\n    }\n catch (    final Exception e) {\n    }\n    String[] cmdArray=null;\n    if (LEnv.OS == OpSys.WINDOWS) {\n      cmdArray=new String[]{\"rundll32\",\"url.dll,FileProtocolHandler\",url.toString()};\n    }\n else {\n      final String[] browsers={\"firefox\",\"google-chrome\",\"opera\",\"konqueror\",\"epiphany\",\"mozilla\",\"netscape\"};\n      for (      final String browser : browsers)       if (Runtime.getRuntime().exec(new String[]{\"which\",browser}).waitFor() == 0) {\n        cmdArray=new String[]{browser,url.toString()};\n        break;\n      }\n    }\n    if (cmdArray != null)     Runtime.getRuntime().exec(cmdArray);\n  }\n catch (  final Exception e) {\n    LEnv.LOGGER.info(\"Failed to open URL: \" + url,e);\n  }\n}\n", "nl": "Opens the web page specified by the URL in the system's default browser."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void addInputProducer(PValue expandedInput,TransformTreeNode producer){\n  checkState(!finishedSpecifying);\n  inputs.put(expandedInput,producer);\n}\n", "nl": "Adds an input to the transform node."}
{"code": "public Clustering<Model> run(Relation<Model> relation){\n  HashMap<Model,ModifiableDBIDs> modelMap=new HashMap<>();\n  for (DBIDIter iditer=relation.iterDBIDs(); iditer.valid(); iditer.advance()) {\n    Model model=relation.get(iditer);\n    ModifiableDBIDs modelids=modelMap.get(model);\n    if (modelids == null) {\n      modelids=DBIDUtil.newHashSet();\n      modelMap.put(model,modelids);\n    }\n    modelids.add(iditer);\n  }\n  Clustering<Model> result=new Clustering<>(\"By Model Clustering\",\"bymodel-clustering\");\n  for (  Entry<Model,ModifiableDBIDs> entry : modelMap.entrySet()) {\n    final Model model=entry.getKey();\n    final ModifiableDBIDs ids=entry.getValue();\n    final String name=(model instanceof GeneratorInterface) ? ((GeneratorInterface)model).getName() : model.toString();\n    Cluster<Model> c=new Cluster<>(name,ids,model);\n    if (noisepattern != null && noisepattern.matcher(name).find()) {\n      c.setNoise(true);\n    }\n    result.addToplevelCluster(c);\n  }\n  return result;\n}\n", "nl": "Run the actual clustering algorithm."}
{"code": "String rrToString(){\n  StringBuffer sb=new StringBuffer();\n  sb.append(Type.string(covered));\n  sb.append(\" \");\n  sb.append(alg);\n  sb.append(\" \");\n  sb.append(labels);\n  sb.append(\" \");\n  sb.append(origttl);\n  sb.append(\" \");\n  if (Options.check(\"multiline\"))   sb.append(\"(\\n\\t\");\n  sb.append(FormattedTime.format(expire));\n  sb.append(\" \");\n  sb.append(FormattedTime.format(timeSigned));\n  sb.append(\" \");\n  sb.append(footprint);\n  sb.append(\" \");\n  sb.append(signer);\n  if (Options.check(\"multiline\")) {\n    sb.append(\"\\n\");\n    sb.append(base64.formatString(signature,64,\"\\t\",true));\n  }\n else {\n    sb.append(\" \");\n    sb.append(base64.toString(signature));\n  }\n  return sb.toString();\n}\n", "nl": "Converts the RRSIG/SIG Record to a String"}
{"code": "private boolean isModel(JavaContext context,Node classDeclaration){\n  String classFilePackage=PackageManager.getPackage(context,classDeclaration);\n  return classFilePackage.contains(\".models.\");\n}\n", "nl": "Check if a class is a Model (is inside a package called 'models')."}
{"code": "public void addPlugin(final IPlugin<IPluginInterface> plugin){\n  Preconditions.checkNotNull(plugin,\"Error: Plugin argument can not be null\");\n  m_registry.addPlugin(plugin);\n}\n", "nl": "Add a new plugin to the list of registered plugins."}
{"code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n  s.writeInt(table.length);\n  s.writeInt(count);\n  for (int index=table.length - 1; index >= 0; index--) {\n    Entry entry=table[index];\n    while (entry != null) {\n      s.writeObject(entry.key);\n      s.writeObject(entry.value);\n      entry=entry.next;\n    }\n  }\n}\n", "nl": "Save the state of the <tt>IdentityHashMap</tt> instance to a stream (i.e., serialize it)."}
{"code": "@Override protected void mouseClicked(int par1,int par2,int par3) throws IOException {\n  super.mouseClicked(par1,par2,par3);\n  tokenBox.mouseClicked(par1,par2,par3);\n  if (tokenBox.isFocused()) {\n    errorText=\"\";\n    helpText=\"\";\n  }\n}\n", "nl": "Called when the mouse is clicked."}
{"code": "public Object call(Object object,String name,Object[] args) throws BSFException {\n  if (object == null) {\n    try {\n      object=interpreter.get(\"global\");\n    }\n catch (    EvalError e) {\n      throw new BSFException(\"bsh internal error: \" + e.toString());\n    }\n  }\n  if (object instanceof bsh.This) {\n    try {\n      return ((bsh.This)object).invokeMethod(name,args);\n    }\n catch (    InterpreterError e) {\n      throw new BSFException(\"BeanShell interpreter internal error: \" + e);\n    }\ncatch (    TargetError e2) {\n      throw new BSFException(\"The application script threw an exception: \" + e2.getTarget());\n    }\ncatch (    EvalError e3) {\n      throw new BSFException(\"BeanShell script error: \" + e3);\n    }\n  }\n else {\n    throw new BSFException(\"Cannot invoke method: \" + name + \". Object: \"+ object+ \" is not a BeanShell scripted object.\");\n  }\n}\n", "nl": "Invoke method name on the specified bsh scripted object. The object may be null to indicate the global namespace of the interpreter."}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:31:30.536 -0500\",hash_original_method=\"55F676D436FF1EC67ECC1C028E81ED27\",hash_generated_method=\"AC9FD73229CF68305BF944740C6C29B7\") private View moveSelection(int delta,int childrenTop,int childrenBottom){\n  final int fadingEdgeLength=getVerticalFadingEdgeLength();\n  final int selectedPosition=mSelectedPosition;\n  final int numColumns=mNumColumns;\n  final int verticalSpacing=mVerticalSpacing;\n  int oldRowStart;\n  int rowStart;\n  int rowEnd=-1;\n  if (!mStackFromBottom) {\n    oldRowStart=(selectedPosition - delta) - ((selectedPosition - delta) % numColumns);\n    rowStart=selectedPosition - (selectedPosition % numColumns);\n  }\n else {\n    int invertedSelection=mItemCount - 1 - selectedPosition;\n    rowEnd=mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));\n    rowStart=Math.max(0,rowEnd - numColumns + 1);\n    invertedSelection=mItemCount - 1 - (selectedPosition - delta);\n    oldRowStart=mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));\n    oldRowStart=Math.max(0,oldRowStart - numColumns + 1);\n  }\n  final int rowDelta=rowStart - oldRowStart;\n  final int topSelectionPixel=getTopSelectionPixel(childrenTop,fadingEdgeLength,rowStart);\n  final int bottomSelectionPixel=getBottomSelectionPixel(childrenBottom,fadingEdgeLength,numColumns,rowStart);\n  mFirstPosition=rowStart;\n  View sel;\n  View referenceView;\n  if (rowDelta > 0) {\n    final int oldBottom=mReferenceViewInSelectedRow == null ? 0 : mReferenceViewInSelectedRow.getBottom();\n    sel=makeRow(mStackFromBottom ? rowEnd : rowStart,oldBottom + verticalSpacing,true);\n    referenceView=mReferenceView;\n    adjustForBottomFadingEdge(referenceView,topSelectionPixel,bottomSelectionPixel);\n  }\n else   if (rowDelta < 0) {\n    final int oldTop=mReferenceViewInSelectedRow == null ? 0 : mReferenceViewInSelectedRow.getTop();\n    sel=makeRow(mStackFromBottom ? rowEnd : rowStart,oldTop - verticalSpacing,false);\n    referenceView=mReferenceView;\n    adjustForTopFadingEdge(referenceView,topSelectionPixel,bottomSelectionPixel);\n  }\n else {\n    final int oldTop=mReferenceViewInSelectedRow == null ? 0 : mReferenceViewInSelectedRow.getTop();\n    sel=makeRow(mStackFromBottom ? rowEnd : rowStart,oldTop,true);\n    referenceView=mReferenceView;\n  }\n  if (!mStackFromBottom) {\n    fillUp(rowStart - numColumns,referenceView.getTop() - verticalSpacing);\n    adjustViewsUpOrDown();\n    fillDown(rowStart + numColumns,referenceView.getBottom() + verticalSpacing);\n  }\n else {\n    fillDown(rowEnd + numColumns,referenceView.getBottom() + verticalSpacing);\n    adjustViewsUpOrDown();\n    fillUp(rowStart - 1,referenceView.getTop() - verticalSpacing);\n  }\n  return sel;\n}\n", "nl": "Fills the grid based on positioning the new selection relative to the old selection. The new selection will be placed at, above, or below the location of the new selection depending on how the selection is moving. The selection will then be pinned to the visible part of the screen, excluding the edges that are faded. The grid is then filled upwards and downwards from there."}
{"code": "public synchronized void clear(){\n  super.clear();\n  mValue.clear();\n  initRange();\n}\n", "nl": "Removes all the values from the series."}
{"code": "public static void fill(int[][][] matrix,int value){\n  int rows=matrix.length;\n  for (int r=0; r < rows; r++) {\n    int cols=matrix[r].length;\n    for (int c=0; c < cols; c++) {\n      int height=matrix[r][c].length;\n      for (int h=0; h < height; h++) {\n        matrix[r][c][h]=value;\n      }\n    }\n  }\n}\n", "nl": "Initialises all values in the matrix to the given value"}
{"code": "@Override public int hashCode(){\n  if (m_RecalcHashCode) {\n    m_HashCode=toString().hashCode();\n    m_RecalcHashCode=false;\n  }\n  return m_HashCode;\n}\n", "nl": "Returns the hash code value for this collection."}
{"code": "@Override public int intValue(){\n  return value;\n}\n", "nl": "Returns the value of this MutableInt as an int."}
{"code": "public DefaultDeployableFactory(ClassLoader classLoader){\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.WAR,WAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.EJB,EJB.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.EAR,EAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.SAR,SAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.RAR,RAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.FILE,File.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.BUNDLE,Bundle.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.HAR,HAR.class);\n  registerDeployable(DEFAULT_CONTAINER_ID,DeployableType.AOP,AOP.class);\n  AbstractFactoryRegistry.register(classLoader,this);\n}\n", "nl": "Register deployable classes mappings."}
{"code": "public VarInt(long value){\n  this.value=value;\n  originallyEncodedSize=getSizeInBytes();\n}\n", "nl": "Constructs a new VarInt with the given unsigned long value."}
{"code": "public void makeClass(Vector v,boolean caseless){\n  makeClass(new IntCharSet(v),caseless);\n}\n", "nl": "Updates the current partition, so that the specified set of characters gets a new character class. Characters that are elements of the set <code>v</code> are not in the same equivalence class with characters that are not elements of the set <code>v</code>."}
{"code": "@POST @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Path(\"/{id}/deactivate\") @CheckPermission(roles={Role.TENANT_ADMIN},acls={ACL.ANY}) public TaskList deactivateSnapshot(@PathParam(\"id\") URI id,@DefaultValue(\"FULL\") @QueryParam(\"type\") String type){\n  _log.info(\"Executing {} snapshot delete for snapshot {}\",type,id);\n  String opStage=null;\n  boolean successStatus=true;\n  String taskId=UUID.randomUUID().toString();\n  TaskList response=new TaskList();\n  BlockSnapshot snap=(BlockSnapshot)queryResource(id);\n  List<Class<? extends DataObject>> excludeTypes=new ArrayList<Class<? extends DataObject>>();\n  excludeTypes.add(BlockSnapshotSession.class);\n  if (VolumeDeleteTypeEnum.VIPR_ONLY.name().equals(type)) {\n    excludeTypes.add(ExportGroup.class);\n    excludeTypes.add(ExportMask.class);\n  }\n  ArgValidator.checkReference(BlockSnapshot.class,id,checkForDelete(snap,excludeTypes));\n  if (!VolumeDeleteTypeEnum.VIPR_ONLY.name().equals(type)) {\n    opStage=AuditLogManager.AUDITOP_BEGIN;\n    URIQueryResultList snapSessionURIs=new URIQueryResultList();\n    _dbClient.queryByConstraint(ContainmentConstraint.Factory.getLinkedTargetSnapshotSessionConstraint(id),snapSessionURIs);\n    Iterator<URI> snapSessionURIsIter=snapSessionURIs.iterator();\n    if (snapSessionURIsIter.hasNext()) {\n      _log.info(\"Snapshot is linked target for a snapshot session\");\n      SnapshotSessionUnlinkTargetsParam param=new SnapshotSessionUnlinkTargetsParam();\n      List<SnapshotSessionUnlinkTargetParam> targetInfoList=new ArrayList<SnapshotSessionUnlinkTargetParam>();\n      SnapshotSessionUnlinkTargetParam targetInfo=new SnapshotSessionUnlinkTargetParam(id,Boolean.TRUE);\n      targetInfoList.add(targetInfo);\n      param.setLinkedTargets(targetInfoList);\n      response.getTaskList().add(getSnapshotSessionManager().unlinkTargetVolumesFromSnapshotSession(snapSessionURIsIter.next(),param,OperationTypeEnum.DELETE_VOLUME_SNAPSHOT));\n      return response;\n    }\n    if (snap.getInactive()) {\n      _log.info(\"Snapshot is already inactive\");\n      Operation op=new Operation();\n      op.ready(\"The snapshot has already been deleted\");\n      op.setResourceType(ResourceOperationTypeEnum.DELETE_VOLUME_SNAPSHOT);\n      _dbClient.createTaskOpStatus(BlockSnapshot.class,snap.getId(),taskId,op);\n      response.getTaskList().add(toTask(snap,taskId,op));\n      return response;\n    }\n  }\n  StorageSystem device=_dbClient.queryObject(StorageSystem.class,snap.getStorageController());\n  List<BlockSnapshot> snapshots=new ArrayList<BlockSnapshot>();\n  final URI cgId=snap.getConsistencyGroup();\n  if (!NullColumnValueGetter.isNullURI(cgId) && !NullColumnValueGetter.isNullValue(snap.getReplicationGroupInstance())) {\n    snapshots=ControllerUtils.getSnapshotsPartOfReplicationGroup(snap,_dbClient);\n  }\n else {\n    snapshots.add(snap);\n  }\n  Volume parentVolume=_permissionsHelper.getObjectById(snap.getParent(),Volume.class);\n  checkForPendingTasks(Arrays.asList(parentVolume.getTenant().getURI()),snapshots);\n  for (  BlockSnapshot snapshot : snapshots) {\n    Operation snapOp=_dbClient.createTaskOpStatus(BlockSnapshot.class,snapshot.getId(),taskId,ResourceOperationTypeEnum.DELETE_VOLUME_SNAPSHOT);\n    response.getTaskList().add(toTask(snapshot,taskId,snapOp));\n  }\n  try {\n    BlockServiceApi blockServiceApiImpl=BlockService.getBlockServiceImpl(parentVolume,_dbClient);\n    blockServiceApiImpl.deleteSnapshot(snap,snapshots,taskId,type);\n  }\n catch (  APIException|InternalException e) {\n    successStatus=false;\n    String errorMsg=String.format(\"Exception attempting to delete snapshot %s: %s\",snap.getId(),e.getMessage());\n    _log.error(errorMsg);\n    for (    TaskResourceRep taskResourceRep : response.getTaskList()) {\n      taskResourceRep.setState(Operation.Status.error.name());\n      taskResourceRep.setMessage(errorMsg);\n      _dbClient.error(BlockSnapshot.class,taskResourceRep.getResource().getId(),taskId,e);\n    }\n  }\ncatch (  Exception e) {\n    successStatus=false;\n    String errorMsg=String.format(\"Exception attempting to delete snapshot %s: %s\",snap.getId(),e.getMessage());\n    _log.error(errorMsg);\n    ServiceCoded sc=APIException.internalServerErrors.genericApisvcError(errorMsg,e);\n    for (    TaskResourceRep taskResourceRep : response.getTaskList()) {\n      taskResourceRep.setState(Operation.Status.error.name());\n      taskResourceRep.setMessage(sc.getMessage());\n      _dbClient.error(BlockSnapshot.class,taskResourceRep.getResource().getId(),taskId,sc);\n    }\n  }\n  auditOp(OperationTypeEnum.DELETE_VOLUME_SNAPSHOT,successStatus,opStage,id.toString(),snap.getLabel(),snap.getParent().getName(),device.getId().toString());\n  return response;\n}\n", "nl": "Deactivate volume snapshot, this will move the snapshot to a \"marked-for-delete\" state. It will be deleted by the garbage collector on a subsequent iteration If this snapshot was created from a volume that is part of a consistency group, then all the related snapshots will be deactivated, as well."}
{"code": "public static List propertyDescriptors(int apiLevel){\n  return PROPERTY_DESCRIPTORS;\n}\n", "nl": "Returns a list of structural property descriptors for this node type. Clients must not modify the result."}
{"code": "public CataclysmicDemographicModel(Parameter N0Parameter,Parameter N1Parameter,Parameter growthRateParameter,Parameter timeParameter,Type units,boolean useSpike){\n  this(CataclysmicDemographicModelParser.CATACLYSM_MODEL,N0Parameter,N1Parameter,growthRateParameter,timeParameter,units,useSpike);\n}\n", "nl": "Construct demographic model with default settings"}
{"code": "public <T extends SuperModel>boolean insert(T model){\n  Object[] objects=model.getInsertSql();\n  return execSQL(objects[0].toString(),Arrays.copyOfRange(objects,1,objects.length));\n}\n", "nl": "Insert a model."}
{"code": "public void update(byte[] in,int off,int len){\n  contentDigest.update(in,off,len);\n}\n", "nl": "update the internal digest with the byte array in"}
{"code": "PostscriptGraphics(PostscriptGraphics copy){\n  m_extent=new Rectangle(copy.m_extent);\n  m_printstream=copy.m_printstream;\n  m_localGraphicsState=new GraphicsState(copy.m_localGraphicsState);\n  m_psGraphicsState=copy.m_psGraphicsState;\n}\n", "nl": "Creates a new cloned PostscriptGraphics object."}
{"code": "public boolean isParameterized(){\n  EList<TypeRef> _typeArgs=this.getTypeArgs();\n  boolean _isEmpty=_typeArgs.isEmpty();\n  return (!_isEmpty);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public ConstraintIntervalType createConstraintIntervalTypeFromString(EDataType eDataType,String initialValue){\n  ConstraintIntervalType result=ConstraintIntervalType.get(initialValue);\n  if (result == null)   throw new IllegalArgumentException(\"The value '\" + initialValue + \"' is not a valid enumerator of '\"+ eDataType.getName()+ \"'\");\n  return result;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private Optional<FeedItem> findLastVisibleFeedItem(Set<ContentType> contentType){\n  List<FeedItem> items=feedAdapter.getFeed().getItems();\n  return getRecyclerViewLayoutManager().<Optional<FeedItem>>transform(null).get();\n}\n", "nl": "Finds the first item in the proxy, that is visible and of one of the given content type."}
{"code": "public TaskBuilder single(){\n  this.type=TaskType.SINGLE;\n  return this;\n}\n", "nl": "<b>This is default value/state of builder.</b> <br> Change task type to single, so it will be only executed once."}
{"code": "public static double mean(Iterator tuples,String field){\n  try {\n    int count=0;\n    double sum=0;\n    while (tuples.hasNext()) {\n      sum+=((Tuple)tuples.next()).getDouble(field);\n      ++count;\n    }\n    return sum / count;\n  }\n catch (  Exception e) {\n    return Double.NaN;\n  }\n}\n", "nl": "Get the mean value of a tuple data value. If any tuple does not have the named field or the field is not a numeric data type, NaN will be returned."}
{"code": "@Override public void onPageScrollStateChanged(int page){\n}\n", "nl": "On scroll state of page changed."}
{"code": "public static boolean exitableTerrain(int terrType){\n  boolean exitableTerrainType=false;\n  for (int i=0; i < Terrains.exitableTerrains.length; i++) {\n    exitableTerrainType|=terrType == Terrains.exitableTerrains[i];\n  }\n  return exitableTerrainType;\n}\n", "nl": "Checks to see if the given terrain type can have exits."}
{"code": "private static CTutorial loadTutorial(final File file) throws ParserConfigurationException, SAXException, IOException {\n  String name=\"\";\n  String description=\"\";\n  final List<CTutorialStep> steps=new ArrayList<CTutorialStep>();\n  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\n  final DocumentBuilder builder=factory.newDocumentBuilder();\n  final Document document=builder.parse(file);\n  final NodeList nodes=document.getFirstChild().getChildNodes();\n  for (int i=0; i < nodes.getLength(); ++i) {\n    final Node node=nodes.item(i);\n    final String nodeName=node.getNodeName();\n    if (\"name\".equals(nodeName)) {\n      name=node.getTextContent();\n    }\n else     if (\"description\".equals(nodeName)) {\n      description=node.getTextContent();\n    }\n else     if (\"steps\".equals(nodeName)) {\n      steps.addAll(readSteps(node));\n    }\n  }\n  return new CTutorial(name,description,steps);\n}\n", "nl": "Loads a single tutorial from a file."}
{"code": "public void readFromNBT(NBTTagCompound nbt){\n  this.cheese=EnumCheeseType.loadFromNBT(nbt);\n  this.cheeseStage=EnumCheeseStage.loadFromNBT(nbt);\n  if (nbt.hasKey(\"age\")) {\n    this.age=nbt.getInteger(\"age\");\n  }\n  if (nbt.hasKey(\"slices\")) {\n    this.slices=nbt.getInteger(\"slices\");\n  }\n  if (nbt.hasKey(\"slices_max\")) {\n    this.slicesMax=nbt.getInteger(\"slices_max\");\n  }\n}\n", "nl": "When the tileentity is reloaded from an ItemStack"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:32:00.390 -0500\",hash_original_method=\"344907C67A02819CC7A230367AD45761\",hash_generated_method=\"4B06F00DE2D9425181B65C93B3228913\") @Override protected int computeHorizontalScrollRange(){\n  final int count=getChildCount();\n  final int contentWidth=getWidth() - mPaddingLeft - mPaddingRight;\n  if (count == 0) {\n    return contentWidth;\n  }\n  int scrollRange=getChildAt(0).getRight();\n  final int scrollX=mScrollX;\n  final int overscrollRight=Math.max(0,scrollRange - contentWidth);\n  if (scrollX < 0) {\n    scrollRange-=scrollX;\n  }\n else   if (scrollX > overscrollRight) {\n    scrollRange+=scrollX - overscrollRight;\n  }\n  return scrollRange;\n}\n", "nl": "<p>The scroll range of a scroll view is the overall width of all of its children.</p>"}
{"code": "public DateBuilder inLocale(Locale locale){\n  this.lc=locale;\n  return this;\n}\n", "nl": "Set the Locale for the Date that will be built by this builder (if \"null\", system default will be used)"}
{"code": "public IgniteThread(GridWorker worker){\n  this(DFLT_GRP,worker.gridName(),worker.name(),worker,GRP_IDX_UNASSIGNED);\n}\n", "nl": "Creates thread with given worker."}
{"code": "void convertRequireToImportStatements(Node n,String fullLocalName,String requiredNamespace){\n  if (!namespaceToModule.containsKey(requiredNamespace)) {\n    compiler.report(JSError.make(n,GentsErrorManager.GENTS_MODULE_PASS_ERROR,String.format(\"Module %s does not exist.\",requiredNamespace)));\n    return;\n  }\n  String localName=nameUtil.lastStepOfName(fullLocalName);\n  FileModule module=namespaceToModule.get(requiredNamespace);\n  String moduleSuffix=nameUtil.lastStepOfName(requiredNamespace);\n  String backupName=moduleSuffix.equals(localName) ? moduleSuffix + \"Exports\" : moduleSuffix;\n  if (module.shouldUseOldSyntax()) {\n    Node importNode=new Node(Token.IMPORT,IR.empty(),Node.newString(Token.NAME,localName),Node.newString(\"goog:\" + requiredNamespace));\n    nodeComments.replaceWithComment(n,importNode);\n    compiler.reportCodeChange();\n    registerLocalSymbol(n.getSourceFileName(),fullLocalName,requiredNamespace,localName);\n    return;\n  }\n  String referencedFile=pathUtil.getImportPath(n.getSourceFileName(),module.file);\n  boolean imported=false;\n  if (module.importedNamespacesToSymbols.containsKey(requiredNamespace)) {\n    Node importSpec=new Node(Token.IMPORT_SPEC,IR.name(moduleSuffix));\n    if (!moduleSuffix.equals(localName)) {\n      importSpec.addChildToBack(IR.name(localName));\n    }\n    Node importNode=new Node(Token.IMPORT,IR.empty(),new Node(Token.IMPORT_SPECS,importSpec),Node.newString(referencedFile));\n    n.getParent().addChildBefore(importNode,n);\n    nodeComments.moveComment(n,importNode);\n    imported=true;\n    registerLocalSymbol(n.getSourceFileName(),fullLocalName,requiredNamespace,localName);\n    localName=backupName;\n  }\n  if (module.providesObjectChildren.get(requiredNamespace).size() > 0) {\n    Node importNode=new Node(Token.IMPORT,IR.empty(),Node.newString(Token.IMPORT_STAR,localName),Node.newString(referencedFile));\n    n.getParent().addChildBefore(importNode,n);\n    nodeComments.moveComment(n,importNode);\n    imported=true;\n    for (    String child : module.providesObjectChildren.get(requiredNamespace)) {\n      if (!valueRewrite.contains(n.getSourceFileName(),child)) {\n        String fileName=n.getSourceFileName();\n        registerLocalSymbol(fileName,fullLocalName + '.' + child,requiredNamespace + '.' + child,localName + '.' + child);\n      }\n    }\n  }\n  if (!imported) {\n    Node importNode=new Node(Token.IMPORT,IR.empty(),IR.empty(),Node.newString(referencedFile));\n    n.getParent().addChildBefore(importNode,n);\n    nodeComments.moveComment(n,importNode);\n  }\n  n.getParent().removeChild(n);\n  compiler.reportCodeChange();\n}\n", "nl": "Converts a Closure goog.require call into a TypeScript import statement. The resulting node is dependent on the exports by the module being imported: import localName from \"goog:old.namespace.syntax\"; import {A as localName} from \"./valueExports\"; import * as localName from \"./objectExports\"; import \"./sideEffectsOnly\""}
{"code": "@VisibleForTesting public void clearPendingInvalidations(Context context){\n  SharedPreferences.Editor editor=PreferenceManager.getDefaultSharedPreferences(context).edit();\n  editor.putString(DELAYED_ACCOUNT_NAME,null);\n  editor.putStringSet(DELAYED_INVALIDATIONS,null);\n  editor.apply();\n}\n", "nl": "If there are any pending invalidations, they will be cleared."}
{"code": "public static int parseCodePoint(String s) throws NumberFormatException {\n  return Integer.parseInt(s,16);\n}\n", "nl": "Parse the codePoint attribute for a Unicode character.  If the parse succeeds, the codePoint field of this UnicodeSpec object is updated and false is returned. The codePoint attribute should be a four to six digit hexadecimal integer."}
{"code": "public final boolean hasIndex(){\n  return (index >= 0);\n}\n", "nl": "Gets whether or not this instance has been assigned an index."}
{"code": "public static String encodeLines(byte[] in,int iOff,int iLen,int lineLen,String lineSeparator){\n  final int blockLen=lineLen * 3 / 4;\n  if (blockLen <= 0) {\n    throw new IllegalArgumentException();\n  }\n  final int lines=(iLen + blockLen - 1) / blockLen;\n  final int bufLen=(iLen + 2) / 3 * 4 + lines * lineSeparator.length();\n  final StringBuilder buf=new StringBuilder(bufLen);\n  int ip=0;\n  while (ip < iLen) {\n    final int l=Math.min(iLen - ip,blockLen);\n    buf.append(encode(in,iOff + ip,l));\n    buf.append(lineSeparator);\n    ip+=l;\n  }\n  return buf.toString();\n}\n", "nl": "Encodes a byte array into Base 64 format and breaks the output into lines."}
{"code": "@SuppressWarnings(\"unchecked\") @Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase EipPackage.ROUTE__OWNED_ENDPOINTS:\n    getOwnedEndpoints().clear();\n  getOwnedEndpoints().addAll((Collection<? extends Endpoint>)newValue);\nreturn;\ncase EipPackage.ROUTE__OWNED_CHANNELS:\ngetOwnedChannels().clear();\ngetOwnedChannels().addAll((Collection<? extends Channel>)newValue);\nreturn;\ncase EipPackage.ROUTE__NAME:\nsetName((String)newValue);\nreturn;\ncase EipPackage.ROUTE__EXCHANGE_TYPE:\nsetExchangeType((ExchangeType)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void write(int c){\n  buf.append((char)c);\n}\n", "nl": "Write a single character."}
{"code": "public void initialize(EngineStatusCallback engineStatusCallback){\n  this.statusEventHandler.initialize(engineStatusCallback);\n  this.outputEventHandler.initialize(engineStatusCallback);\n}\n", "nl": "Initialize some callbacks"}
{"code": "public String encode(String pString) throws EncoderException {\n  if (pString == null) {\n    return null;\n  }\n  try {\n    return encode(pString,getDefaultCharset());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new EncoderException(e.getMessage());\n  }\n}\n", "nl": "Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped. <p> This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in RFC 1521 and is suitable for encoding binary data. </p>"}
{"code": "public DiskBasedCache(File rootDirectory){\n  this(rootDirectory,DEFAULT_DISK_USAGE_BYTES);\n}\n", "nl": "Constructs an instance of the DiskBasedCache at the specified directory using the default maximum cache size of 5MB."}
{"code": "public static OutputLimitClause create(OutputLimitSelector selector,double frequency){\n  return new OutputLimitClause(selector,frequency);\n}\n", "nl": "Creates an output limit clause."}
{"code": "public static boolean isHeadMissing(final VcsException e){\n  @NonNls final String errorText=\"fatal: bad revision 'HEAD'\\n\";\n  return e.getMessage().equals(errorText);\n}\n", "nl": "Check if the exception means that HEAD is missing for the current repository."}
{"code": "private String compute(String left,Boolean right){\n  if (left == null && right == null) {\n    return null;\n  }\n  return (left == null ? \"\" : left) + (right == null ? \"\" : right);\n}\n", "nl": "Adds a String and a Boolean. If both are missing, then the result is missing; if one is missing, it is ignored."}
{"code": "public boolean isNamespaceAware(){\n  return _isNamespaceAware;\n}\n", "nl": "Gets Namespace aware flag."}
{"code": "public void remove(int fieldNumber){\n  int i=binarySearch(fieldNumber);\n  if (i >= 0 && mData[i] != DELETED) {\n    mData[i]=DELETED;\n    mGarbage=true;\n  }\n}\n", "nl": "Removes the data from the specified fieldNumber, if there was any."}
{"code": "protected void sequence_IntersectionTypeExpressionOLD_TypeRef_TypeRefWithModifiers(ISerializationContext context,IntersectionTypeExpression semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: IntersectionTypeExpression.IntersectionTypeExpression_1_0 returns IntersectionTypeExpression PrimaryTypeExpression returns IntersectionTypeExpression Constraint: ( typeRefs+=TypeRefWithoutModifiers  typeRefs+=TypeRefWithoutModifiers*  ((undefModifier=UndefModifierToken? nullModifier=NullModifierToken?) | undefModifier=UndefModifierToken)? )"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:28:44.149 -0500\",hash_original_method=\"A22563797EE8B98D8D2C96F4FC0F2C77\",hash_generated_method=\"EB9D53584F352AD6AC60DCC4EDA82399\") public Cursor query(SQLiteDatabase db,String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){\n  Cursor ret=new DSCursor(DSOnlyType.NOT_USED);\n  ret.addTaint(db.getTaint());\n  ret.addTaint(projectionIn.getTaint());\n  ret.addTaint(projectionIn[0].getTaint());\n  ret.addTaint(selection.getTaint());\n  ret.addTaint(selectionArgs.getTaint());\n  ret.addTaint(selectionArgs[0].getTaint());\n  ret.addTaint(groupBy.getTaint());\n  ret.addTaint(having.getTaint());\n  ret.addTaint(sortOrder.getTaint());\n  ret.addTaint(limit.getTaint());\n  return ret;\n}\n", "nl": "Perform a query by combining all current settings and the information passed into this method."}
{"code": "public PayloadItem(E payloadExt){\n  super();\n  if (payloadExt == null)   throw new IllegalArgumentException(\"payload cannot be 'null'\");\n  payload=payloadExt;\n}\n", "nl": "Create an <tt>Item</tt> with no id and a payload  The id will be set by the server. "}
{"code": "public void testNegPos(){\n  String numA=\"-27384627835298756289327365\";\n  String numB=\"0\";\n  String res=\"-27384627835298756289327365\";\n  BigInteger aNumber=new BigInteger(numA);\n  BigInteger bNumber=new BigInteger(numB);\n  BigInteger result=aNumber.xor(bNumber);\n  assertTrue(res.equals(result.toString()));\n}\n", "nl": "Xor for a negative number and zero "}
{"code": "public void initializeTrie(Context context,int fileResource){\n  TrieNode startInsertionNode=mRoot;\n  InputStream stream=context.getResources().openRawResource(fileResource);\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new InputStreamReader(stream,\"UTF-8\"));\n    String input;\n    while ((input=reader.readLine()) != null) {\n      for (int i=0; i < input.length(); i++) {\n        startInsertionNode=insertSymbol(startInsertionNode,input.charAt(i));\n      }\n    }\n  }\n catch (  IOException e) {\n    LogUtils.log(this,Log.ERROR,\"Unable to read PPMTrie input file: %1$s\",e.toString());\n  }\n finally {\n    try {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n catch (    IOException e) {\n      LogUtils.log(this,Log.ERROR,\"Unable to close input file: %1$s\",e.toString());\n    }\n  }\n}\n", "nl": "Uses the text in a training file to form a ppm model and store it in a trie. The file is a .txt file that contains plain unicode text."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:50.891 -0500\",hash_original_method=\"7045B1DBF21073AA43E994CE221E4094\",hash_generated_method=\"7045B1DBF21073AA43E994CE221E4094\") ObjectStreamField(String signature,String name){\n  if (name == null) {\n    throw new NullPointerException();\n  }\n  this.name=name;\n  this.typeString=signature.replace('.','/').intern();\n  defaultResolve();\n  this.isDeserialized=true;\n}\n", "nl": "Constructs an ObjectStreamField with the given name and the given type. The type may be null."}
{"code": "@Override protected final int nextIndex(){\n  if (_expectedSize != _hash.size()) {\n    throw new ConcurrentModificationException();\n  }\n  Object[] set=_map._set;\n  int i=_index;\n  while (i-- > 0 && (set[i] == null || set[i] == TObjectHash.REMOVED))   ;\n  return i;\n}\n", "nl": "Returns the index of the next value in the data structure or a negative value if the iterator is exhausted."}
{"code": "public static ArrayList<BaseQuestion> returnChatList(String jsonFile){\n  ArrayList<BaseQuestion> questions=new ArrayList<BaseQuestion>();\n  RestAPI api=RestAPI.getAPI();\n  questions=api.getChatQuestions(jsonFile);\n  return questions;\n}\n", "nl": "Get list of chat questions"}
{"code": "public int numElements() throws Exception {\n  if (m_Classifier instanceof PartitionGenerator)   return ((PartitionGenerator)m_Classifier).numElements();\n else   throw new Exception(\"Classifier: \" + getClassifierSpec() + \" cannot generate a partition\");\n}\n", "nl": "Returns the number of elements in the partition. (If the base classifier supports this.)"}
{"code": "@Override protected Instance process(Instance instance) throws Exception {\n  m_Remove.input(instance);\n  return m_Remove.output();\n}\n", "nl": "processes the given instance (may change the provided instance) and returns the modified version."}
{"code": "public static void main(String[] args) throws Exception {\n  if (args.length > 1) {\n    BufferedImage firstImage=ImageIO.read(new File(args[0]));\n    ImageOutputStream output=new FileImageOutputStream(new File(args[args.length - 1]));\n    GifSequenceWriter writer=new GifSequenceWriter(output,firstImage.getType(),1,false);\n    writer.writeToSequence(firstImage);\n    for (int i=1; i < args.length - 1; i++) {\n      BufferedImage nextImage=ImageIO.read(new File(args[i]));\n      writer.writeToSequence(nextImage);\n    }\n    writer.close();\n    output.close();\n  }\n else {\n    System.out.println(\"Usage: java GifSequenceWriter [list of gif files] [output file]\");\n  }\n}\n", "nl": "public GifSequenceWriter( BufferedOutputStream outputStream, int imageType, int timeBetweenFramesMS, boolean loopContinuously) {"}
{"code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  if (index < 0) {\n    throw new IllegalStateException();\n  }\n  if (lag < 0) {\n    throw new IllegalStateException();\n  }\n}\n", "nl": "Adds semantic checks to the default deserialization method. This method must have the standard signature for a readObject method, and the body of the method must begin with \"s.defaultReadObject();\". Other than that, any semantic checks can be specified and do not need to stay the same from version to version. A readObject method of this form may be added to any class, even if Tetrad sessions were previously saved out using a version of the class that didn't include it. (That's what the \"s.defaultReadObject();\" is for. See J. Bloch, Effective Java, for help."}
{"code": "public boolean markAsRead(String smsNumber){\n  try {\n    ContentResolver cr=_context.getContentResolver();\n    ContentValues values=new ContentValues();\n    values.put(\"read\",\"1\");\n    cr.update(SMS_INBOX_CONTENT_URI,values,\" address='\" + smsNumber + \"'\",null);\n    return true;\n  }\n catch (  Exception e) {\n    Log.w(\"markAsRead() exception:\",e);\n    return false;\n  }\n}\n", "nl": "Not supported in Android 5 Marks all SMS from a given phone number as read"}
{"code": "public CategoryAxis3D(String label){\n  super(label);\n}\n", "nl": "Creates a new axis using default attribute values."}
{"code": "@Override public int compare(Triplet<byte[],UserLeafNode,Operation> p1,Triplet<byte[],UserLeafNode,Operation> p2){\n  byte[] buf1=p1.getValue0();\n  byte[] buf2=p2.getValue0();\n  if (buf1.length < 3 || buf2.length < 3) {\n    throw new RuntimeException(\"bad byte array length\");\n  }\n  for (int i=0; i < 3; i++) {\n    if (buf1[i] > buf2[i]) {\n      return 1;\n    }\n else     if (buf1[i] < buf2[i]) {\n      return -1;\n    }\n  }\n  Operation op1=p1.getValue2();\n  Operation op2=p2.getValue2();\n  if (op1 instanceof Register) {\n    return 1;\n  }\n  if (op2 instanceof Register) {\n    return -1;\n  }\n  if (op1 instanceof KeyChange && op2 instanceof KeyChange) {\n    return (((KeyChange)op1).getCounter() > ((KeyChange)op2).getCounter()) ? 1 : -1;\n  }\n  return 0;\n}\n", "nl": "Compares the first 24 bits of two data binding lookup indeces."}
{"code": "private void parsePublicUserIdentity(Node node){\n  String publicUserIdentity=null;\n  if (node == null) {\n    return;\n  }\n  Node childnode=node.getFirstChild();\n  if (childnode != null) {\n    do {\n      if (publicUserIdentity == null) {\n        if ((publicUserIdentity=getValueByParamName(\"Public_User_Identity\",childnode,TYPE_TXT)) != null) {\n          String username=extractUserNamePart(publicUserIdentity.trim());\n          PhoneNumber number=ContactUtil.getValidPhoneNumberFromUri(username);\n          if (number == null) {\n            if (sLogger.isActivated()) {\n              sLogger.error(\"Invalid public user identity '\" + username + \"'\");\n            }\n            mRcsSettings.setUserProfileImsUserName(null);\n          }\n else {\n            ContactId contact=ContactUtil.createContactIdFromValidatedData(number);\n            mRcsSettings.setUserProfileImsUserName(contact);\n          }\n        }\n      }\n    }\n while ((childnode=childnode.getNextSibling()) != null);\n  }\n}\n", "nl": "Parse public user identity"}
{"code": "@Override public void clearUndo(){\n  ((DataSortedTableModel)m_TableData.getModel()).clearUndo();\n}\n", "nl": "removes the undo history"}
{"code": "public static List<org.oscm.internal.vo.VOParameterOption> convertToUpVOParameterOption(List<org.oscm.vo.VOParameterOption> oldVO){\n  if (oldVO == null) {\n    return null;\n  }\n  List<org.oscm.internal.vo.VOParameterOption> newVO=new ArrayList<org.oscm.internal.vo.VOParameterOption>();\n  for (  org.oscm.vo.VOParameterOption tmp : oldVO) {\n    newVO.add(convertToUp(tmp));\n  }\n  return newVO;\n}\n", "nl": "Convert list of VOParameterOption."}
{"code": "public void traceFieldNotStaticInHostJdk(){\n  traceNulledWord(\": field not static in host jdk\");\n}\n", "nl": "Report a field that is an instance field in the host JDK but a static field in ours. "}
{"code": "public SwitchPreference(Context context){\n  super(context,null);\n}\n", "nl": "Construct a new SwitchPreference with default style options."}
{"code": "private void publishTextRecord(final LogRecord record){\n  try {\n    logpane.publish(record);\n  }\n catch (  Exception e) {\n    throw new RuntimeException(\"Error writing a log-like message.\",e);\n  }\n}\n", "nl": "Publish a text record to the pane"}
{"code": "public static final List<String> combine(Collection<String> list,String... args){\n  List<String> ret=new ArrayList<String>(list);\n  for (  String s : args) {\n    ret.add(s);\n  }\n  return ret;\n}\n", "nl": "Combine a string collection (list) with additional strings."}
{"code": "public void clear(){\n  try {\n    skip(size);\n  }\n catch (  EOFException e) {\n    throw new AssertionError(e);\n  }\n}\n", "nl": "Discards all bytes in this buffer. Calling this method when you're done with a buffer will return its segments to the pool."}
{"code": "public static String fromUTF8(byte[] bytes){\n  try {\n    return new String(bytes,ENCODING_UTF8);\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new AssertionError(e);\n  }\n}\n", "nl": "Decodes the given binary data with UTF-8."}
{"code": "private void analyzeFiles(Set<String> fileNames) throws CLIArgumentParserException, IOException {\n  ColorSettings colorSettings=new ColorSettings(configuration.shouldColorOutput(),configuration.shouldInvertColorOutput());\n  Formatter formatter=configuration.getFormatter(colorSettings);\n  Severity maxSeverity=configuration.getMaxSeverity();\n  ConstructLengths constructLengths=configuration.parseConstructLengths();\n  Set<Rules> enabledRules=configuration.getEnabledRules();\n  numberOfFilesBeforePurge=configuration.numberOfFilesBeforePurge();\n  List<File> files=fileNames.parallelStream().map(null).collect(Collectors.toList());\n  formatter.printProgressInfo(String.format(\"Analyzing %s:%n\",Formatter.pluralize(fileNames.size(),\"file\",\"files\")));\n  files.parallelStream().forEach(null);\n  formatter.printProgressInfo(String.format(\"%n\"));\n  printersForAllFiles.forEach(null);\n  formatter.displaySummary(fileNames.size(),numSkippedFiles.get(),numErrors.get(),numWarnings.get());\n  handleErrorViolations(formatter,numErrors.get());\n}\n", "nl": "Analyze files with SwiftLexer, SwiftParser and Listeners."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase UmplePackage.ENUM___NAME_1:\n    setName_1(NAME_1_EDEFAULT);\n  return;\ncase UmplePackage.ENUM___STATE_NAME_1:\nsetStateName_1(STATE_NAME_1_EDEFAULT);\nreturn;\ncase UmplePackage.ENUM___ANONYMOUS_ENUM_11:\ngetAnonymous_enum_1_1().clear();\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private synchronized boolean isSelectedTrackRecording(){\n  return trackDataHub != null && trackDataHub.isSelectedTrackRecording();\n}\n", "nl": "Returns true if the selected track is recording. Needs to be synchronized because the trackDataHub can be accessed by multiple threads."}
{"code": "public byte[] filter(byte[] buffer,int offset,int len){\n  byte[] slices=getSlices(buffer,offset,len);\n  if (null == slices) {\n    return null;\n  }\n  int insertionPoint=findInsertionPoint(slices);\n  if (insertionPoint >= 0) {\n    return buffer;\n  }\n  if (-1 == insertionPoint) {\n    if (hasHinting) {\n      return Arrays.copyOf(this.rangekeys,this.bounds[1]);\n    }\n else {\n      return null;\n    }\n  }\n  if (-nranges - 1 == insertionPoint) {\n    if (hasHinting) {\n      return EMPTY_BYTE_ARRAY;\n    }\n else {\n      return null;\n    }\n  }\n  if (-(insertionPoint + 1) % 2 == 0) {\n    if (hasHinting) {\n      int hintOffset=this.slicesLength * (-(insertionPoint + 1));\n      return Arrays.copyOfRange(this.rangekeys,hintOffset,this.bounds[1]);\n    }\n else {\n      return null;\n    }\n  }\n  return buffer;\n}\n", "nl": "Determine if a key should be filtered or not. This method returns a byte array which indicates how the key should be dealt with. If the return value is 'buffer', the key should be include. If the return value is null, the key should be skipped and no next key hint is available If the return value is a non empty byte array (different from 'buffer'), the key should be skipped and the return value used as the next key hint. If the return value is an empty byte array, the key is passed the last range and scanning should end"}
{"code": "private JPanel createPhotoframe(){\n  JPanel pf=NPComponentUtils.createPanel_root(NPIconFactory.getInstance().getPhotoframeBg(),new Insets(13,15,15,15));\n  pf.setLayout(new BorderLayout());\n  pf.setOpaque(false);\n  return pf;\n}\n", "nl": "Create and return a new photo frame pane object. Its background is NinePatch pictrue."}
{"code": "@SuppressWarnings(\"deprecation\") void insertIntoHoveringConnection(final Operator operator){\n  OutputPort hoveringConnectionSource=model.getHoveringConnectionSource();\n  if (hoveringConnectionSource == null) {\n    return;\n  }\n  InputPort oldDest=hoveringConnectionSource.getDestination();\n  oldDest.lock();\n  hoveringConnectionSource.lock();\n  try {\n    InputPort bestInputPort=null;\n    MetaData md=hoveringConnectionSource.getMetaData();\n    if (md != null) {\n      for (      InputPort inCandidate : operator.getInputPorts().getAllPorts()) {\n        if (!inCandidate.isConnected() && inCandidate.isInputCompatible(md,CompatibilityLevel.PRE_VERSION_5)) {\n          bestInputPort=inCandidate;\n          break;\n        }\n      }\n    }\n else {\n      for (      InputPort inCandidate : operator.getInputPorts().getAllPorts()) {\n        if (!inCandidate.isConnected()) {\n          bestInputPort=inCandidate;\n          break;\n        }\n      }\n    }\n    if (bestInputPort != null) {\n      hoveringConnectionSource.disconnect();\n      connect(hoveringConnectionSource,bestInputPort);\n      if (RapidMinerGUI.getMainFrame().VALIDATE_AUTOMATICALLY_ACTION.isSelected()) {\n        hoveringConnectionSource.getPorts().getOwner().getOperator().transformMetaData();\n        operator.transformMetaData();\n      }\n      OutputPort bestOutput=null;\n      for (      OutputPort outCandidate : operator.getOutputPorts().getAllPorts()) {\n        if (!outCandidate.isConnected()) {\n          md=outCandidate.getMetaData();\n          if (md != null && oldDest.isInputCompatible(md,CompatibilityLevel.PRE_VERSION_5)) {\n            bestOutput=outCandidate;\n            break;\n          }\n        }\n      }\n      if (bestOutput == null) {\n        for (        OutputPort outCandidate : operator.getOutputPorts().getAllPorts()) {\n          if (!outCandidate.isConnected()) {\n            bestOutput=outCandidate;\n            break;\n          }\n        }\n      }\n      if (bestOutput != null) {\n        connect(bestOutput,oldDest);\n      }\n    }\n  }\n  finally {\n    oldDest.unlock();\n    hoveringConnectionSource.unlock();\n    model.setHoveringConnectionSource(null);\n  }\n}\n", "nl": "Insert the specified operator into the currently hovered connection."}
{"code": "protected void unhandledMessageReceived(OFMessage m){\n  switchManagerCounters.unhandledMessage.increment();\n  if (log.isDebugEnabled()) {\n    String msg=getSwitchStateMessage(m,\"Ignoring unexpected message\");\n    log.debug(msg);\n  }\n}\n", "nl": "We have an OFMessage we didn't expect given the current state and we want to ignore the message"}
{"code": "public static int sanitizeInt(int flags){\n  if (((flags & OFMatch.OFPFW_NW_SRC_MASK) >> OFMatch.OFPFW_NW_SRC_SHIFT) > 32) {\n    flags=(flags & ~OFMatch.OFPFW_NW_SRC_MASK) | OFMatch.OFPFW_NW_SRC_ALL;\n  }\n  if (((flags & OFMatch.OFPFW_NW_DST_MASK) >> OFMatch.OFPFW_NW_DST_SHIFT) > 32) {\n    flags=(flags & ~OFMatch.OFPFW_NW_DST_MASK) | OFMatch.OFPFW_NW_DST_ALL;\n  }\n  return flags;\n}\n", "nl": "return the OpenFlow 'wire' integer representation of these wildcards. Sanitize nw_src and nw_dst to be max. 32 (values > 32 are technically possible, but don't make semantic sense)"}
{"code": "public ToHitData(TargetRollModifier targetRollModifier){\n  this(targetRollModifier.getValue(),targetRollModifier.getDesc());\n}\n", "nl": "Construct with a target roll modifier right off the bat."}
{"code": "@Override public void testSendReceive() throws Exception {\n  super.testSendReceive();\n  messages.clear();\n  consumer2.setMessageListener(this);\n  assertMessagesAreReceived();\n  LOG.info(\"\" + data.length + \" messages(s) received, closing down connections\");\n}\n", "nl": "Test if all the messages sent are being received."}
{"code": "public void changeState(boolean newState){\n  if (log.isDebugEnabled()) {\n    log.debug(\"Change state to \" + newState);\n  }\n  isOn=newState;\n  this.setSelected(isOn);\n  for (int i=0; i < listeners.size(); i++) {\n    listeners.get(i).notifyFunctionStateChanged(identity,isOn);\n  }\n}\n", "nl": "Change the state of the function."}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase ExpressionsPackage.SHIFT_EXPRESSION__LEFT_OPERAND:\n    return getLeftOperand();\ncase ExpressionsPackage.SHIFT_EXPRESSION__OPERATOR:\n  return getOperator();\ncase ExpressionsPackage.SHIFT_EXPRESSION__RIGHT_OPERAND:\nreturn getRightOperand();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public String toString(){\n  String result=toString;\n  if (result == null) {\n    result=computeToString();\n    toString=result;\n  }\n  return result;\n}\n", "nl": "Returns the string representation of this media type in the format described in <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>."}
{"code": "public static Border createBevelBorder(int type,Color highlightOuter,Color highlightInner,Color shadowOuter,Color shadowInner){\n  return new BevelBorder(type,highlightOuter,highlightInner,shadowOuter,shadowInner);\n}\n", "nl": "Creates a beveled border of the specified type, using the specified colors for the inner and outer highlight and shadow areas."}
{"code": "public boolean canUserModifyEntry(User user,Entry entry,boolean isAdmin){\n  return canUserSeeEntry(user,entry,isAdmin);\n}\n", "nl": "API method. Checks if the user is entitled to modify the entry."}
{"code": "public Shape3DPortrayal3D(Geometry geometry,Appearance appearance){\n  this(new Shape3D(geometry),appearance);\n}\n", "nl": "Constructs a Shape3DPortrayal3D with the given geometry and appearance."}
{"code": "public MessageProducer createProducer(Session session,Destination destination) throws JMSException {\n  MessageProducer producer=session.createProducer(destination);\n  producer.setDeliveryMode(deliveryMode);\n  return producer;\n}\n", "nl": "Creates a producer."}
{"code": "public static AppEventsLogger newLogger(Context context){\n  return new AppEventsLogger(context,null,null);\n}\n", "nl": "Build an AppEventsLogger instance to log events through.  The Facebook app that these events are targeted at comes from this application's metadata. The application ID used to log events will be determined from the app ID specified in the package metadata."}
{"code": "private boolean haveShownMessageBefore(UpdateMessage msg){\n  if (!msg.isShownOnce())   return false;\n  loadSeenMessages();\n  if (_seenMessages == null || _seenMessages.size() == 0 || !_seenMessages.contains(msg)) {\n    if (_seenMessages == null)     _seenMessages=new HashSet<>();\n    _seenMessages.add(msg);\n    saveSeenMessages();\n    return false;\n  }\n  return true;\n}\n", "nl": "Checks on a Message map, if we've seen this message before. The message map is serialized on disk every time we write to it. Its initialized from disk when we start the Update Manager."}
{"code": "public <T>JsonArray<T> createListDtoFromJson(String json,Class<T> dtoInterface){\n  final DtoProvider<T> dtoProvider=getDtoProvider(dtoInterface);\n  final List<JsonElement> list=gson.fromJson(json,listTypeCache.getUnchecked(JsonElement.class));\n  final List<T> result=new ArrayList<>(list.size());\n  for (  JsonElement e : list) {\n    result.add(dtoProvider.fromJson(e));\n  }\n  return new JsonArrayImpl<>(result);\n}\n", "nl": "Parses the JSON data from the specified sting into list of objects of the specified type."}
{"code": "public boolean isSetHeader(){\n  return this.header != null;\n}\n", "nl": "Returns true if field header is set (has been assigned a value) and false otherwise"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public SimpleProtein(String ac,String id,String name,int length,String md5,String crc64,boolean isProteinFragment){\n  this.ac=ac;\n  this.id=id;\n  this.name=name;\n  this.length=length;\n  this.md5=md5;\n  this.crc64=crc64;\n  this.taxId=null;\n  this.taxScienceName=null;\n  this.taxFullName=null;\n  this.isProteinFragment=isProteinFragment;\n}\n", "nl": "Construct a SimpleProtein without the taxonomy information."}
{"code": "public VfsStream(){\n}\n", "nl": "Create an empty VfsStream."}
{"code": "public synchronized Map<String,Class<T>> compile(final Map<String,CharSequence> classes,final DiagnosticCollector<JavaFileObject> diagnosticsList) throws CharSequenceCompilerException {\n  List<JavaFileObject> sources=new ArrayList<>();\n  for (  Map.Entry<String,CharSequence> entry : classes.entrySet()) {\n    String qualifiedClassName=entry.getKey();\n    CharSequence javaSource=entry.getValue();\n    if (javaSource != null) {\n      final int dotPos=qualifiedClassName.lastIndexOf('.');\n      final String className=dotPos == -1 ? qualifiedClassName : qualifiedClassName.substring(dotPos + 1);\n      final String packageName=dotPos == -1 ? \"\" : qualifiedClassName.substring(0,dotPos);\n      final JavaFileObjectImpl source=new JavaFileObjectImpl(className,javaSource);\n      sources.add(source);\n      javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH,packageName,className + JAVA_EXTENSION,source);\n    }\n  }\n  final JavaCompiler.CompilationTask task=compiler.getTask(null,javaFileManager,diagnostics,options,null,sources);\n  final Boolean result=task.call();\n  if (result == null || !result) {\n    StringBuilder cause=new StringBuilder(\"\\n\");\n    for (    Diagnostic d : diagnostics.getDiagnostics()) {\n      cause.append(d).append(\" \");\n    }\n    throw new CharSequenceCompilerException(\"Compilation failed. Causes: \" + cause,classes.keySet(),diagnostics);\n  }\n  try {\n    Map<String,Class<T>> compiled=new HashMap<>();\n    for (    String qualifiedClassName : classLoader.classNames()) {\n      final Class<T> newClass=loadClass(qualifiedClassName);\n      compiled.put(qualifiedClassName,newClass);\n    }\n    return compiled;\n  }\n catch (  ClassNotFoundException|SecurityException|IllegalArgumentException e) {\n    throw new CharSequenceCompilerException(classes.keySet(),e,diagnostics);\n  }\n}\n", "nl": "Compile multiple Java source strings and return a Map containing the resulting classes. <p/> Thread safety: this method is thread safe if the <var>classes</var> and <var>diagnosticsList</var> are isolated to this thread."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:00.428 -0500\",hash_original_method=\"C7335716F5A5FE392DFA727356C682DF\",hash_generated_method=\"A329A8E4FAEC9FF6A4525B62EAF0DCD3\") public void addOptionHandler(TelnetOptionHandler opthand) throws InvalidTelnetOptionException {\n  super.addOptionHandler(opthand);\n}\n", "nl": "Registers a new TelnetOptionHandler for this telnet client to use. <p>"}
{"code": "public StateMachineConfigurationBuilder(){\n  super();\n}\n", "nl": "Instantiates a new state machine configuration builder."}
{"code": "public RowSetEvent(RowSet source){\n  super(source);\n}\n", "nl": "Constructs a <code>RowSetEvent</code> object initialized with the given <code>RowSet</code> object."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public MoveStaticMembersDescriptor(){\n  super(IJavaRefactorings.MOVE_STATIC_MEMBERS);\n}\n", "nl": "Creates a new refactoring descriptor."}
{"code": "public boolean isActivated() throws RcsGenericException {\n  if (sAccurateLog) {\n    Log.d(LOG_TAG,\"isActivated: Request()\");\n  }\n  Bundle result=queryRcsStackByIntent(new Intent(Intents.Service.ACTION_GET_ACTIVATION_MODE));\n  boolean activated=result.getBoolean(Intents.Service.EXTRA_GET_ACTIVATION_MODE,false);\n  if (sAccurateLog) {\n    Log.d(LOG_TAG,\"isActivated: Response() -> \" + activated + \" (in \"+ result.getLong(TIME_SPENT,-1)+ \"ms)\");\n  }\n  return activated;\n}\n", "nl": "Returns true if the RCS stack is marked as active on the device."}
{"code": "public void init(boolean encrypting,byte[] key){\n  this.doEncrypt=encrypting;\n  this.workingKey=key;\n  setKey(this.workingKey);\n}\n", "nl": "initialise a Blowfish cipher."}
{"code": "public static CTutorialDialog instance(){\n  return m_instance;\n}\n", "nl": "Returns the globally valid instance of the tutorial dialog."}
{"code": "public void play(URL url,String name){\n  AudioClip clip=getAudioClip(url,name);\n  if (clip != null) {\n    clip.play();\n  }\n}\n", "nl": "Plays the audio clip given the URL and a specifier that is relative to it. Nothing happens if the audio clip cannot be found."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:32:18.211 -0500\",hash_original_method=\"D2E29F254410117CE819574854BB79EC\",hash_generated_method=\"9E7D819F4E7FE83734719AA0B6321B58\") public boolean removeFooterView(View v){\n  if (mFooterViewInfos.size() > 0) {\n    boolean result=false;\n    if (mAdapter != null && ((HeaderViewListAdapter)mAdapter).removeFooter(v)) {\n      if (mDataSetObserver != null) {\n        mDataSetObserver.onChanged();\n      }\n      result=true;\n    }\n    removeFixedViewInfo(v,mFooterViewInfos);\n    return result;\n  }\n  return false;\n}\n", "nl": "Removes a previously-added footer view."}
{"code": "@AfterClass public static void closeTemporaryStore() throws InterruptedException {\n  if (temporaryStore == null) {\n    return;\n  }\n  ExecutorService executorService=temporaryStore.getExecutorService();\n  temporaryStore.close();\n  QueryEngine queryEngine=QueryEngineFactory.getInstance().getExistingQueryController(temporaryStore);\n  if (queryEngine != null) {\n    queryEngine.shutdownNow();\n  }\n  SynchronizedHardReferenceQueueWithTimeout.stopStaleReferenceCleaner();\n  executorService.awaitTermination(20,TimeUnit.SECONDS);\n  temporaryStore=null;\n}\n", "nl": "Close the temporary store used by this test."}
{"code": "public static boolean isSvnBuild(){\n  return getBuild().equalsIgnoreCase(\"svn\") ? true : false;\n}\n", "nl": "are we a SVN version?"}
{"code": "public void characters(char ch[],int start,int length) throws org.xml.sax.SAXException {\n  if (!m_shouldProcess)   return;\n  XSLTElementProcessor elemProcessor=getCurrentProcessor();\n  XSLTElementDef def=elemProcessor.getElemDef();\n  if (def.getType() != XSLTElementDef.T_PCDATA)   elemProcessor=def.getProcessorFor(null,\"text()\");\n  if (null == elemProcessor) {\n    if (!XMLCharacterRecognizer.isWhiteSpace(ch,start,length))     error(XSLMessages.createMessage(XSLTErrorResources.ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,null),null);\n  }\n else   elemProcessor.characters(this,ch,start,length);\n}\n", "nl": "Receive notification of character data inside an element."}
{"code": "protected void sendProgrammingReply(ProgListener p,int value,int status){\n  int delay=20;\n  if (!mServiceMode) {\n    delay=100;\n  }\n  NotifyDelay r=new NotifyDelay(delay,p,value,status);\n  r.start();\n}\n", "nl": "Internal routine to forward a programing reply. This is delayed to prevent overruns of the command station."}
{"code": "public Bag(){\n  first=null;\n  n=0;\n}\n", "nl": "Initializes an empty bag."}
{"code": "public boolean isSuperclassOf(ReferenceBinding otherType){\n  while ((otherType=otherType.superclass()) != null) {\n    if (otherType.isEquivalentTo(this))     return true;\n  }\n  return false;\n}\n", "nl": "Answer true if the receiver is in the superclass hierarchy of aType NOTE: Object.isSuperclassOf(Object) -> false"}
{"code": "public void addPinger(Pinger pinger){\n  if (!mPingers.contains(pinger)) {\n    mPingers.add(pinger);\n    notifyDataSetChanged();\n  }\n}\n", "nl": "Add a pinger to the list."}
{"code": "void selectType(Environment env,Context ctx,int tm){\n  if ((left.type == Type.tString) && !right.type.isType(TC_VOID)) {\n    type=Type.tString;\n    return;\n  }\n else   if ((right.type == Type.tString) && !left.type.isType(TC_VOID)) {\n    type=Type.tString;\n    return;\n  }\n  super.selectType(env,ctx,tm);\n}\n", "nl": "Select the type"}
{"code": "public BatchUpdateException(Throwable cause){\n  this((cause == null ? null : cause.toString()),null,0,(int[])null,cause);\n}\n", "nl": "Constructs a <code>BatchUpdateException</code> object initialized with a given <code>cause</code>. The <code>SQLState</code> and <code>updateCounts</code> are initialized to <code>null</code> and the vendor code is initialized to 0. The <code>reason</code>  is initialized to <code>null</code> if <code>cause==null</code> or to <code>cause.toString()</code> if <code>cause!=null</code>."}
{"code": "public static DistinguishedNameException convertToApi(org.oscm.internal.types.exception.DistinguishedNameException oldEx){\n  return convertExceptionToApi(oldEx,DistinguishedNameException.class);\n}\n", "nl": "Convert source version Exception to target version Exception"}
{"code": "@SuppressWarnings(\"unchecked\") public static <K extends Comparable<? super K>,V>ImmutableSortedMap<K,V> of(K k1,V v1,K k2,V v2){\n  return ofEntries(entryOf(k1,v1),entryOf(k2,v2));\n}\n", "nl": "Returns an immutable sorted map containing the given entries, sorted by the natural ordering of their keys."}
{"code": "public boolean saveParameters(){\n  log.config(\"\");\n  if (!validateParameters())   return false;\n  for (int i=0; i < m_mFields.size(); i++) {\n    WEditor editor=(WEditor)m_wEditors.get(i);\n    WEditor editor2=(WEditor)m_wEditors2.get(i);\n    Object result=editor.getValue();\n    Object result2=null;\n    if (editor2 != null)     result2=editor2.getValue();\n    MPInstancePara para=new MPInstancePara(Env.getCtx(),m_processInfo.getAD_PInstance_ID(),i);\n    GridField mField=(GridField)m_mFields.get(i);\n    para.setParameterName(mField.getColumnName());\n    if (result instanceof Timestamp || result2 instanceof Timestamp) {\n      para.setP_Date((Timestamp)result);\n      if (editor2 != null && result2 != null)       para.setP_Date_To((Timestamp)result2);\n    }\n else     if (result instanceof Integer || result2 instanceof Integer) {\n      if (result != null) {\n        Integer ii=(Integer)result;\n        para.setP_Number(ii.intValue());\n      }\n      if (editor2 != null && result2 != null) {\n        Integer ii=(Integer)result2;\n        para.setP_Number_To(ii.intValue());\n      }\n    }\n else     if (result instanceof BigDecimal || result2 instanceof BigDecimal) {\n      para.setP_Number((BigDecimal)result);\n      if (editor2 != null && result2 != null)       para.setP_Number_To((BigDecimal)result2);\n    }\n else     if (result instanceof Boolean) {\n      Boolean bb=(Boolean)result;\n      String value=bb.booleanValue() ? \"Y\" : \"N\";\n      para.setP_String(value);\n    }\n else {\n      if (result != null)       para.setP_String(result.toString());\n      if (editor2 != null && result2 != null)       para.setP_String_To(result2.toString());\n    }\n    para.setInfo(editor.getDisplay());\n    if (editor2 != null)     para.setInfo_To(editor2.getDisplay());\n    para.saveEx();\n    log.fine(para.toString());\n  }\n  return true;\n}\n", "nl": "Save Parameter values"}
{"code": "public TrieNode find(String suffix){\n  TrieNode result;\n  Character c;\n  String newSuffix;\n  TrieNode child;\n  c=suffix.charAt(0);\n  newSuffix=suffix.substring(1);\n  child=m_Children.get(c);\n  if (child == null) {\n    result=null;\n  }\n else   if (newSuffix.length() == 0) {\n    result=child;\n  }\n else {\n    result=child.find(newSuffix);\n  }\n  return result;\n}\n", "nl": "returns the node with the given suffix"}
{"code": "private void processTokenResponse(String responseCode,String result){\n  String refreshToken;\n  String accessToken;\n  int timeToExpireSecond;\n  try {\n    IdentityProxy identityProxy=IdentityProxy.getInstance();\n    if (Constants.REQUEST_SUCCESSFUL.equals(responseCode)) {\n      JSONObject response=new JSONObject(result);\n      try {\n        accessToken=response.getString(Constants.ACCESS_TOKEN);\n        refreshToken=response.getString(Constants.REFRESH_TOKEN);\n        timeToExpireSecond=Integer.parseInt(response.getString(Constants.EXPIRE_LABEL));\n        Token token=new Token();\n        Date date=new Date();\n        String currentDate=dateFormat.format(date);\n        token.setDate(currentDate);\n        token.setRefreshToken(refreshToken);\n        token.setAccessToken(accessToken);\n        token.setExpired(false);\n        SharedPreferences mainPref=IdentityProxy.getInstance().getContext().getSharedPreferences(Constants.APPLICATION_PACKAGE,Context.MODE_PRIVATE);\n        Editor editor=mainPref.edit();\n        editor.putString(Constants.ACCESS_TOKEN,accessToken);\n        editor.putString(Constants.REFRESH_TOKEN,refreshToken);\n        editor.putString(USERNAME_LABEL,info.getUsername());\n        long expiresIn=date.getTime() + (timeToExpireSecond * 1000);\n        Date expireDate=new Date(expiresIn);\n        String strDate=dateFormat.format(expireDate);\n        token.setDate(strDate);\n        editor.putString(Constants.DATE_LABEL,strDate);\n        editor.commit();\n        identityProxy.receiveAccessToken(responseCode,Constants.SUCCESS_RESPONSE,token);\n      }\n catch (      JSONException e) {\n        Log.e(TAG,\"Invalid JSON format\",e);\n      }\n    }\n else     if (responseCode != null) {\n      if (Constants.INTERNAL_SERVER_ERROR.equals(responseCode)) {\n        identityProxy.receiveAccessToken(responseCode,result,null);\n      }\n else {\n        JSONObject mainObject=new JSONObject(result);\n        String errorDescription=mainObject.getString(Constants.ERROR_DESCRIPTION_LABEL);\n        identityProxy.receiveAccessToken(responseCode,errorDescription,null);\n      }\n    }\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON\",e);\n  }\n}\n", "nl": "Processing token response from the server."}
{"code": "@Deprecated public static long checksum(final byte[] data){\n  return FitsCheckSum.checksum(data);\n}\n", "nl": "calculate the checksum for the block of data"}
{"code": "private void grow(){\n  if (keys == null || nkeys >= keys.length) {\n    String[] nk=new String[nkeys + 4];\n    String[] nv=new String[nkeys + 4];\n    if (keys != null)     System.arraycopy(keys,0,nk,0,nkeys);\n    if (values != null)     System.arraycopy(values,0,nv,0,nkeys);\n    keys=nk;\n    values=nv;\n  }\n}\n", "nl": "Grow the key/value arrays as needed"}
{"code": "public Analyzer showAggregate(){\n  showAggregate=true;\n  return this;\n}\n", "nl": "Enables the output of the metric value of the aggregate approximation set, produced by merging all individual seeds."}
{"code": "public static int ECHRNG(){\n  return 44;\n}\n", "nl": "Channel number out of range"}
{"code": "public void createDecSpecificInfoDescriptor(MP4DataStream bitstream) throws IOException {\n  decSpecificDataOffset=bitstream.getOffset();\n  dsid=new byte[size];\n  for (int b=0; b < size; b++) {\n    dsid[b]=(byte)bitstream.readBytes(1);\n    readed++;\n  }\n  decSpecificDataSize=size - readed;\n}\n", "nl": "Loads the MP4DecSpecificInfoDescriptor from the input bitstream."}
{"code": "public AsynchronousIndexWriteConfiguration(){\n}\n", "nl": "<strong>De-serialization ctor</strong>"}
{"code": "public void displayState(String state){\n  updateSize();\n  if (log.isDebugEnabled()) {\n    if (getSignalMast() == null) {\n      log.debug(\"Display state \" + state + \", disconnected\");\n    }\n else {\n      log.debug(\"Display state \" + state + \" for \"+ getSignalMast().getSystemName());\n    }\n  }\n  if (isText()) {\n    if (getSignalMast().getHeld()) {\n      if (isText()) {\n        super.setText(Bundle.getMessage(\"Held\"));\n      }\n      return;\n    }\n else     if (getLitMode() && !getSignalMast().getLit()) {\n      super.setText(Bundle.getMessage(\"Dark\"));\n      return;\n    }\n    super.setText(state);\n  }\n  if (isIcon()) {\n    if ((state != null) && (getSignalMast() != null)) {\n      String s=getSignalMast().getAppearanceMap().getImageLink(state,useIconSet);\n      if ((getSignalMast().getHeld()) && (getSignalMast().getAppearanceMap().getSpecificAppearance(jmri.SignalAppearanceMap.HELD) != null)) {\n        s=getSignalMast().getAppearanceMap().getImageLink(\"$held\",useIconSet);\n      }\n else       if (getLitMode() && !getSignalMast().getLit() && (getSignalMast().getAppearanceMap().getImageLink(\"$dark\",useIconSet) != null)) {\n        s=getSignalMast().getAppearanceMap().getImageLink(\"$dark\",useIconSet);\n      }\n      if (s.equals(\"\")) {\n        return;\n      }\n      if (!s.contains(\"preference:\")) {\n        s=s.substring(s.indexOf(\"resources\"));\n      }\n      if (_iconMap == null) {\n        getIcons();\n      }\n      NamedIcon n=_iconMap.get(s);\n      super.setIcon(n);\n      updateSize();\n      setSize(n.getIconWidth(),n.getIconHeight());\n    }\n  }\n else {\n    super.setIcon(null);\n  }\n  return;\n}\n", "nl": "Drive the current state of the display from the state of the underlying SignalMast object."}
{"code": "private void withStaticallyMockedEnvironmentAndFileApis() throws IOException {\n  mockStatic(Environment.class,File.class);\n  when(Environment.getExternalStorageDirectory()).thenReturn(mDirectory);\n  when(File.createTempFile(anyString(),anyString(),eq(mDirectory))).thenReturn(mImageFile);\n}\n", "nl": "Mock static methods in android.jar"}
{"code": "public static boolean isImageFileCompatible(File f){\n  boolean result=true;\n  try {\n    BufferedImage img=ImageIO.read(f);\n    ColorLayout cl=new ColorLayout();\n    cl.extract(img);\n  }\n catch (  Exception e) {\n    result=false;\n  }\n  return result;\n}\n", "nl": "Just opens an image with Java and reports if false if there are problems. This method can be used to check for JPG etc. that are not supported by the employed Java version."}
{"code": "public <T>T read(Class<? extends T> type,Reader source,boolean strict) throws Exception {\n  return read(type,NodeBuilder.read(source),strict);\n}\n", "nl": "This <code>read</code> method will read the contents of the XML document from the provided source and convert it into an object of the specified type. If the XML source cannot be deserialized or there is a problem building the object graph an exception is thrown. The instance deserialized is returned."}
{"code": "public static Pointer to(float values[]){\n  return new Pointer(FloatBuffer.wrap(values));\n}\n", "nl": "Creates a new Pointer to the given values. The values may not be null."}
{"code": "public InvocationSequenceData(Timestamp timeStamp,long platformIdent,long sensorTypeIdent,long methodIdent){\n  super(timeStamp,platformIdent,sensorTypeIdent,methodIdent);\n}\n", "nl": "Creates a new instance."}
{"code": "public RedundantBranchElimination(){\n  super(\"RedundantBranchElimination\",new OptimizationPlanElement[]{new OptimizationPlanAtomicElement(new EnsureSSA()),new OptimizationPlanAtomicElement(new GlobalValueNumber()),new OptimizationPlanAtomicElement(new RBE())});\n}\n", "nl": "Create this phase element as a composite of other elements"}
{"code": "public void alignItemsInColumns(int columns[]){\n  ArrayList<Integer> rows=new ArrayList<Integer>();\n  for (int i=0; i < columns.length; i++) {\n    rows.add(columns[i]);\n  }\n  int height=-5;\n  int row=0, rowHeight=0, columnsOccupied=0, rowColumns;\n  for (int i=0; i < children_.size(); i++) {\n    CCMenuItem item=(CCMenuItem)children_.get(i);\n    assert row < rows.size() : \"Too many menu items for the amount of rows/columns.\";\n    rowColumns=rows.get(row);\n    assert rowColumns != 0 : \"Can't have zero columns on a row\";\n    rowHeight=(int)Math.max(rowHeight,item.getContentSize().height);\n    ++columnsOccupied;\n    if (columnsOccupied >= rowColumns) {\n      height+=rowHeight + 5;\n      columnsOccupied=0;\n      rowHeight=0;\n      ++row;\n    }\n  }\n  assert columnsOccupied != 0 : \"Too many rows/columns for available menu items.\";\n  CGSize winSize=CCDirector.sharedDirector().winSize();\n  row=0;\n  rowHeight=0;\n  rowColumns=0;\n  float w=0, x=0, y=height / 2;\n  for (int i=0; i < children_.size(); i++) {\n    CCMenuItem item=(CCMenuItem)children_.get(i);\n    if (rowColumns == 0) {\n      rowColumns=rows.get(row);\n      w=winSize.width / (1 + rowColumns);\n      x=w;\n    }\n    rowHeight=Math.max(rowHeight,(int)item.getContentSize().height);\n    item.setPosition(CGPoint.make(x - winSize.width / 2,y - item.getContentSize().height / 2));\n    x+=w + 10;\n    ++columnsOccupied;\n    if (columnsOccupied >= rowColumns) {\n      y-=rowHeight + 5;\n      columnsOccupied=0;\n      rowColumns=0;\n      rowHeight=0;\n      ++row;\n    }\n  }\n}\n", "nl": "align items in rows of columns"}
{"code": "public void testUrlEncoderEncodesNonPrintableNonAsciiCharacters() throws Exception {\n  assertEquals(\"%00\",URLEncoder.encode(\"\\u0000\",\"UTF-8\"));\n  assertEquals(\"%00\",URLEncoder.encode(\"\\u0000\"));\n  assertEquals(\"%E2%82%AC\",URLEncoder.encode(\"\\u20AC\",\"UTF-8\"));\n  assertEquals(\"%E2%82%AC\",URLEncoder.encode(\"\\u20AC\"));\n  assertEquals(\"%F0%A0%AE%9F\",URLEncoder.encode(\"\\ud842\\udf9f\",\"UTF-8\"));\n  assertEquals(\"%F0%A0%AE%9F\",URLEncoder.encode(\"\\ud842\\udf9f\"));\n}\n", "nl": "Android's URLEncoder.encode() failed for surrogate pairs, encoding them as two replacement characters (\"??\"). http://b/3436051"}
{"code": "public ServiceCall<TranslationResult> translate(final String text,final Language source,final Language target){\n  return translate(Collections.singletonList(text),source,target);\n}\n", "nl": "Translate text using source and target languages.<br>"}
{"code": "public static void displayImage(Context context,String url,ImageView image){\n  ImageLoader loader=getImageLoader(context);\n  ImageAware imageAware=new ImageViewAware(image,false);\n  loader.displayImage(url,imageAware);\n}\n", "nl": "Downloads the image for the url"}
{"code": "public static ImageSource resource(int resId){\n  return new ImageSource(resId);\n}\n", "nl": "Create an instance from a resource. The correct resource for the device screen resolution will be used."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  MediaFile mf=getMediaFile(stack);\n  return Boolean.valueOf(mf != null && mf.isLocalFile());\n}\n", "nl": "Returns true if the specified MediaFile is local to this system (i.e. doesn't need to be streamed from a server)"}
{"code": "@SuppressWarnings(\"unchecked\") @Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase UmplePackage.AUTO_TRANSITION___AUTO_TRANSITION_BLOCK_1:\n    getAutoTransitionBlock_1().clear();\n  getAutoTransitionBlock_1().addAll((Collection<? extends AutoTransitionBlock_>)newValue);\nreturn;\ncase UmplePackage.AUTO_TRANSITION___ACTIVITY_1:\ngetActivity_1().clear();\ngetActivity_1().addAll((Collection<? extends Activity_>)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void load(Reader reader,G g) throws IOException {\n  this.current_graph=g;\n  this.graph_factory=null;\n  initializeData();\n  clearData();\n  parse(reader);\n}\n", "nl": "Populates the specified graph with the data parsed from the reader."}
{"code": "public synchronized void close() throws IOException {\n  if (journalWriter == null) {\n    return;\n  }\n  for (  Entry entry : new ArrayList<Entry>(lruEntries.values())) {\n    if (entry.currentEditor != null) {\n      entry.currentEditor.abort();\n    }\n  }\n  trimToSize();\n  journalWriter.close();\n  journalWriter=null;\n}\n", "nl": "Closes this cache. Stored values will remain on the filesystem."}
{"code": "private void addSubCollectionField(NutchDocument doc,String url){\n  for (  String collname : CollectionManager.getCollectionManager(getConf()).getSubCollections(url)) {\n    doc.add(FIELD_NAME,collname);\n  }\n}\n", "nl": "\"Mark\" document to be a part of subcollection"}
{"code": "public String toString(){\n  if (null != m_value) {\n    return (m_value.toString());\n  }\n else   if (null != m_invalidValue) {\n    return m_invalidValue;\n  }\n else {\n    return \"\";\n  }\n}\n", "nl": "Method toString."}
{"code": "public org.apache.nutch.storage.Host.Builder clearMetadata(){\n  metadata=null;\n  fieldSetFlags()[0]=false;\n  return this;\n}\n", "nl": "Clears the value of the 'metadata' field"}
{"code": "public String format(String str,Object... objs){\n  return MessageFormatter.format(str,objs).getMessage();\n}\n", "nl": "Format an slf4j message"}
{"code": "private void tryToAddDataPoint(){\n  if (traceData.size() == traceData.getBufferSize() && plotMode == PlotMode.N_STOP)   return;\nswitch (updateMode) {\ncase X_OR_Y:\n    if ((chronological && currentYDataChanged) || (!chronological && (currentXDataChanged || currentYDataChanged)))     addDataPoint();\n  break;\ncase X_AND_Y:\nif ((chronological && currentYDataChanged) || (!chronological && (currentXDataChanged && currentYDataChanged))) addDataPoint();\nbreak;\ncase X:\nif ((chronological && currentYDataChanged) || (!chronological && currentXDataChanged)) addDataPoint();\nbreak;\ncase Y:\nif (currentYDataChanged) addDataPoint();\nbreak;\ncase TRIGGER:\ndefault :\nbreak;\n}\n}\n", "nl": "Try to add a new data point to trace data.  Whether it will be added or not is up to the update mode."}
{"code": "private View makeAndAddHorizontalView(int position,int offset,int x,boolean fromLeft){\n  View child;\n  if (!mDataChanged) {\n    child=mRecycler.get(position);\n    if (child != null) {\n      int childLeft=child.getLeft();\n      mRightMost=Math.max(mRightMost,childLeft + child.getMeasuredWidth());\n      mLeftMost=Math.min(mLeftMost,childLeft);\n      setUpHorizontalChild(child,offset,x,fromLeft);\n      return child;\n    }\n  }\n  child=mAdapter.getView(position,null,this);\n  setUpHorizontalChild(child,offset,x,fromLeft);\n  return child;\n}\n", "nl": "Obtain a view, either by pulling an existing view from the recycler or by getting a new one from the adapter. If we are animating, make sure there is enough information in the view's layout parameters to animate from the old to new positions."}
{"code": "public final void print(double d) throws IOException {\n  print(String.valueOf(d));\n}\n", "nl": "Prints an double"}
{"code": "public int size(){\n  return nodes.size();\n}\n", "nl": "Returns the number of nodes in this lattice."}
{"code": "protected void finalize() throws Throwable {\n  this.systemID=null;\n  this.encapsulatedException=null;\n  super.finalize();\n}\n", "nl": "Cleans up the object when it's destroyed."}
{"code": "public void addToken(char[] array,int start,int end,int tokenType,int startOffset){\n  super.addToken(array,start,end,tokenType,startOffset);\n  zzStartRead=zzMarkedPos;\n}\n", "nl": "Adds the token specified to the current linked list of tokens."}
{"code": "public void testPing() throws Exception {\n  testServlet(\"/ping-test\");\n  testServlet(\"/ping-test-URL-path\");\n}\n", "nl": "Test the ping."}
{"code": "protected void releaseBeanContextResources(){\n  super.releaseBeanContextResources();\n  releaseAllDelegatedServices();\n  proxy=null;\n}\n", "nl": "Called before the parent context is updated. The implementation releases any service that is currently provided by the parent context."}
{"code": "public BaseCheckBox(String label){\n  this();\n  setText(label);\n}\n", "nl": "Creates a check box with the specified text label."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase N4JSPackage.EXPORT_SPECIFIER__ELEMENT:\n    setElement((IdentifierRef)null);\n  return;\ncase N4JSPackage.EXPORT_SPECIFIER__ALIAS:\nsetAlias(ALIAS_EDEFAULT);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public Object clone(){\n  DefaultMutableTreeNode newNode;\n  try {\n    newNode=(DefaultMutableTreeNode)super.clone();\n    newNode.children=null;\n    newNode.parent=null;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new Error(e.toString());\n  }\n  return newNode;\n}\n", "nl": "Overridden to make clone public.  Returns a shallow copy of this node; the new node has no parent or children and has a reference to the same user object, if any."}
{"code": "public TransactionOutput addOutput(BigInteger value,ECKey pubkey){\n  return addOutput(new TransactionOutput(params,this,value,pubkey));\n}\n", "nl": "Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this transaction, and returns the new output."}
{"code": "public static long index(final int segment,final int displacement){\n  return start(segment) + displacement;\n}\n", "nl": "Computes the index associated with given segment and displacement."}
{"code": "private void dropTables(SQLiteDatabase paramSQLiteDatabase){\n  for (  String table : sTables) {\n    try {\n      paramSQLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + table);\n    }\n catch (    Exception localException) {\n      localException.printStackTrace();\n    }\n  }\n}\n", "nl": "Goes through all of the tables in sTables and drops each table if it exists. Altered to no longer make use of reflection."}
{"code": "static public void assertNotSame(Object expected,Object actual){\n  assertNotSame(null,expected,actual);\n}\n", "nl": "Asserts that two objects refer to the same object. If they are not the same an AssertionFailedError is thrown."}
{"code": "@Override public void process(Number tuple){\n  RMin.this.process(tuple);\n}\n", "nl": "Each tuple is compared to the min and a new min (if so) is stored."}
{"code": "protected Context createContext(HttpServletRequest request,HttpServletResponse response){\n  VelocityContext context=new VelocityContext();\n  context.put(REQUEST,request);\n  context.put(RESPONSE,response);\n  return context;\n}\n", "nl": "Returns a context suitable to pass to the handleRequest() method <br><br> Default implementation will create a VelocityContext object, put the HttpServletRequest and HttpServletResponse into the context accessable via the keys VelocityServlet.REQUEST and VelocityServlet.RESPONSE, respectively."}
{"code": "public static ArrayModifiableDBIDs[] partitionsFromIntegerLabels(DBIDs ids,IntegerDataStore assignment,int k){\n  int[] sizes=new int[k];\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    sizes[assignment.intValue(iter)]+=1;\n  }\n  ArrayModifiableDBIDs[] clusters=new ArrayModifiableDBIDs[k];\n  for (int i=0; i < k; i++) {\n    clusters[i]=DBIDUtil.newArray(sizes[i]);\n  }\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    clusters[assignment.intValue(iter)].add(iter);\n  }\n  return clusters;\n}\n", "nl": "Collect clusters from their [0;k-1] integer labels."}
{"code": "private static String resovlePropConfigFile(String prop){\n  if (prop != null && prop.startsWith(\"file://\")) {\n    try {\n      String filePath=prop.substring(7);\n      BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(filePath),\"UTF-8\"));\n      StringBuffer sb=new StringBuffer();\n      String str=br.readLine();\n      while (str != null) {\n        sb.append(str);\n        str=br.readLine();\n      }\n      return sb.toString();\n    }\n catch (    IOException e) {\n      System.err.println(\"read classpath failed!\");\n      throw new RuntimeException(\" read classpath failed \",e);\n    }\n  }\n  return prop;\n}\n", "nl": "To get the full list for classpath list, Note:sometimes the classpath will be very longer, especially when you are working on a Maven project. Since if classpath too long will cause command line too long issue, we use file to handle it in this case."}
{"code": "public Matrix4f translationRotateScaleInvert(Vector3fc translation,Quaternionfc quat,Vector3fc scale){\n  return translationRotateScaleInvert(translation.x(),translation.y(),translation.z(),quat.x(),quat.y(),quat.z(),quat.w(),scale.x(),scale.y(),scale.z());\n}\n", "nl": "Set <code>this</code> matrix to <tt>(T * R * S)<sup>-1</sup></tt>, where <tt>T</tt> is the given <code>translation</code>, <tt>R</tt> is a rotation transformation specified by the given quaternion, and <tt>S</tt> is a scaling transformation which scales the axes by <code>scale</code>. <p> This method is equivalent to calling: <tt>translationRotateScale(...).invert()</tt>"}
{"code": "public String closureClassName(){\n  return cloClsName;\n}\n", "nl": "Gets closure class name (applicable only for TRANSFORM operations)."}
{"code": "public static void charge(int slotID,IStrictEnergyStorage storer){\n  IInventory inv=(TileEntityContainerBlock)storer;\n  if (inv.getStackInSlot(slotID) != null && storer.getEnergy() > 0) {\n    if (inv.getStackInSlot(slotID).getItem() instanceof IEnergizedItem) {\n      storer.setEnergy(storer.getEnergy() - EnergizedItemManager.charge(inv.getStackInSlot(slotID),storer.getEnergy()));\n    }\n else     if (MekanismUtils.useIC2() && inv.getStackInSlot(slotID).getItem() instanceof IElectricItem) {\n      double sent=ElectricItem.manager.charge(inv.getStackInSlot(slotID),(int)(storer.getEnergy() * general.TO_IC2),4,true,false) * general.FROM_IC2;\n      storer.setEnergy(storer.getEnergy() - sent);\n    }\n else     if (MekanismUtils.useRF() && inv.getStackInSlot(slotID).getItem() instanceof IEnergyContainerItem) {\n      ItemStack itemStack=inv.getStackInSlot(slotID);\n      IEnergyContainerItem item=(IEnergyContainerItem)inv.getStackInSlot(slotID).getItem();\n      int itemEnergy=(int)Math.round(Math.min(Math.sqrt(item.getMaxEnergyStored(itemStack)),item.getMaxEnergyStored(itemStack) - item.getEnergyStored(itemStack)));\n      int toTransfer=(int)Math.round(Math.min(itemEnergy,(storer.getEnergy() * general.TO_TE)));\n      storer.setEnergy(storer.getEnergy() - (item.receiveEnergy(itemStack,toTransfer,false) * general.FROM_TE));\n    }\n  }\n}\n", "nl": "Universally charges an item, and updates the TileEntity's energy level."}
{"code": "public ZkBinLogStateConfig build(){\n  ZkBinLogStateConfig zkBinLogStateConfig=new ZkBinLogStateConfig(this);\n  return zkBinLogStateConfig;\n}\n", "nl": "Build the complete object with properties that were set."}
{"code": "public boolean offerFirst(E e){\n  addFirst(e);\n  return true;\n}\n", "nl": "Inserts the specified element at the front of this deque."}
{"code": "public TermNode right(){\n  return (TermNode)super.getRequiredProperty(Annotations.RIGHT);\n}\n", "nl": "Returns the right term."}
{"code": "private void advanceIfCurrentPieceFullyRead(){\n  if (currentPiece != null && currentPieceIndex == currentPieceSize) {\n    currentPieceOffsetInRope+=currentPieceSize;\n    currentPieceIndex=0;\n    if (pieceIterator.hasNext()) {\n      currentPiece=pieceIterator.next();\n      currentPieceSize=currentPiece.size();\n    }\n else {\n      currentPiece=null;\n      currentPieceSize=0;\n    }\n  }\n}\n", "nl": "Skips to the next piece if we have read all the data in the current piece.  Sets currentPiece to null if we have reached the end of the input."}
{"code": "private MapSettings(){\n  this(megamek.common.preference.PreferenceManager.getClientPreferences().getBoardWidth(),megamek.common.preference.PreferenceManager.getClientPreferences().getBoardHeight(),megamek.common.preference.PreferenceManager.getClientPreferences().getMapWidth(),megamek.common.preference.PreferenceManager.getClientPreferences().getMapHeight());\n}\n", "nl": "Creates new MapSettings"}
{"code": "public void addElement(int value){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  super.addElement(value);\n}\n", "nl": "Append a Node onto the vector."}
{"code": "public DefaultStateContext(Stage stage,Message<E> message,MessageHeaders messageHeaders,ExtendedState extendedState,Transition<S,E> transition,StateMachine<S,E> stateMachine,State<S,E> source,State<S,E> target,Exception exception){\n  this.stage=stage;\n  this.message=message;\n  this.messageHeaders=messageHeaders;\n  this.extendedState=extendedState;\n  this.transition=transition;\n  this.stateMachine=stateMachine;\n  this.source=source;\n  this.target=target;\n  this.exception=exception;\n  this.sources=null;\n  this.targets=null;\n}\n", "nl": "Instantiates a new default state context."}
{"code": "@Override @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED) public InstanceStatus modifyInstance(String instanceId,ProvisioningSettings currentSettings,ProvisioningSettings newSettings) throws APPlatformException {\n  LOGGER.info(\"modifyInstance({})\",LogAndExceptionConverter.getLogText(instanceId,currentSettings));\n  try {\n    newSettings.getParameters().put(PropertyHandler.STACK_NAME,currentSettings.getParameters().get(PropertyHandler.STACK_NAME));\n    PropertyHandler ph=new PropertyHandler(newSettings);\n    ph.setState(FlowState.MODIFICATION_REQUESTED);\n    InstanceStatus result=new InstanceStatus();\n    result.setChangedParameters(newSettings.getParameters());\n    return result;\n  }\n catch (  Exception t) {\n    throw LogAndExceptionConverter.createAndLogPlatformException(t,Context.MODIFICATION);\n  }\n}\n", "nl": "Starts the modification of an application instance. <p> The internal status <code>MODIFICATION_REQUESTED</code> is stored as a controller configuration setting. It is evaluated and handled by the status dispatcher, which is invoked at regular intervals by APP through the <code>getInstanceStatus</code> method."}
{"code": "public void addDisconnectedEventListener(Executor executor,PeerDisconnectedEventListener listener){\n  disconnectedEventListeners.add(new ListenerRegistration(listener,executor));\n}\n", "nl": "Registers a listener that is invoked when a peer is disconnected."}
{"code": "public static Object invokeMethod(Object instance,Class<?> clazz,String methodName,Object... arguments) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n  return getMethod(clazz,methodName,DataType.getPrimitive(arguments)).invoke(instance,arguments);\n}\n", "nl": "Invokes a method of the target class on an object with the given arguments"}
{"code": "@PostConstruct public void postConstruct() throws Exception {\n  timeStarted=System.currentTimeMillis();\n  dateStarted=new Date(timeStarted);\n  if (log.isInfoEnabled()) {\n    log.info(\"|-CMR Management Service active...\");\n  }\n}\n", "nl": "Is executed after dependency injection is done to perform any initialization."}
{"code": "public String toXML(boolean header){\n  XmlTextBuilder bdr;\n  String tagName=\"Sender\";\n  bdr=new XmlTextBuilder();\n  if (header)   bdr.setStandardHeader();\n  bdr.addOpeningTag(tagName);\n  bdr.addSimpleElement(\"Id\",id);\n  bdr.addSimpleElement(\"Name\",name);\n  bdr.addSimpleElement(\"FirstName\",firstName);\n  bdr.addSimpleElement(\"SurName\",surName);\n  bdr.addSimpleElement(\"SurName2\",surName2);\n  bdr.addSimpleElement(\"EMail\",email);\n  bdr.addSimpleElement(\"Certificate_Issuer\",certificateIssuer);\n  bdr.addSimpleElement(\"Certificate_SN\",certificateSN);\n  bdr.addSimpleElement(\"InQualityOf\",inQuality);\n  bdr.addSimpleElement(\"Social_Name\",socialName);\n  bdr.addSimpleElement(\"CIF\",CIF);\n  bdr.addClosingTag(tagName);\n  return bdr.getText();\n}\n", "nl": "Recoge los valores de la instancia en una cadena xml"}
{"code": "@DELETE @Produces(MediaType.APPLICATION_JSON) @Path(\"/{alertId}/notifications/{notificationId}\") @Description(\"Deletes a notification having the given ID if it is associated with the given alert ID.  Associated triggers are not deleted from the alert.\") public Response deleteNotificationsById(@Context HttpServletRequest req,@PathParam(\"alertId\") BigInteger alertId,@PathParam(\"notificationId\") BigInteger notificationId){\n  if (alertId == null || alertId.compareTo(BigInteger.ZERO) < 1) {\n    throw new WebApplicationException(\"Alert Id cannot be null and must be a positive non-zero number.\",Status.BAD_REQUEST);\n  }\n  if (notificationId == null || notificationId.compareTo(BigInteger.ZERO) < 1) {\n    throw new WebApplicationException(\"Notification Id cannot be null and must be a positive non-zero number.\",Status.BAD_REQUEST);\n  }\n  Alert alert=alertService.findAlertByPrimaryKey(alertId);\n  if (alert == null) {\n    throw new WebApplicationException(Response.Status.NOT_FOUND.getReasonPhrase(),Response.Status.NOT_FOUND);\n  }\n  validateResourceAuthorization(req,alert.getOwner(),getRemoteUser(req));\n  List<Notification> listNotification=new ArrayList<Notification>(alert.getNotifications());\n  Iterator<Notification> it=listNotification.iterator();\n  while (it.hasNext()) {\n    Notification notification=it.next();\n    if (notification.getId().equals(notificationId)) {\n      it.remove();\n      alert.setNotifications(listNotification);\n      alert.setModifiedBy(getRemoteUser(req));\n      alertService.updateAlert(alert);\n      return Response.status(Status.OK).build();\n    }\n  }\n  throw new WebApplicationException(Response.Status.NOT_FOUND.getReasonPhrase(),Response.Status.NOT_FOUND);\n}\n", "nl": "Deletes the notification."}
{"code": "protected static IJavaElement handleToElement(final String project,final String handle,final boolean check){\n  return handleToElement(null,project,handle,check);\n}\n", "nl": "Converts an input handle back to the corresponding java element."}
{"code": "public MetadataOmittedITCase(String name){\n  super(name);\n}\n", "nl": "Construct a new instance of this test case."}
{"code": "@Deprecated public static Header[] parseHeaders(final InputStream is) throws IOException, HttpException {\n  LOG.trace(\"enter HeaderParser.parseHeaders(InputStream, String)\");\n  return parseHeaders(is,\"US-ASCII\");\n}\n", "nl": "Parses headers from the given stream. Headers with the same name are not combined."}
{"code": "public boolean containsJoint(Joint joint){\n  return this.joints.contains(joint);\n}\n", "nl": "Returns true if this world contains the given joint."}
{"code": "private Builder(){\n  super(com.wipro.ats.bdre.imcrawler.mr.Contents.SCHEMA$);\n}\n", "nl": "Creates a new Builder"}
{"code": "@Override public boolean supportsCreateDB(){\n  return false;\n}\n", "nl": "Indicate that MySQL can create database from the URL."}
{"code": "public ByteBuffer put(int index,byte b){\n  byteArray.set(index,b);\n  return this;\n}\n", "nl": "Write a byte to the specified index of this buffer without changing the position."}
{"code": "private boolean isParentProperty(MetaProperty metaProperty){\n  return parentProperty != null && metaProperty.getName().equals(parentProperty);\n}\n", "nl": "Checks if specified property is a reference to entity's parent entity. Parent entity can be specified during creating of this screen."}
{"code": "public void store(String filenameToSave,String comments) throws FileNotFoundException, FileAlreadyExistsException {\n  if (StringUtils.isEmpty(filenameToSave)) {\n    throw new FileNotFoundException();\n  }\n  if (filenameToSave.equals(filename)) {\n    throw new FileAlreadyExistsException(filenameToSave);\n  }\n  FileWriter fileWriter=null;\n  BufferedWriter bufferedWriter=null;\n  try {\n    fileWriter=new FileWriter(filenameToSave,false);\n    bufferedWriter=new BufferedWriter(fileWriter);\n    prop.store(bufferedWriter,comments);\n  }\n catch (  IOException e) {\n    logger.error(\"Fail on store properties.\",e);\n  }\n finally {\n    IOUtils.closeQuite(fileWriter);\n    IOUtils.closeQuite(bufferedWriter);\n  }\n}\n", "nl": "Store current properties to file. Always overwrite."}
{"code": "private void closeRemoteResources(){\n  if (reader != null) {\n    try {\n      reader.close();\n    }\n catch (    final IOException ignore) {\n    }\n    reader=null;\n  }\n  if (writer != null) {\n    writer.close();\n    writer=null;\n  }\n  if (socketOutstream != null) {\n    try {\n      socketOutstream.close();\n    }\n catch (    final IOException ignore) {\n    }\n    socketOutstream=null;\n  }\n  if (socketInstream != null) {\n    try {\n      socketInstream.close();\n    }\n catch (    final IOException ignore) {\n    }\n    socketInstream=null;\n  }\n  if (socket != null) {\n    try {\n      socket.close();\n    }\n catch (    final IOException ignore) {\n    }\n    socket=null;\n  }\n}\n", "nl": "Safely close remote resources"}
{"code": "public void delete(String key){\n  mStorage.deleteIfExists(key);\n}\n", "nl": "Delete saved object for given key if it is exist."}
{"code": "public boolean containsFieldValues(Object[] fieldValues){\n  return this.contents.contains(fieldValues);\n}\n", "nl": "Does this set contain a Struct of the correct type with the specified values?"}
{"code": "public RingOfLife(){\n  super(\"emerald ring\",\"ring\",\"emerald-ring\",null);\n  put(\"amount\",1);\n}\n", "nl": "Create a RingOfLife."}
{"code": "public TimeoutException(){\n}\n", "nl": "Creates a new exception."}
{"code": "private boolean processEsbSystemMonitorMessage(String payload){\n  boolean messageProcessed=false;\n  try {\n    sqsNotificationEventService.processSystemMonitorNotificationEvent(payload);\n    messageProcessed=true;\n  }\n catch (  Exception e) {\n    LOGGER.debug(\"Failed to process message from the JMS queue for a system monitor request. jmsQueueName=\\\"{}\\\" jmsMessagePayload={}\",HerdJmsDestinationResolver.SQS_DESTINATION_HERD_INCOMING,payload,e);\n  }\n  return messageProcessed;\n}\n", "nl": "Process the message as system monitor."}
{"code": "public void updateCredentials(String login,String password){\n  sharedPreferences.edit().putString(application.getString(R.string.shared_prefs_login),login).putString(application.getString(R.string.shared_prefs_password),password).apply();\n}\n", "nl": "Update the login and the password in the preferences."}
{"code": "public static boolean isNotEmpty(String[] array){\n  return array != null && array.length > 0;\n}\n", "nl": "Indica si un array tiene valores."}
{"code": "@Override public String toString(){\n  StringBuilder outputString=new StringBuilder();\n  HashSet<String> printed_keys=new HashSet<>();\n  for (int i=0; i < DENSE_FEATURE_NAMES.size(); i++) {\n    outputString.append(String.format(\"%s=%.3f \",DENSE_FEATURE_NAMES.get(i),getDense(i)));\n    printed_keys.add(DENSE_FEATURE_NAMES.get(i));\n  }\n  ArrayList<String> keys=new ArrayList<>(sparseFeatures.keySet());\n  Collections.sort(keys);\n  keys.stream().filter(null).forEach(null);\n  return outputString.toString().trim();\n}\n", "nl": "Outputs a list of feature names. All dense features are printed. Feature names are printed in the order they were read in."}
{"code": "public Bundler putShortArray(String key,short[] value){\n  bundle.putShortArray(key,value);\n  return this;\n}\n", "nl": "Inserts a short array value into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "public int hashCode(){\n  return getName().hashCode() + 31 * mask;\n}\n", "nl": "Returns the hash code value for this CardPermission object."}
{"code": "public static Number sign(Number a){\n  if (isFloatingPoint(a)) {\n    return Math.signum(a.doubleValue());\n  }\n else {\n    return Long.signum(a.longValue());\n  }\n}\n", "nl": "Returns the sign of the number."}
{"code": "public double[][] convertToDoubleMatrix(InputStream input,int rows,int cols) throws IOException {\n  double[][] ret=null;\n  try {\n    ReaderTextCell reader=(ReaderTextCell)MatrixReaderFactory.createMatrixReader(InputInfo.TextCellInputInfo);\n    MatrixBlock mb=reader.readMatrixFromInputStream(input,rows,cols,ConfigurationManager.getBlocksize(),ConfigurationManager.getBlocksize(),(long)rows * cols);\n    ret=DataConverter.convertToDoubleMatrix(mb);\n  }\n catch (  DMLRuntimeException rex) {\n    throw new IOException(rex);\n  }\n  return ret;\n}\n", "nl": "Converts an input stream of a string matrix in textcell format into a dense double array. The number of rows and columns need to be  specified because textcell only represents non-zero values and hence does not define the dimensions in the general case."}
{"code": "FileMenu(){\n  super(I18n.tr(\"&File\"));\n  MENU.add(createMenuItem(new FileMenuActions.SendFileAction()));\n  MENU.addSeparator();\n  MENU.add(createMenuItem(new FileMenuActions.OpenMagnetTorrentAction()));\n  MENU.add(createMenuItem(new FileMenuActions.CreateTorrentAction()));\n  if (!OSUtils.isMacOSX()) {\n    MENU.addSeparator();\n    MENU.add(createMenuItem(new FileMenuActions.CloseAction()));\n    MENU.add(createMenuItem(new FileMenuActions.ExitAction()));\n  }\n}\n", "nl": "Creates a new <tt>FileMenu</tt>, using the <tt>key</tt>  argument for setting the locale-specific title and  accessibility text."}
{"code": "public static String deviceToText(int hByte,int lByte){\n  int mask=0x01;\n  int x=lByte;\n  StringBuilder dev=new StringBuilder();\n  for (int i=8; i > 0; i--) {\n    if ((x & mask) != 0) {\n      dev.append(\" \" + i);\n    }\n    mask=mask << 1;\n  }\n  mask=0x01;\n  x=hByte;\n  for (int i=16; i > 8; i--) {\n    if ((x & mask) != 0) {\n      dev.append(\" \" + i);\n    }\n    mask=mask << 1;\n  }\n  return dev.toString();\n}\n", "nl": "Translate Device Bits to Text"}
{"code": "final float sloppyFreq() throws IOException {\n  ensureFreq();\n  return freq;\n}\n", "nl": "Returns the intermediate \"sloppy freq\" adjusted for edit distance"}
{"code": "public void testNynorskStemming() throws Exception {\n  Reader reader=new StringReader(\"gut guten gutar gutane gutens gutanes\");\n  TokenStream stream=new MockTokenizer(MockTokenizer.WHITESPACE,false);\n  ((Tokenizer)stream).setReader(reader);\n  stream=tokenFilterFactory(\"NorwegianMinimalStem\",\"variant\",\"nn\").create(stream);\n  assertTokenStreamContents(stream,new String[]{\"gut\",\"gut\",\"gut\",\"gut\",\"gut\",\"gut\"});\n}\n", "nl": "Test stemming with variant set explicitly to Nynorsk"}
{"code": "@Override @Inline public void processNode(ObjectReference object){\n  buffer.insert(object.toAddress());\n}\n", "nl": "Enqueue an object during a trace."}
{"code": "public int computePastValue(int[][][] data,int rowNumber,int columnNumber,int t){\n  int pastVal=0;\n  for (int p=0; p < k; p++) {\n    pastVal*=base;\n    pastVal+=data[t - k + 1 + p][rowNumber][columnNumber];\n  }\n  return pastVal;\n}\n", "nl": "Utility function to compute the combined embedded  past values of x up to and including time step t (i.e. (x_{t-k+1}, ... ,x_{t-1},x_{t})) where x is a time-series for a given row and column in data"}
{"code": "public NTLMException(int errorCode,String msg){\n  super(msg);\n  this.errorCode=errorCode;\n}\n", "nl": "Constructs an NTLMException object."}
{"code": "public static Trellis orderTrellis(Trellis trel,double I[][],Random rand){\n  int L=I.length;\n  int Y[]=new int[L];\n  ArrayList<Integer> list=new ArrayList<Integer>();\n  for (  int i : trel.indices) {\n    list.add(new Integer(i));\n  }\n  Y[0]=list.remove(rand.nextInt(L));\n  for (int j=1; j < L; j++) {\n    double max_w=-1.;\n    int j_=-1;\n    for (    int j_prop : list) {\n      double w=trel.weight(Y,j,j_prop,I);\n      if (w >= max_w) {\n        max_w=w;\n        j_=j_prop;\n      }\n    }\n    list.remove(new Integer(j_));\n    Y[j]=j_;\n  }\n  trel=new Trellis(Y,trel.WIDTH,trel.TYPE);\n  return trel;\n}\n", "nl": "OrderTrellis - order the trellis according to marginal label dependencies."}
{"code": "@Override public boolean hasName(){\n  log.log(Level.FINE,\"hasName(): {0}\",event == START_ELEMENT || event == END_ELEMENT);\n  return event == START_ELEMENT || event == END_ELEMENT;\n}\n", "nl": "returns true if the current event has a name (is a START_ELEMENT or END_ELEMENT) returns false otherwise"}
{"code": "public boolean isListenInBackground(){\n  return listenInBackground;\n}\n", "nl": "Returns whether this state is configured to allow background listening."}
{"code": "private void readObject(){\n}\n", "nl": "<!-- begin-user-doc --> Write your own initialization here <!-- end-user-doc -->"}
{"code": "public static boolean isLongCategory(ClassNode type){\n  return type == long_TYPE || isIntCategory(type);\n}\n", "nl": "It is of a long category, if the provided type is a long, its wrapper or if it is a long category."}
{"code": "public static byte[] decode(String s,int options) throws java.io.IOException {\n  if (s == null) {\n    throw new NullPointerException(\"Input string was null.\");\n  }\n  byte[] bytes;\n  try {\n    bytes=s.getBytes(PREFERRED_ENCODING);\n  }\n catch (  java.io.UnsupportedEncodingException uee) {\n    bytes=s.getBytes();\n  }\n  bytes=decode(bytes,0,bytes.length,options);\n  boolean dontGunzip=(options & DONT_GUNZIP) != 0;\n  if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n    int head=((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n    if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n      java.io.ByteArrayInputStream bais=null;\n      java.util.zip.GZIPInputStream gzis=null;\n      java.io.ByteArrayOutputStream baos=null;\n      byte[] buffer=new byte[2048];\n      int length=0;\n      try {\n        baos=new java.io.ByteArrayOutputStream();\n        bais=new java.io.ByteArrayInputStream(bytes);\n        gzis=new java.util.zip.GZIPInputStream(bais);\n        while ((length=gzis.read(buffer)) >= 0) {\n          baos.write(buffer,0,length);\n        }\n        bytes=baos.toByteArray();\n      }\n catch (      java.io.IOException e) {\n        e.printStackTrace();\n      }\n finally {\n        try {\n          baos.close();\n        }\n catch (        Exception e) {\n        }\n        try {\n          gzis.close();\n        }\n catch (        Exception e) {\n        }\n        try {\n          bais.close();\n        }\n catch (        Exception e) {\n        }\n      }\n    }\n  }\n  return bytes;\n}\n", "nl": "Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it."}
{"code": "public CViewsTableRenderer(final IViewsTable table,final IViewContainer container){\n  this.container=Preconditions.checkNotNull(container,\"IE02032: Container argument can't be null\");\n  this.table=Preconditions.checkNotNull(table,\"IE02351: table argument can not be null\");\n  if (starImage == null) {\n    try {\n      starImage=new ImageIcon(CMain.class.getResource(\"data/star.png\").toURI().toURL()).getImage();\n    }\n catch (    MalformedURLException|URISyntaxException e) {\n    }\n  }\n  CWindowManager.instance().addListener(listener);\n  for (  final CGraphWindow window : CWindowManager.instance().getOpenWindows()) {\n    window.addListener(panelListener);\n  }\n}\n", "nl": "Creates a new renderer object."}
{"code": "public void output(OutputStream out){\n  m_html.output(out);\n}\n", "nl": "Output Document"}
{"code": "protected void sequence_ParameterizedTypeRefNominal_TypeRefWithModifiers_TypeRefWithoutModifiers(ISerializationContext context,ParameterizedTypeRef semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: BogusTypeRef returns ParameterizedTypeRef TypeRefWithModifiers returns ParameterizedTypeRef Constraint: ( undefModifier=UndefModifierToken |  (declaredType=[Type|TypeReferenceName] (typeArgs+=TypeArgument typeArgs+=TypeArgument*)? dynamic?='+'? undefModifier=UndefModifierToken?) )"}
{"code": "public static ArchiveAccess createArchiveAccess(){\n  return new ArchiveAccessImpl();\n}\n", "nl": "Crea la instancia para obtener el acceso al sistema de archivadores."}
{"code": "public synchronized final int evictionCount(){\n  return evictionCount;\n}\n", "nl": "Returns the number of values that have been evicted."}
{"code": "public void testAnalyse(){\n  System.out.println(\"analyse\");\n  AuditCommandImpl instance=null;\n}\n", "nl": "Test of analyse method, of class AuditCommandImpl."}
{"code": "public void put(final String key,final int value){\n  pageLookup.put(key,value);\n}\n", "nl": "The pageLookup to set."}
{"code": "public static long estimateMemory(long nrows,long ncols,double sparsity){\n  double cnnz=Math.max(SparseRow.initialCapacity,Math.ceil(sparsity * ncols));\n  double rlen=Math.min(nrows,Math.ceil(sparsity * nrows * ncols));\n  double size=16;\n  size+=rlen * (116 + cnnz * 12);\n  size+=32 + nrows * 8d;\n  return (long)Math.min(size,Long.MAX_VALUE);\n}\n", "nl": "Get the estimated in-memory size of the sparse block in MCSR  with the given dimensions w/o accounting for overallocation."}
{"code": "static boolean isWhiteSpace(char ch){\n  return ((ch == ' ') || (ch == '\\n') || (ch == '\\t')|| (ch == 10)|| (ch == 13));\n}\n", "nl": "Checks if the specified character is a white space or not. Exposed to packaage since used by HTMLComponent as well"}
{"code": "protected double measureHermitianOverlap(ComplexVector other){\n  other.toCartesian();\n  double result=0;\n  double norm1=0;\n  double norm2=0;\n  for (int i=0; i < dimension * 2; ++i) {\n    result+=coordinates[i] * other.coordinates[i];\n    norm1+=coordinates[i] * coordinates[i];\n    norm2+=other.coordinates[i] * other.coordinates[i];\n  }\n  return result / Math.sqrt(norm1 * norm2);\n}\n", "nl": "Measure overlap, again using the Hermitian / Euclidean scalar product."}
{"code": "protected void baselineLayout(int targetSpan,int axis,int[] offsets,int[] spans){\n  int totalAscent=(int)(targetSpan * getAlignment(axis));\n  int totalDescent=targetSpan - totalAscent;\n  int n=getViewCount();\n  for (int i=0; i < n; i++) {\n    View v=getView(i);\n    float align=v.getAlignment(axis);\n    float viewSpan;\n    if (v.getResizeWeight(axis) > 0) {\n      float minSpan=v.getMinimumSpan(axis);\n      float maxSpan=v.getMaximumSpan(axis);\n      if (align == 0.0f) {\n        viewSpan=Math.max(Math.min(maxSpan,totalDescent),minSpan);\n      }\n else       if (align == 1.0f) {\n        viewSpan=Math.max(Math.min(maxSpan,totalAscent),minSpan);\n      }\n else {\n        float fitSpan=Math.min(totalAscent / align,totalDescent / (1.0f - align));\n        viewSpan=Math.max(Math.min(maxSpan,fitSpan),minSpan);\n      }\n    }\n else {\n      viewSpan=v.getPreferredSpan(axis);\n    }\n    offsets[i]=totalAscent - (int)(viewSpan * align);\n    spans[i]=(int)viewSpan;\n  }\n}\n", "nl": "Computes the location and extent of each child view in this <code>BoxView</code> given the <code>targetSpan</code>, which is the width (or height) of the region we have to work with."}
{"code": "public void validateBusinessObjectDataStatusInformation(BusinessObjectDataKey expectedBusinessObjectDataKey,String expectedBusinessObjectDataStatus,BusinessObjectDataStatusInformation businessObjectDataStatusInformation){\n  assertNotNull(businessObjectDataStatusInformation);\n  assertEquals(expectedBusinessObjectDataKey,businessObjectDataStatusInformation.getBusinessObjectDataKey());\n  assertEquals(expectedBusinessObjectDataStatus,businessObjectDataStatusInformation.getStatus());\n}\n", "nl": "Validates the contents of a business object data status information against the specified parameters."}
{"code": "@Override public boolean add(E value){\n  final int hash;\n  int index;\n  if (value == null) {\n    hash=0;\n    index=indexOfNull();\n  }\n else {\n    hash=value.hashCode();\n    index=indexOf(value,hash);\n  }\n  if (index >= 0) {\n    return false;\n  }\n  index=~index;\n  if (mSize >= mHashes.length) {\n    final int n=mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);\n    if (DEBUG)     Log.d(TAG,\"add: grow from \" + mHashes.length + \" to \"+ n);\n    final int[] ohashes=mHashes;\n    final Object[] oarray=mArray;\n    allocArrays(n);\n    if (mHashes.length > 0) {\n      if (DEBUG)       Log.d(TAG,\"add: copy 0-\" + mSize + \" to 0\");\n      System.arraycopy(ohashes,0,mHashes,0,ohashes.length);\n      System.arraycopy(oarray,0,mArray,0,oarray.length);\n    }\n    freeArrays(ohashes,oarray,mSize);\n  }\n  if (index < mSize) {\n    if (DEBUG)     Log.d(TAG,\"add: move \" + index + \"-\"+ (mSize - index)+ \" to \"+ (index + 1));\n    System.arraycopy(mHashes,index,mHashes,index + 1,mSize - index);\n    System.arraycopy(mArray,index,mArray,index + 1,mSize - index);\n  }\n  mHashes[index]=hash;\n  mArray[index]=value;\n  mSize++;\n  return true;\n}\n", "nl": "Adds the specified object to this set. The set is not modified if it already contains the object."}
{"code": "public ArrowNeedle(boolean isArrowAtTop){\n  this.isArrowAtTop=isArrowAtTop;\n}\n", "nl": "Constructs a new arrow needle."}
{"code": "public void deHalfOp(UserHostmask user){\n  if (user == null)   throw new IllegalArgumentException(\"Can't remove halfop on null user\");\n  setMode(\"-h \" + user.getNick());\n}\n", "nl": "Removes owner privileges to a user on a channel. Successful use of this method may require the bot to have operator or halfOp status itself. <p> <b>Warning:</b> Not all IRC servers support this. Some servers may even use it to mean something else!"}
{"code": "@Override public String address(Class<?> api,String address){\n  Objects.requireNonNull(address);\n  if (address.isEmpty()) {\n    address=addressDefault(api);\n  }\n  int slash=address.indexOf(\"/\");\n  if (address.endsWith(\":\") && slash < 0) {\n    address+=\"//\";\n  }\n  int p=address.indexOf(\"://\");\n  int q=-1;\n  if (p > 0) {\n    q=address.indexOf('/',p + 3);\n  }\n  if (address.indexOf('{') > 0) {\n    return addressBraces(api,address);\n  }\n  boolean isPrefix=address.startsWith(\"session:\") || address.startsWith(\"pod:\");\n  if (address.isEmpty() || p > 0 && q < 0 && isPrefix) {\n    if (Vault.class.isAssignableFrom(api)) {\n      TypeRef itemRef=TypeRef.of(api).to(Vault.class).param(\"T\");\n      Class<?> assetClass=itemRef.rawClass();\n      address=address + \"/\" + apiAddress(assetClass);\n    }\n else {\n      address=address + \"/\" + apiAddress(api);\n    }\n  }\n  return address;\n}\n", "nl": "Calculate address from an API with an address default"}
{"code": "private void checkOrMarkPrivateAccess(Expression source,MethodNode mn){\n  if (mn == null) {\n    return;\n  }\n  ClassNode declaringClass=mn.getDeclaringClass();\n  ClassNode enclosingClassNode=typeCheckingContext.getEnclosingClassNode();\n  if (declaringClass != enclosingClassNode || typeCheckingContext.getEnclosingClosure() != null) {\n    int mods=mn.getModifiers();\n    boolean sameModule=declaringClass.getModule() == enclosingClassNode.getModule();\n    String packageName=declaringClass.getPackageName();\n    if (packageName == null) {\n      packageName=\"\";\n    }\n    if ((Modifier.isPrivate(mods) && sameModule)) {\n      addPrivateFieldOrMethodAccess(source,declaringClass,StaticTypesMarker.PV_METHODS_ACCESS,mn);\n    }\n else     if (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName()) && !implementsInterfaceOrIsSubclassOf(enclosingClassNode,declaringClass)) {\n      ClassNode cn=enclosingClassNode;\n      while ((cn=cn.getOuterClass()) != null) {\n        if (implementsInterfaceOrIsSubclassOf(cn,declaringClass)) {\n          addPrivateFieldOrMethodAccess(source,cn,StaticTypesMarker.PV_METHODS_ACCESS,mn);\n          break;\n        }\n      }\n    }\n  }\n}\n", "nl": "Given a method node, checks if we are calling a private method from an inner class."}
{"code": "public static void zipAndEncryptAll(File inZipFile,File outFile,String password,AESEncrypter encrypter) throws IOException {\n  AesZipFileEncrypter enc=new AesZipFileEncrypter(outFile,encrypter);\n  try {\n    enc.addAll(inZipFile,password);\n  }\n  finally {\n    enc.close();\n  }\n}\n", "nl": "Encrypt all files from an existing zip to one new \"zipOutFile\" using \"password\"."}
{"code": "void resetCache(Panel boundaryPanel,DragContext context){\n  ArrayList<Candidate> list=new ArrayList<Candidate>();\n  if (context.draggable != null) {\n    WidgetArea boundaryArea=new WidgetArea(boundaryPanel,null);\n    for (    DropController dropController : dropControllerList) {\n      Candidate candidate=new Candidate(dropController);\n      Widget dropTarget=candidate.getDropTarget();\n      if (DOM.isOrHasChild(context.draggable.getElement(),dropTarget.getElement())) {\n        continue;\n      }\n      if (candidate.getTargetArea().intersects(boundaryArea)) {\n        list.add(candidate);\n      }\n    }\n  }\n  sortedCandidates=list.toArray(new Candidate[list.size()]);\n  Arrays.sort(sortedCandidates);\n}\n", "nl": "Cache a list of eligible drop controllers, sorted by relative DOM positions of their respective drop targets. Called at the beginning of each drag operation, or whenever drop target eligibility has changed while dragging."}
{"code": "public static void main(String[] args){\n  ArrayList<String> tmpArgs=new ArrayList<String>(Arrays.asList(args));\n  int numThreads=1;\n  for (int i=0; i < tmpArgs.size() - 1; i++) {\n    if (tmpArgs.get(i).equals(\"-t\")) {\n      try {\n        numThreads=Integer.parseInt(tmpArgs.get(i + 1));\n        tmpArgs.remove(i + 1);\n        tmpArgs.remove(i);\n      }\n catch (      NumberFormatException e) {\n        System.err.println(\"Invalid number of threads.\");\n        System.err.println(e.getStackTrace());\n      }\n    }\n  }\n  logger.info(\"Number of threads:{}\",numThreads);\n  args=tmpArgs.toArray(new String[0]);\n  StringBuilder cliString=new StringBuilder();\n  for (int i=0; i < args.length; i++) {\n    cliString.append(\" \").append(args[i]);\n  }\n  logger.debug(\"Command line string = {}\",cliString.toString());\n  System.out.println(\"Command line string = \" + cliString.toString());\n  Task task=null;\n  try {\n    task=(Task)ClassOption.cliStringToObject(cliString.toString(),Task.class,null);\n    logger.info(\"Sucessfully instantiating {}\",task.getClass().getCanonicalName());\n  }\n catch (  Exception e) {\n    logger.error(\"Fail to initialize the task\",e);\n    System.out.println(\"Fail to initialize the task\" + e);\n    return;\n  }\n  task.setFactory(new ThreadsComponentFactory());\n  task.init();\n  ThreadsEngine.submitTopology(task.getTopology(),numThreads);\n}\n", "nl": "The main method."}
{"code": "public void testKeyPairGenerator11() throws NoSuchAlgorithmException, NoSuchProviderException {\n  if (!DSASupported) {\n    fail(NotSupportMsg);\n    return;\n  }\n  int[] keys={-10000,-1024,-1,0,10000};\n  KeyPairGenerator[] kpg=createKPGen();\n  assertNotNull(\"KeyPairGenerator objects were not created\",kpg);\n  SecureRandom random=new SecureRandom();\n  AlgorithmParameterSpec aps=null;\n  for (int i=0; i < kpg.length; i++) {\n    for (int j=0; j < keys.length; j++) {\n      try {\n        kpg[i].initialize(keys[j]);\n        kpg[i].initialize(keys[j],random);\n      }\n catch (      InvalidParameterException e) {\n      }\n    }\n    try {\n      kpg[i].initialize(aps);\n      kpg[i].initialize(aps,random);\n    }\n catch (    InvalidAlgorithmParameterException e) {\n    }\n  }\n}\n", "nl": "Test for methods: <code>initialize(int keysize)</code> <code>initialize(int keysize, SecureRandom random)</code> <code>initialize(AlgorithmParameterSpec param)</code> <code>initialize(AlgorithmParameterSpec param, SecureRandom random)</code> Assertion: throws InvalidParameterException or InvalidAlgorithmParameterException when parameters keysize or param are incorrect"}
{"code": "public static IMultiPoint[] randomPoints(int n,int d){\n  IMultiPoint points[]=new IMultiPoint[n];\n  for (int i=0; i < n; i++) {\n    StringBuilder sb=new StringBuilder();\n    for (int j=0; j < d; j++) {\n      sb.append(rGen.nextDouble());\n      if (j < d - 1) {\n        sb.append(\",\");\n      }\n    }\n    points[i]=new Hyperpoint(sb.toString());\n  }\n  return points;\n}\n", "nl": "generate array of n d-dimensional points whose coordinates are values in the range 0 .. 1"}
{"code": "public ObjectMatrix2D like2D(int rows,int columns){\n  return new SparseObjectMatrix2D(rows,columns);\n}\n", "nl": "Construct and returns a new 2-d matrix <i>of the corresponding dynamic type</i>, entirelly independent of the receiver. For example, if the receiver is an instance of type <tt>DenseObjectMatrix1D</tt> the new matrix must be of type <tt>DenseObjectMatrix2D</tt>, if the receiver is an instance of type <tt>SparseObjectMatrix1D</tt> the new matrix must be of type <tt>SparseObjectMatrix2D</tt>, etc."}
{"code": "public int connectSrcHandlerToPackageSync(Context srcContext,Handler srcHandler,String dstPackageName,String dstClassName){\n  if (DBG)   log(\"connect srcHandler to dst Package & class E\");\n  mConnection=new AsyncChannelConnection();\n  mSrcContext=srcContext;\n  mSrcHandler=srcHandler;\n  mSrcMessenger=new Messenger(srcHandler);\n  mDstMessenger=null;\n  Intent intent=new Intent(Intent.ACTION_MAIN);\n  intent.setClassName(dstPackageName,dstClassName);\n  boolean result=srcContext.bindService(intent,mConnection,Context.BIND_AUTO_CREATE);\n  if (DBG)   log(\"connect srcHandler to dst Package & class X result=\" + result);\n  return result ? STATUS_SUCCESSFUL : STATUS_BINDING_UNSUCCESSFUL;\n}\n", "nl": "Connect handler to named package/class synchronously."}
{"code": "@Override public int read() throws IOException {\nsynchronized (lock) {\n    checkNotClosed();\n    if (pos != count) {\n      return str.charAt(pos++);\n    }\n    return -1;\n  }\n}\n", "nl": "Reads a single character from the source string and returns it as an integer with the two higher-order bytes set to 0. Returns -1 if the end of the source string has been reached."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public boolean canBuildFormatter(){\n  return isFormatter(getFormatter());\n}\n", "nl": "Returns true if toFormatter can be called without throwing an UnsupportedOperationException."}
{"code": "public void unsetMatchColumn(int[] columnIdxes) throws SQLException {\n  throw new UnsupportedOperationException();\n}\n", "nl": "Unsets the designated parameter to the given int array. This was set using <code>setMatchColumn</code> as the column which will form the basis of the join. <P> The parameter value unset by this method should be same as was set."}
{"code": "public static boolean areColinear(Vec4 a,Vec4 b,Vec4 c){\n  if (a == null || b == null || c == null) {\n    String msg=Logging.getMessage(\"nullValue.Vec4IsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  Vec4 ab=b.subtract3(a).normalize3();\n  Vec4 bc=c.subtract3(b).normalize3();\n  return Math.abs(ab.dot3(bc)) > 0.999;\n}\n", "nl": "Indicates whether three vectors are colinear."}
{"code": "protected void reset(Point treePoint){\n  this.drawPoint.x=this.bounds.x + treePoint.x;\n  this.drawPoint.y=this.bounds.y + treePoint.y;\n  this.screenBounds=new Rectangle(this.drawPoint.x,this.drawPoint.y,this.bounds.width,this.bounds.height);\n  int pickX=this.pickBounds.x + treePoint.x;\n  int pickY=this.pickBounds.y + treePoint.y;\n  this.pickScreenBounds=new Rectangle(pickX,pickY,this.pickBounds.width,this.pickBounds.height);\n}\n", "nl": "Reset the draw point to the lower left corner of the node bounds."}
{"code": "public SimpleName newSimpleName(String identifier){\n  if (identifier == null) {\n    throw new IllegalArgumentException();\n  }\n  SimpleName result=new SimpleName(this);\n  result.setIdentifier(identifier);\n  return result;\n}\n", "nl": "Creates and returns a new unparented simple name node for the given identifier. The identifier should be a legal Java identifier, but not a keyword, boolean literal (\"true\", \"false\") or null literal (\"null\")."}
{"code": "public double unweightedMacroFmeasure(){\n  return m_delegate.unweightedMacroFmeasure();\n}\n", "nl": "Unweighted macro-averaged F-measure. If some classes not present in the test set, they're just skipped (since recall is undefined there anyway) ."}
{"code": "public HadoopJobHistoryNodeExtractor(Properties prop) throws Exception {\n  this.serverURL=prop.getProperty(Constant.AZ_HADOOP_JOBHISTORY_KEY);\n  String CURRENT_DIR=System.getProperty(\"user.dir\");\n  String WH_HOME=System.getenv(\"WH_HOME\");\n  String USER_HOME=System.getenv(\"HOME\") + \"/.kerberos\";\n  String ETC=\"/etc\";\n  String TMP=\"/var/tmp\" + \"/.kerberos\";\n  String[] allPositions=new String[]{CURRENT_DIR,WH_HOME,USER_HOME,TMP};\n  for (  String possition : allPositions) {\n    String gssFileName=possition + \"/gss-jaas.conf\";\n    File gssFile=new File(gssFileName);\n    if (gssFile.exists()) {\n      logger.debug(\"find gss-jaas.conf file in : {}\",gssFile.getAbsolutePath());\n      System.setProperty(\"java.security.auth.login.config\",gssFile.getAbsolutePath());\n      break;\n    }\n else {\n      logger.debug(\"can't find here: {}\",gssFile.getAbsolutePath());\n    }\n  }\n  for (  String possition : allPositions) {\n    String krb5FileName=possition + \"/krb5.conf\";\n    File krb5File=new File(krb5FileName);\n    if (krb5File.exists()) {\n      logger.debug(\"find krb5.conf file in : {}\",krb5File.getAbsolutePath());\n      System.setProperty(\"java.security.krb5.conf\",krb5File.getAbsolutePath());\n      break;\n    }\n else {\n      logger.debug(\"can't find here: {}\",krb5File.getAbsolutePath());\n    }\n  }\n  if (System.getProperty(\"java.security.auth.login.config\") == null || System.getProperty(\"java.security.krb5.conf\") == null) {\n    throw new Exception(\"Can't find java security config files\");\n  }\n  if (logger.isTraceEnabled()) {\n    System.setProperty(\"sun.security.krb5.debug\",\"true\");\n  }\n else {\n    System.setProperty(\"sun.security.krb5.debug\",\"false\");\n  }\n  System.setProperty(\"javax.security.auth.useSubjectCredsOnly\",\"false\");\n  System.setProperty(\"java.security.krb5.realm\",prop.getProperty(\"krb5.realm\"));\n  System.setProperty(\"java.security.krb5.kdc\",prop.getProperty(\"krb5.kdc\"));\n  PoolingHttpClientConnectionManager cm=new PoolingHttpClientConnectionManager();\n  cm.setMaxTotal(200);\n  cm.setDefaultMaxPerRoute(100);\n  CredentialsProvider credsProvider=new BasicCredentialsProvider();\n  credsProvider.setCredentials(AuthScope.ANY,new UsernamePasswordCredentials(\"DUMMY\",null));\n  Lookup<AuthSchemeProvider> authRegistry=RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.SPNEGO,new SPNegoSchemeFactory()).build();\n  httpClient=HttpClients.custom().setDefaultCredentialsProvider(credsProvider).setDefaultAuthSchemeRegistry(authRegistry).setConnectionManager(cm).build();\n}\n", "nl": "Use HTTPClient to connect to Hadoop job history server. Need to set the environment for kerberos, keytab..."}
{"code": "public Interval withDurationBeforeEnd(ReadableDuration duration){\n  long durationMillis=DateTimeUtils.getDurationMillis(duration);\n  if (durationMillis == toDurationMillis()) {\n    return this;\n  }\n  Chronology chrono=getChronology();\n  long endMillis=getEndMillis();\n  long startMillis=chrono.add(endMillis,durationMillis,-1);\n  return new Interval(startMillis,endMillis,chrono);\n}\n", "nl": "Creates a new interval with the specified duration before the end instant."}
{"code": "public void yypushback(int number){\n  if (number > yylength())   zzScanError(ZZ_PUSHBACK_2BIG);\n  zzMarkedPos-=number;\n}\n", "nl": "Pushes the specified amount of characters back into the input stream. They will be read again by then next call of the scanning method"}
{"code": "public Projection create(Properties props) throws ProjectionException {\n  try {\n    LatLonPoint llp=convertToLLP((Point2D)props.get(ProjectionFactory.CENTER));\n    float scale=PropUtils.floatFromProperties(props,ProjectionFactory.SCALE,10000000);\n    int height=PropUtils.intFromProperties(props,ProjectionFactory.HEIGHT,100);\n    int width=PropUtils.intFromProperties(props,ProjectionFactory.WIDTH,100);\n    return new Mercator(llp,scale,width,height);\n  }\n catch (  Exception e) {\n    if (Debug.debugging(\"proj\")) {\n      Debug.output(\"MercatorLoader: problem creating Mercator projection \" + e.getMessage());\n    }\n  }\n  throw new ProjectionException(\"MercatorLoader: problem creating Mercator projection\");\n}\n", "nl": "Create the projection with the given parameters."}
{"code": "@Override public void zoomRangeAxes(double lowerPercent,double upperPercent,PlotRenderingInfo info,Point2D source){\n  XYPlot subplot=findSubplot(info,source);\n  if (subplot != null) {\n    subplot.zoomRangeAxes(lowerPercent,upperPercent,info,source);\n  }\n else {\n    for (    XYPlot p : this.subplots) {\n      p.zoomRangeAxes(lowerPercent,upperPercent,info,source);\n    }\n  }\n}\n", "nl": "Zooms in on the range axes."}
{"code": "private void startReconcilingPositions(){\n  presenter.addAllPositions(removedPositions);\n  removedPositionCount=removedPositions.size();\n}\n", "nl": "Start reconciling positions."}
{"code": "public void actionPerformed(ActionEvent e){\n  log.info(\"Cmd=\" + e.getActionCommand());\n  if (e.getActionCommand().equals(ConfirmPanel.A_CANCEL)) {\n    dispose();\n    return;\n  }\n  saveSelection();\n  if (selection != null && selection.size() > 0 && m_selectionActive && m_DD_Order_ID != null && m_MovementDate != null)   generateMovements();\n else   dispose();\n}\n", "nl": "Action Listener"}
{"code": "UniformModel(final int numOutcomes){\n  mNumOutcomes=numOutcomes;\n}\n", "nl": "Construct a uniform model."}
{"code": "public int lengthOfLastWord(String s){\n  if (s == null || s.length() == 0)   return 0;\n  int len=s.length();\n  int count=0;\n  for (int i=len - 1; i >= 0; i--) {\n    if (s.charAt(i) != ' ')     count++;\n    if (s.charAt(i) == ' ' && count != 0)     return count;\n  }\n  return count;\n}\n", "nl": "Traverse backwards Use count to remember length of word Start counting from non-space char Return when next space is met and length is not zero"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public void trace(String msg,Throwable t){\n}\n", "nl": "Do nothing"}
{"code": "@Override protected void doGet(HttpServletRequest request,HttpServletResponse response){\n  processGetRequest(request,response);\n}\n", "nl": "Handles the HTTP <code>GET</code> method."}
{"code": "public ListIterator<VariableMapElement> iterator(){\n  return list.listIterator(0);\n}\n", "nl": "Creates and returns an enumerator for this object"}
{"code": "public GPUImage3x3ConvolutionFilter(final float[] convolutionKernel){\n  super(THREE_X_THREE_TEXTURE_SAMPLING_FRAGMENT_SHADER);\n  mConvolutionKernel=convolutionKernel;\n}\n", "nl": "Instantiates a new GPUimage3x3ConvolutionFilter with given convolution kernel."}
{"code": "@RequestMapping(value=BUSINESS_OBJECT_DATA_NOTIFICATIONS_URI_PREFIX + \"/namespaces/{namespace}/notificationNames/{notificationName}\",method=RequestMethod.PUT) @Secured(SecurityFunctions.FN_BUSINESS_OBJECT_DATA_NOTIFICATION_REGISTRATIONS_PUT) public BusinessObjectDataNotificationRegistration updateBusinessObjectDataNotificationRegistration(@PathVariable(\"namespace\") String namespace,@PathVariable(\"notificationName\") String notificationName,@RequestBody BusinessObjectDataNotificationRegistrationUpdateRequest request){\n  return businessObjectDataNotificationRegistrationService.updateBusinessObjectDataNotificationRegistration(new NotificationRegistrationKey(namespace,notificationName),request);\n}\n", "nl": "Updates an existing business object data notification by key. <p>Requires WRITE permission on namespace</p> <p>Requires READ permission on filter namespace</p> <p>Requires EXECUTE permission on ALL job action namespaces</p>"}
{"code": "boolean isDimming(){\n  return mTargetAlpha != 0;\n}\n", "nl": "Return true if dim layer is showing"}
{"code": "public static StringSet declaredSymbolsInScopeSet(ModuleNode module,Location loc){\n  StringSet result=new StringSet();\n  addDeclaredSymbolsInScopeSet(result,module,loc);\n  return result;\n}\n", "nl": "Returns a HashSet containing all user-definable names that are globally  defined or declared at Location loc of the module.  The returned value may or may not contain strings that are not user-definable names--in particular strings like \"I!bar\".   If the statement at loc defines or declares a symbol, that symbol does not appear in the returned value.  However, the implementation assumes that there there is no declaration or definition that begins on the same line as the beginning of loc.  If there is, the symbol it defines will not  appear in the returned result.  The method also assumes that loc is after any EXTENDS statement in the module."}
{"code": "private final void increaseConcentration(double by){\n  setConcentration(getConcentration() + by);\n}\n", "nl": "Increase the current concentration by a certain amount. According to increase the concentration the amount of nectar has to be recomputed."}
{"code": "public PostProcessor(int fboWidth,int fboHeight,boolean useDepth,boolean useAlphaChannel,boolean use32Bits){\n  this(fboWidth,fboHeight,useDepth,useAlphaChannel,use32Bits,TextureWrap.ClampToEdge,TextureWrap.ClampToEdge);\n}\n", "nl": "Construct a new PostProcessor with the given parameters, defaulting to <em>TextureWrap.ClampToEdge</em> as texture wrap mode"}
{"code": "public static void main(String[] args){\n  ComparableCircle comparableCircle1=new ComparableCircle(12.5);\n  ComparableCircle comparableCircle2=new ComparableCircle(18.3);\n  System.out.println(\"\\nComparableCircle1:\");\n  System.out.println(comparableCircle1);\n  System.out.println(\"\\nComparableCircle2:\");\n  System.out.println(comparableCircle2);\n  System.out.println((comparableCircle1.compareTo(comparableCircle2) == 1 ? \"\\nComparableCircle1 \" : \"\\nComparableCircle2 \") + \"is the larger of the two Circles\");\n}\n", "nl": "Main method"}
{"code": "public FilterQuery track(final String[] track){\n  this.track=track;\n  return this;\n}\n", "nl": "Sets track"}
{"code": "public static PolygonRDD SpatialRangeQueryUsingIndex(PolygonRDD polygonRDD,Envelope envelope,Integer condition){\n  if (polygonRDD.indexedRDDNoId == null) {\n    throw new NullPointerException(\"Need to invoke buildIndex() first, indexedRDDNoId is null\");\n  }\n  JavaRDD<Polygon> result=polygonRDD.indexedRDDNoId.mapPartitions(new PolygonRangeFilterUsingIndex(envelope));\n  return new PolygonRDD(result);\n}\n", "nl": "Spatial range query on top of PolygonRDD"}
{"code": "public byte[] analyzeWavData(InputStream i){\n  try {\n    int headSize=44, metaDataSize=48;\n    byte[] data=IOUtils.toByteArray(i);\n    if (data.length < headSize) {\n      throw new IOException(\"Wrong Wav header\");\n    }\n    if (this.sampleRate == 0 && data.length > 28) {\n      this.sampleRate=readInt(data,24);\n    }\n    int destPos=headSize + metaDataSize;\n    int rawLength=data.length - destPos;\n    byte[] d=new byte[rawLength];\n    System.arraycopy(data,destPos,d,0,rawLength);\n    return d;\n  }\n catch (  IOException e) {\n    Log.e(TAG,\"Error while formatting header\");\n  }\n  return new byte[0];\n}\n", "nl": "Analyze sample rate and return the PCM data"}
{"code": "public Quaterniond scale(double factor){\n  return scale(factor,this);\n}\n", "nl": "Scale the rotation represented by this quaternion by the given <code>factor</code> using spherical linear interpolation. <p> This method is equivalent to performing a spherical linear interpolation between the unit quaternion and <code>this</code>, and thus equivalent to calling: <tt>new Quaterniond().slerp(this, factor)</tt> <p> Reference: <a href=\"http://fabiensanglard.net/doom3_documentation/37725-293747_293747.pdf\">http://fabiensanglard.net</a>"}
{"code": "private void handleDispose(){\n  if (infoFont != null && !infoFont.isDisposed()) {\n    infoFont.dispose();\n  }\n  infoFont=null;\n  if (titleFont != null && !titleFont.isDisposed()) {\n    titleFont.dispose();\n  }\n  titleFont=null;\n}\n", "nl": "The dialog is being disposed. Dispose of any resources allocated."}
{"code": "public String prepareTable(ColumnInfo[] layout,String from,String where,boolean multiSelection,String tableName,boolean addAccessSQL){\n  int columnIndex=0;\n  StringBuffer sql=new StringBuffer(\"SELECT \");\n  setLayout(layout);\n  clearColumns();\n  setColorColumn(-1);\n  setMultiSelection(multiSelection);\n  for (columnIndex=0; columnIndex < layout.length; columnIndex++) {\n    if (columnIndex > 0) {\n      sql.append(\", \");\n    }\n    sql.append(layout[columnIndex].getColSQL());\n    if (layout[columnIndex].isKeyPairCol()) {\n      sql.append(\",\").append(layout[columnIndex].getKeyPairColSQL());\n    }\n    addColumn(layout[columnIndex]);\n    if (layout[columnIndex].isColorColumn()) {\n      setColorColumn(columnIndex);\n    }\n    if (layout[columnIndex].getColClass() == IDColumn.class) {\n      setKeyColumnIndex(columnIndex);\n    }\n  }\n  for (columnIndex=0; columnIndex < layout.length; columnIndex++) {\n    setColumnClass(columnIndex,layout[columnIndex].getColClass(),layout[columnIndex].isReadOnly(),layout[columnIndex].getColHeader());\n  }\n  sql.append(\" FROM \").append(from);\n  sql.append(\" WHERE \").append(where);\n  if (from.length() == 0) {\n    return sql.toString();\n  }\n  if (addAccessSQL) {\n    String finalSQL=MRole.getDefault().addAccessSQL(sql.toString(),tableName,MRole.SQL_FULLYQUALIFIED,MRole.SQL_RO);\n    logger.finest(finalSQL);\n    return finalSQL;\n  }\n else {\n    return sql.toString();\n  }\n}\n", "nl": "Prepare Table and return SQL required to get resultset to populate table"}
{"code": "public ReadInputRegistersRequest(int ref,int count){\n  super();\n  setFunctionCode(Modbus.READ_INPUT_REGISTERS);\n  setDataLength(4);\n  setReference(ref);\n  setWordCount(count);\n}\n", "nl": "Constructs a new <tt>ReadInputRegistersRequest</tt> instance with a given reference and count of words to be read. <p>"}
{"code": "protected void correlatedPointAddedCallback(int correlatedTimeStep){\n  boolean sourceMatches=false;\n  if (Math.abs(sourceObs - source[correlatedTimeStep]) <= kernelWidthSourceInUse) {\n    countPastSource++;\n    sourceMatches=true;\n  }\n  if (Math.abs(destNextObs - destNext[correlatedTimeStep]) <= kernelWidthsInUse[0]) {\n    countNextPast++;\n    if (sourceMatches) {\n      countNextPastSource++;\n    }\n  }\n}\n", "nl": "A callback for where a correlated point is found at correlatedTimeStep in the destination's past. Now check whether we need to increment the joint counts."}
{"code": "public void showFab(float translationX,float translationY){\n  setFabAnchor(translationX,translationY);\n  if (!isSheetVisible()) {\n    fab.show(translationX,translationY);\n  }\n}\n", "nl": "Shows the FAB and sets the FAB's translation."}
{"code": "@Override public void add(Permission permission){\n  if (!(permission instanceof PackagePermission))   throw new IllegalArgumentException(\"invalid permission: \" + permission);\n  if (isReadOnly())   throw new SecurityException(\"attempt to add a Permission to a \" + \"readonly PermissionCollection\");\n  PackagePermission pp=(PackagePermission)permission;\n  String name=pp.getName();\n  PackagePermission existing=(PackagePermission)permissions.get(name);\n  if (existing != null) {\n    int oldMask=existing.getMask();\n    int newMask=pp.getMask();\n    if (oldMask != newMask) {\n      permissions.put(name,new PackagePermission(name,oldMask | newMask));\n    }\n  }\n else {\n    permissions.put(name,permission);\n  }\n  if (!all_allowed) {\n    if (name.equals(\"*\"))     all_allowed=true;\n  }\n}\n", "nl": "Adds a permission to the <tt>PackagePermission</tt> objects. The key for the hash is the name."}
{"code": "protected boolean convertToUppercase(){\n  return false;\n}\n", "nl": "Method convertToUppercase."}
{"code": "public void queryGreaterThan(String type,int index,String value,int page,int limit,int visibilityScope,CloudResponse<CloudObject[]> response){\n  try {\n    queryImpl(type,value,index,page,limit,visibilityScope,2,0,false,false,false,response);\n  }\n catch (  CloudException e) {\n    response.onError(e);\n  }\n}\n", "nl": "Performs a query to the server finding the objects where the key value is greater than the given value.  This operation executes immeditely without waiting for commit."}
{"code": "public static byte[] parseSchemeSpecificData(byte[] atom,UUID uuid){\n  Pair<UUID,byte[]> parsedAtom=parsePsshAtom(atom);\n  if (parsedAtom == null) {\n    return null;\n  }\n  if (uuid != null && !uuid.equals(parsedAtom.first)) {\n    Log.w(TAG,\"UUID mismatch. Expected: \" + uuid + \", got: \"+ parsedAtom.first+ \".\");\n    return null;\n  }\n  return parsedAtom.second;\n}\n", "nl": "Parses the scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are supported. <p> The scheme specific data is only parsed if the data is a valid PSSH atom matching the given UUID, or if the data is a valid PSSH atom of any type in the case that the passed UUID is null."}
{"code": "private boolean termFilter(Term term,String[] desiredFields,int minFreq,int maxFreq,int maxNonAlphabet,boolean filterNumbers,int minTermLength){\n  if (filterNumbers) {\n    try {\n      Double.parseDouble(term.text());\n      return false;\n    }\n catch (    Exception e) {\n    }\n  }\n  return termFilter(term,desiredFields,minFreq,maxFreq,maxNonAlphabet,minTermLength);\n}\n", "nl": "Applies termFilter and additionally (if requested) filters out digit-only words."}
{"code": "protected String int2singlealphaCount(long val,CharArrayWrapper table){\n  int radix=table.getLength();\n  if (val > radix) {\n    return getZeroString();\n  }\n else   return (new Character(table.getChar((int)val - 1))).toString();\n}\n", "nl": "Convert a long integer into alphabetic counting, in other words count using the sequence A B C ... Z."}
{"code": "public void componentHidden(final ComponentEvent e){\n  setVisible(false);\n}\n", "nl": "Invoked when the component has been made invisible. MenuComponent.setVisible does nothing, so we remove the ScreenMenuItem from the ScreenMenu but leave it in fItems"}
{"code": "protected Position computeMainLabelPosition(DrawContext dc,TacticalGraphicLabel label,Position midpoint,Position posB){\n  Globe globe=dc.getGlobe();\n  Vec4 pMid=globe.computePointFromPosition(midpoint);\n  Vec4 pB=globe.computePointFromPosition(posB);\n  Vec4 normal=globe.computeSurfaceNormalAtPoint(pMid);\n  Vec4 vMB=pB.subtract3(pMid);\n  Vec4 eyePoint=dc.getView().getEyePoint();\n  double pixelSize=dc.getView().computePixelSizeAtDistance(eyePoint.distanceTo3(pMid));\n  Rectangle labelBounds=label.getBounds(dc);\n  double labelDiagonal=labelBounds != null ? Math.hypot(labelBounds.width,labelBounds.height) : 0d;\n  double pixelDistance=labelDiagonal / 2.0;\n  Vec4 perpendicular=vMB.cross3(normal);\n  perpendicular=perpendicular.normalize3().multiply3(this.getWidth() / 2.0 + pixelDistance * pixelSize);\n  Vec4 pLabel=pMid.add3(perpendicular);\n  return globe.computePositionFromPoint(pLabel);\n}\n", "nl": "Compute the position of the graphic's main label. This label is positioned to the side of the first segment along the route."}
{"code": "protected void validateState(State currentState){\n  ValidationUtils.validateState(currentState);\n}\n", "nl": "Validate the service state for coherence."}
{"code": "public void updateTableEntity(TableEntity tableEntity,boolean commit){\n  SolrInputDocument doc=new SolrInputDocument();\n  doc.setField(ID,tableEntity.getFqdn());\n  doc.setField(TYPE,TYPE_TABLE);\n  doc.setField(DATABASE_NAME,tableEntity.getDatabaseName());\n  doc.setField(TABLE_NAME,tableEntity.getTableName());\n  doc.setField(FIELDS,tableEntity.getFieldNames());\n  doc.setField(TRANSFORMATION,tableEntity.getTransformationType().split(\" -> \")[0]);\n  doc.setField(EXPORTS,tableEntity.getExportNames());\n  doc.setField(STORAGE_FORMAT,tableEntity.getStorageFormat());\n  doc.setField(MATERIALIZE_ONCE,tableEntity.isMaterializeOnce());\n  doc.setField(EXTERNAL,tableEntity.isExternalTable());\n  doc.setField(CREATED_AT,tableEntity.getCreatedAt());\n  doc.setField(OWNER,tableEntity.getTableOwner());\n  doc.setField(DESCRIPTION,tableEntity.getTableDescription());\n  doc.setField(TAXONOMIES,tableEntity.getTaxonomyNames());\n  doc.setField(CATEGORIES,tableEntity.getCategoryNames());\n  doc.setField(CATEGORIE_OBJECTSS,tableEntity.getCategoryObjectNames());\n  doc.setField(TAGS,tableEntity.getTags());\n  doc.setField(STATUS,tableEntity.getStatus());\n  if (tableEntity.getComment() != null) {\n    doc.setField(DOCUMENTATION,tableEntity.getComment().getPlainText());\n    String comments=\"\";\n    for (    CommentEntity comment : tableEntity.getComments()) {\n      if (!comments.isEmpty()) {\n        comments+=\"     \";\n      }\n      comments+=comment.getUsername() + \": \" + comment.getPlainText();\n    }\n    if (!comments.isEmpty()) {\n      doc.setField(COMMENTS,comments);\n    }\n  }\n  addDocument(doc);\n  if (commit) {\n    commit();\n  }\n}\n", "nl": "Updates the Solr document for the given table entity"}
{"code": "private ArrayDBIDs initialSet(DBIDs sampleSet,int k,Random random){\n  return DBIDUtil.ensureArray(DBIDUtil.randomSample(sampleSet,k,random));\n}\n", "nl": "Returns a set of k elements from the specified sample set."}
{"code": "private byte[] blockFragmentizerSafe(long blockIdx) throws IOException {\n  try {\n    try {\n      return block(blockIdx);\n    }\n catch (    IgfsCorruptedFileException e) {\n      if (log.isDebugEnabled())       log.debug(\"Failed to fetch file block [path=\" + path + \", fileInfo=\"+ fileInfo+ \", blockIdx=\"+ blockIdx+ \", errMsg=\"+ e.getMessage()+ ']');\n      if (fileInfo != null && fileInfo.fileMap() != null && !fileInfo.fileMap().ranges().isEmpty()) {\n        IgfsEntryInfo newInfo=igfsCtx.meta().info(fileInfo.id());\n        if (newInfo == null)         throw new IgfsPathNotFoundException(\"Failed to read file block (file was concurrently \" + \"deleted) [path=\" + path + \", blockIdx=\"+ blockIdx+ ']');\n        fileInfo=newInfo;\n        locCache.clear();\n        if (log.isDebugEnabled())         log.debug(\"Updated input stream file info after block fetch failure [path=\" + path + \", fileInfo=\"+ fileInfo+ ']');\n        return block(blockIdx);\n      }\n      throw new IOException(e.getMessage(),e);\n    }\n  }\n catch (  IgniteCheckedException e) {\n    throw new IOException(e.getMessage(),e);\n  }\n}\n", "nl": "Method to safely retrieve file block. In case if file block is missing this method will check file map and update file info. This may be needed when file that we are reading is concurrently fragmented."}
{"code": "public ReplacableProperties loadProperties(){\n  ReplacableProperties propertiesBeingLoaded=new ReplacableProperties();\n  try (InputStream propertiesToLoad=PlayOnLinuxContext.class.getClassLoader().getResourceAsStream(this.getPropertyFileName())){\n    propertiesBeingLoaded.load(propertiesToLoad);\n  }\n catch (  PlayOnLinuxException|IOException e) {\n    throw new PlayOnLinuxRuntimeException(\"Cannot load properties\",e);\n  }\n  return propertiesBeingLoaded;\n}\n", "nl": "Get the properties for the current OS"}
{"code": "public ThumbnailParameterBuilder fitWithinDimensions(boolean fit){\n  this.fitWithinDimensions=fit;\n  return this;\n}\n", "nl": "Sets whether or not the thumbnail should fit within the specified dimensions."}
{"code": "private boolean isBoundsEnforced(){\n  return boundsEnforced;\n}\n", "nl": "True iff bounds checking is performed on variable values indices."}
{"code": "@SuppressWarnings(\"unchecked\") public JdbcData(Connection connection,String table,boolean buffered){\n  this.connection=connection;\n  this.table=table;\n  setBuffered(buffered);\n  try {\n    setColumnTypes(getJdbcColumnTypes());\n  }\n catch (  SQLException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Initializes a new instance to query the data from a specified table using a specified JDBC connection. It is assumed the table columns are constant during the connection."}
{"code": "public void dispatch(){\n  try {\n    if (catchExceptions) {\n      try {\n        runnable.run();\n      }\n catch (      Throwable t) {\n        if (t instanceof Exception) {\n          exception=(Exception)t;\n        }\n        throwable=t;\n      }\n    }\n else {\n      runnable.run();\n    }\n  }\n  finally {\n    finishedDispatching(true);\n  }\n}\n", "nl": "Executes the Runnable's <code>run()</code> method and notifies the notifier (if any) when <code>run()</code> has returned or thrown an exception."}
{"code": "public void lock(){\n  lockPositions(true);\n  this.locked=true;\n}\n", "nl": "Lock this Order."}
{"code": "private int measureLong(int measureSpec){\n  int result;\n  int specMode=MeasureSpec.getMode(measureSpec);\n  int specSize=MeasureSpec.getSize(measureSpec);\n  if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n    result=specSize;\n  }\n else {\n    final int count=mViewPager.getAdapter().getCount();\n    result=(int)(getPaddingLeft() + getPaddingRight() + (count * 2 * mRadius)+ (count - 1) * mRadius + 1);\n    if (specMode == MeasureSpec.AT_MOST) {\n      result=Math.min(result,specSize);\n    }\n  }\n  return result;\n}\n", "nl": "Determines the width of this view"}
{"code": "public void trace(String format,Object arg1,Object arg2){\n}\n", "nl": "Do nothing"}
{"code": "public static String makeKey(String host,int port,String transport){\n  return new StringBuffer(host).append(\":\").append(port).append(\"/\").append(transport).toString().toLowerCase();\n}\n", "nl": "Construct a key to refer to this structure from the SIP stack"}
{"code": "protected void buildSettings(){\n  SETTINGS=SEARCH_SETTINGS;\n}\n", "nl": "Sets SETTINGS to be the static SEARCH_SETTINGS, instead of constructing a new one for each ResultPanel."}
{"code": "public void testNoElementThrowsException(){\n  try {\n    util.selectElementMatchingXPath(\"app-deployment\",testElement);\n    fail(\"should have thrown an exception\");\n  }\n catch (  ElementNotFoundException e) {\n    assertEquals(testElement,e.getSearched());\n  }\n}\n", "nl": "Test that search for a non-existing element throws an exception."}
{"code": "public String replace(final StringBuffer source,final int offset,final int length){\n  if (source == null) {\n    return null;\n  }\n  final StrBuilder buf=new StrBuilder(length).append(source,offset,length);\n  substitute(buf,0,length);\n  return buf.toString();\n}\n", "nl": "Replaces all the occurrences of variables with their matching values from the resolver using the given source buffer as a template. The buffer is not altered by this method. <p> Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not returned."}
{"code": "public Builder addKernel(Script.KernelID k){\n  if (mLines.size() != 0) {\n    throw new RSInvalidStateException(\"Kernels may not be added once connections exist.\");\n  }\n  if (findNode(k) != null) {\n    return this;\n  }\n  mKernelCount++;\n  Node n=findNode(k.mScript);\n  if (n == null) {\n    n=new Node(k.mScript);\n    mNodes.add(n);\n  }\n  n.mKernels.add(k);\n  return this;\n}\n", "nl": "Adds a Kernel to the group."}
{"code": "@Override public void unregisterVASACertificate(String existingCertificate) throws InvalidCertificate, InvalidSession, StorageFault {\n  final String methodName=\"unregisterVASACertificate(): \";\n  log.debug(methodName + \"Entry with input existingCertificate[\" + (existingCertificate != null ? \"***\" : null)+ \"]\");\n  try {\n    _sslUtil.checkHttpRequest(true,true);\n    X509Certificate x509Cert=(X509Certificate)_sslUtil.buildCertificate(existingCertificate);\n    SimpleTimeCounter counter=new SimpleTimeCounter(\"unregisterVASACertificate\");\n    unregisterCertificate(x509Cert);\n    counter.stop();\n  }\n catch (  InvalidSession is) {\n    log.error(methodName + \"invalid session\",is);\n    throw is;\n  }\ncatch (  InvalidCertificate ic) {\n    log.error(methodName + \"invalid certificate\",ic);\n    throw ic;\n  }\ncatch (  StorageFault sf) {\n    log.error(methodName + \"storage fault occured \",sf);\n    throw sf;\n  }\ncatch (  Exception e) {\n    log.error(methodName + \"unknown exception\",e);\n    throw FaultUtil.StorageFault(\"runtime \",e);\n  }\n  log.debug(methodName + \"Exit\");\n}\n", "nl": "vasaService interface"}
{"code": "K key(){\n  return key;\n}\n", "nl": "Getter of key."}
{"code": "private void clearListSelection(){\n  _pathList.clearSelection();\n  int state=_block.getState() & ~OBlock.ALLOCATED;\n  _block.pseudoPropertyChange(\"state\",Integer.valueOf(0),Integer.valueOf(state));\n  _length.setText(\"\");\n}\n", "nl": "*********************** end setup"}
{"code": "public static String[] stringArrayFromString(String string,char delimiter){\n  List<String> result=new ArrayList<String>(10);\n  if (StringUtils.isNotBlank(string)) {\n    RaptorStringTokenizer tok=new RaptorStringTokenizer(string,String.valueOf(delimiter),false);\n    while (tok.hasMoreTokens()) {\n      String token=tok.nextToken();\n      result.add(token);\n    }\n  }\n  return result.toArray(new String[0]);\n}\n", "nl": "Returns a String[] of strings from a string that is formatted in what toString(String[]) returns."}
{"code": "public boolean startsWith(XMLString prefix){\n  return startsWith(prefix,0);\n}\n", "nl": "Tests if this string starts with the specified prefix."}
{"code": "public boolean isEnableMove(){\n  return this.enableMove;\n}\n", "nl": "Specifies whether the user can move the frame by dragging the title bar."}
{"code": "public String toString(){\n  return \"[Certificate Exception: \" + getMessage() + \"]\";\n}\n", "nl": "Returns a string describing the certificate exception."}
{"code": "public DistributionLocatorId(int port,String bindAddress){\n  this(port,bindAddress,null);\n}\n", "nl": "Constructs a DistributionLocatorId with the given port. The host will be set to the local host."}
{"code": "@Override public double kurtosis(){\n  QL.require(sampleNumber_ > 3,UNSUFFICIENT_SAMPLE_NUMBER_3);\n  double m=mean();\n  double v=variance();\n  double c=(sampleNumber_ - 1.0) / (sampleNumber_ - 2.0);\n  c*=(sampleNumber_ - 1.0) / (sampleNumber_ - 3.0);\n  c*=3.0;\n  if (v == 0)   return c;\n  double result=fourthPowerSum_ / sampleWeight_;\n  result-=4.0 * m * (cubicSum_ / sampleWeight_);\n  result+=6.0 * m * m* (quadraticSum_ / sampleWeight_);\n  result-=3.0 * m * m* m* m;\n  result/=v * v;\n  result*=sampleNumber_ / (sampleNumber_ - 1.0);\n  result*=sampleNumber_ / (sampleNumber_ - 2.0);\n  result*=(sampleNumber_ + 1.0) / (sampleNumber_ - 3.0);\n  return result - c;\n}\n", "nl": "returns the excess kurtosis, defined as \\fracN^2(N+1)}{(N-1)(N-2)(N-3)} \\frac{\\left\\langle \\left(x-\\langle x \\rangle \\right)^4 \\right\\rangle}{\\sigma^4} - \\frac{3(N-1)^2}{(N-2)(N-3)}. } The above evaluates to 0 for a Gaussian distribution."}
{"code": "public void testSneakyFieldTypes() throws Exception {\n  TypeFactory tf=TypeFactory.defaultInstance();\n  Field field=SneakyBean.class.getDeclaredField(\"intMap\");\n  JavaType type=tf.constructType(field.getGenericType());\n  assertTrue(type instanceof MapType);\n  MapType mapType=(MapType)type;\n  assertEquals(tf.constructType(Integer.class),mapType.getKeyType());\n  assertEquals(tf.constructType(Long.class),mapType.getContentType());\n  field=SneakyBean.class.getDeclaredField(\"longList\");\n  type=tf.constructType(field.getGenericType());\n  assertTrue(type instanceof CollectionType);\n  CollectionType collectionType=(CollectionType)type;\n  assertEquals(tf.constructType(Long.class),collectionType.getContentType());\n}\n", "nl": "Plus sneaky types may be found via introspection as well."}
{"code": "public LambdaContainer(LambdaBlock wrapper,int arity){\n  super();\n  this.loadFXML(\"LambdaContainer\");\n  this.wrapper=wrapper;\n  attachedBlocks=new HashSet<>();\n  this.args=new ArrayList<>();\n  for (int i=0; i < arity; i++) {\n    this.args.add(new BinderAnchor(this,wrapper,new Binder(\"a_\" + i)));\n  }\n  this.res=new ResultAnchor(this,wrapper,Optional.empty());\n  this.argSpace.getChildren().addAll(this.args);\n  this.resSpace.getChildren().add(this.res);\n  TouchContext context=new TouchContext(this,false);\n  context.setPanningAction(null);\n}\n", "nl": "Constructs a LambdaContainer for an untyped lambda of n arguments."}
{"code": "public void mouseDragged(final MouseEvent e){\n  if (drawingWalls) {\n    draggingPoint=e.getPoint();\n    repaint();\n  }\n  if (selectedEntity != null) {\n    final Point test=new Point(e.getPoint().x + distanceX,e.getPoint().y + distanceY);\n    final Rectangle testRect=new Rectangle((int)test.getX(),(int)test.getY(),selectedEntity.getWidth(),selectedEntity.getHeight());\n    testRect.grow(-5,-5);\n    if (getBounds().contains((testRect.getBounds()))) {\n      selectedEntity.setX(test.x);\n      selectedEntity.setY(test.y);\n      repaint();\n    }\n  }\n}\n", "nl": "Task to perform when mouse button is held and mouse moved."}
{"code": "private void fillNewTags(final Map<String,Object> dataModel) throws Exception {\n  dataModel.put(Common.NEW_TAGS,tagQueryService.getNewTags(Symphonys.getInt(\"newTagsCnt\")));\n}\n", "nl": "Fils new tags."}
{"code": "public void listaTiposDocumentosExecuteLogic(ActionMapping mappings,ActionForm form,HttpServletRequest request,HttpServletResponse response){\n  saveCurrentInvocation(KeysClientsInvocations.DOCUMENTOS_VITALES_VER_TIPOS_DOCUMENTOS,request);\n  request.setAttribute(DocumentosVitalesConstants.TIPOS_DOCUMENTOS_VITALES_KEY,getGestionDocumentosVitalesBI(request).getTiposDocumentosVitales());\n  setReturnActionFordward(request,mappings.findForward(\"ver_tipos\"));\n}\n", "nl": "Muestra la lista de tipos de documentos vitales."}
{"code": "public MicroPipelineManager(final String processingNodeId,final ComponentRepository componentRepository,final int maxNumberOfThreads) throws RequiredInputMissingException {\n  if (componentRepository == null)   throw new RequiredInputMissingException(\"Missing required component repository\");\n  if (StringUtils.isBlank(processingNodeId))   throw new RequiredInputMissingException(\"Missing required processing node identifier\");\n  this.processingNodeId=StringUtils.lowerCase(StringUtils.trim(processingNodeId));\n  this.microPipelineFactory=new MicroPipelineFactory(this.processingNodeId,componentRepository);\n  if (maxNumberOfThreads == 1)   this.executorService=Executors.newSingleThreadExecutor();\n else   if (maxNumberOfThreads > 1)   this.executorService=Executors.newFixedThreadPool(maxNumberOfThreads);\n else   this.executorService=Executors.newCachedThreadPool();\n}\n", "nl": "Initializes the micro pipeline manager"}
{"code": "@Override public void close(){\n  _client.destroy();\n}\n", "nl": "Close the client"}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static LoggingFraction createDefaultLoggingFraction(Level level){\n  return new LoggingFraction().applyDefaults(level);\n}\n", "nl": "Create a default logging fraction for the specified level."}
{"code": "public void init() throws ServletException {\n}\n", "nl": "Initialization of the servlet. <br>"}
{"code": "public static synchronized Bitmap decodeSampledBitmapFromFile(String filename,int reqWidth,int reqHeight){\n  final BitmapFactory.Options options=new BitmapFactory.Options();\n  options.inJustDecodeBounds=true;\n  BitmapFactory.decodeFile(filename,options);\n  options.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);\n  options.inJustDecodeBounds=false;\n  return BitmapFactory.decodeFile(filename,options);\n}\n", "nl": "Decode and sample down a bitmap from a file to the requested width and height."}
{"code": "public Quaterniond rotateLocalX(double angle){\n  return rotateLocalX(angle,this);\n}\n", "nl": "Apply a rotation to <code>this</code> quaternion rotating the given radians about the local x axis. <p> If <code>Q</code> is <code>this</code> quaternion and <code>R</code> the quaternion representing the  specified rotation, then the new quaternion will be <code>R * Q</code>. So when transforming a vector <code>v</code> with the new quaternion by using <code>R * Q * v</code>, the rotation represented by <code>this</code> will be applied first!"}
{"code": "DrmConstraintInfo(){\n  count=-1;\n  startDate=-1;\n  endDate=-1;\n  interval=-1;\n}\n", "nl": "Construct the DrmConstraint."}
{"code": "private InstrumentationNode cloneWithNewTarget(ValueNode newTarget,VirtualizerTool tool){\n  InstrumentationNode clone=new InstrumentationNode(newTarget,anchored,weakDependencies.size(),stateBefore);\n  clone.instrumentationGraph=instrumentationGraph;\n  for (int i=0; i < weakDependencies.size(); i++) {\n    ValueNode input=weakDependencies.get(i);\n    if (!(input instanceof VirtualObjectNode)) {\n      ValueNode alias=tool.getAlias(input);\n      if (alias instanceof VirtualObjectNode) {\n        clone.weakDependencies.initialize(i,alias);\n        continue;\n      }\n    }\n    clone.weakDependencies.initialize(i,input);\n  }\n  return clone;\n}\n", "nl": "Clone the InstrumentationNode with the given new target. The weakDependencies will be initialized with aliased nodes."}
{"code": "public SaveAsAction(KseFrame kseFrame){\n  super(kseFrame);\n  putValue(ACCELERATOR_KEY,KeyStroke.getKeyStroke(res.getString(\"SaveAsAction.accelerator\").charAt(0),Toolkit.getDefaultToolkit().getMenuShortcutKeyMask() + InputEvent.ALT_MASK));\n  putValue(LONG_DESCRIPTION,res.getString(\"SaveAsAction.statusbar\"));\n  putValue(NAME,res.getString(\"SaveAsAction.text\"));\n  putValue(SHORT_DESCRIPTION,res.getString(\"SaveAsAction.tooltip\"));\n  putValue(SMALL_ICON,new ImageIcon(Toolkit.getDefaultToolkit().createImage(getClass().getResource(res.getString(\"SaveAsAction.image\")))));\n}\n", "nl": "Construct action."}
{"code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  trimToFileCount();\n  journalWriter.flush();\n}\n", "nl": "Force buffered operations to the filesystem."}
{"code": "@Override void initAnimation(){\n  if (!mInitialized) {\n    int numValues=mValues.length;\n    for (int i=0; i < numValues; ++i) {\n      mValues[i].setupSetterAndGetter(mTarget);\n    }\n    super.initAnimation();\n  }\n}\n", "nl": "This function is called immediately before processing the first animation frame of an animation. If there is a nonzero <code>startDelay</code>, the function is called after that delay ends. It takes care of the final initialization steps for the animation. This includes setting mEvaluator, if the user has not yet set it up, and the setter/getter methods, if the user did not supply them. <p>Overriders of this method should call the superclass method to cause internal mechanisms to be set up correctly.</p>"}
{"code": "public StatementBuilder(String string){\n  builder=new StringBuilder(string);\n}\n", "nl": "Create a new builder."}
{"code": "private void relocateFromHeaders(ByteBuffer f,SceModule module,int baseAddress,Elf32 elf,int elfOffset) throws IOException {\n  int i=0;\n  for (  Elf32ProgramHeader phdr : elf.getProgramHeaderList()) {\n    if (phdr.getP_type() == 0x700000A0L) {\n      int RelCount=phdr.getP_filesz() / Elf32Relocate.sizeof();\n      if (log.isDebugEnabled()) {\n        log.debug(String.format(\"PH#%d: relocating %d entries\",i,RelCount));\n      }\n      f.position(elfOffset + phdr.getP_offset());\n      relocateFromBuffer(f,module,baseAddress,elf,RelCount,true);\n      return;\n    }\n else     if (phdr.getP_type() == 0x700000A1L) {\n      if (log.isDebugEnabled()) {\n        log.debug(String.format(\"Type 0x700000A1 PH#%d: relocating A1 entries, size=0x%X\",i,phdr.getP_filesz()));\n      }\n      f.position(elfOffset + phdr.getP_offset());\n      relocateFromBufferA1(f,elf,baseAddress,i,phdr.getP_filesz());\n      return;\n    }\n    i++;\n  }\n  for (  Elf32SectionHeader shdr : elf.getSectionHeaderList()) {\n    if (mustRelocate(elf,shdr)) {\n      int RelCount=shdr.getSh_size() / Elf32Relocate.sizeof();\n      if (log.isDebugEnabled()) {\n        log.debug(shdr.getSh_namez() + \": relocating \" + RelCount+ \" entries\");\n      }\n      f.position(elfOffset + shdr.getSh_offset());\n      relocateFromBuffer(f,module,baseAddress,elf,RelCount,shdr.getSh_type() != Elf32SectionHeader.SHT_REL);\n    }\n  }\n}\n", "nl": "Uses info from the elf program headers and elf section headers to relocate a PRX."}
{"code": "public CompiledST defineTemplate(String name,String argsS,String template){\n  if (name.charAt(0) != '/')   name=\"/\" + name;\n  String[] args=argsS.split(\",\");\n  List<FormalArgument> a=new ArrayList<FormalArgument>();\n  for (  String arg : args) {\n    a.add(new FormalArgument(arg));\n  }\n  return defineTemplate(name,new CommonToken(GroupParser.ID,name),a,template,null);\n}\n", "nl": "for testing"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-03-24 16:07:23.812 -0400\",hash_original_method=\"F5106D0386D3020336DFAB8E81694EB1\",hash_generated_method=\"19EBF7A8C1F496ACA7BB8F658932423D\") private void onAgentCancel(){\n  Intent intent=new Intent(BluetoothDevice.ACTION_PAIRING_CANCEL);\n  mContext.sendBroadcast(intent,BLUETOOTH_ADMIN_PERM);\n  mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_AGENT_CANCEL),1500);\n  return;\n}\n", "nl": "Called by native code on a Cancel method call to org.bluez.Agent."}
{"code": "public String optString(int index){\n  return this.optString(index,\"\");\n}\n", "nl": "Get the optional string value associated with an index. It returns an empty string if there is no value at that index. If the value is not a string and is not null, then it is coverted to a string."}
{"code": "public void addOutMessage(final String address){\n}\n", "nl": "Add a new OSC out message with the specified address."}
{"code": "@Override public void remove(){\n  throw new UnsupportedOperationException(\"The remove  operation is not supported by this Iterator.\");\n}\n", "nl": "The remove  operation is not supported by this Iterator."}
{"code": "@PostMapping(consumes=\"multipart/form-data\") public ResponseEntity<FileInfo> uploadFile(@RequestParam(\"file\") MultipartFile file,@RequestParam(required=false) String name,HttpServletRequest request){\n  try {\n    if (Strings.isNullOrEmpty(name)) {\n      name=file.getOriginalFilename();\n    }\n    long size=file.getSize();\n    FileDescriptor fd=createFileDescriptor(name,size);\n    InputStream is=file.getInputStream();\n    uploadToMiddleware(is,fd);\n    saveFileDescriptor(fd);\n    return createFileInfoResponseEntity(request,fd);\n  }\n catch (  Exception e) {\n    log.error(\"File upload failed\",e);\n    throw new RestAPIException(\"File upload failed\",\"File upload failed\",HttpStatus.INTERNAL_SERVER_ERROR);\n  }\n}\n", "nl": "Method for multipart file upload. It expects the file contents to be passed in the part called 'file'"}
{"code": "static double ensureNonNegative(double value){\n  checkArgument(!isNaN(value));\n  if (value > 0.0) {\n    return value;\n  }\n else {\n    return 0.0;\n  }\n}\n", "nl": "Returns its argument if it is non-negative, zero if it is negative."}
{"code": "public v4ParserException(){\n}\n", "nl": "Used for remote debugger deserialization"}
{"code": "void log(String msg){\n  System.err.println(msg);\n}\n", "nl": "Write a message to stderr."}
{"code": "@After public void tearDown() throws Exception {\n  Locale.setDefault(this.savedLocale);\n}\n", "nl": "Restore the default locale after the tests complete."}
{"code": "public void multiply(Matrix2f rhs){\n  Matrix2f tmp=new Matrix2f();\n  tmp.loadMultiply(this,rhs);\n  load(tmp);\n}\n", "nl": "Post-multiplies the current matrix by a given parameter"}
{"code": "public Quaternionf mul(float qx,float qy,float qz,float qw){\n  set(w * qx + x * qw + y * qz - z * qy,w * qy - x * qz + y * qw + z * qx,w * qz + x * qy - y * qx + z * qw,w * qw - x * qx - y * qy - z * qz);\n  return this;\n}\n", "nl": "Multiply this quaternion by the quaternion represented via <tt>(qx, qy, qz, qw)</tt>. <p> If <tt>T</tt> is <code>this</code> and <tt>Q</tt> is the given quaternion, then the resulting quaternion <tt>R</tt> is: <p> <tt>R = T * Q</tt> <p> So, this method uses post-multiplication like the matrix classes, resulting in a vector to be transformed by <tt>Q</tt> first, and then by <tt>T</tt>."}
{"code": "public JRangeSlider createRangeSlider(int orientation,int direction){\n  return new JRangeSlider(m_model,orientation,direction);\n}\n", "nl": "Create a new range slider for interacting with the query, using the given orientation and direction."}
{"code": "private JPopupMenu createOperatorPopupMenu(){\n  JPopupMenu menu=new JPopupMenu();\n  menu.add(EXPAND_ALL_ACTION);\n  menu.add(COLLAPSE_ALL_ACTION);\n  menu.addSeparator();\n  String name=\"Tree\";\n  if (mainFrame.getProcess().getProcessLocation() != null) {\n    name=mainFrame.getProcess().getProcessLocation().getShortName();\n  }\n  menu.add(PrintingTools.makeExportPrintMenu(this,name));\n  return menu;\n}\n", "nl": "Creates a new popup menu for the selected operator."}
{"code": "public final LC rightToLeft(){\n  setLeftToRight(Boolean.FALSE);\n  return this;\n}\n", "nl": "Same functionality as setLeftToRight(false) only this method returns <code>this</code> for chaining multiple calls. <p> For a more thorough explanation of what this constraint does see the white paper or cheat Sheet at www.migcomponents.com."}
{"code": "private boolean removeOrMaterializeIf(SimplifierTool tool){\n  assert trueSuccessor().hasNoUsages() && falseSuccessor().hasNoUsages();\n  if (trueSuccessor().next() instanceof AbstractEndNode && falseSuccessor().next() instanceof AbstractEndNode) {\n    AbstractEndNode trueEnd=(AbstractEndNode)trueSuccessor().next();\n    AbstractEndNode falseEnd=(AbstractEndNode)falseSuccessor().next();\n    AbstractMergeNode merge=trueEnd.merge();\n    if (merge == falseEnd.merge() && trueSuccessor().anchored().isEmpty() && falseSuccessor().anchored().isEmpty()) {\n      PhiNode singlePhi=null;\n      int distinct=0;\n      for (      PhiNode phi : merge.phis()) {\n        ValueNode trueValue=phi.valueAt(trueEnd);\n        ValueNode falseValue=phi.valueAt(falseEnd);\n        if (trueValue != falseValue) {\n          distinct++;\n          singlePhi=phi;\n        }\n      }\n      if (distinct == 0) {\n        removeThroughFalseBranch(tool);\n        return true;\n      }\n else       if (distinct == 1) {\n        ValueNode trueValue=singlePhi.valueAt(trueEnd);\n        ValueNode falseValue=singlePhi.valueAt(falseEnd);\n        ConditionalNode conditional=canonicalizeConditionalCascade(trueValue,falseValue);\n        if (conditional != null) {\n          singlePhi.setValueAt(trueEnd,conditional);\n          removeThroughFalseBranch(tool);\n          return true;\n        }\n      }\n    }\n  }\n  if (trueSuccessor().next() instanceof ReturnNode && falseSuccessor().next() instanceof ReturnNode) {\n    ReturnNode trueEnd=(ReturnNode)trueSuccessor().next();\n    ReturnNode falseEnd=(ReturnNode)falseSuccessor().next();\n    ValueNode trueValue=trueEnd.result();\n    ValueNode falseValue=falseEnd.result();\n    ValueNode value=null;\n    if (trueValue != null) {\n      if (trueValue == falseValue) {\n        value=trueValue;\n      }\n else {\n        value=canonicalizeConditionalCascade(trueValue,falseValue);\n        if (value == null) {\n          return false;\n        }\n      }\n    }\n    ReturnNode newReturn=graph().add(new ReturnNode(value));\n    replaceAtPredecessor(newReturn);\n    GraphUtil.killCFG(this);\n    return true;\n  }\n  return false;\n}\n", "nl": "Tries to remove an empty if construct or replace an if construct with a materialization."}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "private void resize(int c){\n  int[] newItems=new int[c];\n  for (int i=0; i < items.length; i+=1) {\n    newItems[i]=items[i];\n  }\n  items=newItems;\n}\n", "nl": "Resizes ITEMS to C, copying things over."}
{"code": "public static double calculateRSquared(Instances data,double ssr) throws Exception {\n  double yMean=data.meanOrMode(data.classIndex());\n  double tss=0.0;\n  for (int i=0; i < data.numInstances(); i++) {\n    tss+=(data.instance(i).value(data.classIndex()) - yMean) * (data.instance(i).value(data.classIndex()) - yMean);\n  }\n  double rsq=1 - (ssr / tss);\n  return rsq;\n}\n", "nl": "Returns the R-squared value for a linear regression model, where sum of squared residuals is already calculated. This works for either a simple or a multiple linear regression model."}
{"code": "public final void testSetCaseSensitivity(){\n  Case caseSensitivity=Case.UPPERCASE;\n  LetterOrNumberValidator characterOrNumberValidator=new LetterOrNumberValidator(\"foo\",Case.CASE_INSENSITIVE,true);\n  characterOrNumberValidator.setCaseSensitivity(caseSensitivity);\n  assertEquals(caseSensitivity,characterOrNumberValidator.getCaseSensitivity());\n}\n", "nl": "Tests the functionality of the method, which allows to set the case sensitivity."}
{"code": "@Util public static void resetAdminTenantId(){\n  session.put(TENANT_ID,Security.getUserInfo().getTenant());\n}\n", "nl": "Resets the AdminTenant in the session back to the users TenantId"}
{"code": "public void closeAllFiles(){\n  while (m_TabbedPane.getTabCount() > 0) {\n    if (!saveChanges(true)) {\n      return;\n    }\n    m_TabbedPane.removeTabAt(getCurrentIndex());\n    updateFrameTitle();\n    System.gc();\n  }\n}\n", "nl": "closes all open files"}
{"code": "@Override public final int size(){\n  return (int)Math.max((tail.get() - head.get()),0);\n}\n", "nl": "This implemention is known to be broken if preemption were to occur after reading the tail pointer. Code should not depend on size for a correct result."}
{"code": "public RAkELdTest(String name){\n  super(name);\n}\n", "nl": "Initializes the test."}
{"code": "public static void main(String[] args){\n  try {\n    int fdNum=Integer.parseInt(args[0],10);\n    int targetSdkVersion=Integer.parseInt(args[1],10);\n    if (fdNum != 0) {\n      try {\n        FileDescriptor fd=ZygoteInit.createFileDescriptor(fdNum);\n        DataOutputStream os=new DataOutputStream(new FileOutputStream(fd));\n        os.writeInt(Process.myPid());\n        os.close();\n        IoUtils.closeQuietly(fd);\n      }\n catch (      IOException ex) {\n        Slog.d(TAG,\"Could not write pid of wrapped process to Zygote pipe.\",ex);\n      }\n    }\n    ZygoteInit.preload();\n    String[] runtimeArgs=new String[args.length - 2];\n    System.arraycopy(args,2,runtimeArgs,0,runtimeArgs.length);\n    RuntimeInit.wrapperInit(targetSdkVersion,runtimeArgs);\n  }\n catch (  ZygoteInit.MethodAndArgsCaller caller) {\n    caller.run();\n  }\n}\n", "nl": "The main function called when starting a runtime application through a wrapper process instead of by forking Zygote. The first argument specifies the file descriptor for a pipe that should receive the pid of this process, or 0 if none. The second argument is the target SDK version for the app. The remaining arguments are passed to the runtime."}
{"code": "private final void completeConstruction(){\n  if (mDbg)   mSm.log(\"completeConstruction: E\");\n  int maxDepth=0;\n  for (  StateInfo si : mStateInfo.values()) {\n    int depth=0;\n    for (StateInfo i=si; i != null; depth++) {\n      i=i.parentStateInfo;\n    }\n    if (maxDepth < depth) {\n      maxDepth=depth;\n    }\n  }\n  if (mDbg)   mSm.log(\"completeConstruction: maxDepth=\" + maxDepth);\n  mStateStack=new StateInfo[maxDepth];\n  mTempStateStack=new StateInfo[maxDepth];\n  setupInitialStateStack();\n  sendMessageAtFrontOfQueue(obtainMessage(SM_INIT_CMD,mSmHandlerObj));\n  if (mDbg)   mSm.log(\"completeConstruction: X\");\n}\n", "nl": "Complete the construction of the state machine."}
{"code": "private void createTestImage(){\n  mInitialImage=new byte[3 * mSize / 2];\n  for (int i=0; i < mSize; i++) {\n    mInitialImage[i]=(byte)(40 + i % 199);\n  }\n  for (int i=mSize; i < 3 * mSize / 2; i+=2) {\n    mInitialImage[i]=(byte)(40 + i % 200);\n    mInitialImage[i + 1]=(byte)(40 + (i + 99) % 200);\n  }\n}\n", "nl": "Creates the test image that will be used to feed the encoder."}
{"code": "public void addCascaded(Component comp,Integer layer){\n  this.add(comp,layer);\n  if (comp instanceof JInternalFrame) {\n    this.cascade(comp);\n  }\n  this.moveToFront(comp);\n}\n", "nl": "Method addCascaded."}
{"code": "private static void dualPivotQuicksort(long[] a,int left,int right){\n  int sixth=(right - left + 1) / 6;\n  int e1=left + sixth;\n  int e5=right - sixth;\n  int e3=(left + right) >>> 1;\n  int e4=e3 + sixth;\n  int e2=e3 - sixth;\n  long ae1=a[e1], ae2=a[e2], ae3=a[e3], ae4=a[e4], ae5=a[e5];\n  if (ae1 > ae2) {\n    long t=ae1;\n    ae1=ae2;\n    ae2=t;\n  }\n  if (ae4 > ae5) {\n    long t=ae4;\n    ae4=ae5;\n    ae5=t;\n  }\n  if (ae1 > ae3) {\n    long t=ae1;\n    ae1=ae3;\n    ae3=t;\n  }\n  if (ae2 > ae3) {\n    long t=ae2;\n    ae2=ae3;\n    ae3=t;\n  }\n  if (ae1 > ae4) {\n    long t=ae1;\n    ae1=ae4;\n    ae4=t;\n  }\n  if (ae3 > ae4) {\n    long t=ae3;\n    ae3=ae4;\n    ae4=t;\n  }\n  if (ae2 > ae5) {\n    long t=ae2;\n    ae2=ae5;\n    ae5=t;\n  }\n  if (ae2 > ae3) {\n    long t=ae2;\n    ae2=ae3;\n    ae3=t;\n  }\n  if (ae4 > ae5) {\n    long t=ae4;\n    ae4=ae5;\n    ae5=t;\n  }\n  a[e1]=ae1;\n  a[e3]=ae3;\n  a[e5]=ae5;\n  long pivot1=ae2;\n  a[e2]=a[left];\n  long pivot2=ae4;\n  a[e4]=a[right];\n  int less=left + 1;\n  int great=right - 1;\n  boolean pivotsDiffer=(pivot1 != pivot2);\n  if (pivotsDiffer) {\n    outer:     for (int k=less; k <= great; k++) {\n      long ak=a[k];\n      if (ak < pivot1) {\n        if (k != less) {\n          a[k]=a[less];\n          a[less]=ak;\n        }\n        less++;\n      }\n else       if (ak > pivot2) {\n        while (a[great] > pivot2) {\n          if (great-- == k) {\n            break outer;\n          }\n        }\n        if (a[great] < pivot1) {\n          a[k]=a[less];\n          a[less++]=a[great];\n          a[great--]=ak;\n        }\n else {\n          a[k]=a[great];\n          a[great--]=ak;\n        }\n      }\n    }\n  }\n else {\n    for (int k=less; k <= great; k++) {\n      long ak=a[k];\n      if (ak == pivot1) {\n        continue;\n      }\n      if (ak < pivot1) {\n        if (k != less) {\n          a[k]=a[less];\n          a[less]=ak;\n        }\n        less++;\n      }\n else {\n        while (a[great] > pivot1) {\n          great--;\n        }\n        if (a[great] < pivot1) {\n          a[k]=a[less];\n          a[less++]=a[great];\n          a[great--]=ak;\n        }\n else {\n          a[k]=pivot1;\n          a[great--]=ak;\n        }\n      }\n    }\n  }\n  a[left]=a[less - 1];\n  a[less - 1]=pivot1;\n  a[right]=a[great + 1];\n  a[great + 1]=pivot2;\n  doSort(a,left,less - 2);\n  doSort(a,great + 2,right);\n  if (!pivotsDiffer) {\n    return;\n  }\n  if (less < e1 && great > e5) {\n    while (a[less] == pivot1) {\n      less++;\n    }\n    while (a[great] == pivot2) {\n      great--;\n    }\n    outer:     for (int k=less; k <= great; k++) {\n      long ak=a[k];\n      if (ak == pivot2) {\n        while (a[great] == pivot2) {\n          if (great-- == k) {\n            break outer;\n          }\n        }\n        if (a[great] == pivot1) {\n          a[k]=a[less];\n          a[less++]=pivot1;\n        }\n else {\n          a[k]=a[great];\n        }\n        a[great--]=pivot2;\n      }\n else       if (ak == pivot1) {\n        a[k]=a[less];\n        a[less++]=pivot1;\n      }\n    }\n  }\n  doSort(a,less,great);\n}\n", "nl": "Sorts the specified range of the array into ascending order by the Dual-Pivot Quicksort algorithm."}
{"code": "public final int yystate(){\n  return zzLexicalState;\n}\n", "nl": "Returns the current lexical state."}
{"code": "@Override public void onSeekComplete(MediaPlayer mp){\n  Log.d(TAG,\"onSeekComplete\");\n  stopLoading();\n  if (lastState != null) {\nswitch (lastState) {\ncase STARTED:\n{\n        start();\n        break;\n      }\ncase PLAYBACKCOMPLETED:\n{\n      currentState=State.PLAYBACKCOMPLETED;\n      break;\n    }\ncase PREPARED:\n{\n    currentState=State.PREPARED;\n    break;\n  }\n}\n}\nif (this.seekCompleteListener != null) this.seekCompleteListener.onSeekComplete(mp);\n}\n", "nl": "Restore the last State before seekTo()"}
{"code": "public int computeWordValue(Vertex word){\n  int value=2;\n  int count=0;\n  if (word.instanceOf(Primitive.NOUN)) {\n    value=value + 12;\n    count++;\n  }\n  if (word.instanceOf(Primitive.ADJECTIVE)) {\n    value=value + 6;\n    count++;\n  }\n  if (word.instanceOf(Primitive.INTERJECTION)) {\n    value=value + 6;\n    count++;\n  }\n  if (word.instanceOf(Primitive.VERB)) {\n    value=value + 4;\n    count++;\n  }\n  if (word.instanceOf(Primitive.QUESTION)) {\n    value=value + 3;\n    count++;\n  }\n  if (word.instanceOf(Primitive.ADVERB)) {\n    value=value + 2;\n    count++;\n  }\n  if (count == 0) {\n    Collection<Relationship> meanings=word.getRelationships(Primitive.MEANING);\n    if (meanings != null) {\n      for (      Relationship relation : meanings) {\n        Vertex meaning=relation.getTarget();\n        if (meaning.instanceOf(Primitive.THING)) {\n          value=value + 12;\n        }\n else         if (meaning.instanceOf(Primitive.DESCRIPTION)) {\n          value=value + 6;\n        }\n else         if (meaning.instanceOf(Primitive.INTERJECTION)) {\n          value=value + 6;\n        }\n else         if (meaning.instanceOf(Primitive.ACTION)) {\n          value=value + 4;\n        }\n else         if (meaning.instanceOf(Primitive.QUESTION)) {\n          value=value + 3;\n        }\n else {\n          value=value + 2;\n        }\n      }\n      value=value / meanings.size();\n    }\n else {\n      value=value + 4;\n    }\n  }\n else {\n    value=value / count;\n  }\n  if (word.instanceOf(Primitive.PUNCTUATION) || (word.instanceOf(Primitive.ARTICLE))) {\n    value=1;\n  }\n  if (word.instanceOf(Primitive.KEYWORD)) {\n    value=25;\n  }\n  return value;\n}\n", "nl": "Return the matching value for the word, some word types are worth more than others."}
{"code": "public TenantResource tenant(){\n  return tenant;\n}\n", "nl": "Get the subresource containing all of the commands related to a tenant"}
{"code": "public static <E>List<E> of(E e1,E e2,E e3,E e4){\n  List<E> list=new ArrayList<>();\n  list.add(e1);\n  list.add(e2);\n  list.add(e3);\n  list.add(e4);\n  return list;\n}\n", "nl": "Returns a list of the given elements, in order."}
{"code": "@Deprecated public BitmapDrawable(){\n  mBitmapState=new BitmapState((Bitmap)null);\n}\n", "nl": "Create an empty drawable, not dealing with density."}
{"code": "public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {\n  String l_szRequestID=null;\n  HttpSession sess=request.getSession(true);\n  sess.setMaxInactiveInterval(WebEnv.TIMEOUT);\n  ctx=getCtx();\n  if (sess.getAttribute(\"ctx\") != null)   ctx=(Properties)sess.getAttribute(\"ctx\");\n  WebSessionCtx wsc=(WebSessionCtx)sess.getAttribute(WebSessionCtx.NAME);\n  if (wsc != null) {\n    String mode=WebUtil.getParameter(request,\"Mode\");\n    if (mode != null && mode.equals(\"RequestNew\")) {\n      l_szRequestID=Request.createRequest(request,ctx);\n    }\n else     if (mode != null && mode.equals(\"RequestChange\")) {\n      l_szRequestID=Request.changeRequest(request,ctx);\n    }\n  }\n  String url=request.getParameter(\"ForwardTo\") + l_szRequestID;\n  if (!url.startsWith(\"/\"))   url=\"/\" + url;\n  response.sendRedirect(url);\n}\n", "nl": "Process Get Request"}
{"code": "public short convertIndexToLocation(int index){\n  if (index == 0)   return 0;\n  if (index <= currentNumLocals) {\n    return currentCompiledMethod.getGeneralLocalLocation(index - 1);\n  }\n else {\n    return currentCompiledMethod.getGeneralStackLocation(index - 1 - currentNumLocals);\n  }\n}\n", "nl": "given a index in the local area (biased : local0 has index 1) this routine determines the correspondig offset in the stack"}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public void load(String filename,G g) throws IOException {\n  load(new FileReader(filename),g);\n}\n", "nl": "Populates the specified graph with the data parsed from the specified file."}
{"code": "public MockNioSession(){\n}\n", "nl": "Creates empty mock session."}
{"code": "public void reduceNetworkCapacity(String outputFilename,double fraction){\n  log.info(\"Changing the network capacity. Multiplying by \" + fraction);\n  int counter=0;\n  int multiplier=1;\n  for (  Id<Link> id : sc.getNetwork().getLinks().keySet()) {\n    double old=sc.getNetwork().getLinks().get(id).getCapacity();\n    sc.getNetwork().getLinks().get(id).setCapacity(old * fraction);\n    if (++counter == multiplier) {\n      log.info(\"   Links adapted: \" + counter);\n      multiplier*=2;\n    }\n  }\n  log.info(\"   Links adapted: \" + counter + \" (Done)\");\n  NetworkWriter nw=new NetworkWriter(sc.getNetwork());\n  nw.write(outputFilename);\n}\n", "nl": "Changing the network's capacity. Values smaller than 1.0 implies a reduction, while values greater than 1.0 implies an increase."}
{"code": "public static boolean isDangerous(double d){\n  return Double.isInfinite(d) || Double.isNaN(d) || d == 0.0;\n}\n", "nl": "Returns true if the argument is a \"dangerous\" double to have around, namely one that is infinite, NaN or zero."}
{"code": "static public void saveData(Context context,String key,String val){\n  context.getSharedPreferences(PREF_APP,Context.MODE_PRIVATE).edit().putString(key,val).apply();\n}\n", "nl": "Save data."}
{"code": "private String createChoiceWithFictionalProgressXML(String choiceId,String choiceDescription,String nextMomentId,boolean depleteWeaponCharge,boolean incrementNumEnemiesDefeated,String progressDescription,String iconResourceName){\n  String xml=\"\";\n  xml+=\"<choice \";\n  xml+=\"id='\" + choiceId + \"' >\";\n  xml+=\"<description>\" + choiceDescription + \"</description>\";\n  xml+=createNextMomentXml(nextMomentId);\n  xml+=\"<outcome \";\n  xml+=\"deplete_weapon='\" + Boolean.toString(depleteWeaponCharge) + \"' \";\n  xml+=\"increment_enemies='\" + Boolean.toString(incrementNumEnemiesDefeated) + \"' />\";\n  xml+=createFictionalProgressXml(progressDescription);\n  if (iconResourceName != null) {\n    xml+=createIconXML(iconResourceName);\n  }\n  xml+=\"</choice>\";\n  return xml;\n}\n", "nl": "A helper function to create an XML string representing a choice.  Choices are found within choice moments. Contains a piece of fictional progress."}
{"code": "public static void sort(char[] a){\n  sort1(a,0,a.length);\n}\n", "nl": "Sorts the specified array of chars into ascending numerical order. The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley and M. Douglas McIlroy's \"Engineering a Sort Function\", Software-Practice and Experience, Vol. 23(11) P. 1249-1265 (November 1993).  This algorithm offers n*log(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance."}
{"code": "private void addOrUpdateNode(AStarNode newNode){\n  boolean found=false;\n  for (  AStarNode toUpdate : closedNodes) {\n    if (newNode.equals(toUpdate)) {\n      toUpdate.updateDistance(newNode.getG(),newNode.parent);\n      found=true;\n      break;\n    }\n  }\n  if (!found) {\n    openQueue.offer(newNode);\n  }\n}\n", "nl": "Adds a new AStarNode to the queue unless it is already among the closed nodes, in which case it only updates the closed Node with the new distance."}
{"code": "public boolean hasUnsupportedCriticalExtension(){\n  Set extns=getCriticalExtensionOIDs();\n  if (extns == null) {\n    return false;\n  }\n  extns.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);\n  extns.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);\n  return !extns.isEmpty();\n}\n", "nl": "Will return true if any extensions are present and marked as critical as we currently dont handle any extensions!"}
{"code": "public void test_MultipleAccessToSeveralTables() throws SQLException {\n  threadPool.runTask(createTask1(1));\n  threadPool.runTask(createTask2(2));\n  threadPool.runTask(createTask3(3));\n}\n", "nl": "A few threads execute select operation in the same time for different tables in the database. Number of threads is defined by numThreads variable"}
{"code": "synchronized void releaseLocalIdOnDisk(String localId){\n  MapEntry entry=getMapEntry(localId);\n  entry.retainCount--;\n  if (entry.retainCount > 0) {\n    putMapEntry(localId,entry);\n  }\n else {\n    removeMapEntry(localId);\n  }\n}\n", "nl": "Decrements the retain count of a local id on disk. If the retain count hits zero, the id is forgotten forever."}
{"code": "public CCriteriumWrapper(final ICriteriumCreator creator){\n  super(creator);\n}\n", "nl": "Creates a new criterium object."}
{"code": "@Get(\"json\") public Map<String,Object> retrieve(){\n  return retrieveInternal(false);\n}\n", "nl": "Retrieves information about all modules available to Floodlight."}
{"code": "public boolean springBackX(int start,int min,int max){\n  mScrollerX.mMode=FLING_MODE;\n  return mScrollerX.springback(start,min,max);\n}\n", "nl": "Call this when you want to 'spring back' into a valid coordinate range."}
{"code": "@Override protected int sizeOf(String key,BitmapDrawable value){\n  final int bitmapSize=getBitmapSize(value) / 1024;\n  return bitmapSize == 0 ? 1 : bitmapSize;\n}\n", "nl": "Measure item size in kilobytes rather than units which is more practical for a bitmap cache"}
{"code": "public PersianCharFilterFactory(Map<String,String> args){\n  super(args);\n  if (!args.isEmpty()) {\n    throw new IllegalArgumentException(\"Unknown parameters: \" + args);\n  }\n}\n", "nl": "Creates a new PersianCharFilterFactory"}
{"code": "public boolean hasPercentComplete(){\n  return hasExtension(PercentComplete.class);\n}\n", "nl": "Returns whether it has the percent complete."}
{"code": "private void prohibitLandrushIfExactlyOneSunrise(Registry registry) throws UncontestedSunriseApplicationBlockedInLandrushException {\n  if (registry.getTldState(now) == TldState.LANDRUSH) {\n    ImmutableSet<DomainApplication> applications=loadActiveApplicationsByDomainName(targetId,now);\n    if (applications.size() == 1 && getOnlyElement(applications).getPhase().equals(LaunchPhase.SUNRISE)) {\n      throw new UncontestedSunriseApplicationBlockedInLandrushException();\n    }\n  }\n}\n", "nl": "Prohibit creating a landrush application in LANDRUSH (but not in SUNRUSH) if there is exactly one sunrise application for the same name."}
{"code": "private void resetNamePatternSection(){\n  disposeOptionalControls(NAME_PATTERN_ID);\n  validationManager.validationRemoved(NAME_PATTERN_TEXT);\n  validationManager.validationRemoved(REGULAR_EXPRESSION_TEXT);\n  useRegexForNameRadioButton.setSelection(false);\n  useStringValueAsNameRadioButton.setSelection(true);\n  useDefaultPattern=true;\n}\n", "nl": "Resets the name pattern section."}
{"code": "public static PurityResult checkPurity(Tree statement,AnnotationProvider annoProvider,boolean assumeSideEffectFree){\n  PurityCheckerHelper helper=new PurityCheckerHelper(annoProvider,assumeSideEffectFree);\n  PurityResult res=helper.scan(statement,new PurityResult());\n  return res;\n}\n", "nl": "Compute whether the given statement is side-effect-free, deterministic, or both. Returns a result that can be queried."}
{"code": "public Node buildTreeFull(Class<?> type,int depth){\n  if (depth == 0) {\n    return PRNG.nextItem(listAvailableTerminals(type)).copyNode();\n  }\n else {\n    Node node=PRNG.nextItem(listAvailableFunctions(type)).copyNode();\n    for (int i=0; i < node.getNumberOfArguments(); i++) {\n      node.setArgument(i,buildTreeFull(node.getArgumentType(i),depth - 1));\n    }\n    return node;\n  }\n}\n", "nl": "Generates an expression tree with the given return type using the <i>full</i> initialization method.  This method builds the tree so every leaf node is at the specified depth."}
{"code": "private static void sort(DefaultListModel model){\n  Object[] elements=model.toArray();\n  Arrays.sort(elements);\n  model.clear();\n  for (  Object element : elements) {\n    model.addElement(element);\n  }\n}\n", "nl": "Sorts the elemenets of a default list model"}
{"code": "protected boolean handleMarkSeenNotPermanent(MimeMessage aMessage) throws MessagingException {\n  return aMessage.isSet(Flags.Flag.SEEN);\n}\n", "nl": "<p> Handler for when the folder does not support the SEEN flag. The default behaviour implemented here is to answer the value of the SEEN flag anyway. </p> <p> Subclasses may choose to override this method and implement their own solutions. </p>"}
{"code": "public PatternsRequestCondition(String[] patterns,HttpRequestPathHelper pathHelper,PathMatcher pathMatcher,boolean useSuffixPatternMatch,boolean useTrailingSlashMatch,Set<String> extensions){\n  this(asList(patterns),pathHelper,pathMatcher,useSuffixPatternMatch,useTrailingSlashMatch,extensions);\n}\n", "nl": "Creates a new instance with the given URL patterns. Each pattern that is not empty and does not start with \"/\" is pre-pended with \"/\"."}
{"code": "public DataAsyncHttpResponseHandler(){\n  super();\n}\n", "nl": "Creates a new AsyncHttpResponseHandler"}
{"code": "public DDFSubfield(DDFSubfieldDefinition ddfsd,Object value){\n  setDefn(ddfsd);\n  setValue(value);\n}\n", "nl": "Create a subfield with a definition and a value."}
{"code": "private java.lang.String registerPrefix(javax.xml.stream.XMLStreamWriter xmlWriter,java.lang.String namespace) throws javax.xml.stream.XMLStreamException {\n  java.lang.String prefix=xmlWriter.getPrefix(namespace);\n  if (prefix == null) {\n    prefix=generatePrefix(namespace);\n    while (xmlWriter.getNamespaceContext().getNamespaceURI(prefix) != null) {\n      prefix=org.apache.axis2.databinding.utils.BeanUtil.getUniquePrefix();\n    }\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  return prefix;\n}\n", "nl": "Register a namespace prefix"}
{"code": "static void testBytes(int numBytes,long expectedCount,long start,long lim) throws UnsupportedEncodingException {\n  Random rnd=new Random();\n  byte[] bytes=new byte[numBytes];\n  if (lim == -1) {\n    lim=1L << (numBytes * 8);\n  }\n  long count=0;\n  long countRoundTripped=0;\n  for (long byteChar=start; byteChar < lim; byteChar++) {\n    long tmpByteChar=byteChar;\n    for (int i=0; i < numBytes; i++) {\n      bytes[bytes.length - i - 1]=(byte)tmpByteChar;\n      tmpByteChar=tmpByteChar >> 8;\n    }\n    ByteString bs=ByteString.copyFrom(bytes);\n    boolean isRoundTrippable=bs.isValidUtf8();\n    String s=new String(bytes,\"UTF-8\");\n    byte[] bytesReencoded=s.getBytes(\"UTF-8\");\n    boolean bytesEqual=Arrays.equals(bytes,bytesReencoded);\n    if (bytesEqual != isRoundTrippable) {\n      outputFailure(byteChar,bytes,bytesReencoded);\n    }\n    assertEquals(isRoundTrippable,Utf8.isValidUtf8(bytes));\n    assertEquals(isRoundTrippable,Utf8.isValidUtf8(bytes,0,numBytes));\n    int i=rnd.nextInt(numBytes);\n    int j=rnd.nextInt(numBytes);\n    if (j < i) {\n      int tmp=i;\n      i=j;\n      j=tmp;\n    }\n    int state1=Utf8.partialIsValidUtf8(Utf8.COMPLETE,bytes,0,i);\n    int state2=Utf8.partialIsValidUtf8(state1,bytes,i,j);\n    int state3=Utf8.partialIsValidUtf8(state2,bytes,j,numBytes);\n    if (isRoundTrippable != (state3 == Utf8.COMPLETE)) {\n      System.out.printf(\"state=%04x %04x %04x i=%d j=%d%n\",state1,state2,state3,i,j);\n      outputFailure(byteChar,bytes,bytesReencoded);\n    }\n    assertEquals(isRoundTrippable,(state3 == Utf8.COMPLETE));\n    ByteString rope=RopeByteString.newInstanceForTest(bs.substring(0,i),RopeByteString.newInstanceForTest(bs.substring(i,j),bs.substring(j,numBytes)));\n    assertSame(RopeByteString.class,rope.getClass());\n    ByteString[] byteStrings={bs,bs.substring(0,numBytes),rope};\n    for (    ByteString x : byteStrings) {\n      assertEquals(isRoundTrippable,x.isValidUtf8());\n      assertEquals(state3,x.partialIsValidUtf8(Utf8.COMPLETE,0,numBytes));\n      assertEquals(state1,x.partialIsValidUtf8(Utf8.COMPLETE,0,i));\n      assertEquals(state1,x.substring(0,i).partialIsValidUtf8(Utf8.COMPLETE,0,i));\n      assertEquals(state2,x.partialIsValidUtf8(state1,i,j - i));\n      assertEquals(state2,x.substring(i,j).partialIsValidUtf8(state1,0,j - i));\n      assertEquals(state3,x.partialIsValidUtf8(state2,j,numBytes - j));\n      assertEquals(state3,x.substring(j,numBytes).partialIsValidUtf8(state2,0,numBytes - j));\n    }\n    ByteString ropeADope=RopeByteString.newInstanceForTest(bs,bs.substring(0,numBytes));\n    assertEquals(isRoundTrippable,ropeADope.isValidUtf8());\n    if (isRoundTrippable) {\n      countRoundTripped++;\n    }\n    count++;\n    if (byteChar != 0 && byteChar % 1000000L == 0) {\n      logger.info(\"Processed \" + (byteChar / 1000000L) + \" million characters\");\n    }\n  }\n  logger.info(\"Round tripped \" + countRoundTripped + \" of \"+ count);\n  assertEquals(expectedCount,countRoundTripped);\n}\n", "nl": "Helper to run the loop to test all the permutations for the number of bytes specified. This overload is useful for debugging to get the loop to start at a certain character."}
{"code": "public void addParameterValues(final String requestParameterName,final Object... requestParameterValues){\n  if (requestParameterValues != null) {\n    for (    final Object requestParameterValue : requestParameterValues) {\n      getParameters().add(requestParameterName,requestParameterValue);\n    }\n  }\n}\n", "nl": "Adds 1 or more parameter values to the HTTP request. <p/>"}
{"code": "public String globalInfo(){\n  return \"An instance filter that assumes instances form time-series data and \" + \"replaces attribute values in the current instance with the difference \" + \"between the current value and the equivalent attribute attribute value \"+ \"of some previous (or future) instance. For instances where the time-shifted \"+ \"value is unknown either the instance may be dropped, or missing values \"+ \"used. Skips the class attribute if it is set.\";\n}\n", "nl": "Returns a string describing this classifier"}
{"code": "protected CCBitmapFontAtlas(CharSequence theString,String fntFile){\n  super((parsed=FNTConfigLoadFile(fntFile)).atlasName,theString.length());\n  configuration_=parsed;\n  opacity_=255;\n  color_=new ccColor3B(ccColor3B.ccWHITE);\n  contentSize_=CGSize.zero();\n  opacityModifyRGB_=textureAtlas_.getTexture().hasPremultipliedAlpha();\n  anchorPoint_=CGPoint.ccp(0.5f,0.5f);\n  string_=new TextBuilder();\n  setString(theString);\n}\n", "nl": "init a bitmap font altas with an initial string and the FNT file"}
{"code": "public static <T>T checkNotNull(T reference,@Nullable String errorMessageTemplate,@Nullable Object... errorMessageArgs){\n  if (reference == null) {\n    throw new NullPointerException(format(errorMessageTemplate,errorMessageArgs));\n  }\n  return reference;\n}\n", "nl": "Ensures that an object reference passed as a parameter to the calling method is not null."}
{"code": "public X509Name(String dirName,X509NameEntryConverter converter){\n  this(DefaultReverse,DefaultLookUp,dirName,converter);\n}\n", "nl": "Takes an X509 dir name as a string of the format \"C=AU, ST=Victoria\", or some such, converting it into an ordered set of name attributes with each string value being converted to its associated ASN.1 type using the passed in converter."}
{"code": "void fireMonitorsUpdatedEvents(){\n  ArrayList registered=null;\n  VmEvent ev=null;\nsynchronized (listeners) {\n    registered=(ArrayList)listeners.clone();\n  }\n  for (Iterator i=registered.iterator(); i.hasNext(); ) {\n    VmListener l=(VmListener)i.next();\n    if (ev == null) {\n      ev=new VmEvent(this);\n    }\n    l.monitorsUpdated(ev);\n  }\n}\n", "nl": "Fire MonitoredVmStructureChanged events."}
{"code": "private void exportGuideLine(Project aProject,File aCopyDir) throws IOException {\n  File guidelineDir=new File(aCopyDir + GUIDELINES_FOLDER);\n  FileUtils.forceMkdir(guidelineDir);\n  File annotationGuidlines=repository.getGuidelinesFile(aProject);\n  if (annotationGuidlines.exists()) {\n    for (    File annotationGuideline : annotationGuidlines.listFiles()) {\n      FileUtils.copyFileToDirectory(annotationGuideline,guidelineDir);\n    }\n  }\n}\n", "nl": "Copy Project guidelines from the file system of this project to the export folder"}
{"code": "public boolean hasChild(String name){\n  return (getChild(name) != null);\n}\n", "nl": "Checks whether the node has a child with the given name."}
{"code": "public static double value(double x){\n  if ((x >= 0) && (x <= epsilon)) {\n    return 0.0;\n  }\n  if ((x < 0) && (-x <= epsilon)) {\n    return 0.0;\n  }\n  return x;\n}\n", "nl": "See if the value is close enough to actually be considered 0.0 and return 0.0 if need be. <p> Otherwise the value is returned."}
{"code": "public static void updateComponentTreeUI(@Nullable Component c){\n  if (c == null)   return;\n  for (  Component component : uiTraverser().postOrderTraversal(c)) {\n    if (component instanceof JComponent)     ((JComponent)component).updateUI();\n  }\n  c.invalidate();\n  c.validate();\n  c.repaint();\n}\n", "nl": "A copy of javax.swing.SwingUtilities#updateComponentTreeUI that invokes children updateUI() first"}
{"code": "void addTopLevel(String key,JFrame frame){\n  if (frame != this) {\n    toplevels.put(key,frame);\n  }\n}\n", "nl": "Records a new internal frame."}
{"code": "protected void resultSetLogError(String message,Throwable error){\n  Logger.sqlErrorLog(message,error);\n}\n", "nl": "Description: <br>"}
{"code": "private boolean validate(Class type,InputNode node,Session session) throws Exception {\n  return validate(type,node,new Source(strategy,support,session));\n}\n", "nl": "This <code>validate</code> method will validate the contents of the XML document against the specified XML class schema. This is used to perform a read traversal of the class schema such that  the document can be tested against it. This is preferred to reading the document as it does not instantiate the objects or invoke any callback methods, thus making it a safe validation."}
{"code": "public void printMemory(){\n  m_readLock.lock();\n  for (  final MemoryChunk chunk : m_chunks) {\n    chunk.print();\n  }\n  m_readLock.unlock();\n}\n", "nl": "Prints the content of the memory to stdout."}
{"code": "public static ImageSource uri(String uri){\n  if (uri == null) {\n    throw new NullPointerException(\"Uri must not be null\");\n  }\n  if (!uri.contains(\"://\")) {\n    if (uri.startsWith(\"/\")) {\n      uri=uri.substring(1);\n    }\n    uri=FILE_SCHEME + uri;\n  }\n  return new ImageSource(Uri.parse(uri));\n}\n", "nl": "Create an instance from a URI. If the URI does not start with a scheme, it's assumed to be the URI of a file."}
{"code": "public GroupBuilder<T,UnionBuilder<T,E>> left(){\n  return new GroupBuilder<T,UnionBuilder<T,E>>(this);\n}\n", "nl": "Return a builder for creating the left operand of the union"}
{"code": "public JSONObject increment(String key) throws JSONException {\n  Object value=this.opt(key);\n  if (value == null) {\n    this.put(key,1);\n  }\n else   if (value instanceof Integer) {\n    this.put(key,((Integer)value).intValue() + 1);\n  }\n else   if (value instanceof Long) {\n    this.put(key,((Long)value).longValue() + 1);\n  }\n else   if (value instanceof Double) {\n    this.put(key,((Double)value).doubleValue() + 1);\n  }\n else   if (value instanceof Float) {\n    this.put(key,((Float)value).floatValue() + 1);\n  }\n else {\n    throw new JSONException(\"Unable to increment [\" + quote(key) + \"].\");\n  }\n  return this;\n}\n", "nl": "Increment a property of a JSONObject. If there is no such property, create one with a value of 1. If there is such a property, and if it is an Integer, Long, Double, or Float, then add one to it."}
{"code": "public static cuComplex cuCmplx(float r,float i){\n  cuComplex res=new cuComplex();\n  res.x=r;\n  res.y=i;\n  return res;\n}\n", "nl": "Creates a new complex number consisting of the given real and imaginary part."}
{"code": "public Observable<String> exerciseZip(Observable<String> a,Observable<String> b){\n  return Observable.zip(a,b,null);\n}\n", "nl": "Combine 2 streams into pairs using zip. a -> \"one\", \"two\", \"red\", \"blue\" b -> \"fish\", \"fish\", \"fish\", \"fish\" output -> \"one fish\", \"two fish\", \"red fish\", \"blue fish\""}
{"code": "public int maximalSquare(char[][] matrix){\n  if (matrix == null) {\n    return 0;\n  }\n  int r=matrix.length;\n  int c=r == 0 ? 0 : matrix[0].length;\n  int[][] dp=new int[r + 1][c + 1];\n  int maxLen=0;\n  for (int i=1; i <= r; i++) {\n    for (int j=1; j <= c; j++) {\n      if (matrix[i - 1][j - 1] == '1') {\n        dp[i][j]=Math.min(Math.min(dp[i - 1][j],dp[i][j - 1]),dp[i - 1][j - 1]) + 1;\n        maxLen=Math.max(maxLen,dp[i][j]);\n      }\n    }\n  }\n  return maxLen * maxLen;\n}\n", "nl": "DP, 2D matrix. The recurrence relation here is not easy to see. Use largest square's edge length formed including current grid. If the current grid is an 1,the edge length of current grid is the (minimum of its top, top-left, and left) + 1. Otherwise, if its 0, the edge length is still zero."}
{"code": "public PermissionCollection newPermissionCollection(){\n  return new ExecOptionPermissionCollection();\n}\n", "nl": "Returns a new PermissionCollection object for storing ExecOptionPermission objects. <p> A ExecOptionPermissionCollection stores a collection of ExecOptionPermission permissions. <p>ExecOptionPermission objects must be stored in a manner that allows them to be inserted in any order, but that also enables the PermissionCollection <code>implies</code> method to be implemented in an efficient (and consistent) manner."}
{"code": "public void watchForAvailability(){\n  watch(true);\n}\n", "nl": "Wait till the monitored Deployable is made available or throw an exception if the timeout period is reached. Equivalent to <code>watch(true)</code>."}
{"code": "private static String extractIdFromUrl(String url){\n  int lastSlash=url.lastIndexOf('/');\n  if (lastSlash == -1 || lastSlash == (url.length() - 1)) {\n    throw new IllegalArgumentException(\"Id is in a strange format. \" + url);\n  }\n  String oid=url.substring(lastSlash + 1);\n  return oid;\n}\n", "nl": "Extracts the id of the item from the given url. The id found in GoogleBaseEntry is a URL that contains the real, numerical id of the item in Google Base. Parsing the URL is unfortunately the only way of getting a numerical id given a GoogleBaseEntry."}
{"code": "public static Mapper<String> singleString(){\n  return singleString;\n}\n", "nl": "Maps the first string column"}
{"code": "protected void applyStatus(IStatus status){\n  String msg=status.getMessage();\n  if (msg != null && msg.length() == 0) {\n    msg=null;\n  }\nswitch (status.getSeverity()) {\ncase IStatus.OK:\n    setMessage(msg,IMessageProvider.NONE);\n  setErrorMessage(null);\nbreak;\ncase IStatus.WARNING:\nsetMessage(msg,IMessageProvider.WARNING);\nsetErrorMessage(null);\nbreak;\ncase IStatus.INFO:\nsetMessage(msg,IMessageProvider.INFORMATION);\nsetErrorMessage(null);\nbreak;\ndefault :\nsetMessage(null);\nsetErrorMessage(msg);\nbreak;\n}\n}\n", "nl": "Applies the status to the status line of the wizard page."}
{"code": "public StrBuilder append(long value){\n  return append(String.valueOf(value));\n}\n", "nl": "Appends a long value to the string builder using <code>String.valueOf</code>."}
{"code": "public StrBuilder appendln(final char ch){\n  return append(ch).appendNewLine();\n}\n", "nl": "Appends a char value followed by a new line to the string builder."}
{"code": "public void put(String key,Boolean value){\n  mValues.put(key,value);\n}\n", "nl": "Adds a value to the set."}
{"code": "private Workflow.Method deleteStorageViewMethod(URI vplexURI,URI exportMaskURI){\n  return new Workflow.Method(DELETE_STORAGE_VIEW,vplexURI,exportMaskURI);\n}\n", "nl": "Create a Workflow Method for deleteStorageView(). Args must match deleteStorageView except for extra stepId arg."}
{"code": "public void addInternetScsiSendTargets(HostStorageSystem storageSystem,HostInternetScsiHba hba,String... addresses){\n  try {\n    storageSystem.addInternetScsiSendTargets(hba.getDevice(),createInternetScsiSendTargets(addresses));\n  }\n catch (  HostConfigFault e) {\n    throw new VMWareException(e);\n  }\ncatch (  NotFound e) {\n    throw new VMWareException(e);\n  }\ncatch (  RuntimeFault e) {\n    throw new VMWareException(e);\n  }\ncatch (  RemoteException e) {\n    throw new VMWareException(e);\n  }\n}\n", "nl": "Adds iSCSI send targets to the host storage system."}
{"code": "private void testBug71396MultiSettingsCheck(String connProps,int maxRows,int limitClause,int expRowCount) throws SQLException {\n  Connection testConn=getConnectionWithProps(connProps);\n  Statement testStmt=testConn.createStatement();\n  if (maxRows > 0) {\n    testStmt.setMaxRows(maxRows);\n  }\n  testStmt.execute(\"SELECT 1\");\n  testBug71396StatementCheck(testStmt,String.format(\"SELECT * FROM testBug71396 LIMIT %d\",limitClause),expRowCount);\n  testBug71396PrepStatementCheck(testConn,String.format(\"SELECT * FROM testBug71396 LIMIT %d\",limitClause),expRowCount,maxRows);\n  testStmt.close();\n  testConn.close();\n}\n", "nl": "Executes a query containing the clause LIMIT with a Statement and a PreparedStatement, using a combination of Connection properties, maxRows value and limit clause value, and tests if the results count is the expected."}
{"code": "private Base64(){\n}\n", "nl": "Defeats instantiation."}
{"code": "public void dumpAll(Iterator<? extends Object> data,Writer output){\n  dumpAll(data,output,null);\n}\n", "nl": "Serialize a sequence of Java objects into a YAML stream."}
{"code": "public void add(String documentId,HistoryEvent event){\n  if (historyLogger == null) {\n    LOGGER.error(\"Logging history event withouth an initialised logger\");\n    return;\n  }\nswitch (loggerLevel) {\ncase \"warn\":\n    historyLogger.warn(DEFAULT_FORMAT,Instant.ofEpochMilli(event.getTimestamp()),documentId,event.getRecordable().getInternalId(),event.getReferrer(),event.getAction());\n  break;\ncase \"error\":\nhistoryLogger.error(DEFAULT_FORMAT,Instant.ofEpochMilli(event.getTimestamp()),documentId,event.getRecordable().getInternalId(),event.getReferrer(),event.getAction());\nbreak;\ncase \"trace\":\nhistoryLogger.trace(DEFAULT_FORMAT,Instant.ofEpochMilli(event.getTimestamp()),documentId,event.getRecordable().getInternalId(),event.getReferrer(),event.getAction());\nbreak;\ncase \"info\":\ndefault :\nhistoryLogger.info(DEFAULT_FORMAT,Instant.ofEpochMilli(event.getTimestamp()),documentId,event.getRecordable().getInternalId(),event.getReferrer(),event.getAction());\nbreak;\n}\n}\n", "nl": "Add the event to the specific document."}
{"code": "public synchronized <T>T unwrap(java.lang.Class<T> iface) throws java.sql.SQLException {\n  try {\n    if (\"java.sql.Connection\".equals(iface.getName()) || \"java.sql.Wrapper.class\".equals(iface.getName())) {\n      return iface.cast(this);\n    }\n    if (unwrappedInterfaces == null) {\n      unwrappedInterfaces=new HashMap<Class<?>,Object>();\n    }\n    Object cachedUnwrapped=unwrappedInterfaces.get(iface);\n    if (cachedUnwrapped == null) {\n      cachedUnwrapped=Proxy.newProxyInstance(this.mc.getClass().getClassLoader(),new Class<?>[]{iface},new ConnectionErrorFiringInvocationHandler(this.mc));\n      unwrappedInterfaces.put(iface,cachedUnwrapped);\n    }\n    return iface.cast(cachedUnwrapped);\n  }\n catch (  ClassCastException cce) {\n    throw SQLError.createSQLException(\"Unable to unwrap to \" + iface.toString(),SQLError.SQL_STATE_ILLEGAL_ARGUMENT,this.exceptionInterceptor);\n  }\n}\n", "nl": "Returns an object that implements the given interface to allow access to non-standard methods, or standard methods not exposed by the proxy. The result may be either the object found to implement the interface or a proxy for that object. If the receiver implements the interface then that is the object. If the receiver is a wrapper and the wrapped object implements the interface then that is the object. Otherwise the object is the result of calling <code>unwrap</code> recursively on the wrapped object. If the receiver is not a wrapper and does not implement the interface, then an <code>SQLException</code> is thrown."}
{"code": "public static void addOptionalFeatures(ImageRequestBuilder imageRequestBuilder,Config config){\n  if (config.usePostprocessor) {\n    final Postprocessor postprocessor;\nswitch (config.postprocessorType) {\ncase \"use_slow_postprocessor\":\n      postprocessor=DelayPostprocessor.getMediumPostprocessor();\n    break;\ncase \"use_fast_postprocessor\":\n  postprocessor=DelayPostprocessor.getFastPostprocessor();\nbreak;\ndefault :\npostprocessor=DelayPostprocessor.getMediumPostprocessor();\n}\nimageRequestBuilder.setPostprocessor(postprocessor);\n}\nif (config.rotateUsingMetaData) {\nimageRequestBuilder.setRotationOptions(RotationOptions.autoRotateAtRenderTime());\n}\n else {\nimageRequestBuilder.setRotationOptions(RotationOptions.forceRotation(config.forcedRotationAngle));\n}\n}\n", "nl": "Utility method which adds optional configuration to ImageRequest"}
{"code": "@CanIgnoreReturnValue public static <T>T checkNotNull(T reference){\n  if (reference == null) {\n    throw new NullPointerException();\n  }\n  return reference;\n}\n", "nl": "Ensures that an object reference passed as a parameter to the calling method is not null."}
{"code": "Node(K key,Object value,Node<K,V> next){\n  this.key=key;\n  this.value=value;\n  this.next=next;\n}\n", "nl": "Creates a new regular node."}
{"code": "public static void run(AdSense adsense) throws Exception {\n  System.out.println(\"=================================================================\");\n  System.out.println(\"Listing all dimensions for default account\");\n  System.out.println(\"=================================================================\");\n  Metadata dimensions=adsense.metadata().dimensions().list().execute();\n  if (dimensions.getItems() != null && !dimensions.getItems().isEmpty()) {\n    for (    ReportingMetadataEntry dimension : dimensions.getItems()) {\n      boolean firstProduct=true;\n      StringBuilder products=new StringBuilder();\n      for (      String product : dimension.getSupportedProducts()) {\n        if (!firstProduct) {\n          products.append(\", \");\n        }\n        products.append(product);\n        firstProduct=false;\n      }\n      System.out.printf(\"Dimension id \\\"%s\\\" for product(s): [%s] was found.\\n\",dimension.getId(),products.toString());\n    }\n  }\n else {\n    System.out.println(\"No dimensions found.\");\n  }\n  System.out.println();\n}\n", "nl": "Runs this sample."}
{"code": "public void doTest(String filename,int dim,int iter) throws Exception {\n  System.out.println(\"Allocating arrays.\");\n  double[] db=new double[dim];\n  float[] fl=new float[dim];\n  int[] in=new int[dim];\n  long[] ln=new long[dim];\n  short[] sh=new short[dim];\n  byte[] by=new byte[dim];\n  char[] ch=new char[dim];\n  boolean[] bl=new boolean[dim];\n  System.out.println(\"Initializing arrays -- may take a while\");\n  int sign=1;\n  for (int i=0; i < dim; i+=1) {\n    double x=sign * Math.pow(10.,20 * Math.random() - 10);\n    db[i]=x;\n    fl[i]=(float)x;\n    if (Math.abs(x) < 1) {\n      x=1 / x;\n    }\n    in[i]=(int)x;\n    ln[i]=(long)x;\n    sh[i]=(short)x;\n    by[i]=(byte)x;\n    ch[i]=(char)x;\n    bl[i]=x > 0;\n    sign=-sign;\n  }\n  by[0]=Byte.MIN_VALUE;\n  by[1]=Byte.MAX_VALUE;\n  by[2]=0;\n  ch[0]=Character.MIN_VALUE;\n  ch[1]=Character.MAX_VALUE;\n  ch[2]=0;\n  sh[0]=Short.MAX_VALUE;\n  sh[1]=Short.MIN_VALUE;\n  sh[0]=0;\n  in[0]=Integer.MAX_VALUE;\n  in[1]=Integer.MIN_VALUE;\n  in[2]=0;\n  ln[0]=Long.MIN_VALUE;\n  ln[1]=Long.MAX_VALUE;\n  ln[2]=0;\n  fl[0]=Float.MIN_VALUE;\n  fl[1]=Float.MAX_VALUE;\n  fl[2]=Float.POSITIVE_INFINITY;\n  fl[3]=Float.NEGATIVE_INFINITY;\n  fl[4]=Float.NaN;\n  fl[5]=0;\n  db[0]=Double.MIN_VALUE;\n  db[1]=Double.MAX_VALUE;\n  db[2]=Double.POSITIVE_INFINITY;\n  db[3]=Double.NEGATIVE_INFINITY;\n  db[4]=Double.NaN;\n  db[5]=0;\n  double[] db2=new double[dim];\n  float[] fl2=new float[dim];\n  int[] in2=new int[dim];\n  long[] ln2=new long[dim];\n  short[] sh2=new short[dim];\n  byte[] by2=new byte[dim];\n  char[] ch2=new char[dim];\n  boolean[] bl2=new boolean[dim];\n  int[][][][] multi=new int[10][10][10][10];\n  int[][][][] multi2=new int[10][10][10][10];\n  for (int i=0; i < 10; i+=1) {\n    multi[i][i][i][i]=i;\n  }\n  standardFileTest(filename,iter,in,in2);\n  standardStreamTest(filename,iter,in,in2);\n  buffStreamSimpleTest(filename,iter,in,in2);\n  bufferedFileTest(filename,iter,db,db2,fl,fl2,ln,ln2,in,in2,sh,sh2,ch,ch2,by,by2,bl,bl2,multi,multi2);\n  bufferedStreamTest(filename,iter,db,db2,fl,fl2,ln,ln2,in,in2,sh,sh2,ch,ch2,by,by2,bl,bl2,multi,multi2);\n}\n", "nl": "Usage: java nom.tam.util.test.BufferedFileTester file [dim [iter [flags]]] where file is the file to be read and written. dim is the dimension of the arrays to be written. iter is the number of times each tiledImageOperation is written. flags a string indicating what I/O to test O -- test old I/O (RandomAccessFile and standard streams) R -- BufferedFile (i.e., random access) S -- BufferedDataXPutStream X -- BufferedDataXPutStream using standard methods"}
{"code": "public void go(){\nsynchronized (monitor) {\n    this.returnValue=GO;\n    monitor.notifyAll();\n  }\n}\n", "nl": "Resumes execution of script."}
{"code": "protected void reset(){\n}\n", "nl": "Resets the associated attribute value according to the current value. This should be overridden in descendant classes that associate the angle object with an attribute."}
{"code": "public UndeployDeployableScriptCommand(Configuration configuration,String resourcePath,Deployable deployable){\n  super(configuration,resourcePath);\n  this.deployable=deployable;\n}\n", "nl": "Sets configuration containing all needed information for building configuration scripts."}
{"code": "PdfBoxRenderer(BaseDocument doc,UnicodeImplementation unicode,HttpStreamFactory httpStreamFactory,OutputStream os,FSUriResolver resolver,FSCache cache,SVGDrawer svgImpl,PageDimensions pageSize,float pdfVersion,String replacementText,boolean testMode){\n  _pdfDoc=new PDDocument();\n  _pdfDoc.setVersion(pdfVersion);\n  _svgImpl=svgImpl;\n  _dotsPerPoint=DEFAULT_DOTS_PER_POINT;\n  _testMode=testMode;\n  _outputDevice=new PdfBoxOutputDevice(DEFAULT_DOTS_PER_POINT,testMode);\n  _outputDevice.setWriter(_pdfDoc);\n  PdfBoxUserAgent userAgent=new PdfBoxUserAgent(_outputDevice);\n  if (httpStreamFactory != null) {\n    userAgent.setHttpStreamFactory(httpStreamFactory);\n  }\n  if (resolver != null) {\n    userAgent.setUriResolver(resolver);\n  }\n  if (cache != null) {\n    userAgent.setExternalCache(cache);\n  }\n  _sharedContext=new SharedContext();\n  _sharedContext.registerWithThread();\n  _sharedContext.setUserAgentCallback(userAgent);\n  _sharedContext.setCss(new StyleReference(userAgent));\n  userAgent.setSharedContext(_sharedContext);\n  _outputDevice.setSharedContext(_sharedContext);\n  PdfBoxFontResolver fontResolver=new PdfBoxFontResolver(_sharedContext,_pdfDoc);\n  _sharedContext.setFontResolver(fontResolver);\n  PdfBoxReplacedElementFactory replacedElementFactory=new PdfBoxReplacedElementFactory(_outputDevice,svgImpl);\n  _sharedContext.setReplacedElementFactory(replacedElementFactory);\n  _sharedContext.setTextRenderer(new PdfBoxTextRenderer());\n  _sharedContext.setDPI(DEFAULT_PDF_POINTS_PER_INCH * _dotsPerPoint);\n  _sharedContext.setDotsPerPixel(DEFAULT_DOTS_PER_PIXEL);\n  _sharedContext.setPrint(true);\n  _sharedContext.setInteractive(false);\n  this.getSharedContext().setDefaultPageSize(pageSize.w,pageSize.h,pageSize.isSizeInches);\n  if (replacementText != null) {\n    this.getSharedContext().setReplacementText(replacementText);\n  }\n  if (unicode.splitterFactory != null) {\n    this._splitterFactory=unicode.splitterFactory;\n  }\n  if (unicode.reorderer != null) {\n    this._reorderer=unicode.reorderer;\n    this._outputDevice.setBidiReorderer(_reorderer);\n  }\n  if (unicode.lineBreaker != null) {\n    _sharedContext.setLineBreaker(unicode.lineBreaker);\n  }\n  if (unicode.charBreaker != null) {\n    _sharedContext.setCharacterBreaker(unicode.charBreaker);\n  }\n  if (unicode.toLowerTransformer != null) {\n    _sharedContext.setUnicodeToLowerTransformer(unicode.toLowerTransformer);\n  }\n  if (unicode.toUpperTransformer != null) {\n    _sharedContext.setUnicodeToUpperTransformer(unicode.toUpperTransformer);\n  }\n  if (unicode.toTitleTransformer != null) {\n    _sharedContext.setUnicodeToTitleTransformer(unicode.toTitleTransformer);\n  }\n  this._defaultTextDirection=unicode.textDirection ? BidiSplitter.RTL : BidiSplitter.LTR;\n  if (doc.html != null) {\n    this.setDocumentFromStringP(doc.html,doc.baseUri);\n  }\n else   if (doc.document != null) {\n    this.setDocumentP(doc.document,doc.baseUri);\n  }\n else   if (doc.uri != null) {\n    this.setDocumentP(doc.uri);\n  }\n else   if (doc.file != null) {\n    try {\n      this.setDocumentP(doc.file);\n    }\n catch (    IOException e) {\n      XRLog.exception(\"Problem trying to read input XHTML file\",e);\n      throw new RuntimeException(\"File IO problem\",e);\n    }\n  }\n  this._os=os;\n}\n", "nl": "This method is constantly changing as options are added to the builder."}
{"code": "public boolean isEsmeDeliveryAcknowledgement(){\n  return isEsmeDeliveryAcknowledgement(esmClass);\n}\n", "nl": "Message Type."}
{"code": "public QueryException(String message,int errorCode,String sqlState,Throwable cause){\n  super(message,cause);\n  this.message=message;\n  this.errorCode=errorCode;\n  this.sqlState=sqlState;\n}\n", "nl": "Creates a query exception with a message and a cause."}
{"code": "public static Class<?> mapSimpleType(RamlParamType param){\nswitch (param) {\ncase BOOLEAN:\n    return Boolean.class;\ncase DATE:\n  return Date.class;\ncase INTEGER:\nreturn Long.class;\ncase NUMBER:\nreturn BigDecimal.class;\ncase FILE:\nreturn MultipartFile.class;\ndefault :\nreturn String.class;\n}\n}\n", "nl": "Maps simple types supported by RAML into primitives and other simple Java types"}
{"code": "public void put(String key,boolean value){\n  super.put(key,Boolean.valueOf(value));\n}\n", "nl": "<p> Adds the given <code>boolean</code> value to the <code>StringKeyDirtyFlagMap</code>. </p>"}
{"code": "public ExtensionInfo(String extensionKey,Attributes attr) throws NullPointerException {\n  String s;\n  if (extensionKey != null) {\n    s=extensionKey + \"-\";\n  }\n else {\n    s=\"\";\n  }\n  String attrKey=s + Name.EXTENSION_NAME.toString();\n  name=attr.getValue(attrKey);\n  if (name != null)   name=name.trim();\n  attrKey=s + Name.SPECIFICATION_TITLE.toString();\n  title=attr.getValue(attrKey);\n  if (title != null)   title=title.trim();\n  attrKey=s + Name.SPECIFICATION_VERSION.toString();\n  specVersion=attr.getValue(attrKey);\n  if (specVersion != null)   specVersion=specVersion.trim();\n  attrKey=s + Name.SPECIFICATION_VENDOR.toString();\n  specVendor=attr.getValue(attrKey);\n  if (specVendor != null)   specVendor=specVendor.trim();\n  attrKey=s + Name.IMPLEMENTATION_VERSION.toString();\n  implementationVersion=attr.getValue(attrKey);\n  if (implementationVersion != null)   implementationVersion=implementationVersion.trim();\n  attrKey=s + Name.IMPLEMENTATION_VENDOR.toString();\n  vendor=attr.getValue(attrKey);\n  if (vendor != null)   vendor=vendor.trim();\n  attrKey=s + Name.IMPLEMENTATION_VENDOR_ID.toString();\n  vendorId=attr.getValue(attrKey);\n  if (vendorId != null)   vendorId=vendorId.trim();\n  attrKey=s + Name.IMPLEMENTATION_URL.toString();\n  url=attr.getValue(attrKey);\n  if (url != null)   url=url.trim();\n}\n", "nl": "<p> Create and initialize an extension information object. The initialization uses the attributes passed as being the content of a manifest file to load the extension information from. Since manifest file may contain information on several extension they may depend on, the extension key parameter is prepanded to the attribute name to make the key used to retrieve the attribute from the manifest file <p>"}
{"code": "public void increaseNestingLevel(){\n  this.nestingLevel++;\n}\n", "nl": "Increase this parameter's nesting level."}
{"code": "private void writeQNameAttribute(java.lang.String namespace,java.lang.String attName,javax.xml.namespace.QName qname,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  java.lang.String attributeNamespace=qname.getNamespaceURI();\n  java.lang.String attributePrefix=xmlWriter.getPrefix(attributeNamespace);\n  if (attributePrefix == null) {\n    attributePrefix=registerPrefix(xmlWriter,attributeNamespace);\n  }\n  java.lang.String attributeValue;\n  if (attributePrefix.trim().length() > 0) {\n    attributeValue=attributePrefix + \":\" + qname.getLocalPart();\n  }\n else {\n    attributeValue=qname.getLocalPart();\n  }\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attributeValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attributeValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "public void addPage(@NotNull WizardPage<T> page,int index,boolean replace){\n  if (index >= wizardPages.size()) {\n    addPage(page);\n    return;\n  }\n  if (replace) {\n    setPage(page,index);\n  }\n else {\n    List<WizardPage<T>> before=ListHelper.slice(wizardPages,0,index);\n    WizardPage<T> currentPage=wizardPages.get(index);\n    List<WizardPage<T>> after=ListHelper.slice(wizardPages,index + 1,wizardPages.size());\n    wizardPages.clear();\n    wizardPages.addAll(before);\n    addPage(page);\n    wizardPages.add(currentPage);\n    wizardPages.addAll(after);\n  }\n}\n", "nl": "Add page to wizard at the specified position."}
{"code": "public DecoderResult decode(boolean[][] image) throws FormatException, ChecksumException {\n  int dimension=image.length;\n  BitMatrix bits=new BitMatrix(dimension);\n  for (int i=0; i < dimension; i++) {\n    for (int j=0; j < dimension; j++) {\n      if (image[j][i]) {\n        bits.set(j,i);\n      }\n    }\n  }\n  return decode(bits);\n}\n", "nl": "<p>Convenience method that can decode a PDF417 Code represented as a 2D array of booleans. \"true\" is taken to mean a black module.</p>"}
{"code": "public void paint(Graphics g,Shape allocation){\n  Rectangle a=(Rectangle)allocation;\n  painter.paint(g,a.x,a.y,a.width,a.height,this);\n  super.paint(g,a);\n}\n", "nl": "Renders using the given rendering surface and area on that surface.  This is implemented to delegate to the css box painter to paint the border and background prior to the interior."}
{"code": "void jbInit() throws Exception {\n  this.setLayout(borderLayout1);\n  jPanel1.setLayout(borderLayout6);\n  jPanel4.setLayout(gridLayout1);\n  jPanel2.setLayout(borderLayout3);\n  jPanel3.setLayout(borderLayout5);\n  jPanel4.setBackground(Color.orange);\n  jPanel2.setBackground(Color.red);\n  jPanel3.setBackground(Color.pink);\n  gridLayout1.setVgap(5);\n  jPanel17.setLayout(borderLayout9);\n  jPanel16.setLayout(borderLayout8);\n  jPanel10.setLayout(gridLayout5);\n  flowLayout5.setVgap(0);\n  jPanel7.setLayout(flowLayout5);\n  flowLayout4.setHgap(2);\n  flowLayout4.setAlignment(0);\n  flowLayout4.setVgap(0);\n  jPanel8.setLayout(flowLayout4);\n  jPanel9.setLayout(gridLayout9);\n  jPanel18.setLayout(flowLayout1);\n  jPanel.setLayout(gridLayout8);\n  flowLayout1.setVgap(2);\n  flowLayout1.setHgap(2);\n  flowLayout5.setAlignment(0);\n  flowLayout5.setHgap(1);\n  jPanel15.setLayout(borderLayout7);\n  gridLayout1.setHgap(2);\n  jPanel13.setLayout(gridLayout2);\n  jPanel5.setLayout(borderLayout2);\n  this.add(jPanel1,BorderLayout.CENTER);\n  jPanel1.add(jPanel2,BorderLayout.NORTH);\n  jPanel2.add(jPanel5,BorderLayout.NORTH);\n  jPanel5.add(jPanel16,BorderLayout.NORTH);\n  jPanel16.add(jPanel8,BorderLayout.EAST);\n  jPanel8.add(jPanel9,null);\n  jPanel9.add(jButtonHelp,null);\n  jPanel16.add(jPanel7,BorderLayout.WEST);\n  jPanel7.add(jPanel10,null);\n  jPanel10.add(jButtonNew,null);\n  jPanel10.add(jButtonOpen,null);\n  jPanel10.add(jButtonSaveAs,null);\n  jPanel10.add(jButtonSave,null);\n  jPanel10.add(jButtonPrint,null);\n  jPanel10.add(jButtonClose,null);\n  jPanel5.add(jPanel17,BorderLayout.SOUTH);\n  jPanel17.add(jPanel18,BorderLayout.WEST);\n  jPanel18.add(jPanel,null);\n  jPanel.add(jButtonCopy,null);\n  jPanel.add(jButtonCut,null);\n  jPanel.add(jButtonPaste,null);\n  jPanel1.add(jPanel3,BorderLayout.CENTER);\n  jPanel3.add(jPanel15,BorderLayout.CENTER);\n  jPanel15.add(jScrollPane1,BorderLayout.CENTER);\n  jScrollPane1.getViewport().add(jTextArea1,null);\n  jPanel1.add(jPanel4,BorderLayout.SOUTH);\n  jPanel4.add(jPanel13,null);\n  jPanel13.add(statusBar,null);\n  jTextArea1.setPreferredSize(new Dimension(200,100));\n}\n", "nl": "Method jbInit."}
{"code": "@Override public void performRequest(String request){\n  if (request.compareTo(\"Show preview\") == 0) {\n    showPreview();\n    return;\n  }\n  if (request.indexOf(\":\") < 0) {\n    return;\n  }\n  String tempI=request.substring(0,request.indexOf(':'));\n  int index=Integer.parseInt(tempI);\n  index--;\n  String req=request.substring(request.indexOf(')') + 1,request.length()).trim();\n  Object target=((BeanInstance)m_subFlow.elementAt(index)).getBean();\n  if (target instanceof Startable && req.equals(((Startable)target).getStartMessage())) {\n    try {\n      ((Startable)target).start();\n    }\n catch (    Exception ex) {\n      if (m_log != null) {\n        String compName=(target instanceof BeanCommon) ? ((BeanCommon)target).getCustomName() : \"\";\n        m_log.logMessage(\"Problem starting subcomponent \" + compName);\n      }\n    }\n  }\n else {\n    ((UserRequestAcceptor)target).performRequest(req);\n  }\n}\n", "nl": "Perform a particular request"}
{"code": "private String addAliasToIdentifier(String where,String alias){\n  String sqlkey=\"AND,OR,FROM,WHERE,JOIN,BY,GROUP,IN,INTO,SELECT,NOT,SET,UPDATE,DELETE,HAVING,IS,NULL,EXISTS,BETWEEN,LIKE,INNER,OUTER\";\n  StringTokenizer st=new StringTokenizer(where);\n  String result=\"\";\n  String token=\"\";\n  int o=-1;\n  while (true) {\n    token=st.nextToken();\n    String test=token.startsWith(\"(\") ? token.substring(1) : token;\n    if (sqlkey.indexOf(test) == -1) {\n      token=token.trim();\n      if (o != -1)       result=result + \" \" + token;\n else {\n        result=result + \" \";\n        StringBuffer t=new StringBuffer();\n        for (int i=0; i < token.length(); i++) {\n          char c=token.charAt(i);\n          if (isOperator(c)) {\n            if (t.length() > 0) {\n              if (c == '(')               result=result + t.toString();\n else               if (isIdentifier(t.toString()) && t.toString().indexOf('.') == -1)               result=result + alias + \".\"+ t.toString();\n else               result=result + t.toString();\n              t=new StringBuffer();\n            }\n            result=result + c;\n          }\n else {\n            t.append(c);\n          }\n        }\n        if (t.length() > 0) {\n          if (\"SELECT\".equalsIgnoreCase(t.toString().toUpperCase())) {\n            o=0;\n            result=result + t.toString();\n          }\n else           if (isIdentifier(t.toString()) && t.toString().indexOf('.') == -1)           result=result + alias + \".\"+ t.toString();\n else           result=result + t.toString();\n        }\n      }\n      if (o != -1) {\n        for (int i=0; i < token.length(); i++) {\n          char c=token.charAt(i);\n          if (c == '(')           o++;\n          if (c == ')')           o--;\n        }\n      }\n    }\n else {\n      result=result + \" \" + token;\n      if (\"SELECT\".equalsIgnoreCase(test)) {\n        o=0;\n      }\n    }\n    if (!st.hasMoreElements())     break;\n  }\n  return result;\n}\n", "nl": "Add table alias to identifier in where clause"}
{"code": "public IntVector sortWithIndex(){\n  IntVector index=IntVector.seq(0,size() - 1);\n  sortWithIndex(0,size() - 1,index);\n  return index;\n}\n", "nl": "Sorts the array in place with index returned"}
{"code": "private void writeQName(javax.xml.namespace.QName qname,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  java.lang.String namespaceURI=qname.getNamespaceURI();\n  if (namespaceURI != null) {\n    java.lang.String prefix=xmlWriter.getPrefix(namespaceURI);\n    if (prefix == null) {\n      prefix=generatePrefix(namespaceURI);\n      xmlWriter.writeNamespace(prefix,namespaceURI);\n      xmlWriter.setPrefix(prefix,namespaceURI);\n    }\n    if (prefix.trim().length() > 0) {\n      xmlWriter.writeCharacters(prefix + \":\" + org.apache.axis2.databinding.utils.ConverterUtil.convertToString(qname));\n    }\n else {\n      xmlWriter.writeCharacters(org.apache.axis2.databinding.utils.ConverterUtil.convertToString(qname));\n    }\n  }\n else {\n    xmlWriter.writeCharacters(org.apache.axis2.databinding.utils.ConverterUtil.convertToString(qname));\n  }\n}\n", "nl": "method to handle Qnames"}
{"code": "public boolean isUnboundedMax(){\n  return unboundedMax;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static Description createTestDescription(Class<?> clazz,String name,Annotation... annotations){\n  return new Description(clazz,formatDisplayName(name,clazz.getName()),annotations);\n}\n", "nl": "Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>. Generally, this will be a leaf <code>Description</code>."}
{"code": "@Override public void respond(String response){\n  getChannel().send().message(getUser(),response);\n}\n", "nl": "Respond by send a message in the channel to the user that set the mode in <code>user: message</code> format"}
{"code": "protected void useClassAttributes(){\n  int[] indices;\n  StringBuilder range;\n  MekaClassAttributes catts;\n  String newName;\n  getOwner().addUndoPoint();\n  indices=m_PanelClassAttributes.getSelectedAttributes();\n  range=new StringBuilder();\n  for (  int index : indices) {\n    if (range.length() > 0)     range.append(\",\");\n    range.append((index + 1));\n  }\n  catts=new MekaClassAttributes();\n  newName=getData().relationName().replaceFirst(\" -C [0-9]+\",\" -C \" + indices.length);\n  try {\n    catts.setAttributeIndices(range.toString());\n    filterData(catts,newName);\n  }\n catch (  Exception e) {\n    System.err.println(\"Setting of class attributes failed:\");\n    e.printStackTrace();\n    JOptionPane.showMessageDialog(PreprocessTab.this,\"Setting of class attributes failed:\\n\" + e,\"Error\",JOptionPane.ERROR_MESSAGE);\n  }\n}\n", "nl": "Sets the selected attributes as class attributes."}
{"code": "public CButton(String text){\n  this(text,null);\n}\n", "nl": "Creates a button with text."}
{"code": "@Override public Pane createRootPane(){\n  BorderPane root=new BorderPane();\n  StackPane envView=new StackPane();\n  envViewCtrl=new VacuumEnvironmentViewCtrl(envView);\n  Parameter[] params=createParameters();\n  SimulationPaneBuilder builder=new SimulationPaneBuilder();\n  builder.defineParameters(params);\n  builder.defineStateView(envView);\n  builder.defineInitMethod(null);\n  builder.defineSimMethod(null);\n  simPaneCtrl=builder.getResultFor(root);\n  return root;\n}\n", "nl": "Defines state view, parameters, and call-back functions and calls the simulation pane builder to create layout and controller objects."}
{"code": "public T caseFieldAccessor(FieldAccessor object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>Field Accessor</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public boolean wearsOutfitFromHere(final Player player){\n  final Outfit currentOutfit=player.getOutfit();\n  for (  final String outfitType : priceCalculator.dealtItems()) {\n    final List<Outfit> possibleOutfits=outfitTypes.get(outfitType);\n    for (    final Outfit possibleOutfit : possibleOutfits) {\n      if (possibleOutfit.isPartOf(currentOutfit)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Checks whether or not the given player is currently wearing an outfit that may have been bought/lent from an NPC with this behaviour."}
{"code": "public void write(@Nullable String spaceName,SwapKey key,byte[] val,@Nullable ClassLoader ldr) throws IgniteCheckedException {\n  assert key != null;\n  assert val != null;\n  try {\n    getSpi().store(spaceName,key,val,context(ldr));\n  }\n catch (  IgniteSpiException e) {\n    throw new IgniteCheckedException(\"Failed to write to swap space [space=\" + spaceName + \", key=\"+ key+ \", valLen=\"+ val.length+ ']',e);\n  }\n}\n", "nl": "Writes value to swap."}
{"code": "private void establecerElementosVista(HttpServletRequest request,GestionAuditoriaBI service,String module){\n  List modulos=(List)service.getModules();\n  request.setAttribute(AuditoriaConstants.LISTA_MODULOS_KEY,modulos);\n  List acciones=null;\n  if (module == null)   acciones=(List)service.getActions(ArchivoModules.NONE_MODULE);\n else   acciones=(List)service.getActions(Integer.parseInt(module));\n  request.setAttribute(AuditoriaConstants.LISTA_ACCIONES_KEY,acciones);\n  List listaGrupos=getGestionControlUsuarios(request).getGrupos();\n  listaGrupos.remove(new GrupoVO(CritUsuarioVO.GLOBAL_GROUP));\n  listaGrupos.remove(new GrupoVO(CritUsuarioVO.GLOBAL_GROUP_ADM));\n  request.setAttribute(AuditoriaConstants.LISTA_GRUPOS_KEY,listaGrupos);\n}\n", "nl": "Establece los elementos necesarios para mostrar en la vista"}
{"code": "public MapBackedDirectory(){\n  this(Collections.<K,V>emptyMap());\n}\n", "nl": "Creates an empty directory backed by an empty Map"}
{"code": "public static void createIndex(Connection conn,String schema,String table,String columnList) throws SQLException {\n  init(conn);\n  PreparedStatement prep=conn.prepareStatement(\"INSERT INTO \" + SCHEMA + \".INDEXES(SCHEMA, TABLE, COLUMNS) VALUES(?, ?, ?)\");\n  prep.setString(1,schema);\n  prep.setString(2,table);\n  prep.setString(3,columnList);\n  prep.execute();\n  createTrigger(conn,schema,table);\n  indexExistingRows(conn,schema,table);\n}\n", "nl": "Create a new full text index for a table and column list. Each table may only have one index at any time."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:16.621 -0500\",hash_original_method=\"6C96B3E47AB792BE3053A98B747C02B0\",hash_generated_method=\"762C6F42E9E67BA3B76C7151964CBF27\") public synchronized boolean hasCookies(boolean privateBrowsing){\n  if (!JniUtil.useChromiumHttpStack()) {\n    return hasCookies();\n  }\n  return nativeHasCookies(privateBrowsing);\n}\n", "nl": "Return true if there are stored cookies."}
{"code": "public StorageUnitAlternateKeyDto createStorageUnitKey(BusinessObjectDataKey businessObjectDataKey,String storageName){\n  StorageUnitAlternateKeyDto storageUnitKey=new StorageUnitAlternateKeyDto();\n  storageUnitKey.setNamespace(businessObjectDataKey.getNamespace());\n  storageUnitKey.setBusinessObjectDefinitionName(businessObjectDataKey.getBusinessObjectDefinitionName());\n  storageUnitKey.setBusinessObjectFormatUsage(businessObjectDataKey.getBusinessObjectFormatUsage());\n  storageUnitKey.setBusinessObjectFormatFileType(businessObjectDataKey.getBusinessObjectFormatFileType());\n  storageUnitKey.setBusinessObjectFormatVersion(businessObjectDataKey.getBusinessObjectFormatVersion());\n  storageUnitKey.setPartitionValue(businessObjectDataKey.getPartitionValue());\n  storageUnitKey.setSubPartitionValues(businessObjectDataKey.getSubPartitionValues());\n  storageUnitKey.setBusinessObjectDataVersion(businessObjectDataKey.getBusinessObjectDataVersion());\n  storageUnitKey.setStorageName(storageName);\n  return storageUnitKey;\n}\n", "nl": "Creates a storage unit key from a business object data key and a storage name."}
{"code": "public static <L,R>MutablePair<L,R> of(final L left,final R right){\n  return new MutablePair<L,R>(left,right);\n}\n", "nl": "<p>Obtains an immutable pair of from two objects inferring the generic types.</p> <p>This factory allows the pair to be created using inference to obtain the generic types.</p>"}
{"code": "static int bitLengthForInt(int n){\n  return 32 - Integer.numberOfLeadingZeros(n);\n}\n", "nl": "Package private method to return bit length for an integer."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  String distanceOutputHeader=null;\n  int i;\n  int progress;\n  int row, col;\n  double z=0;\n  double distConvFactor=1.0;\n  double gridRes=0;\n  double currentVal=0;\n  double currentMaxVal=0;\n  double maxValDist=0;\n  double maxDist=0;\n  double lineSlope=0;\n  boolean saveDistance=false;\n  double azimuth=0;\n  double deltaX=0;\n  double deltaY=0;\n  double x=0;\n  int x1=0;\n  int x2=0;\n  double y=0;\n  int y1=0;\n  int y2=0;\n  double z1=0;\n  double z2=0;\n  double dist=0;\n  double slope=0;\n  double yIntercept=0;\n  int xStep=0;\n  int yStep=0;\n  double noData=0;\n  boolean flag=false;\n  double aSmallValue=-9999999;\n  maxDist=Double.MAX_VALUE;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputHeader=args[0];\n  outputHeader=args[1];\n  azimuth=Double.parseDouble(args[2]);\n  if (azimuth > 360 || azimuth < 0) {\n    azimuth=0.1;\n  }\n  if (azimuth == 0) {\n    azimuth=0.1;\n  }\n  if (azimuth == 180) {\n    azimuth=179.9;\n  }\n  if (azimuth == 360) {\n    azimuth=359.9;\n  }\n  if (azimuth < 180) {\n    lineSlope=Math.tan(Math.toRadians(90 - azimuth));\n  }\n else {\n    lineSlope=Math.tan(Math.toRadians(270 - azimuth));\n  }\n  if (!args[3].toLowerCase().equals(\"not specified\")) {\n    maxDist=Double.parseDouble(args[3]);\n  }\n  if (!args[4].toLowerCase().equals(\"not specified\")) {\n    saveDistance=true;\n    distanceOutputHeader=args[4];\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster DEM=new WhiteboxRaster(inputHeader,\"r\");\n    DEM.setForceAllDataInMemory(true);\n    int rows=DEM.getNumberRows();\n    int cols=DEM.getNumberColumns();\n    noData=DEM.getNoDataValue();\n    if (DEM.getXYUnits().toLowerCase().contains(\"deg\") || DEM.getProjection().toLowerCase().contains(\"geog\")) {\n      double midLat=(DEM.getNorth() - DEM.getSouth()) / 2.0;\n      if (midLat <= 90 && midLat >= -90) {\n        distConvFactor=(113200 * Math.cos(Math.toRadians(midLat)));\n      }\n    }\n    gridRes=(DEM.getCellSizeX() + DEM.getCellSizeY()) / 2 * distConvFactor;\n    WhiteboxRaster output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    output.setPreferredPalette(\"grey.pal\");\n    output.setForceAllDataInMemory(true);\n    WhiteboxRaster outputDist=null;\n    if (saveDistance) {\n      outputDist=new WhiteboxRaster(distanceOutputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n      outputDist.setPreferredPalette(\"blue_white_red.pal\");\n      outputDist.setForceAllDataInMemory(true);\n    }\n    if (azimuth > 0 && azimuth <= 90) {\n      xStep=1;\n      yStep=1;\n    }\n else     if (azimuth <= 180) {\n      xStep=1;\n      yStep=-1;\n    }\n else     if (azimuth <= 270) {\n      xStep=-1;\n      yStep=-1;\n    }\n else {\n      xStep=-1;\n      yStep=1;\n    }\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        currentVal=DEM.getValue(row,col);\n        if (currentVal != noData) {\n          yIntercept=-row - lineSlope * col;\n          currentMaxVal=aSmallValue;\n          maxValDist=aSmallValue;\n          x=col;\n          flag=true;\n          do {\n            x=x + xStep;\n            if (x < 0 || x >= cols) {\n              flag=false;\n              break;\n            }\n            y=(lineSlope * x + yIntercept) * -1;\n            if (y < 0 || y >= rows) {\n              flag=false;\n              break;\n            }\n            deltaX=(x - col) * gridRes;\n            deltaY=(y - row) * gridRes;\n            dist=Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n            if (dist > maxDist) {\n              flag=false;\n              break;\n            }\n            y1=(int)(y);\n            y2=y1 + yStep * -1;\n            z1=DEM.getValue(y1,(int)x);\n            z2=DEM.getValue(y2,(int)x);\n            z=z1 + (y - y1) * (z2 - z1);\n            slope=(z - currentVal) / dist;\n            if (slope > currentMaxVal) {\n              currentMaxVal=slope;\n              maxValDist=dist;\n            }\n else             if (currentMaxVal < 0) {\n              maxValDist=dist;\n            }\n          }\n while (flag);\n          y=-row;\n          flag=true;\n          do {\n            y=y + yStep;\n            if (-y < 0 || -y >= rows) {\n              flag=false;\n              break;\n            }\n            x=(y - yIntercept) / lineSlope;\n            if (x < 0 || x >= cols) {\n              flag=false;\n              break;\n            }\n            deltaX=(x - col) * gridRes;\n            deltaY=(-y - row) * gridRes;\n            dist=Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n            if (dist > maxDist) {\n              flag=false;\n              break;\n            }\n            x1=(int)x;\n            x2=x1 + xStep;\n            if (x2 < 0 || x2 >= cols) {\n              flag=false;\n              break;\n            }\n            z1=DEM.getValue((int)-y,x1);\n            z2=DEM.getValue((int)y,x2);\n            z=z1 + (x - x1) * (z2 - z1);\n            slope=(z - currentVal) / dist;\n            if (slope > currentMaxVal) {\n              currentMaxVal=slope;\n              maxValDist=dist;\n            }\n else             if (currentMaxVal < 0) {\n              maxValDist=dist;\n            }\n          }\n while (flag);\n          z=Math.toDegrees(Math.atan(currentMaxVal));\n          if (z < -89) {\n            z=0;\n          }\n          if (currentMaxVal != aSmallValue) {\n            output.setValue(row,col,z);\n            if (saveDistance) {\n              if (z < 0) {\n                maxValDist=maxValDist * -1;\n              }\n              outputDist.setValue(row,col,maxValDist);\n            }\n          }\n else {\n            output.setValue(row,col,noData);\n            if (saveDistance) {\n              outputDist.setValue(row,col,noData);\n            }\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (rows - 1));\n      updateProgress(progress);\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    DEM.close();\n    output.close();\n    if (saveDistance) {\n      outputDist.close();\n    }\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:53.485 -0400\",hash_original_method=\"B6CCE4550C29DDD6A02AB62B3A5D936A\",hash_generated_method=\"979F94608D9916FD462CA7E4AAD1B55D\") @Override public boolean accept(File file){\n  return file.canWrite();\n}\n", "nl": "Checks to see if the file can be written to."}
{"code": "private Map<SoftwareVersion,URL> parseDirectory(URL url,String input) throws IOException, RemoteRepositoryException {\n  Map<SoftwareVersion,URL> versions=new HashMap<SoftwareVersion,URL>();\n  ParserCallback callback=new ParserCallback(url,versions);\n  new HTMLEditor().getParser().parse(new StringReader(input.toString()),callback,true);\n  return versions;\n}\n", "nl": "Parse the remote repository directory string"}
{"code": "public DouglasPeuckerSimplifier(Geometry inputGeom){\n  this.inputGeom=inputGeom;\n}\n", "nl": "Creates a simplifier for a given geometry."}
{"code": "public void reserveStock(MDDOrderLine[] lines){\n  BigDecimal Volume=Env.ZERO;\n  BigDecimal Weight=Env.ZERO;\n  for (  MDDOrderLine line : lines) {\n    MLocator locator_from=MLocator.get(getCtx(),line.getM_Locator_ID());\n    MLocator locator_to=MLocator.get(getCtx(),line.getM_LocatorTo_ID());\n    BigDecimal reserved_ordered=line.getQtyOrdered().subtract(line.getQtyReserved()).subtract(line.getQtyDelivered());\n    if (reserved_ordered.signum() == 0) {\n      MProduct product=line.getProduct();\n      if (product != null) {\n        Volume=Volume.add(product.getVolume().multiply(line.getQtyOrdered()));\n        Weight=Weight.add(product.getWeight().multiply(line.getQtyOrdered()));\n      }\n      continue;\n    }\n    log.fine(\"Line=\" + line.getLine() + \" - Ordered=\"+ line.getQtyOrdered()+ \",Reserved=\"+ line.getQtyReserved()+ \",Delivered=\"+ line.getQtyDelivered());\n    MProduct product=line.getProduct();\n    if (product != null) {\n      if (product.isStocked()) {\n        if (!MStorage.add(getCtx(),locator_to.getM_Warehouse_ID(),locator_to.getM_Locator_ID(),line.getM_Product_ID(),line.getM_AttributeSetInstance_ID(),line.getM_AttributeSetInstance_ID(),Env.ZERO,Env.ZERO,reserved_ordered,get_TrxName())) {\n          throw new AdempiereException();\n        }\n        if (!MStorage.add(getCtx(),locator_from.getM_Warehouse_ID(),locator_from.getM_Locator_ID(),line.getM_Product_ID(),line.getM_AttributeSetInstanceTo_ID(),line.getM_AttributeSetInstance_ID(),Env.ZERO,reserved_ordered,Env.ZERO,get_TrxName())) {\n          throw new AdempiereException();\n        }\n      }\n      line.setQtyReserved(line.getQtyReserved().add(reserved_ordered));\n      line.saveEx();\n      Volume=Volume.add(product.getVolume().multiply(line.getQtyOrdered()));\n      Weight=Weight.add(product.getWeight().multiply(line.getQtyOrdered()));\n    }\n  }\n  setVolume(Volume);\n  setWeight(Weight);\n}\n", "nl": "Reserve Inventory. Counterpart: MMovement.completeIt()"}
{"code": "protected void addMapping(int hashIndex,int hashCode,K key,V value){\n  modCount++;\n  HashEntry<K,V> entry=createEntry(data[hashIndex],hashCode,key,value);\n  addEntry(entry,hashIndex);\n  size++;\n  checkCapacity();\n}\n", "nl": "Adds a new key-value mapping into this map. <p/> This implementation calls <code>createEntry()</code>, <code>addEntry()</code> and <code>checkCapacity()</code>. It also handles changes to <code>modCount</code> and <code>size</code>. Subclasses could override to fully control adds to the map."}
{"code": "private Hop simplifyWeightedSquaredLoss(Hop parent,Hop hi,int pos) throws HopsException {\n  Hop hnew=null;\n  if (hi instanceof AggUnaryOp && ((AggUnaryOp)hi).getDirection() == Direction.RowCol && ((AggUnaryOp)hi).getOp() == AggOp.SUM && hi.getInput().get(0) instanceof BinaryOp && hi.getInput().get(0).getDim2() > 1) {\n    BinaryOp bop=(BinaryOp)hi.getInput().get(0);\n    boolean appliedPattern=false;\n    if (bop.getOp() == OpOp2.MULT && bop.getInput().get(1) instanceof BinaryOp && bop.getInput().get(0).getDataType() == DataType.MATRIX && HopRewriteUtils.isEqualSize(bop.getInput().get(0),bop.getInput().get(1)) && ((BinaryOp)bop.getInput().get(1)).getOp() == OpOp2.POW && bop.getInput().get(1).getInput().get(1) instanceof LiteralOp && HopRewriteUtils.getDoubleValue((LiteralOp)bop.getInput().get(1).getInput().get(1)) == 2) {\n      Hop W=bop.getInput().get(0);\n      Hop tmp=bop.getInput().get(1).getInput().get(0);\n      if (tmp instanceof BinaryOp && ((BinaryOp)tmp).getOp() == OpOp2.MINUS && HopRewriteUtils.isEqualSize(tmp.getInput().get(0),tmp.getInput().get(1)) && tmp.getInput().get(0).getDataType() == DataType.MATRIX) {\n        int uvIndex=-1;\n        if (tmp.getInput().get(1) instanceof AggBinaryOp && HopRewriteUtils.isSingleBlock(tmp.getInput().get(1).getInput().get(0),true)) {\n          uvIndex=1;\n        }\n else         if (tmp.getInput().get(0) instanceof AggBinaryOp && HopRewriteUtils.isSingleBlock(tmp.getInput().get(0).getInput().get(0),true)) {\n          uvIndex=0;\n        }\n        if (uvIndex >= 0) {\n          Hop X=tmp.getInput().get((uvIndex == 0) ? 1 : 0);\n          Hop U=tmp.getInput().get(uvIndex).getInput().get(0);\n          Hop V=tmp.getInput().get(uvIndex).getInput().get(1);\n          if (!HopRewriteUtils.isTransposeOperation(V)) {\n            V=HopRewriteUtils.createTranspose(V);\n          }\n else {\n            V=V.getInput().get(0);\n          }\n          if (HopRewriteUtils.isNonZeroIndicator(W,X)) {\n            W=new LiteralOp(1);\n          }\n          hnew=new QuaternaryOp(hi.getName(),DataType.SCALAR,ValueType.DOUBLE,OpOp4.WSLOSS,X,U,V,W,true);\n          HopRewriteUtils.setOutputParametersForScalar(hnew);\n          appliedPattern=true;\n          LOG.debug(\"Applied simplifyWeightedSquaredLoss1\" + uvIndex + \" (line \"+ hi.getBeginLine()+ \")\");\n        }\n      }\n    }\n    if (!appliedPattern && bop.getOp() == OpOp2.POW && bop.getInput().get(1) instanceof LiteralOp && HopRewriteUtils.getDoubleValue((LiteralOp)bop.getInput().get(1)) == 2 && bop.getInput().get(0) instanceof BinaryOp && bop.getInput().get(0).getDataType() == DataType.MATRIX && ((BinaryOp)bop.getInput().get(0)).getOp() == OpOp2.MINUS && HopRewriteUtils.isEqualSize(bop.getInput().get(0).getInput().get(0),bop.getInput().get(0).getInput().get(1)) && bop.getInput().get(0).getInput().get(0).getDataType() == DataType.MATRIX) {\n      Hop lleft=bop.getInput().get(0).getInput().get(0);\n      Hop lright=bop.getInput().get(0).getInput().get(1);\n      int wuvIndex=-1;\n      if (lright instanceof BinaryOp && lright.getInput().get(1) instanceof AggBinaryOp) {\n        wuvIndex=1;\n      }\n else       if (lleft instanceof BinaryOp && lleft.getInput().get(1) instanceof AggBinaryOp) {\n        wuvIndex=0;\n      }\n      if (wuvIndex >= 0) {\n        Hop X=bop.getInput().get(0).getInput().get((wuvIndex == 0) ? 1 : 0);\n        Hop tmp=bop.getInput().get(0).getInput().get(wuvIndex);\n        if (((BinaryOp)tmp).getOp() == OpOp2.MULT && tmp.getInput().get(0).getDataType() == DataType.MATRIX && HopRewriteUtils.isEqualSize(tmp.getInput().get(0),tmp.getInput().get(1)) && HopRewriteUtils.isSingleBlock(tmp.getInput().get(1).getInput().get(0),true)) {\n          Hop W=tmp.getInput().get(0);\n          Hop U=tmp.getInput().get(1).getInput().get(0);\n          Hop V=tmp.getInput().get(1).getInput().get(1);\n          if (!HopRewriteUtils.isTransposeOperation(V)) {\n            V=HopRewriteUtils.createTranspose(V);\n          }\n else {\n            V=V.getInput().get(0);\n          }\n          hnew=new QuaternaryOp(hi.getName(),DataType.SCALAR,ValueType.DOUBLE,OpOp4.WSLOSS,X,U,V,W,false);\n          HopRewriteUtils.setOutputParametersForScalar(hnew);\n          appliedPattern=true;\n          LOG.debug(\"Applied simplifyWeightedSquaredLoss2\" + wuvIndex + \" (line \"+ hi.getBeginLine()+ \")\");\n        }\n      }\n    }\n    if (!appliedPattern && bop.getOp() == OpOp2.POW && bop.getInput().get(1) instanceof LiteralOp && HopRewriteUtils.getDoubleValue((LiteralOp)bop.getInput().get(1)) == 2 && bop.getInput().get(0) instanceof BinaryOp && bop.getInput().get(0).getDataType() == DataType.MATRIX && ((BinaryOp)bop.getInput().get(0)).getOp() == OpOp2.MINUS && HopRewriteUtils.isEqualSize(bop.getInput().get(0).getInput().get(0),bop.getInput().get(0).getInput().get(1)) && bop.getInput().get(0).getInput().get(0).getDataType() == DataType.MATRIX) {\n      Hop lleft=bop.getInput().get(0).getInput().get(0);\n      Hop lright=bop.getInput().get(0).getInput().get(1);\n      int uvIndex=-1;\n      if (lright instanceof AggBinaryOp && HopRewriteUtils.isSingleBlock(lright.getInput().get(0),true)) {\n        uvIndex=1;\n      }\n else       if (lleft instanceof AggBinaryOp && HopRewriteUtils.isSingleBlock(lleft.getInput().get(0),true)) {\n        uvIndex=0;\n      }\n      if (uvIndex >= 0) {\n        Hop X=bop.getInput().get(0).getInput().get((uvIndex == 0) ? 1 : 0);\n        Hop tmp=bop.getInput().get(0).getInput().get(uvIndex);\n        Hop W=new LiteralOp(1);\n        Hop U=tmp.getInput().get(0);\n        Hop V=tmp.getInput().get(1);\n        if (!HopRewriteUtils.isTransposeOperation(V)) {\n          V=HopRewriteUtils.createTranspose(V);\n        }\n else {\n          V=V.getInput().get(0);\n        }\n        hnew=new QuaternaryOp(hi.getName(),DataType.SCALAR,ValueType.DOUBLE,OpOp4.WSLOSS,X,U,V,W,false);\n        HopRewriteUtils.setOutputParametersForScalar(hnew);\n        appliedPattern=true;\n        LOG.debug(\"Applied simplifyWeightedSquaredLoss3\" + uvIndex + \" (line \"+ hi.getBeginLine()+ \")\");\n      }\n    }\n  }\n  if (hnew != null) {\n    HopRewriteUtils.removeChildReferenceByPos(parent,hi,pos);\n    HopRewriteUtils.addChildReference(parent,hnew,pos);\n    hi=hnew;\n  }\n  return hi;\n}\n", "nl": "Searches for weighted squared loss expressions and replaces them with a quaternary operator.  Currently, this search includes the following three patterns: 1) sum (W * (X - U %*% t(V)) ^ 2) (post weighting) 2) sum ((X - W * (U %*% t(V))) ^ 2) (pre weighting) 3) sum ((X - (U %*% t(V))) ^ 2) (no weighting) NOTE: We include transpose into the pattern because during runtime we need to compute U%*% t(V) pointwise; having V and not t(V) at hand allows for a cache-friendly implementation without additional memory requirements for internal transpose. This rewrite is conceptually a static rewrite; however, the current MR runtime only supports U/V factors of rank up to the blocksize (1000). We enforce this contraint here during the general rewrite because this is an uncommon case. Also, the intention is to remove this constaint as soon as we generalized the runtime or hop/lop compilation."}
{"code": "void listMetricDescriptors() throws IOException {\n  ListMetricDescriptorsResponse metricsResponse=this.monitoringService.projects().metricDescriptors().list(this.projectResource).execute();\n  this.outputStream.println(\"listMetricDescriptors response\");\n  this.outputStream.println(metricsResponse.toPrettyString());\n}\n", "nl": "Query to MetricDescriptors.list <p>This lists all the current metrics. Package-private to be accessible to tests."}
{"code": "public void cancel(){\n  isCanceled.set(true);\n}\n", "nl": "Informs this executor to stop processing and returns any results collected thus far.  This method is thread-safe."}
{"code": "public Map<String,String> systemInfo(){\n  HashMap<String,String> info=new HashMap<String,String>();\n  NaElement elem=new NaElement(\"system-get-node-info-iter\");\n  NaElement attributesList=null;\n  try {\n    List outputElements=(List)server.getNaServer().invokeElem(elem).getChildByName(\"attributes-list\").getChildren();\n    Iterator iter=outputElements.iterator();\n    while (iter.hasNext()) {\n      attributesList=(NaElement)iter.next();\n      for (      NaElement child : (List<NaElement>)attributesList.getChildren()) {\n        String name=child.getName();\n        info.put(name,child.getContent());\n      }\n    }\n    return info;\n  }\n catch (  Exception e) {\n    String msg=\"Failed to get array system info\";\n    log.error(msg,e);\n    throw new NetAppCException(msg,e);\n  }\n}\n", "nl": "get array system-info."}
{"code": "public MajorityLabelsetTest(String name){\n  super(name);\n}\n", "nl": "Initializes the test."}
{"code": "public void allocateLoadBalance(){\n  _loadBalanceAllocateCount.incrementAndGet();\n}\n", "nl": "Allocate a connection for load balancing."}
{"code": "public static void main(String[] args){\n  try (Ignite ignite=Ignition.start(\"examples/config/example-ignite.xml\")){\n    System.out.println();\n    System.out.println(\">>> Binary objects cache put-get example started.\");\n    CacheConfiguration<Integer,Organization> cfg=new CacheConfiguration<>();\n    cfg.setCacheMode(CacheMode.PARTITIONED);\n    cfg.setName(CACHE_NAME);\n    cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);\n    try (IgniteCache<Integer,Organization> cache=ignite.getOrCreateCache(cfg)){\n      if (ignite.cluster().forDataNodes(cache.getName()).nodes().isEmpty()) {\n        System.out.println();\n        System.out.println(\">>> This example requires remote cache node nodes to be started.\");\n        System.out.println(\">>> Please start at least 1 remote cache node.\");\n        System.out.println(\">>> Refer to example's javadoc for details on configuration.\");\n        System.out.println();\n        return;\n      }\n      putGet(cache);\n      putGetBinary(cache);\n      putGetAll(cache);\n      putGetAllBinary(cache);\n      System.out.println();\n    }\n  finally {\n      ignite.destroyCache(CACHE_NAME);\n    }\n  }\n }\n", "nl": "Executes example."}
{"code": "public Task(String description,Date start,Date end){\n  this(description,new SimpleTimePeriod(start,end));\n}\n", "nl": "Creates a new task."}
{"code": "public static void w(String tag,String msg,Object... args){\n  if (sLevel > LEVEL_WARNING) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.w(tag,msg);\n}\n", "nl": "Send a WARNING log message"}
{"code": "public StateMachineSecurityInterceptor(){\n  this(null,null);\n}\n", "nl": "Instantiates a new state machine security interceptor."}
{"code": "public void testRandomSortsOnLargeIndex() throws Exception {\n  final Collection<String> allFieldNames=getAllSortFieldNames();\n  final int initialDocs=TestUtil.nextInt(random(),100,200);\n  final int totalDocs=atLeast(500);\n  for (int i=1; i <= initialDocs; i++) {\n    SolrInputDocument doc=buildRandomDocument(i);\n    assertU(adoc(doc));\n  }\n  assertU(commit());\n  for (  String f : allFieldNames) {\n    for (    String order : new String[]{\" asc\",\" desc\"}) {\n      String sort=f + order + (\"id\".equals(f) ? \"\" : \", id\" + order);\n      String rows=\"\" + TestUtil.nextInt(random(),13,50);\n      SentinelIntSet ids=assertFullWalkNoDups(totalDocs,params(\"q\",\"*:*\",\"fl\",\"id\",\"rows\",rows,\"sort\",sort));\n      assertEquals(initialDocs,ids.size());\n    }\n  }\n  for (int i=initialDocs + 1; i <= totalDocs; i++) {\n    SolrInputDocument doc=buildRandomDocument(i);\n    assertU(adoc(doc));\n  }\n  assertU(commit());\n  final int numRandomSorts=atLeast(3);\n  for (int i=0; i < numRandomSorts; i++) {\n    final String sort=buildRandomSort(allFieldNames);\n    final String rows=\"\" + TestUtil.nextInt(random(),63,113);\n    final String fl=random().nextBoolean() ? \"id\" : \"id,score\";\n    final boolean matchAll=random().nextBoolean();\n    final String q=matchAll ? \"*:*\" : buildRandomQuery();\n    SentinelIntSet ids=assertFullWalkNoDups(totalDocs,params(\"q\",q,\"fl\",fl,\"rows\",rows,\"sort\",sort));\n    if (matchAll) {\n      assertEquals(totalDocs,ids.size());\n    }\n  }\n}\n", "nl": "randomized testing of a non-trivial number of docs using assertFullWalkNoDups"}
{"code": "protected void reOrganizeFeatures(){\n  double[] f;\n  Cluster best;\n  double v, minDistance;\n  for (int k=0; k < features.size(); k++) {\n    f=features.get(k);\n    best=clusters[0];\n    minDistance=clusters[0].getDistance(f);\n    for (int i=1; i < clusters.length; i++) {\n      v=clusters[i].getDistance(f);\n      if (minDistance > v) {\n        best=clusters[i];\n        minDistance=v;\n      }\n    }\n    best.assignMember(f);\n  }\n}\n", "nl": "Re-shuffle all features."}
{"code": "public int subtreeDepth() throws UnsupportedOperationException {\n  int sum=1;\n  for (int i=name.indexOf('.'); i >= 0; i=name.indexOf('.',i + 1)) {\n    ++sum;\n  }\n  return sum;\n}\n", "nl": "Return subtree depth of this name for purposes of determining NameConstraints minimum and maximum bounds and for calculating path lengths in name subtrees."}
{"code": "@Override public QParser createParser(String qstr,SolrParams localParams,SolrParams params,SolrQueryRequest req){\n  return new SimpleQParser(qstr,localParams,params,req);\n}\n", "nl": "Returns a QParser that will create a query by using Lucene's SimpleQueryParser."}
{"code": "public VdcConfig toConfigParam(Properties vdcInfo){\n  log.info(\"copy {} to the sync config param\",vdcInfo.getProperty(GeoServiceJob.VDC_SHORT_ID));\n  VdcConfig vdcConfig=new VdcConfig();\n  vdcConfig.setId(URIUtil.uri(vdcInfo.getProperty(GeoServiceJob.OPERATED_VDC_ID)));\n  vdcConfig.setShortId(vdcInfo.getProperty(GeoServiceJob.VDC_SHORT_ID));\n  vdcConfig.setSecretKey(vdcInfo.getProperty(GeoServiceJob.VDC_SECRETE_KEY));\n  String name=vdcInfo.getProperty(GeoServiceJob.VDC_NAME);\n  if ((name != null) && (!name.isEmpty())) {\n    vdcConfig.setName(name);\n  }\n  String description=vdcInfo.getProperty(GeoServiceJob.VDC_DESCRIPTION);\n  if ((description != null) && (!description.isEmpty())) {\n    vdcConfig.setDescription(description);\n  }\n  String endPnt=vdcInfo.getProperty(GeoServiceJob.VDC_API_ENDPOINT);\n  if (endPnt != null) {\n    vdcConfig.setApiEndpoint(endPnt);\n  }\n  vdcConfig.setGeoCommandEndpoint(vdcInfo.getProperty(GeoServiceJob.VDC_GEOCOMMAND_ENDPOINT));\n  vdcConfig.setGeoDataEndpoint(vdcInfo.getProperty(GeoServiceJob.VDC_GEODATA_ENDPOINT));\n  return vdcConfig;\n}\n", "nl": "Build VdcConfig for a vdc for SyncVdcConfig call"}
{"code": "final public SyntaxTreeNode LetIn() throws ParseException {\n  SyntaxTreeNode zn[]=new SyntaxTreeNode[4];\n  SyntaxTreeNode tn;\n  Token t;\n  bpa(\"Case Other Arm\");\n  t=jj_consume_token(LET);\n  zn[0]=new SyntaxTreeNode(mn,t);\n  zn[1]=LetDefinitions();\n  t=jj_consume_token(LETIN);\n  zn[2]=new SyntaxTreeNode(mn,t);\n  zn[3]=Expression();\n  epa();\n{\n    if (true)     return new SyntaxTreeNode(mn,N_LetIn,zn);\n  }\n  throw new Error(\"Missing return statement in function\");\n}\n", "nl": "LetIn ::= <LET> LetDefinitions() <LETIN> Expression()                     * It produces a SyntaxTreeNode tn with the four heirs                       \"LET\", LetDefinitions, \"IN\", Expression                                in tn.zero.                                                             "}
{"code": "public final String toString(byte[] buffer){\n  return toString(buffer,0,buffer.length);\n}\n", "nl": "Convert the byte buffer to a string using this instance's character encoding."}
{"code": "public static <T>T checkNotNull(T reference){\n  if (reference == null) {\n    throw new IllegalArgumentException();\n  }\n  return reference;\n}\n", "nl": "Check if the reference is not null. This differs from Guava that throws Illegal Argument Exception"}
{"code": "public void add(final URI uri){\n  this.uris.add(uri);\n}\n", "nl": "Adds a new URI to the list of redirects."}
{"code": "@RequestMapping(value=\"/{id}\",method=RequestMethod.DELETE) @ResponseBody public RestWrapper delete(@PathVariable(\"id\") Integer processTemplateId,Principal principal){\n  RestWrapper restWrapper=null;\n  try {\n    processTemplateDAO.delete(processTemplateId);\n    restWrapper=new RestWrapper(null,RestWrapper.OK);\n    LOGGER.info(\"Record with ID:\" + processTemplateId + \" deleted from ProcessTemplate by User:\"+ principal.getName());\n  }\n catch (  Exception e) {\n    LOGGER.error(e);\n    restWrapper=new RestWrapper(e.getMessage(),RestWrapper.ERROR);\n  }\n  return restWrapper;\n}\n", "nl": "This method calls proc DeleteProcess and deletes a record from process table corresponding to processId passed."}
{"code": "public AccountHeaderBuilder withOnlySmallProfileImagesVisible(boolean onlySmallProfileImagesVisible){\n  this.mOnlySmallProfileImagesVisible=onlySmallProfileImagesVisible;\n  return this;\n}\n", "nl": "define if only the small profile images should be visible"}
{"code": "public static boolean isGreater(Date d1,Date d2){\n  if (d1 == null || d2 == null) {\n    return false;\n  }\n  return d1.compareTo(d2) > 0;\n}\n", "nl": "Returns <code>true</code> if the date d1 is greater than date d2. Returns <code>false</code> if either d1 or d2 are <code>null</code>."}
{"code": "private ReplaceTokens.Token createPortToken(){\n  String port=getPropertyValue(ServletPropertySet.PORT);\n  if (port == null) {\n    port=JRun4xPropertySet.DEFAULT_PORT;\n  }\n  ReplaceTokens.Token tokenPort=new ReplaceTokens.Token();\n  tokenPort.setKey(ServletPropertySet.PORT);\n  tokenPort.setValue(port);\n  return tokenPort;\n}\n", "nl": "Creates the port token for inclusion in jrun.xml ."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String n=getString(stack);\n  String k=getString(stack);\n  String r=getString(stack);\n  if (!Sage.WINDOWS_OS)   return \"\";\n  return Sage.readStringValue(Sage.getHKEYForName(r),k,n);\n}\n", "nl": "Returns a string value from the Windows registry for the specified root, key and name(Windows only) Acceptable values for the Root are: \"HKCR\", \"HKEY_CLASSES_ROOT\", \"HKCC\", \"HKEY_CURRENT_CONFIG\", \"HKCU\", \"HKEY_CURRENT_USER\", \"HKU\", \"HKEY_USERS\", \"HKLM\" or \"HKEY_LOCAL_MACHINE\" (HKLM is the default if nothing matches)"}
{"code": "public AccountMetaData(final AccountStatus status,final AccountRemoteStatus remoteStatus,final List<AccountInfo> cosignatoryOf,final List<AccountInfo> cosignatories){\n  this.status=status;\n  this.remoteStatus=remoteStatus;\n  this.cosignatoryOf=cosignatoryOf;\n  this.cosignatories=cosignatories;\n}\n", "nl": "Creates a new meta data."}
{"code": "public boolean initialise(ServletContext servletContext){\n  boolean ok=super.initialise(servletContext);\n  if (ok) {\n    String displayName=getDisplayName();\n    log.debug(\"loaded outbound rule \" + displayName + \" (\"+ from+ \", \"+ to+ ')');\n  }\n else {\n    log.debug(\"failed to load outbound rule\");\n  }\n  if (errors.size() > 0) {\n    ok=false;\n  }\n  valid=ok;\n  return ok;\n}\n", "nl": "Will initialise the outbound rule."}
{"code": "public void doWindowOpen(Object parm){\n  if (parm instanceof String) {\n    jTextArea1.setText((String)parm);\n  }\n}\n", "nl": "doWindowOpen() -"}
{"code": "private boolean isExcluded(String[] cargoFiles,String filename){\n  if (cargoFiles == null) {\n    return false;\n  }\n  for (  String cargoFile : cargoFiles) {\n    if (cargoFile.equals(filename)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Check if file with name <code>filename</code> is one of cargo resources file."}
{"code": "public Builder<V> dimensions(int dimensions){\n  this.dimensions=dimensions;\n  return this;\n}\n", "nl": "Set the dimensions."}
{"code": "public String toString(){\n  return representation;\n}\n", "nl": "Returns the string representation."}
{"code": "public AbstractSailImplConfig(){\n}\n", "nl": "Create a new RepositoryConfigImpl."}
{"code": "@Override public String toString(){\n  return \"[SSL: \" + super.toString() + \"]\";\n}\n", "nl": "Provides a brief description of this SSL socket."}
{"code": "protected void sequence_FunctionBody_FunctionExpression_FunctionHeader_FunctionImpl_StrictFormalParameters_TypeVariables(ISerializationContext context,FunctionExpression semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: FunctionExpression returns FunctionExpression Constraint: ( generator?='*'?  (typeVars+=TypeVariable typeVars+=TypeVariable*)?  name=BindingIdentifier?  (fpars+=FormalParameter fpars+=FormalParameter*)?  returnTypeRef=TypeRef?  body=Block )"}
{"code": "public String clusterTypeTipText(){\n  return \"The type of cluster to use.\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "public DefaultReadTrimmer(int windowSize,int qualityThreshold){\n  mWindowSize=windowSize;\n  mQualityThreshold=qualityThreshold;\n}\n", "nl": "Construct a read trimmer"}
{"code": "public Task<FileShareRestRep> updateExport(URI id,String protocol,String securityType,String permissions,String rootUserMapping,FileExportUpdateParam update){\n  return putTask(update,getExportsUrl() + \"/{protocol},{securityType},{permissions},{rootUserMapping}\",id,protocol,securityType,permissions,rootUserMapping);\n}\n", "nl": "Updates an export from the given file system by ID. <p> API Call: <tt>PUT /file/filesystems/{id}/exports/{protocol},{securityType},{permissions},{rootUserMapping}</tt>"}
{"code": "@Override public void send(Object message,boolean sent) throws RemotingException {\n  if (closed) {\n    throw new RemotingException(this.getLocalAddress(),null,\"Failed to send message \" + message + \", cause: The channel \"+ this+ \" is closed!\");\n  }\n  if (message instanceof RpcInvocation) {\n    RpcInvocation inv=(RpcInvocation)message;\n    int id=SEQUENCE.incrementAndGet();\n    ChannelBuffer output=createRequestBuffer(id,inv);\n    channel.send(output,sent);\n  }\n}\n", "nl": "Description: <br>"}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(attrparentnodenull.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "protected SVGOMMPathElement(){\n}\n", "nl": "Creates a new SVGOMMPathElement object."}
{"code": "public final Vec3D reciprocal(){\n  x=1f / x;\n  y=1f / y;\n  z=1f / z;\n  return this;\n}\n", "nl": "Replaces the vector components with their multiplicative inverse."}
{"code": "public AbstractKeyRangeIndexProcedure(){\n}\n", "nl": "De-serialization ctor."}
{"code": "public TestRunner(){\n  this(System.out);\n}\n", "nl": "Constructs a TestRunner."}
{"code": "public String patch_addPadding(LinkedList<Patch> patches){\n  short paddingLength=this.Patch_Margin;\n  String nullPadding=\"\";\n  for (short x=1; x <= paddingLength; x++) {\n    nullPadding+=String.valueOf((char)x);\n  }\n  for (  Patch aPatch : patches) {\n    aPatch.start1+=paddingLength;\n    aPatch.start2+=paddingLength;\n  }\n  Patch patch=patches.getFirst();\n  LinkedList<Diff> diffs=patch.diffs;\n  if (diffs.isEmpty() || diffs.getFirst().operation != Operation.EQUAL) {\n    diffs.addFirst(new Diff(Operation.EQUAL,nullPadding));\n    patch.start1-=paddingLength;\n    patch.start2-=paddingLength;\n    patch.length1+=paddingLength;\n    patch.length2+=paddingLength;\n  }\n else   if (paddingLength > diffs.getFirst().text.length()) {\n    Diff firstDiff=diffs.getFirst();\n    int extraLength=paddingLength - firstDiff.text.length();\n    firstDiff.text=nullPadding.substring(firstDiff.text.length()) + firstDiff.text;\n    patch.start1-=extraLength;\n    patch.start2-=extraLength;\n    patch.length1+=extraLength;\n    patch.length2+=extraLength;\n  }\n  patch=patches.getLast();\n  diffs=patch.diffs;\n  if (diffs.isEmpty() || diffs.getLast().operation != Operation.EQUAL) {\n    diffs.addLast(new Diff(Operation.EQUAL,nullPadding));\n    patch.length1+=paddingLength;\n    patch.length2+=paddingLength;\n  }\n else   if (paddingLength > diffs.getLast().text.length()) {\n    Diff lastDiff=diffs.getLast();\n    int extraLength=paddingLength - lastDiff.text.length();\n    lastDiff.text+=nullPadding.substring(0,extraLength);\n    patch.length1+=extraLength;\n    patch.length2+=extraLength;\n  }\n  return nullPadding;\n}\n", "nl": "Add some padding on text start and end so that edges can match something. Intended to be called only from within patch_apply."}
{"code": "private void updateChannels(){\n  channel.setEnabled(!rejoinOpenChannels.isEnabled() || !rejoinOpenChannels.isSelected());\n}\n", "nl": "Enables or disables the channel inputbox depending on whether the rejoin open channels option is active and selected."}
{"code": "protected void startBridgeServer(int port) throws IOException {\n  startBridgeServer(port,-1);\n}\n", "nl": "Starts a bridge server on the given port, using the given deserializeValues and notifyBySubscription to serve up the given region."}
{"code": "public GeneralRuntimeException(String msg){\n  super(msg);\n}\n", "nl": "Constructs an <code>GeneralException</code> with the specified detail message."}
{"code": "public JobDefinitionEntity createJobDefinitionEntity(NamespaceEntity namespaceEntity,String jobName,String description,String activitiId){\n  JobDefinitionEntity jobDefinitionEntity=new JobDefinitionEntity();\n  jobDefinitionEntity.setNamespace(namespaceEntity);\n  jobDefinitionEntity.setName(jobName);\n  jobDefinitionEntity.setDescription(description);\n  jobDefinitionEntity.setActivitiId(activitiId);\n  return jobDefinitionDao.saveAndRefresh(jobDefinitionEntity);\n}\n", "nl": "Creates and persists a new job definition entity."}
{"code": "public QuadEdge insertSite(Vertex v){\n  QuadEdge e=locate(v);\n  if ((v.equals(e.orig(),tolerance)) || (v.equals(e.dest(),tolerance))) {\n    return e;\n  }\n  QuadEdge base=makeEdge(e.orig(),v);\n  QuadEdge.splice(base,e);\n  QuadEdge startEdge=base;\n  do {\n    base=connect(e,base.sym());\n    e=base.oPrev();\n  }\n while (e.lNext() != startEdge);\n  return startEdge;\n}\n", "nl": "Inserts a new site into the Subdivision, connecting it to the vertices of the containing triangle (or quadrilateral, if the split point falls on an existing edge). <p> This method does NOT maintain the Delaunay condition. If desired, this must be checked and enforced by the caller. <p> This method does NOT check if the inserted vertex falls on an edge. This must be checked by the caller, since this situation may cause erroneous triangulation"}
{"code": "public DHPrivateKeySpec(BigInteger x,BigInteger p,BigInteger g){\n  this.x=x;\n  this.p=p;\n  this.g=g;\n}\n", "nl": "Creates a new <code>DHPrivateKeySpec</code> with the specified <i>private value</i> <code>x</code>. <i>prime modulus</i> <code>p</code> and <i>base generator</i> <code>g</code>."}
{"code": "private boolean isMatEqual(Mat mat1,Mat mat2){\n  if (mat1.empty() && mat2.empty()) {\n    return true;\n  }\n  if (mat1.cols() != mat2.cols() || mat1.rows() != mat2.rows() || mat1.dims() != mat2.dims()) {\n    return false;\n  }\n  Mat diff=new Mat();\n  opencv_core.compare(mat1,mat2,diff,opencv_core.CMP_NE);\n  int nz=opencv_core.countNonZero(diff);\n  return nz == 0;\n}\n", "nl": "This method was found here http://stackoverflow.com/a/32235744/3708426 Converted from C++ to Java"}
{"code": "protected NewTargetImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public double strikeSensitivity(){\n  final double temp=stdDev * strike;\n  final double DalphaDstrike=-dAlpha_dD1 / temp;\n  final double DbetaDstrike=-dBeta_dD2 / temp;\n  final double temp2=DalphaDstrike * forward + DbetaDstrike * x + beta * dx_dStrike;\n  return discount * temp2;\n}\n", "nl": "Sensitivity to strike."}
{"code": "public boolean hasChildren(){\n  return children.size() > 0;\n}\n", "nl": "Checks if this node has children"}
{"code": "@Override public boolean ready() throws IOException {\n  ensureOpen();\n  return true;\n}\n", "nl": "Tells whether this stream is ready to be read."}
{"code": "public String generateKey(){\n  if (invocationKey == null) {\n    StringBuffer sb=new StringBuffer();\n    sb.append(table.getSchema());\n    sb.append(\".\").append(table.getName());\n    sb.append(\".\").append(key.getName());\n    for (    Object v : values) {\n      sb.append(\"-\").append(v.hashCode());\n    }\n    invocationKey=sb.toString();\n  }\n  return invocationKey;\n}\n", "nl": "Returns a reasonably efficient key for this select that incorporates both the fully qualified key name as well as select values. This key can be used for caching information about this particular index prefetch query."}
{"code": "private int readFrameType(final Object[] frame,final int index,int v,final char[] buf,final Label[] labels){\n  int type=b[v++] & 0xFF;\nswitch (type) {\ncase 0:\n    frame[index]=Opcodes.TOP;\n  break;\ncase 1:\nframe[index]=Opcodes.INTEGER;\nbreak;\ncase 2:\nframe[index]=Opcodes.FLOAT;\nbreak;\ncase 3:\nframe[index]=Opcodes.DOUBLE;\nbreak;\ncase 4:\nframe[index]=Opcodes.LONG;\nbreak;\ncase 5:\nframe[index]=Opcodes.NULL;\nbreak;\ncase 6:\nframe[index]=Opcodes.UNINITIALIZED_THIS;\nbreak;\ncase 7:\nframe[index]=readClass(v,buf);\nv+=2;\nbreak;\ndefault :\nframe[index]=readLabel(readUnsignedShort(v),labels);\nv+=2;\n}\nreturn v;\n}\n", "nl": "Reads a stack map frame type and stores it at the given index in the given array."}
{"code": "@action(name=\"query\",args={@arg(name=GamaMessageType.MESSAGE_STR,type=IType.MESSAGE,optional=false,doc=@doc(\"The message to be replied\")),@arg(name=GamaMessage.CONTENTS,type=IType.LIST,optional=false,doc=@doc(\"The content of the replying message\"))},doc=@doc(\"Replies a message with a 'query' performative message.\")) public Object primQuery(final IScope scope) throws GamaRuntimeException {\n  final IList originals=getMessageArg(scope);\n  if (originals == null || originals.size() == 0) {\n    throw GamaRuntimeException.error(\"No message to reply\",scope);\n  }\n  return replyMessage(scope,originals,QUERY,getContentArg(scope));\n}\n", "nl": "Prim query."}
{"code": "protected String generateLockServiceDestroyedMessage(){\n  return LocalizedStrings.DLockService_0_HAS_BEEN_DESTROYED.toLocalizedString(this);\n}\n", "nl": "Returns the string message to use in a LockServiceDestroyedException for this lock service."}
{"code": "protected void computeAverageLocalOfObservations(int[] sourceValues,int indexToModify){\n  if (indexToModify < sourceValues.length) {\n    for (int s=0; s < base; s++) {\n      sourceValues[indexToModify]=s;\n      computeAverageLocalOfObservations(sourceValues,indexToModify + 1);\n    }\n    return;\n  }\n  double logTerm, localValue, sepCont;\n  int jointSourcesVal, sourceVal;\n  jointSourcesVal=0;\n  for (int sIndex=0; sIndex < numSources; sIndex++) {\n    jointSourcesVal*=base;\n    jointSourcesVal+=sourceValues[sIndex];\n  }\n  double[] localActAndTes=new double[numSources + 1];\n  for (int pastVal=0; pastVal < base_power_k; pastVal++) {\n    for (int destVal=0; destVal < base; destVal++) {\n      if (sourcesNextPastCount[jointSourcesVal][destVal][pastVal] != 0) {\n        logTerm=((double)nextPastCount[destVal][pastVal]) / ((double)nextCount[destVal] * (double)pastCount[pastVal]);\n        logTerm*=(double)observations;\n        if (computeMultiInfoCoherence) {\n          localActAndTes[0]=Math.log(logTerm);\n        }\n        for (int sIndex=0; sIndex < numSources; sIndex++) {\n          sourceVal=sourceValues[sIndex];\n          localActAndTes[sIndex + 1]=((double)sourceNumValueNextPastCount[sIndex][sourceVal][destVal][pastVal] / (double)sourceNumValuePastCount[sIndex][sourceVal][pastVal]) / ((double)nextPastCount[destVal][pastVal] / (double)pastCount[pastVal]);\n          logTerm*=localActAndTes[sIndex + 1];\n          if (computeMultiInfoCoherence) {\n            localActAndTes[sIndex + 1]=Math.log(localActAndTes[sIndex + 1]);\n          }\n        }\n        if (computeMultiInfoCoherence) {\n          for (int i=0; i < sourcesNextPastCount[jointSourcesVal][destVal][pastVal]; i++) {\n            miCalc.addObservation(localActAndTes);\n          }\n        }\n        localValue=Math.log(logTerm) / log_2;\n        sepCont=(double)sourcesNextPastCount[jointSourcesVal][destVal][pastVal] / (double)observations * localValue;\n        average+=sepCont;\n        if (sepCont >= 0.0) {\n          avPositiveLocal+=sepCont;\n        }\n else {\n          avNegativeLocal+=sepCont;\n        }\n        if (localValue > max) {\n          max=localValue;\n        }\n else         if (localValue < min) {\n          min=localValue;\n        }\n        meanSqLocals+=sepCont * localValue;\n      }\n    }\n  }\n}\n", "nl": "Private utility function. <p>Updates the average, max, min and meanSq of locals for the separable information for the given source values in sourceValues up to the index indexToModify over all possible source values after the index indexToModify onwards. Uses recursion on increasing indexToModify. Designed to be called with indexToModify == 0 to compute average over all states."}
{"code": "private void drawItems(Canvas canvas){\n  canvas.save();\n  int top=(currentItem - firstItem) * getItemHeight() + (getItemHeight() - getHeight()) / 2;\n  canvas.translate(PADDING,-top + scrollingOffset);\n  itemsLayout.draw(canvas);\n  canvas.restore();\n}\n", "nl": "Draws items"}
{"code": "void importRecursivelyFrom(Object fileSystemObject,int policy) throws CoreException {\n  if (monitor.isCanceled()) {\n    throw new OperationCanceledException();\n  }\n  if (!provider.isFolder(fileSystemObject)) {\n    importFile(fileSystemObject,policy);\n    return;\n  }\n  int childPolicy=importFolder(fileSystemObject,policy);\n  if (childPolicy != POLICY_SKIP_CHILDREN) {\n    Iterator children=provider.getChildren(fileSystemObject).iterator();\n    while (children.hasNext()) {\n      importRecursivelyFrom(children.next(),childPolicy);\n    }\n  }\n}\n", "nl": "Imports the specified file system object recursively into the workspace. If the import fails, adds a status object to the list to be returned by <code>getStatus</code>."}
{"code": "public double[] homogeneVector(double[] v){\n  assert (v.length == dim);\n  double[] dv=Arrays.copyOf(v,dim + 1);\n  dv[dim]=1.0;\n  return dv;\n}\n", "nl": "Transform an absolute vector into homogeneous coordinates."}
{"code": "public boolean isSpread(){\n  return spread;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public LRS(int L,int R,RegressionDataSet rds,Regressor evaluater,int folds){\n  this(L,R,evaluater,folds);\n  search(rds,L,R,evaluater,folds);\n}\n", "nl": "Performs LRS feature selection for a regression problem"}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "private double calculateDistance(Example first,Example second){\n  double distance=0;\n  for (  Attribute attribute : first.getAttributes()) {\n    double diff=first.getValue(attribute) - second.getValue(attribute);\n    distance+=diff * diff;\n  }\n  return Math.sqrt(distance);\n}\n", "nl": "Calculates the euclidean distance between both examples."}
{"code": "protected boolean verifyAuthorizedInTenantOrg(URI tenantId){\n  StorageOSUser user=getUserFromContext();\n  if (tenantId.toString().equals(user.getTenantId()) || _permissionsHelper.userHasGivenRole(user,tenantId,Role.TENANT_ADMIN)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks if the user is authorized in the tenant org or not. Authorized if, The user is in the tenant org. The user who is not in the tenant org, but is a TenantAdmin of the tenant org."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public void release(int id){\n  if (id < 0) {\n    throw new IllegalArgumentException(LocalizedStrings.UniqueIdGenerator_NEGATIVE_ID_0.toLocalizedString(Integer.valueOf(id)));\n  }\n else   if (id > this.MAX_ID) {\n    throw new IllegalArgumentException(LocalizedStrings.UniqueIdGenerator_ID_MAX_ID_0.toLocalizedString(Integer.valueOf(id)));\n  }\nsynchronized (this) {\n    clearBit(id);\n  }\n}\n", "nl": "Release a previously obtained id allowing it to be obtained in the future."}
{"code": "String fullName(){\n  String parsable=name;\n  if (scope != null) {\n    parsable+=\".\" + scope.getName();\n  }\n  return parsable;\n}\n", "nl": "Returns a parsable name for identity: identityName.scopeName"}
{"code": "public static int flashTime(){\n  return info().flashTime;\n}\n", "nl": "Returns the time delay of drawing operation flashing."}
{"code": "private double calcArea(double width,double height){\n  return Math.max(minSideLength,width) * Math.max(minSideLength,height);\n}\n", "nl": "Calculates the area while applying the minimum side length."}
{"code": "public FuzzyQuery(Term term,int maxEdits,int prefixLength,int maxExpansions,boolean transpositions){\n  super(term.field());\n  if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n    throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n  }\n  if (prefixLength < 0) {\n    throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n  }\n  if (maxExpansions <= 0) {\n    throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n  }\n  this.term=term;\n  this.maxEdits=maxEdits;\n  this.prefixLength=prefixLength;\n  this.transpositions=transpositions;\n  this.maxExpansions=maxExpansions;\n  setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n}\n", "nl": "Create a new FuzzyQuery that will match terms with an edit distance  of at most <code>maxEdits</code> to <code>term</code>. If a <code>prefixLength</code> &gt; 0 is specified, a common prefix of that length is also required."}
{"code": "public void insertLeaf(int index,Object key,Object value){\n  int len=keys.length + 1;\n  Object[] newKeys=new Object[len];\n  DataUtils.copyWithGap(keys,newKeys,len - 1,index);\n  keys=newKeys;\n  Object[] newValues=new Object[len];\n  DataUtils.copyWithGap(values,newValues,len - 1,index);\n  values=newValues;\n  keys[index]=key;\n  values[index]=value;\n  totalCount++;\n  addMemory(map.getKeyType().getMemory(key) + map.getValueType().getMemory(value));\n}\n", "nl": "Insert a key-value pair into this leaf."}
{"code": "public UpgradeProjectVisualPanel2(Project context){\n  this.context=context;\n  initComponents();\n}\n", "nl": "Creates new form UpgradeProjectVisualPanel2"}
{"code": "public void init() throws MessagingException {\n  checkInitParameters(getAllowedInitParameters());\n  try {\n    initDebug();\n    if (isDebug()) {\n      log(\"Initializing\");\n    }\n    initHost();\n    initPort();\n    initMaxPings();\n    initPingIntervalMilli();\n    initStreamBufferSize();\n    if (getMaxPings() > 0) {\n      ping();\n    }\n  }\n catch (  Exception e) {\n    log(\"Exception thrown\",e);\n    throw new MessagingException(\"Exception thrown\",e);\n  }\n}\n", "nl": "Mailet initialization routine."}
{"code": "public JPAUserFlag(String name){\n  super();\n  this.name=name;\n}\n", "nl": "Constructs a User Flag."}
{"code": "public Collection<?> toCollection(String column) throws SQLException {\n  return super.toCollection(column);\n}\n", "nl": "To Collection"}
{"code": "public boolean isOverlap(Object objA,Object objB){\n  SpatialKey a=(SpatialKey)objA;\n  SpatialKey b=(SpatialKey)objB;\n  if (a.isNull() || b.isNull()) {\n    return false;\n  }\n  for (int i=0; i < dimensions; i++) {\n    if (a.max(i) < b.min(i) || a.min(i) > b.max(i)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Check whether the two objects overlap."}
{"code": "public static Object readObjectFromFile(String name) throws ClassNotFoundException, IOException {\n  byte[] data=readDataFromFile(name);\n  return deserialize(data);\n}\n", "nl": "Read serialized object from a file"}
{"code": "public void scanReset(){\n  currentFeatureIdx=0;\n}\n", "nl": "Scan reset."}
{"code": "public String next(int n) throws JSONException {\n  if (n == 0) {\n    return \"\";\n  }\n  char[] chars=new char[n];\n  int pos=0;\n  while (pos < n) {\n    chars[pos]=this.next();\n    if (this.end()) {\n      throw this.syntaxError(\"Substring bounds error\");\n    }\n    pos+=1;\n  }\n  return new String(chars);\n}\n", "nl": "Get the next n characters."}
{"code": "public boolean isEndPointDead(){\n  return this.endPointDied;\n}\n", "nl": "Returns true if the end point represented by this updater is considered dead."}
{"code": "private boolean canUseLookup(Raster src,Raster dst){\n  int datatype=src.getDataBuffer().getDataType();\n  if (datatype != DataBuffer.TYPE_BYTE && datatype != DataBuffer.TYPE_USHORT) {\n    return false;\n  }\n  SampleModel dstSM=dst.getSampleModel();\n  dstNbits=dstSM.getSampleSize(0);\n  if (!(dstNbits == 8 || dstNbits == 16)) {\n    return false;\n  }\n  for (int i=1; i < src.getNumBands(); i++) {\n    int bandSize=dstSM.getSampleSize(i);\n    if (bandSize != dstNbits) {\n      return false;\n    }\n  }\n  SampleModel srcSM=src.getSampleModel();\n  srcNbits=srcSM.getSampleSize(0);\n  if (srcNbits > 16) {\n    return false;\n  }\n  for (int i=1; i < src.getNumBands(); i++) {\n    int bandSize=srcSM.getSampleSize(i);\n    if (bandSize != srcNbits) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determines if the rescale can be performed as a lookup. The dst must be a byte or short type. The src must be less than 16 bits. All source band sizes must be the same and all dst band sizes must be the same."}
{"code": "@SuppressWarnings(\"unchecked\") TypeDeclaration loadObject(String name,Map<String,Object> m,Scope parent,List<TypeParameter> existing){\n  Value obj;\n  if (m.get(KEY_METATYPE) instanceof Value) {\n    obj=(Value)m.get(KEY_METATYPE);\n  }\n else {\n    obj=new Value();\n    m.put(KEY_METATYPE,obj);\n    obj.setName(name);\n    obj.setContainer(parent);\n    obj.setScope(parent);\n    obj.setUnit(u2);\n    com.redhat.ceylon.model.typechecker.model.Class type=new com.redhat.ceylon.model.typechecker.model.Class();\n    type.setName(name);\n    type.setAnonymous(true);\n    type.setUnit(u2);\n    type.setContainer(parent);\n    type.setScope(parent);\n    if (parent == this) {\n      u2.addDeclaration(obj);\n      u2.addDeclaration(type);\n    }\n    parent.addMember(obj);\n    obj.setType(type.getType());\n    setAnnotations(obj,(Integer)m.get(KEY_PACKED_ANNS),(Map<String,Object>)m.get(KEY_ANNOTATIONS));\n    setAnnotations(obj.getTypeDeclaration(),(Integer)m.remove(KEY_PACKED_ANNS),(Map<String,Object>)m.remove(KEY_ANNOTATIONS));\n    if (type.getExtendedType() == null) {\n      if (m.containsKey(\"super\")) {\n        type.setExtendedType(getTypeFromJson((Map<String,Object>)m.remove(\"super\"),parent instanceof Declaration ? (Declaration)parent : null,existing));\n      }\n else {\n        type.setExtendedType(getTypeFromJson(idobj,parent instanceof Declaration ? (Declaration)parent : null,existing));\n      }\n    }\n    if (m.containsKey(KEY_SATISFIES)) {\n      List<Map<String,Object>> stypes=(List<Map<String,Object>>)m.remove(KEY_SATISFIES);\n      type.setSatisfiedTypes(parseTypeList(stypes,existing));\n    }\n    if (m.containsKey(KEY_INTERFACES)) {\n      for (      Map.Entry<String,Map<String,Object>> inner : ((Map<String,Map<String,Object>>)m.remove(KEY_INTERFACES)).entrySet()) {\n        loadInterface(inner.getKey(),inner.getValue(),type,existing);\n      }\n    }\n    if (m.containsKey(KEY_CLASSES)) {\n      for (      Map.Entry<String,Map<String,Object>> inner : ((Map<String,Map<String,Object>>)m.remove(KEY_CLASSES)).entrySet()) {\n        loadClass(inner.getKey(),inner.getValue(),type,existing);\n      }\n    }\n    if (m.containsKey(KEY_OBJECTS)) {\n      for (      Map.Entry<String,Map<String,Object>> inner : ((Map<String,Map<String,Object>>)m.remove(KEY_OBJECTS)).entrySet()) {\n        loadObject(inner.getKey(),inner.getValue(),type,existing);\n      }\n    }\n    addAttributesAndMethods(m,type,existing);\n  }\n  return obj.getTypeDeclaration();\n}\n", "nl": "Loads an object declaration, creating it if necessary, and returns its type declaration."}
{"code": "@Override public boolean isCellEditable(EventObject anEvent){\n  if (anEvent instanceof MouseEvent) {\n    return ((MouseEvent)anEvent).getClickCount() >= clickCountToEdit;\n  }\n  return true;\n}\n", "nl": "isCellEditable, Returns true if anEvent is not a MouseEvent. Otherwise, it returns true if the necessary number of clicks have occurred, and returns false otherwise."}
{"code": "public static void debugLineContents(Element line){\n  Document doc=line.getDocument();\n  System.out.print(\"[\");\n  for (int i=0; i < line.getElementCount(); i++) {\n    Element l=line.getElement(i);\n    try {\n      System.out.print(\"'\" + doc.getText(l.getStartOffset(),l.getEndOffset() - l.getStartOffset()) + \"'\");\n    }\n catch (    BadLocationException ex) {\n      System.out.println(\"Bad location\");\n    }\n  }\n  System.out.println(\"]\");\n}\n", "nl": "Output the text of the subelements of the given element."}
{"code": "public void changePriority(T item,double priority){\n}\n", "nl": "Change the node in this heap with the given item to have the given priority. For this method only, you can assume the heap will not have two nodes with the same item. Check for item equality with .equals(), not =="}
{"code": "public PacketExtension parseExtension(XmlPullParser parser) throws Exception {\n  OfflineMessageInfo info=new OfflineMessageInfo();\n  boolean done=false;\n  while (!done) {\n    int eventType=parser.next();\n    if (eventType == XmlPullParser.START_TAG) {\n      if (parser.getName().equals(\"item\"))       info.setNode(parser.getAttributeValue(\"\",\"node\"));\n    }\n else     if (eventType == XmlPullParser.END_TAG) {\n      if (parser.getName().equals(\"offline\")) {\n        done=true;\n      }\n    }\n  }\n  return info;\n}\n", "nl": "Parses a OfflineMessageInfo packet (extension sub-packet)."}
{"code": "protected CharacterClassEscapeSequenceImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  int idx=getInt(stack);\n  MediaNode node=getMediaNode(stack);\n  if (node != null) {\n    DataObjectFilter[] filts=node.getFilters();\n    if (filts != null && idx >= 0 && idx < filts.length)     return filts[idx].getTechnique();\n  }\n  return null;\n}\n", "nl": "Returns the name of the current filtering technique used by the specified MediaNode hierarchy. Since multiple filters can be set; an index must be specified to determine which one to get the technique of"}
{"code": "private ArrayList<ArrayDBIDs> buildOneDimIndexes(Relation<? extends NumberVector> relation,DBIDs ids,DimensionSimilarityMatrix matrix){\n  final int dim=matrix.size();\n  ArrayList<ArrayDBIDs> subspaceIndex=new ArrayList<>(dim);\n  SortDBIDsBySingleDimension comp=new VectorUtil.SortDBIDsBySingleDimension(relation);\n  for (int i=0; i < dim; i++) {\n    ArrayModifiableDBIDs amDBIDs=DBIDUtil.newArray(ids);\n    comp.setDimension(matrix.dim(i));\n    amDBIDs.sort(comp);\n    subspaceIndex.add(amDBIDs);\n  }\n  return subspaceIndex;\n}\n", "nl": "Calculates \"index structures\" for every attribute, i.e. sorts a ModifiableArray of every DBID in the database for every dimension and stores them in a list"}
{"code": "public Vertex parseFunction(TextStream stream,Map<String,Map<String,Vertex>> elements,boolean debug,Network network){\n  stream.nextWord();\n  Vertex function=parseElementName(Primitive.FUNCTION,stream,elements,debug,network);\n  stream.skipWhitespace();\n  ensureNext('{',stream);\n  function.addRelationship(Primitive.OPERATOR,new Primitive(function.getName()));\n  stream.skipWhitespace();\n  char peek=stream.peek();\n  int index=0;\n  while (peek != '}') {\n    stream.skipWhitespace();\n    Vertex element=parseElement(stream,elements,debug,network);\n    function.addRelationship(Primitive.DO,element,index);\n    String previous=stream.peekPreviousWord();\n    stream.skipWhitespace();\n    if (!\"}\".equals(previous)) {\n      ensureNext(';',',',stream);\n    }\n    stream.skipWhitespace();\n    peek=stream.peek();\n    index++;\n  }\n  ensureNext('}',stream);\n  return function;\n}\n", "nl": "Parse the function."}
{"code": "private LayerDefinition readLayer(final Node t) throws Exception {\n  final int layerWidth=getAttribute(t,\"width\",stendhalMap.getWidth());\n  final int layerHeight=getAttribute(t,\"height\",stendhalMap.getHeight());\n  final LayerDefinition layer=new LayerDefinition(layerWidth,layerHeight);\n  final int offsetX=getAttribute(t,\"x\",0);\n  final int offsetY=getAttribute(t,\"y\",0);\n  if ((offsetX != 0) || (offsetY != 0)) {\n    System.err.println(\"Severe error: maps has offset displacement\");\n  }\n  layer.setName(getAttributeValue(t,\"name\"));\n  for (Node child=t.getFirstChild(); child != null; child=child.getNextSibling()) {\n    if (\"data\".equalsIgnoreCase(child.getNodeName())) {\n      final String encoding=getAttributeValue(child,\"encoding\");\n      if ((encoding != null) && \"base64\".equalsIgnoreCase(encoding)) {\n        final Node cdata=child.getFirstChild();\n        if (cdata != null) {\n          final char[] enc=cdata.getNodeValue().trim().toCharArray();\n          final byte[] dec=Base64.decode(enc);\n          final ByteArrayInputStream bais=new ByteArrayInputStream(dec);\n          InputStream is;\n          final String comp=getAttributeValue(child,\"compression\");\n          if (\"gzip\".equalsIgnoreCase(comp)) {\n            is=new GZIPInputStream(bais);\n          }\n else           if (\"zlib\".equalsIgnoreCase(comp)) {\n            is=new InflaterInputStream(bais);\n          }\n else {\n            is=bais;\n          }\n          final byte[] raw=layer.exposeRaw();\n          int offset=0;\n          while (offset != raw.length) {\n            offset+=is.read(raw,offset,raw.length - offset);\n          }\n          bais.close();\n        }\n      }\n    }\n  }\n  return layer;\n}\n", "nl": "Loads a map layer from a layer node."}
{"code": "public AsyncResult QueryFirstAsync(RequestHeader RequestHeader,ViewDescription View,NodeTypeDescription[] NodeTypes,ContentFilter Filter,UnsignedInteger MaxDataSetsToReturn,UnsignedInteger MaxReferencesToReturn){\n  QueryFirstRequest req=new QueryFirstRequest(RequestHeader,View,NodeTypes,Filter,MaxDataSetsToReturn,MaxReferencesToReturn);\n  return channel.serviceRequestAsync(req);\n}\n", "nl": "Asynchronous QueryFirst service request."}
{"code": "public boolean contains(PrintStream p){\n  return m_Streams.contains(p);\n}\n", "nl": "checks whether the given PrintStream is already in the list."}
{"code": "private void resetLoggedInOutIndicators(){\n  getLoggedInIndicaterRegexField().setToolTipText(null);\n  getLoggedInIndicaterRegexField().setEnabled(true);\n  getLoggedOutIndicaterRegexField().setToolTipText(null);\n  getLoggedOutIndicaterRegexField().setEnabled(true);\n}\n", "nl": "Resets the tool tip and enables the fields of the logged in/out indicators."}
{"code": "public Topology buildAppTopology(){\n  Topology t=tp.newTopology(\"mqttClientPublisher\");\n  TStream<String> msgs=t.poll(new MsgSupplier(options.get(OPT_PUB_CNT)),1L,TimeUnit.SECONDS);\n  MqttConfig config=Runner.newConfig(options);\n  MqttStreams mqtt=new MqttStreams(t,null);\n  mqtt.publish(msgs,options.get(OPT_TOPIC),options.get(OPT_QOS),options.get(OPT_RETAIN));\n  return t;\n}\n", "nl": "Create a topology for the publisher application."}
{"code": "private String identifier() throws IOException {\n  _asExpected=true;\n  if (!isIdentifierStartChar()) {\n    _asExpected=false;\n    return null;\n  }\n  StringBuffer identifierValue=new StringBuffer();\n  while (!isAllRead() && isIdentifierChar()) {\n    saveCurrent();\n    identifierValue.append(_working[_pos]);\n    go();\n  }\n  while (identifierValue.length() > 0 && Utils.isIdentifierHelperChar(identifierValue.charAt(identifierValue.length() - 1))) {\n    identifierValue.deleteCharAt(identifierValue.length() - 1);\n  }\n  if (identifierValue.length() == 0) {\n    return null;\n  }\n  String id=identifierValue.toString();\n  int columnIndex=id.indexOf(':');\n  if (columnIndex >= 0) {\n    String prefix=id.substring(0,columnIndex);\n    String suffix=id.substring(columnIndex + 1);\n    int nextColumnIndex=suffix.indexOf(':');\n    if (nextColumnIndex >= 0) {\n      suffix=suffix.substring(0,nextColumnIndex);\n    }\n    if (props.isNamespacesAware()) {\n      id=prefix + \":\" + suffix;\n      if (!\"xmlns\".equalsIgnoreCase(prefix)) {\n        _namespacePrefixes.add(prefix.toLowerCase());\n      }\n    }\n else {\n      id=suffix;\n    }\n  }\n  return id;\n}\n", "nl": "Parses an identifier from the current position."}
{"code": "protected void handleException(JMSException je){\n  if (endTime == 0) {\n    endTime=System.currentTimeMillis();\n  }\n  Exception le=je.getLinkedException();\n  Throwable t=je.getCause();\n  if (null == t && null != le && t != le) {\n    je.initCause(le);\n  }\n  handleException((Exception)je);\n}\n", "nl": "Overloaded method to cross-link JDK 1.4 initCause and JMS 1.1 linkedException if it has not already been done by the JMS vendor implementation."}
{"code": "public boolean isCloseOnCompletion(){\n  checkClosed();\n  return true;\n}\n", "nl": "[Not supported]Java 1.7"}
{"code": "public InvalidParameterSpecException(){\n  super();\n}\n", "nl": "Constructs an InvalidParameterSpecException with no detail message. A detail message is a String that describes this particular exception."}
{"code": "ScheduledFutureTask(Runnable r,V result,long ns){\n  super(r,result);\n  this.time=ns;\n  this.period=0;\n  this.sequenceNumber=sequencer.getAndIncrement();\n}\n", "nl": "Creates a one-shot action with given nanoTime-based trigger time."}
{"code": "public static CreateInstance parse(javax.xml.stream.XMLStreamReader reader) throws java.lang.Exception {\n  CreateInstance object=new CreateInstance();\n  int event;\n  java.lang.String nillableValue=null;\n  java.lang.String prefix=\"\";\n  java.lang.String namespaceuri=\"\";\n  try {\n    while (!reader.isStartElement() && !reader.isEndElement())     reader.next();\n    if (reader.getAttributeValue(\"http://www.w3.org/2001/XMLSchema-instance\",\"type\") != null) {\n      java.lang.String fullTypeName=reader.getAttributeValue(\"http://www.w3.org/2001/XMLSchema-instance\",\"type\");\n      if (fullTypeName != null) {\n        java.lang.String nsPrefix=null;\n        if (fullTypeName.indexOf(\":\") > -1) {\n          nsPrefix=fullTypeName.substring(0,fullTypeName.indexOf(\":\"));\n        }\n        nsPrefix=nsPrefix == null ? \"\" : nsPrefix;\n        java.lang.String type=fullTypeName.substring(fullTypeName.indexOf(\":\") + 1);\n        if (!\"createInstance\".equals(type)) {\n          java.lang.String nsUri=reader.getNamespaceContext().getNamespaceURI(nsPrefix);\n          return (CreateInstance)org.oscm.xsd.ExtensionMapper.getTypeObject(nsUri,type,reader);\n        }\n      }\n    }\n    java.util.Vector handledAttributes=new java.util.Vector();\n    reader.next();\n    while (!reader.isStartElement() && !reader.isEndElement())     reader.next();\n    if (reader.isStartElement() && new javax.xml.namespace.QName(\"\",\"request\").equals(reader.getName())) {\n      object.setRequest(org.oscm.xsd.InstanceRequest.Factory.parse(reader));\n      reader.next();\n    }\n else {\n    }\n    while (!reader.isStartElement() && !reader.isEndElement())     reader.next();\n    if (reader.isStartElement() && new javax.xml.namespace.QName(\"\",\"requestingUser\").equals(reader.getName())) {\n      object.setRequestingUser(org.oscm.xsd.User.Factory.parse(reader));\n      reader.next();\n    }\n else {\n    }\n    while (!reader.isStartElement() && !reader.isEndElement())     reader.next();\n    if (reader.isStartElement())     throw new org.apache.axis2.databinding.ADBException(\"Unexpected subelement \" + reader.getLocalName());\n  }\n catch (  javax.xml.stream.XMLStreamException e) {\n    throw new java.lang.Exception(e);\n  }\n  return object;\n}\n", "nl": "static method to create the object Precondition: If this object is an element, the current or next start element starts this object and any intervening reader events are ignorable If this object is not an element, it is a complex type and the reader is at the event just after the outer start element Postcondition: If this object is an element, the reader is positioned at its end element If this object is a complex type, the reader is positioned at the end element of its outer element"}
{"code": "public void testSimpleFunction() throws Exception {\n  check(\"test()\",\"{fn test()}\");\n  check(\"select test()\",\"select {fn test()}\");\n  check(\"select test() from table;\",\"select {fn test()} from table;\");\n  check(\"func(field1) func(field2)\",\"{fn func(field1)} {fn func(field2)}\");\n  check(\"select func(field1), func(field2)\",\"select {fn func(field1)}, {fn func(field2)}\");\n  check(\"select func(field1), func(field2) from table;\",\"select {fn func(field1)}, {fn func(field2)} from table;\");\n}\n", "nl": "Test escape sequence series."}
{"code": "@NamespacePermission(fields=\"#request.namespace\",permissions=NamespacePermissionEnum.WRITE) @Override public BusinessObjectFormat createBusinessObjectFormat(BusinessObjectFormatCreateRequest request){\n  validateBusinessObjectFormatCreateRequest(request);\n  BusinessObjectFormatKey businessObjectFormatKey=getBusinessObjectFormatKey(request);\n  BusinessObjectDefinitionEntity businessObjectDefinitionEntity=businessObjectDefinitionDaoHelper.getBusinessObjectDefinitionEntity(new BusinessObjectDefinitionKey(businessObjectFormatKey.getNamespace(),businessObjectFormatKey.getBusinessObjectDefinitionName()));\n  FileTypeEntity fileTypeEntity=fileTypeDaoHelper.getFileTypeEntity(request.getBusinessObjectFormatFileType());\n  BusinessObjectFormatEntity latestVersionBusinessObjectFormatEntity=businessObjectFormatDao.getBusinessObjectFormatByAltKey(businessObjectFormatKey);\n  if (latestVersionBusinessObjectFormatEntity != null) {\n    BusinessObjectFormat latestVersionBusinessObjectFormat=businessObjectFormatHelper.createBusinessObjectFormatFromEntity(latestVersionBusinessObjectFormatEntity);\n    if (latestVersionBusinessObjectFormat.getSchema() != null) {\n      validateNewSchemaIsAdditiveToOldSchema(request.getSchema(),latestVersionBusinessObjectFormat.getSchema());\n    }\n    latestVersionBusinessObjectFormatEntity.setLatestVersion(false);\n    businessObjectFormatDao.saveAndRefresh(latestVersionBusinessObjectFormatEntity);\n  }\n  Integer businessObjectFormatVersion=latestVersionBusinessObjectFormatEntity == null ? 0 : latestVersionBusinessObjectFormatEntity.getBusinessObjectFormatVersion() + 1;\n  BusinessObjectFormatEntity newBusinessObjectFormatEntity=createBusinessObjectFormatEntity(request,businessObjectDefinitionEntity,fileTypeEntity,businessObjectFormatVersion);\n  return businessObjectFormatHelper.createBusinessObjectFormatFromEntity(newBusinessObjectFormatEntity);\n}\n", "nl": "Creates a new business object format."}
{"code": "public KafkaConfigState(ZookeeperConfiguration zkConfig){\n  this.configStore=new CuratorConfigStore<>(zkConfig.getFrameworkName(),zkConfig.getMesosZkUri());\n}\n", "nl": "Creates a new Kafka config state manager based on the provided bootstrap information."}
{"code": "public static ComponentUI createUI(JComponent c){\n  return new BEToolBarSeparatorUI();\n}\n", "nl": "Creates the ui."}
{"code": "public static void generateSample(MatrixBlock out,long range,int size,boolean replace,long seed) throws DMLRuntimeException {\n  out.reset(size,1,false);\n  out.allocateDenseBlock();\n  seed=(seed == -1 ? System.nanoTime() : seed);\n  if (!replace) {\n    for (int i=1; i <= size; i++)     out.setValueDenseUnsafe(i - 1,0,i);\n    Random rand=new Random(seed);\n    for (int i=size + 1; i <= range; i++) {\n      if (rand.nextInt(i) < size)       out.setValueDenseUnsafe(rand.nextInt(size),0,i);\n    }\n    double tmp;\n    int idx;\n    for (int i=size - 1; i >= 1; i--) {\n      idx=rand.nextInt(i);\n      tmp=out.getValueDenseUnsafe(idx,0);\n      out.setValueDenseUnsafe(idx,0,out.getValueDenseUnsafe(i,0));\n      out.setValueDenseUnsafe(i,0,tmp);\n    }\n  }\n else {\n    Random r=new Random(seed);\n    for (int i=0; i < size; i++)     out.setValueDenseUnsafe(i,0,1 + nextLong(r,range));\n  }\n  out.recomputeNonZeros();\n  out.examSparsity();\n}\n", "nl": "Generates a sample of size <code>size</code> from a range of values [1,range]. <code>replace</code> defines if sampling is done with or without replacement."}
{"code": "protected double defaultDistMult(){\n  return 4.0;\n}\n", "nl": "returns the default distance multiplier"}
{"code": "public void registerActivityType(String type,Class<? extends Activity> activityClass){\n  registerActivityType(type,activityClass,new DefaultActivityFactory(activityClass));\n}\n", "nl": "<p> Register an activity type with the specified non-default type name. </p>"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String role=getString(stack);\n  Show s=getShow(stack);\n  return (s == null) ? Pooler.EMPTY_PERSON_ARRAY : s.getPeopleObjList(Show.getRoleForString(role));\n}\n", "nl": "Gets the people in the specified Show in the specified Role. Returned as a Person array."}
{"code": "public ParseException(){\n  super();\n}\n", "nl": "Constructs a new exception with no detail message."}
{"code": "public String splitEvaluatorTipText(){\n  return \"The evaluator to apply to the cross validation folds. \" + \"This may be a classifier, regression scheme etc.\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "public void testCanEscapeWindowsSlashes(){\n  assertEquals(\"c:\\\\\\\\test\",PropertyUtils.escapeBackSlashesIfNotNull(\"c:\\\\test\"));\n}\n", "nl": "Test whether Windows backslash escaping works properly."}
{"code": "public void refresh(){\n  if (myColorsAware != null) {\n    myNormalAttributesCache.clear();\n    mySelectedAttributesCache.clear();\n  }\n}\n", "nl": "Asks the implementation to ensure that it uses the most up-to-date colors. <p/> I.e. this method is assumed to be called when color settings has been changed and gives a chance to reflect the changes accordingly."}
{"code": "protected void sendResponse(final PrintWriter writer,final String header,final String message,final String data){\n  try {\n    JSONObject json=new JSONObject();\n    json.put(\"header\",header);\n    json.put(\"message\",message);\n    if (StringUtils.isNotBlank(data)) {\n      json.put(\"data\",data);\n    }\n    writer.write(json.toString());\n  }\n catch (  JSONException e) {\n    LOGGER.error(\"Could not write JSON\",e);\n    if (StringUtils.isNotBlank(data)) {\n      writer.write(String.format(\"{\\\"header\\\" : \\\"%s\\\", \\\"message\\\" : \\\"%s\\\", \\\"data\\\" :  \\\"%s\\\"}\",header,message,data));\n    }\n else {\n      writer.write(String.format(\"{\\\"header\\\" : \\\"%s\\\", \\\"message\\\" : \\\"%s\\\"}\",header,message));\n    }\n  }\n}\n", "nl": "Send the JSON response."}
{"code": "public ObjectName metricName(String contextName) throws MalformedObjectNameException {\n  return new ObjectName(\"debezium.mysql:type=connector-metrics,context=\" + contextName + \",server=\"+ serverName());\n}\n", "nl": "Create a JMX metric name for the given metric."}
{"code": "public void stopObligation(int id){\n  if (proverProcess != null && !proverProcess.isTerminated()) {\n    try {\n      proverProcess.getStreamsProxy().write(\"stop \" + id + \"\\n\");\n    }\n catch (    IOException e) {\n      ProverUIActivator.getDefault().logError(\"Error sending signal to tlapm to stop obligation \" + id,e);\n    }\n  }\n}\n", "nl": "Sends a signal to the tlapm indicating that the obligation with the given id should be stopped."}
{"code": "public ConnectException(){\n}\n", "nl": "Construct a new ConnectException with no detailed message."}
{"code": "private void computeTabTiltHelper(long time,RectF stackRect){\n  final boolean portrait=mCurrentMode == Orientation.PORTRAIT;\n  final float parentWidth=stackRect.width();\n  final float parentHeight=stackRect.height();\n  final float overscrollPercent=computeOverscrollPercent();\n  if (mOverviewAnimationType == OverviewAnimationType.START_PINCH || mOverviewAnimationType == OverviewAnimationType.DISCARD || mOverviewAnimationType == OverviewAnimationType.FULL_ROLL || mOverviewAnimationType == OverviewAnimationType.TAB_FOCUSED || mOverviewAnimationType == OverviewAnimationType.UNDISCARD || mOverviewAnimationType == OverviewAnimationType.DISCARD_ALL) {\n  }\n else   if (mPinch0TabIndex >= 0 || overscrollPercent == 0.0f || mOverviewAnimationType == OverviewAnimationType.REACH_TOP) {\n    for (int i=0; i < mStackTabs.length; ++i) {\n      StackTab stackTab=mStackTabs[i];\n      LayoutTab layoutTab=stackTab.getLayoutTab();\n      layoutTab.setTiltX(0,0);\n      layoutTab.setTiltY(0,0);\n    }\n  }\n else   if (overscrollPercent < 0) {\n    if (mOverScrollCounter >= OVERSCROLL_FULL_ROLL_TRIGGER) {\n      startAnimation(time,OverviewAnimationType.FULL_ROLL);\n      mOverScrollCounter=0;\n      setScrollTarget(MathUtils.clamp(mScrollOffset,getMinScroll(false),getMaxScroll(false)),false);\n    }\n else {\n      float tilt=0;\n      if (overscrollPercent < -OVERSCROLL_TOP_SLIDE_PCTG) {\n        float scaledOverscroll=(overscrollPercent + OVERSCROLL_TOP_SLIDE_PCTG) / (1 - OVERSCROLL_TOP_SLIDE_PCTG);\n        tilt=mUnderScrollAngleInterpolator.getInterpolation(-scaledOverscroll) * -mMaxOverScrollAngle * BACKWARDS_TILT_SCALE;\n      }\n      float pivotOffset=0;\n      LayoutTab topTab=mStackTabs[mStackTabs.length - 1].getLayoutTab();\n      pivotOffset=portrait ? topTab.getScaledContentHeight() / 2 + topTab.getY() : topTab.getScaledContentWidth() / 2 + topTab.getX();\n      for (int i=0; i < mStackTabs.length; ++i) {\n        StackTab stackTab=mStackTabs[i];\n        LayoutTab layoutTab=stackTab.getLayoutTab();\n        if (portrait) {\n          layoutTab.setTiltX(tilt,pivotOffset - layoutTab.getY());\n        }\n else {\n          layoutTab.setTiltY(LocalizationUtils.isLayoutRtl() ? -tilt : tilt,pivotOffset - layoutTab.getX());\n        }\n      }\n    }\n  }\n else {\n    float tilt=mOverScrollAngleInterpolator.getInterpolation(overscrollPercent) * mMaxOverScrollAngle;\n    float offset=mOverscrollSlideInterpolator.getInterpolation(overscrollPercent) * mMaxOverScrollSlide;\n    for (int i=0; i < mStackTabs.length; ++i) {\n      StackTab stackTab=mStackTabs[i];\n      LayoutTab layoutTab=stackTab.getLayoutTab();\n      if (portrait) {\n        float adjust=MathUtils.clamp((layoutTab.getY() / parentHeight) + 0.50f,0,1);\n        layoutTab.setTiltX(tilt * adjust,layoutTab.getScaledContentHeight() / 3);\n        layoutTab.setY(layoutTab.getY() + offset);\n      }\n else       if (LocalizationUtils.isLayoutRtl()) {\n        float adjust=MathUtils.clamp(-(layoutTab.getX() / parentWidth) + 0.50f,0,1);\n        layoutTab.setTiltY(-tilt * adjust,layoutTab.getScaledContentWidth() * 2 / 3);\n        layoutTab.setX(layoutTab.getX() - offset);\n      }\n else {\n        float adjust=MathUtils.clamp((layoutTab.getX() / parentWidth) + 0.50f,0,1);\n        layoutTab.setTiltY(tilt * adjust,layoutTab.getScaledContentWidth() / 3);\n        layoutTab.setX(layoutTab.getX() + offset);\n      }\n    }\n  }\n}\n", "nl": "ComputeTabPosition pass 4: Update the tilt of each tab."}
{"code": "public ActionForward executeAction(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response){\n  HttpSession session=request.getSession();\n  String idEntidad=(String)session.getAttribute(Misc.ENTIDAD_ID);\n  ListaExpedientesForm listaExpedienteForm=(ListaExpedientesForm)form;\n  try {\n    String cnif=request.getParameter(Misc.CNIF);\n    String numExpediente=request.getParameter(Misc.EXPEDIENTE);\n    String procedimiento=request.getParameter(Misc.PROCEDIMIENTO);\n    String numeroRegistroInicial=request.getParameter(Misc.NUMERO_REGISTRO_INICIAL);\n    String fechaRegistroInicialDesdeRequest=request.getParameter(Misc.FECHA_REGISTRO_INICIAL_DESDE);\n    String operadorFechaInicial=request.getParameter(Misc.OPERADOR_CONSULTA_FECHA_INICIAL);\n    String fechaRegistroInicialHastaRequest=request.getParameter(Misc.FECHA_REGISTRO_INICIAL_HASTA);\n    String fechaDesdeRequest=request.getParameter(Misc.FECHA_DESDE);\n    String operador=request.getParameter(Misc.OPERADOR_CONSULTA);\n    String fechaHastaRequest=request.getParameter(Misc.FECHA_HASTA);\n    String estado=request.getParameter(Misc.ESTADO);\n    String fechaParseadaDesde=null;\n    String fechaParseadaHasta=null;\n    String fechaRegistroInicialParseadaDesde=null;\n    String fechaRegistroInicialParseadaHasta=null;\n    try {\n      fechaParseadaDesde=parsearFecha(fechaDesdeRequest);\n      fechaParseadaHasta=parsearFecha(fechaHastaRequest);\n      fechaRegistroInicialParseadaDesde=parsearFecha(fechaRegistroInicialDesdeRequest);\n      fechaRegistroInicialParseadaHasta=parsearFecha(fechaRegistroInicialHastaRequest);\n    }\n catch (    Exception e) {\n      ActionMessages errors=new ActionMessages();\n      errors.add(\"error\",new ActionMessage(\"formatoFechaIncorrecto\"));\n      return mapping.findForward(\"Busqueda\");\n    }\n    session.setAttribute(Misc.CNIF,cnif);\n    session.setAttribute(Misc.EXPEDIENTE,numExpediente);\n    session.setAttribute(Misc.PROCEDIMIENTO,procedimiento);\n    session.setAttribute(Misc.NUMERO_REGISTRO_INICIAL,numeroRegistroInicial);\n    session.setAttribute(Misc.FECHA_REGISTRO_INICIAL_DESDE,fechaRegistroInicialParseadaDesde);\n    session.setAttribute(Misc.FECHA_REGISTRO_INICIAL_DESDE_BUSQUEDA,fechaRegistroInicialDesdeRequest);\n    session.setAttribute(Misc.OPERADOR_CONSULTA_FECHA_INICIAL,operadorFechaInicial);\n    session.setAttribute(Misc.FECHA_REGISTRO_INICIAL_HASTA,fechaRegistroInicialParseadaHasta);\n    session.setAttribute(Misc.FECHA_REGISTRO_INICIAL_HASTA_BUSQUEDA,fechaRegistroInicialHastaRequest);\n    session.setAttribute(Misc.FECHA_DESDE,fechaParseadaDesde);\n    session.setAttribute(Misc.FECHA_DESDE_BUSQUEDA,fechaDesdeRequest);\n    session.setAttribute(Misc.OPERADOR_CONSULTA,operador);\n    session.setAttribute(Misc.FECHA_HASTA,fechaParseadaHasta);\n    session.setAttribute(Misc.FECHA_HASTA_BUSQUEDA,fechaHastaRequest);\n    session.setAttribute(Misc.ESTADO,estado);\n    Entidad entidad=Misc.obtenerEntidad(idEntidad);\n    ServicioConsultaExpedientes oServicio=LocalizadorServicios.getServicioConsultaExpedientes();\n    CriterioBusquedaExpedientes oCriterio=new CriterioBusquedaExpedientes();\n    oCriterio.setNIF(cnif);\n    oCriterio.setExpediente(numExpediente);\n    oCriterio.setNumeroRegistroInicial(numeroRegistroInicial);\n    oCriterio.setProcedimiento(procedimiento);\n    oCriterio.setFechaDesde(fechaParseadaDesde);\n    oCriterio.setFechaHasta(fechaParseadaHasta);\n    oCriterio.setOperadorConsulta(operador);\n    oCriterio.setFechaRegistroInicialDesde(fechaRegistroInicialParseadaDesde);\n    oCriterio.setFechaRegistroInicialHasta(fechaRegistroInicialParseadaHasta);\n    oCriterio.setOperadorConsultaFechaInicial(operadorFechaInicial);\n    oCriterio.setEstado(estado);\n    Expedientes nuevoExpedientes=new Expedientes();\n    Expedientes expedientes=oServicio.busquedaExpedientes(oCriterio,entidad);\n    for (int a=0; a < expedientes.count(); a++) {\n      Expediente expediente=(Expediente)expedientes.get(a);\n      if (expediente.getEstado().equals(Expediente.COD_ESTADO_EXPEDIENTE_FINALIZADO)) {\n        expediente.setEstado(\"cerrado\");\n      }\n else {\n        expediente.setEstado(\"abierto\");\n      }\n      String proc=expediente.getProcedimiento();\n      if (proc.length() > 60) {\n        proc=proc.substring(0,57) + \"...\";\n        expediente.setProcedimiento(proc);\n      }\n      boolean existeNotificacion=oServicio.existenNotificaciones(expediente.getNumero(),entidad);\n      if (existeNotificacion) {\n        expediente.setNotificacion(\"S\");\n      }\n else {\n        expediente.setNotificacion(\"N\");\n      }\n      boolean existeSubsanacion=oServicio.existenSubsanaciones(expediente.getNumero(),entidad);\n      if (existeSubsanacion) {\n        expediente.setAportacion(\"S\");\n      }\n else {\n        expediente.setAportacion(\"N\");\n      }\n      boolean existePago=oServicio.existenPagos(expediente.getNumero(),entidad);\n      if (existePago) {\n        expediente.setPagos(\"S\");\n      }\n else {\n        expediente.setPagos(\"N\");\n      }\n      nuevoExpedientes.add(expediente);\n    }\n    listaExpedienteForm.setExpedientes(nuevoExpedientes);\n    request.setAttribute(\"expedientes\",nuevoExpedientes.getExpedientes());\n  }\n catch (  Exception ex) {\n    request.setAttribute(Misc.MENSAJE_ERROR,ex.getMessage());\n  }\n  return mapping.findForward(\"Success_Search\");\n}\n", "nl": "Se sobrescribe el metodo execute de la clase Action"}
{"code": "public synchronized void flush() throws IOException {\n  checkNotClosed();\n  trimToSize();\n  journalWriter.flush();\n}\n", "nl": "Force buffered operations to the filesystem."}
{"code": "public byte[] internalArray(){\n  return data;\n}\n", "nl": "Returns the underlying array. This method exists as performance optimization to avoid extra copying of the arrays. Data inside of this array should not be altered, only copied."}
{"code": "protected Expression number(int opPos) throws TransformerException {\n  return compileUnary(new org.apache.xpath.operations.Number(),opPos);\n}\n", "nl": "Compile a 'number(...)' operation."}
{"code": "void transfer(IntEntry[] newTable){\n  IntEntry<VALUE>[] src=table;\n  int newCapacity=newTable.length;\n  for (int j=0; j < src.length; j++) {\n    IntEntry<VALUE> e=src[j];\n    if (e != null) {\n      src[j]=null;\n      do {\n        IntEntry<VALUE> next=e.next;\n        int i=indexFor(e.hash,newCapacity);\n        e.next=newTable[i];\n        newTable[i]=e;\n        e=next;\n      }\n while (e != null);\n    }\n  }\n}\n", "nl": "Transfer all entries from current table to newTable."}
{"code": "protected void addPhraseFieldQueries(BooleanQuery.Builder query,List<Clause> clauses,ExtendedDismaxConfiguration config) throws SyntaxError {\n  List<FieldParams> allPhraseFields=config.getAllPhraseFields();\n  if (allPhraseFields.size() > 0) {\n    List<Clause> normalClauses=new ArrayList<>(clauses.size());\n    for (    Clause clause : clauses) {\n      if (clause.field != null || clause.isPhrase)       continue;\n      if (clause.isBareWord()) {\n        String s=clause.val;\n        if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s)|| \"TO\".equals(s))         continue;\n      }\n      normalClauses.add(clause);\n    }\n    Multimap<Integer,FieldParams> phraseFieldsByWordGram=Multimaps.index(allPhraseFields,WORD_GRAM_EXTRACTOR);\n    for (    Map.Entry<Integer,Collection<FieldParams>> phraseFieldsByWordGramEntry : phraseFieldsByWordGram.asMap().entrySet()) {\n      Multimap<Integer,FieldParams> phraseFieldsBySlop=Multimaps.index(phraseFieldsByWordGramEntry.getValue(),PHRASE_SLOP_EXTRACTOR);\n      for (      Map.Entry<Integer,Collection<FieldParams>> phraseFieldsBySlopEntry : phraseFieldsBySlop.asMap().entrySet()) {\n        addShingledPhraseQueries(query,normalClauses,phraseFieldsBySlopEntry.getValue(),phraseFieldsByWordGramEntry.getKey(),config.tiebreaker,phraseFieldsBySlopEntry.getKey());\n      }\n    }\n  }\n}\n", "nl": "Adds shingled phrase queries to all the fields specified in the pf, pf2 anf pf3 parameters"}
{"code": "private void showResult(){\n  if (mLastDewarpedImg != null) {\n    mShownBitmap=mLastDewarpedImg.convertToBitmap();\n    mLastDewarpedImg=null;\n    mImageView.setImageBitmap(mShownBitmap);\n    mResultView.setVisibility(View.VISIBLE);\n    mHaveResult=false;\n    if (Build.VERSION.SDK_INT >= 23) {\n      if (checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n        mBtnSave.setVisibility(View.INVISIBLE);\n        requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},MY_STORAGE_REQUEST_CODE);\n      }\n    }\n  }\n}\n", "nl": "Shows the view with result image."}
{"code": "public static boolean isValidMD5(String s){\n  return s.matches(\"[a-fA-F0-9]{32}\");\n}\n", "nl": "Checks if given string is a valid MD5 hash string using pattern"}
{"code": "protected Map<String,String> loadSessionVariables(HttpServletRequest req) throws ServletException {\n  Map<String,String> datastoreMap=new HashMap<>();\n  String sessionId=getCookieValue(req,\"bookshelfSessionId\");\n  if (sessionId.equals(\"\")) {\n    return datastoreMap;\n  }\n  Key key=keyFactory.newKey(sessionId);\n  Transaction transaction=datastore.newTransaction();\n  try {\n    Entity stateEntity=transaction.get(key);\n    StringBuilder logNames=new StringBuilder();\n    if (stateEntity != null) {\n      for (      String varName : stateEntity.names()) {\n        req.getSession().setAttribute(varName,stateEntity.getString(varName));\n        datastoreMap.put(varName,stateEntity.getString(varName));\n        logNames.append(varName + \" \");\n      }\n    }\n else {\n    }\n  }\n  finally {\n    if (transaction.active()) {\n      transaction.rollback();\n    }\n  }\n  return datastoreMap;\n}\n", "nl": "Take an HttpServletRequest, and copy all of the current session variables over to it"}
{"code": "@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){\n  mFastAdapter.onBindViewHolder(holder,position);\n}\n", "nl": "the onBindViewHolder is managed by the FastAdapter so forward this correctly"}
{"code": "public void clear(){\n  m.clear();\n}\n", "nl": "Removes all of the elements from this set."}
{"code": "public boolean hasMoreElements(){\n  if (m_mine.hasMoreElements()) {\n    return true;\n  }\n  if (m_next != null) {\n    return m_next.hasMoreElements();\n  }\n  return false;\n}\n", "nl": "Method hasMoreElements."}
{"code": "public void testVerifyCommitRecordIndex(){\n  final Properties properties=new Properties(getProperties());\n  properties.setProperty(AbstractTransactionService.Options.MIN_RELEASE_AGE,\"400\");\n  final Journal store=getJournal(properties);\n  try {\n    MemStrategy bs=(MemStrategy)store.getBufferStrategy();\n    for (int r=0; r < 10; r++) {\n      ArrayList<Long> addrs=new ArrayList<Long>();\n      for (int i=0; i < 100; i++) {\n        addrs.add(bs.write(randomData(45)));\n      }\n      store.commit();\n      for (      long addr : addrs) {\n        bs.delete(addr);\n      }\n      store.commit();\n    }\n    Thread.currentThread().sleep(400);\n    verifyCommitIndex(store,20);\n    store.close();\n  }\n catch (  InterruptedException e) {\n  }\n finally {\n    store.destroy();\n  }\n}\n", "nl": "Can be tested by removing RWStore call to journal.removeCommitRecordEntries in freeDeferrals. final int commitPointsRemoved = journal.removeCommitRecordEntries(fromKey, toKey); replaced with final int commitPointsRemoved = commitPointsRecycled;"}
{"code": "@Override public FlowHandler createFlowHandler(FacesContext context){\n  return new FlowHandlerImpl();\n}\n", "nl": "Create the flow handler."}
{"code": "private Operation createNotifyOp(String coordinator,String serviceLink,String header,Operation.CompletionHandler callback){\n  ConflictCheckRequest body=new ConflictCheckRequest();\n  body.serviceLink=serviceLink;\n  return Operation.createPatch(this,coordinator).addRequestHeader(Operation.TRANSACTION_HEADER,header).setBody(body).setReferer(getUri()).setCompletion(callback);\n}\n", "nl": "Prepare an operation to check conflicts with a remote coordinator"}
{"code": "public void testConstructorSignBytesNegative1(){\n  byte aBytes[]={12,56,100,-2,-76,89,45,91,3,-15};\n  int aSign=-1;\n  byte rBytes[]={-13,-57,-101,1,75,-90,-46,-92,-4,15};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=aNumber.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,aNumber.signum());\n}\n", "nl": "Create a negative number from a sign and an array of bytes. The number fits in an array of integers. The most significant byte is positive."}
{"code": "public boolean isMotorEnabled(){\n  return joint.isMotorEnabled();\n}\n", "nl": "Is the joint motor enabled?"}
{"code": "static void writeShort(final byte[] b,final int index,final int s){\n  b[index]=(byte)(s >>> 8);\n  b[index + 1]=(byte)s;\n}\n", "nl": "Writes a short value in the given byte array."}
{"code": "public DERUTCTime(Date time){\n  SimpleDateFormat dateF=new SimpleDateFormat(\"yyMMddHHmmss'Z'\");\n  dateF.setTimeZone(new SimpleTimeZone(0,\"Z\"));\n  this.time=Strings.toByteArray(dateF.format(time));\n}\n", "nl": "base constructer from a java.util.date object"}
{"code": "private void updateWidget(){\n  RemoteViews remoteViews=WidgetProvider.configureWidgetIntents(this,mCurrentEpisode);\n  AppWidgetManager appWidgetManager=AppWidgetManager.getInstance(this);\n  ComponentName thisWidget=new ComponentName(getApplicationContext(),WidgetProvider.class);\n  int playPauseResId=PlaybackButtonHelper.getWidgetPlaybackButtonResId(getPlaybackState());\n  int[] allWidgetIds=appWidgetManager.getAppWidgetIds(thisWidget);\n  if (allWidgetIds == null || allWidgetIds.length == 0) {\n    return;\n  }\n  if (mCurrentEpisode == null) {\n    remoteViews.setTextViewText(R.id.episode_title,\"\");\n    remoteViews.setTextViewText(R.id.channel_title,\"\");\n    remoteViews.setImageViewResource(R.id.play,playPauseResId);\n    remoteViews.setImageViewResource(R.id.channel_art,R.drawable.default_channel_art);\n  }\n else {\n    ImageLoadHelper.loadImageIntoWidget(this,mCurrentEpisode.getChannelArtworkUrl(),remoteViews,R.id.channel_art,allWidgetIds,new RoundedCornersTransformation(this));\n    remoteViews.setOnClickPendingIntent(R.id.play,PendingIntentHelper.getPlayOrPauseIntent(this,getPlaybackState()));\n    remoteViews.setTextViewText(R.id.episode_title,mCurrentEpisode.getTitle());\n    remoteViews.setTextViewText(R.id.channel_title,mCurrentEpisode.getChannelTitle());\n    remoteViews.setImageViewResource(R.id.play,playPauseResId);\n  }\n  for (  int widgetId : allWidgetIds) {\n    appWidgetManager.updateAppWidget(widgetId,remoteViews);\n  }\n}\n", "nl": "Widget update related functions"}
{"code": "private int trimToPowerOf2(int initialCapacity){\n  int capacity=1;\n  while (capacity < initialCapacity) {\n    capacity<<=1;\n  }\n  return capacity;\n}\n", "nl": "Return a power of 2 for initialCapacity"}
{"code": "protected Polygon createArrow(mxPoint p0,mxPoint pe){\n  double spacing=mxConstants.ARROW_SPACING * scale;\n  double width=mxConstants.ARROW_WIDTH * scale;\n  double arrow=mxConstants.ARROW_SIZE * scale;\n  double dx=pe.getX() - p0.getX();\n  double dy=pe.getY() - p0.getY();\n  double dist=Math.sqrt(dx * dx + dy * dy);\n  double length=dist - 2 * spacing - arrow;\n  double nx=dx / dist;\n  double ny=dy / dist;\n  double basex=length * nx;\n  double basey=length * ny;\n  double floorx=width * ny / 3;\n  double floory=-width * nx / 3;\n  double p0x=p0.getX() - floorx / 2 + spacing * nx;\n  double p0y=p0.getY() - floory / 2 + spacing * ny;\n  double p1x=p0x + floorx;\n  double p1y=p0y + floory;\n  double p2x=p1x + basex;\n  double p2y=p1y + basey;\n  double p3x=p2x + floorx;\n  double p3y=p2y + floory;\n  double p5x=p3x - 3 * floorx;\n  double p5y=p3y - 3 * floory;\n  Polygon poly=new Polygon();\n  poly.addPoint((int)Math.round(p0x),(int)Math.round(p0y));\n  poly.addPoint((int)Math.round(p1x),(int)Math.round(p1y));\n  poly.addPoint((int)Math.round(p2x),(int)Math.round(p2y));\n  poly.addPoint((int)Math.round(p3x),(int)Math.round(p3y));\n  poly.addPoint((int)Math.round(pe.getX() - spacing * nx),(int)Math.round(pe.getY() - spacing * ny));\n  poly.addPoint((int)Math.round(p5x),(int)Math.round(p5y));\n  poly.addPoint((int)Math.round(p5x + floorx),(int)Math.round(p5y + floory));\n  return poly;\n}\n", "nl": "Creates a polygon that represents an arrow."}
{"code": "public EventType(){\n  id=String.valueOf(count++);\n}\n", "nl": "Creates a new event type."}
{"code": "public boolean startsWith(XMLString prefix){\n  return m_str.startsWith(prefix.toString());\n}\n", "nl": "Tests if this string starts with the specified prefix."}
{"code": "public IOUtils(){\n  super();\n}\n", "nl": "Instances should NOT be constructed in standard programming."}
{"code": "@Override public void slaveLost(SchedulerDriver driver,Protos.SlaveID slaveId){\n  scheduler.expireAllLeasesByVMId(slaveId.getValue());\n}\n", "nl": "Upon slave lost notification, tell Fenzo scheduler to expire all leases with the given slave ID. Note, however, that if there was no offer received from that slave prior to this call, Fenzo would not have a mapping from the slave ID to hostname (Fenzo maintains slaves state by hostname). This is OK since there would be no offers to expire. However, any tasks running on the lost slave will not be removed by this call to Fenzo. Task lost status updates would ensure that."}
{"code": "@Override public void draw(Graphics2D g){\n  if (getOwner().isTransformable()) {\n    drawRectangle(g,(Color)getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_FILL_COLOR),(Color)getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_STROKE_COLOR));\n  }\n else {\n    drawRectangle(g,(Color)getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_FILL_COLOR),(Color)getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_STROKE_COLOR));\n  }\n}\n", "nl": "Draws this handle. <p> If the figure is transformable, the handle is drawn as a filled rectangle. If the figure is not transformable, the handle is drawn as an unfilled rectangle."}
{"code": "@Override public void addExternalHandler(final Object newHandler,final int type){\nswitch (type) {\ncase Options.FormsActionHandler:\n    userActionHandler=(ActionHandler)newHandler;\n  break;\ncase Options.CustomMouseHandler:\nJavaFXMouseListener.setCustomMouseFunctions((JavaFXMouseFunctionality)newHandler);\nbreak;\ncase Options.ThumbnailHandler:\npages.setThumbnailPanel((org.jpedal.display.GUIThumbnailPanel)newHandler);\nbreak;\ndefault :\nexternalHandlers.addExternalHandler(newHandler,type);\n}\n}\n", "nl": "not part of API used internally allows external helper classes to be added to JPedal to alter default functionality -"}
{"code": "public static void main(String[] args){\n  double[][] matrix1=getmatrix(1);\n  double[][] matrix2=getmatrix(2);\n  double[][] matrix3=multiplyMatrix(matrix1,matrix2);\n  print(matrix1,matrix2,matrix3);\n}\n", "nl": "Main method"}
{"code": "private void genTable(String tableName,String whereClause,boolean completeXML,Properties ctx,WebInfo wi){\n  String l_szTrxName=null;\n  StringBuffer tmpCode=new StringBuffer();\n  String dataTableName=tableName;\n  String l_whereClause=replaceSessionElements(wi,whereClause);\n  tmpCode.append(\"<\" + tableName + \">\\n\");\n  if (whereClause.indexOf(\"AD_Reference\") > -1) {\n    dataTableName=\"AD_Ref_List\";\n  }\n  int[] l_nIDs=PO.getAllIDs(dataTableName,l_whereClause,l_szTrxName);\n  int[] l_nTableIDs=MTable.getAllIDs(\"AD_Table\",\"TableName='\" + dataTableName + \"'\",l_szTrxName);\n  if (l_nTableIDs.length > 0) {\n    MTable table=MTable.get(ctx,l_nTableIDs[0]);\n    PO l_Object=null;\n    if (completeXML) {\n      for (int i=0; i < l_nIDs.length; i++) {\n        l_Object=table.getPO(l_nIDs[i],l_szTrxName);\n        l_Object.get_xmlString(tmpCode);\n      }\n    }\n else {\n      String sql=MLookupFactory.getLookup_TableDirEmbed(Language.getLanguage(\"en\"),dataTableName + \"_ID\",dataTableName);\n      sql=sql.concat(\" AND \" + l_whereClause);\n      PreparedStatement pstm=DB.prepareStatement(sql,l_szTrxName);\n      ResultSet rs=null;\n      try {\n        rs=pstm.executeQuery();\n      }\n catch (      Exception e) {\n      }\n      for (int i=0; i < l_nIDs.length; i++) {\n        l_Object=table.getPO(l_nIDs[i],l_szTrxName);\n        tmpCode.append(\"<\" + dataTableName + \" AD_Table_ID=\\\"\"+ table.get_ID()+ \"\\\" Record_ID=\\\"\"+ l_Object.get_ID()+ \"\\\">\\n\");\n        tmpCode.append(\"<\" + dataTableName + \"_ID>\");\n        tmpCode.append(l_Object.get_ID());\n        tmpCode.append(\"</\" + dataTableName + \"_ID>\\n\");\n        if (dataTableName.equals(\"AD_Ref_List\")) {\n          tmpCode.append(\"<Value>\");\n          tmpCode.append(\"<![CDATA[\" + l_Object.get_Value(\"Value\") + \"]]>\\n\");\n          tmpCode.append(\"</Value>\\n\");\n        }\n        if (dataTableName.equals(\"AD_User\") || dataTableName.equals(\"C_Project\")) {\n          tmpCode.append(\"<C_BPartner_ID>\");\n          tmpCode.append(l_Object.get_Value(\"C_BPartner_ID\"));\n          tmpCode.append(\"</C_BPartner_ID>\\n\");\n        }\n        tmpCode.append(\"<DisplayName>\\n\");\n        try {\n          if (rs.next()) {\n            tmpCode.append(\"<![CDATA[\" + rs.getString(1) + \"]]>\\n\");\n          }\n        }\n catch (        SQLException e) {\n          tmpCode.append(\"<![CDATA[\" + e.getMessage() + \"]]\\n\");\n        }\n        tmpCode.append(\"</DisplayName>\\n\");\n        tmpCode.append(\"</\" + dataTableName + \">\\n\");\n      }\n      try {\n        rs.close();\n        pstm.close();\n      }\n catch (      Exception e) {\n      }\n    }\n  }\n  tmpCode.append(\"</\" + tableName + \">\\n\");\n  xmlCode.append(tmpCode);\n}\n", "nl": "Creates the nodes for the request tables in the XML-tree."}
{"code": "@Inline public static boolean isZeroed(Address start,int bytes){\n  return isSet(start,bytes,false,0);\n}\n", "nl": "Check that a memory range is zeroed"}
{"code": "public int kthSmallestB(TreeNode root,int k){\n  Deque<TreeNode> stack=new ArrayDeque<>();\n  int count=k;\n  while (!stack.isEmpty() || root != null) {\n    if (root != null) {\n      stack.push(root);\n      root=root.left;\n    }\n else {\n      root=stack.pop();\n      count--;\n      if (count == 0) {\n        return root.val;\n      }\n      root=root.right;\n    }\n  }\n  return -1;\n}\n", "nl": "Iterasive solution with stack."}
{"code": "public static String toString(Calendar v){\n  if (v != null) {\n    return new SimpleDateFormat(\"EEE MM/dd/yyyy hh:mm:ss a\").format(v.getTime());\n  }\n  return null;\n}\n", "nl": "Calendar -> String"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int col;\n  int row;\n  int numCols;\n  int numRows;\n  int a;\n  int i;\n  float progress;\n  int range;\n  boolean blnTextOutput=false;\n  double z;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  for (i=0; i < args.length; i++) {\n    if (i == 0) {\n      inputHeader=args[i];\n    }\n else     if (i == 1) {\n      outputHeader=args[i];\n    }\n else     if (i == 2) {\n      blnTextOutput=Boolean.parseBoolean(args[i]);\n    }\n  }\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster image=new WhiteboxRaster(inputHeader,\"r\");\n    numRows=image.getNumberRows();\n    numCols=image.getNumberColumns();\n    double noData=image.getNoDataValue();\n    WhiteboxRaster output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    output.setPreferredPalette(\"spectrum.pal\");\n    output.setDataScale(WhiteboxRaster.DataScale.CONTINUOUS);\n    int minValue=(int)(image.getMinimumValue());\n    int maxValue=(int)(image.getMaximumValue());\n    range=maxValue - minValue;\n    double[] data;\n    double[][] totals=new double[4][range + 1];\n    double[] radius=new double[range + 1];\n    double[][] centroid=new double[2][range + 1];\n    double[] DFCSum=new double[range + 1];\n    long[][] minRowAndCol=new long[2][range + 1];\n    for (a=0; a <= range; a++) {\n      minRowAndCol[0][a]=Long.MAX_VALUE;\n      minRowAndCol[1][a]=Long.MAX_VALUE;\n    }\n    updateProgress(\"Finding patch min row and columns:\",0);\n    for (row=0; row < numRows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < numCols; col++) {\n        if (data[col] > 0) {\n          a=(int)(data[col] - minValue);\n          if (row < minRowAndCol[0][a]) {\n            minRowAndCol[0][a]=row;\n          }\n          if (col < minRowAndCol[1][a]) {\n            minRowAndCol[1][a]=col;\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Finding patch min row and columns:\",(int)progress);\n    }\n    updateProgress(\"Loop 1 of 3:\",0);\n    for (row=0; row < numRows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < numCols; col++) {\n        if (data[col] > 0) {\n          a=(int)(data[col] - minValue);\n          totals[0][a]+=(col - minRowAndCol[1][a]);\n          totals[1][a]+=(row - minRowAndCol[0][a]);\n          totals[2][a]++;\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 1 of 3:\",(int)progress);\n    }\n    for (a=0; a <= range; a++) {\n      if (totals[2][a] > 0) {\n        centroid[0][a]=totals[0][a] / totals[2][a] + minRowAndCol[1][a];\n        centroid[1][a]=totals[1][a] / totals[2][a] + minRowAndCol[0][a];\n        radius[a]=Math.sqrt((totals[2][a]) / Math.PI) - 0.5;\n      }\n    }\n    updateProgress(\"Loop 2 of 3:\",0);\n    double d;\n    for (row=0; row < numRows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < numCols; col++) {\n        if (data[col] > 0) {\n          a=(int)(data[col] - minValue);\n          d=Math.sqrt(Math.pow((col - centroid[0][a]),2d) + Math.pow((row - centroid[1][a]),2));\n          DFCSum[a]+=(double)d;\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 2 of 3:\",(int)progress);\n    }\n    for (a=0; a <= range; a++) {\n      if (totals[2][a] > 0) {\n        DFCSum[a]=DFCSum[a] / totals[2][a];\n      }\n    }\n    updateProgress(\"Loop 3 of 3:\",0);\n    for (row=0; row < numRows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < numCols; col++) {\n        if (data[col] > 0) {\n          a=(int)(data[col] - minValue);\n          output.setValue(row,col,DFCSum[a]);\n        }\n else {\n          output.setValue(row,col,noData);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (numRows - 1));\n      updateProgress(\"Loop 3 of 3:\",(int)progress);\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    image.close();\n    output.close();\n    if (blnTextOutput) {\n      DecimalFormat df;\n      df=new DecimalFormat(\"0.0000\");\n      String retstr=\"Radius of Gyration\\nPatch ID\\tValue\";\n      for (a=0; a <= range; a++) {\n        if (DFCSum[a] > 0) {\n          retstr=retstr + \"\\n\" + (a + minValue)+ \"\\t\"+ df.format(DFCSum[a]);\n        }\n      }\n      returnData(retstr);\n    }\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public String transformBackToOriginalTipText(){\n  return \"Transform through the PC space and back to the original space. \" + \"If only the best n PCs are retained (by setting varianceCovered < 1) \" + \"then this option will give a dataset in the original space but with \"+ \"less attribute noise.\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "public StandardOutputPrinter(){\n  this(InternalLogWriter.ALL_LEVEL);\n}\n", "nl": "Creates a writer that logs to <code>System.err</code>. All messages will be logged."}
{"code": "@Override public JnaDatabase identify() throws SQLException {\n  return new JnaDatabase(this);\n}\n", "nl": "Contrary to the description in the super class, this will simply return an unconnected instance."}
{"code": "private boolean isBigEndian(){\n  return getFormat().isBigEndian();\n}\n", "nl": "Returns if this stream (the decoded one) is big endian."}
{"code": "public static void playAlbum(final Context context,final long albumId,int position){\n  final long[] albumList=getSongListForAlbum(context,albumId);\n  if (albumList != null) {\n    playAll(albumList,position,false);\n  }\n}\n", "nl": "Plays songs from an album."}
{"code": "public String edgesToString(){\n  String result=\"\";\n  for (Iterator<Edge<T>> it=edgesIterator(); it.hasNext(); ) {\n    Edge<T> edge=it.next();\n    result+=\"(\" + edge.from.value + \"->\"+ edge.to.value+ \")\";\n  }\n  return result;\n}\n", "nl": "Returns a String describing the Edges only. May be helpful while analyzing cycles."}
{"code": "public static _Fields findByThriftIdOrThrow(int fieldId){\n  _Fields fields=findByThriftId(fieldId);\n  if (fields == null)   throw new IllegalArgumentException(\"Field \" + fieldId + \" doesn't exist!\");\n  return fields;\n}\n", "nl": "Find the _Fields constant that matches fieldId, throwing an exception if it is not found."}
{"code": "@Override public AffineTransform inverse(){\n  double det=this.determinant();\n  return new AffineTransform((m11 * m22 - m21 * m12) / det,(m21 * m01 - m01 * m22) / det,(m01 * m12 - m11 * m02) / det,(m01 * (m22 * m13 - m12 * m23) + m02 * (m11 * m23 - m21 * m13) - m03 * (m11 * m22 - m21 * m12)) / det,(m20 * m12 - m10 * m22) / det,(m00 * m22 - m20 * m02) / det,(m10 * m02 - m00 * m12) / det,(m00 * (m12 * m23 - m22 * m13) - m02 * (m10 * m23 - m20 * m13) + m03 * (m10 * m22 - m20 * m12)) / det,(m10 * m21 - m20 * m11) / det,(m20 * m01 - m00 * m21) / det,(m00 * m11 - m10 * m01) / det,(m00 * (m21 * m13 - m11 * m23) + m01 * (m10 * m23 - m20 * m13) - m03 * (m10 * m21 - m20 * m11)) / det);\n}\n", "nl": "Computes the inverse affine transform."}
{"code": "public Instrumenter attachAdaptiveTimeContinuationCollector(){\n  includeAdaptiveTimeContinuation=true;\n  return this;\n}\n", "nl": "Includes the adaptive time continuation collector when instrumenting algorithms."}
{"code": "public void push(final int value){\n  if (value >= -1 && value <= 5) {\n    mv.visitInsn(Opcodes.ICONST_0 + value);\n  }\n else   if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {\n    mv.visitIntInsn(Opcodes.BIPUSH,value);\n  }\n else   if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {\n    mv.visitIntInsn(Opcodes.SIPUSH,value);\n  }\n else {\n    mv.visitLdcInsn(value);\n  }\n}\n", "nl": "Generates the instruction to push the given value on the stack."}
{"code": "protected void handleENumValChildren(Element e,EnumVariableValue var){\n  List<Element> local=e.getChildren();\n  for (int k=0; k < local.size(); k++) {\n    Element el=local.get(k);\n    if (el.getName().equals(\"enumChoice\")) {\n      Attribute valAttr=el.getAttribute(\"value\");\n      if (valAttr == null) {\n        var.addItem(LocaleSelector.getAttribute(el,\"choice\"));\n      }\n else {\n        var.addItem(LocaleSelector.getAttribute(el,\"choice\"),Integer.parseInt(valAttr.getValue()));\n      }\n    }\n else     if (el.getName().equals(\"enumChoiceGroup\")) {\n      var.startGroup(LocaleSelector.getAttribute(el,\"name\"));\n      handleENumValChildren(el,var);\n      var.endGroup();\n    }\n  }\n}\n", "nl": "Recursively walk the child enumChoice elements, working through the enumChoiceGroup elements as needed."}
{"code": "public void resetOriginals(){\n  mStartingStartTrim=0;\n  mStartingEndTrim=0;\n  mStartingRotation=0;\n  setStartTrim(0);\n  setEndTrim(0);\n  setRotation(0);\n}\n", "nl": "Reset the progress spinner to default rotation, start and end angles."}
{"code": "public void put(Object key,Object value){\n  if (hints != null) {\n    hints.put(key,value);\n  }\n}\n", "nl": "Set RenderingHint on this object."}
{"code": "public boolean contains(Object o){\n  if (o == null)   return false;\n  int mask=elements.length - 1;\n  int i=head;\n  Object x;\n  while ((x=elements[i]) != null) {\n    if (o.equals(x))     return true;\n    i=(i + 1) & mask;\n  }\n  return false;\n}\n", "nl": "Returns <tt>true</tt> if this deque contains the specified element. More formally, returns <tt>true</tt> if and only if this deque contains at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>."}
{"code": "public void addCertificates(Store certStore) throws CMSException {\n  certs.addAll(CMSUtils.getCertificatesFromStore(certStore));\n}\n", "nl": "Add the certificates in certStore to the certificate set to be included with the generated SignedData message."}
{"code": "public int compareTo(Boolean that){\n  return compare(value,that.value);\n}\n", "nl": "Compares this object to the specified boolean object to determine their relative order."}
{"code": "public final AlertDialog initiateScan(int cameraId){\n  return initiateScan(ALL_CODE_TYPES,cameraId);\n}\n", "nl": "Initiates a scan for all known barcode types with the specified camera."}
{"code": "public MutablePeriod(long startInstant,long endInstant,Chronology chrono){\n  super(startInstant,endInstant,null,chrono);\n}\n", "nl": "Creates a period from the given interval endpoints using the standard set of fields."}
{"code": "public final RealMatrix procrustinate(RealMatrix X){\n  if (X.getRowDimension() != rowDimension) {\n    throw new IllegalArgumentException(\"X does not have the expected number of rows\");\n  }\n  if (X.getColumnDimension() != columnDimension) {\n    throw new IllegalArgumentException(\"X does not have the expected number of columns\");\n  }\n  RealMatrix tt=new Array2DRowRealMatrix(rowDimension,columnDimension);\n  for (int i=0; i < rowDimension; i++) {\n    tt.setRowMatrix(i,T.transpose());\n  }\n  return X.multiply(R).scalarMultiply(s).add(tt);\n}\n", "nl": "procrustinate the complete matrix of coordinates"}
{"code": "public Instant withDurationAdded(long durationToAdd,int scalar){\n  if (durationToAdd == 0 || scalar == 0) {\n    return this;\n  }\n  long instant=getChronology().add(getMillis(),durationToAdd,scalar);\n  return withMillis(instant);\n}\n", "nl": "Gets a copy of this instant with the specified duration added. <p> If the addition is zero, then <code>this</code> is returned."}
{"code": "public InspectableFileCachedInputStream(final int bufferSize) throws IOException {\n  this(bufferSize,null);\n}\n", "nl": "Creates a new instance with specified buffer size and default overflow-file directory."}
{"code": "public Builder addFormDataPart(String name,String value){\n  return addPart(Part.createFormData(name,value));\n}\n", "nl": "Add a form data part to the body."}
{"code": "public Object extractMin(){\n  int numElem=this.numElem;\n  Object[] objects=this.objects;\n  double[] keys=this.keys;\n  if (numElem == 0)   return null;\n  keys[1 - 1]=keys[numElem - 1];\n  keys[numElem - 1]=0;\n  Object result=objects[1 - 1];\n  objects[1 - 1]=objects[numElem - 1];\n  objects[numElem - 1]=null;\n  numElem--;\n  heapify(1,numElem);\n  this.numElem=numElem;\n  return result;\n}\n", "nl": "Removes the minimum element and its key from the heap, and returns the minimum element.  Will return null if the heap is empty"}
{"code": "public boolean isActive(){\n  return active;\n}\n", "nl": "Gets the value of the active property."}
{"code": "protected void processOtherEvent(SimEvent ev){\n  if (ev == null) {\n    Log.printConcatLine(getName(),\".processOtherEvent(): Error - an event is null.\");\n  }\n}\n", "nl": "Here all the method related to VM requests will be received and forwarded to the related method."}
{"code": "public DoubleConverter(final Object defaultValue){\n  super(true,defaultValue);\n}\n", "nl": "Construct a <b>java.lang.Double</b> <i>Converter</i> that returns a default value if an error occurs."}
{"code": "public PdxFieldAlreadyExistsException(String message){\n  super(message);\n}\n", "nl": "Constructs a new exception with the given message."}
{"code": "public void restart(BackgroundTask<T,V> task){\n  cancel();\n  this.task=task;\n  taskHandler=backgroundWorker.handle(task);\n  taskHandler.execute();\n}\n", "nl": "Cancel running task if there is at the moment. Launch new task specified as parameter."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase GamlPackage.UNIT_NAME__REF:\n    return ref != null;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean removeCheckedMessage(){\n  SQLiteDatabase db=getWritableDatabase();\n  if (db != null) {\n    db.execSQL(\"UPDATE \" + TABLE + \" SET \"+ COL_DELETED+ \"=\"+ TRUE+ \" WHERE \"+ COL_CHECKED+ \"=\"+ TRUE+ \";\");\n    return true;\n  }\n  log.debug(\"Message not added to store, database is null.\");\n  return false;\n}\n", "nl": "Remove the given all checked messages from the store, the message data is retained with its deleted state set to true."}
{"code": "public boolean isEmpty(){\n  return count == 0;\n}\n", "nl": "<p>Tests if this hashtable maps no keys to values.</p>"}
{"code": "@Timed @ExceptionMetered @GET @Path(\"{name}/clients\") @Produces(APPLICATION_JSON) public Set<Client> clientDetailForGroup(@Auth AutomationClient automationClient,@PathParam(\"name\") String name){\n  Group group=groupDAO.getGroup(name).orElseThrow(null);\n  return aclDAO.getClientsFor(group);\n}\n", "nl": "Retrieve metadata for clients in a particular group."}
{"code": "protected void paintDeterminate(Graphics g,JComponent c){\n  if (!(g instanceof Graphics2D)) {\n    return;\n  }\n  if (isUseParentPaint()) {\n    super.paintDeterminate(g,c);\n    return;\n  }\n  Insets b=progressBar.getInsets();\n  int barRectWidth=progressBar.getWidth() - (b.right + b.left);\n  int barRectHeight=progressBar.getHeight() - (b.top + b.bottom);\n  paintProgressBarBgImpl(progressBar.getOrientation() == JProgressBar.HORIZONTAL,g,b,barRectWidth,barRectHeight);\n  if (barRectWidth <= 0 || barRectHeight <= 0) {\n    return;\n  }\n  int amountFull=getAmountFull(b,barRectWidth,barRectHeight);\n  Graphics2D g2=(Graphics2D)g;\n  g2.setColor(progressBar.getForeground());\n  if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {\n    if (WinUtils.isLeftToRight(c)) {\n      paintProgressBarContentImpl(true,g,b.left,b.top,amountFull,barRectHeight,-1);\n    }\n else {\n      paintProgressBarContentImpl(true,g,barRectWidth + b.left,b.top,barRectWidth + b.left - amountFull,barRectHeight,-1);\n    }\n  }\n else {\n    paintProgressBarContentImpl(false,g,b.left,b.top + barRectHeight - amountFull,barRectWidth,amountFull,barRectHeight);\n  }\n  if (progressBar.isStringPainted()) {\n    paintString(g,b.left,b.top,barRectWidth,barRectHeight,amountFull,b);\n  }\n}\n", "nl": "All purpose paint method that should do the right thing for almost all linear, determinate progress bars. By setting a few values in the defaults table, things should work just fine to paint your progress bar. Naturally, override this if you are making a circular or semi-circular progress bar."}
{"code": "private void emitHeader(ArrayList<PositionList.Entry> sortedPositions,ArrayList<LocalList.Entry> methodArgs) throws IOException {\n  boolean annotate=(annotateTo != null) || (debugPrint != null);\n  int mark=output.getCursor();\n  if (sortedPositions.size() > 0) {\n    PositionList.Entry entry=sortedPositions.get(0);\n    line=entry.getPosition().getLine();\n  }\n  output.writeUleb128(line);\n  if (annotate) {\n    annotate(output.getCursor() - mark,\"line_start: \" + line);\n  }\n  int curParam=getParamBase();\n  StdTypeList paramTypes=desc.getParameterTypes();\n  int szParamTypes=paramTypes.size();\n  if (!isStatic) {\n    for (    LocalList.Entry arg : methodArgs) {\n      if (curParam == arg.getRegister()) {\n        lastEntryForReg[curParam]=arg;\n        break;\n      }\n    }\n    curParam++;\n  }\n  mark=output.getCursor();\n  output.writeUleb128(szParamTypes);\n  if (annotate) {\n    annotate(output.getCursor() - mark,String.format(\"parameters_size: %04x\",szParamTypes));\n  }\n  for (int i=0; i < szParamTypes; i++) {\n    Type pt=paramTypes.get(i);\n    LocalList.Entry found=null;\n    mark=output.getCursor();\n    for (    LocalList.Entry arg : methodArgs) {\n      if (curParam == arg.getRegister()) {\n        found=arg;\n        if (arg.getSignature() != null) {\n          emitStringIndex(null);\n        }\n else {\n          emitStringIndex(arg.getName());\n        }\n        lastEntryForReg[curParam]=arg;\n        break;\n      }\n    }\n    if (found == null) {\n      emitStringIndex(null);\n    }\n    if (annotate) {\n      String parameterName=(found == null || found.getSignature() != null) ? \"<unnamed>\" : found.getName().toHuman();\n      annotate(output.getCursor() - mark,\"parameter \" + parameterName + \" \"+ RegisterSpec.PREFIX+ curParam);\n    }\n    curParam+=pt.getCategory();\n  }\n  for (  LocalList.Entry arg : lastEntryForReg) {\n    if (arg == null) {\n      continue;\n    }\n    CstString signature=arg.getSignature();\n    if (signature != null) {\n      emitLocalStartExtended(arg);\n    }\n  }\n}\n", "nl": "Emits the header sequence, which consists of LEB128-encoded initial line number and string indicies for names of all non-\"this\" arguments."}
{"code": "@Timed @ExceptionMetered @DELETE @Path(\"{name}\") public Response deleteClient(@Auth AutomationClient automationClient,@PathParam(\"name\") String name){\n  Client client=clientDAO.getClient(name).orElseThrow(null);\n  clientDAO.deleteClient(client);\n  auditLog.recordEvent(new Event(Instant.now(),EventTag.CLIENT_DELETE,automationClient.getName(),client.getName()));\n  return Response.noContent().build();\n}\n", "nl": "Delete a client"}
{"code": "public static boolean equals(Object[] array1,Object[] array2){\n  if (array1 == array2) {\n    return true;\n  }\n  if (array1 == null || array2 == null || array1.length != array2.length) {\n    return false;\n  }\n  for (int i=0; i < array1.length; i++) {\n    Object e1=array1[i], e2=array2[i];\n    if (!(e1 == null ? e2 == null : e1.equals(e2))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Compares the two arrays."}
{"code": "public static void writeByteArrayToFile(File file,byte[] data) throws IOException {\n  writeByteArrayToFile(file,data,false);\n}\n", "nl": "Writes a byte array to a file creating the file if it does not exist. <p> NOTE: As from v1.3, the parent directories of the file will be created if they do not exist."}
{"code": "public void processDialogTerminated(DialogTerminatedEvent dialogTerminatedEvent){\n  if (sLogger.isActivated()) {\n    sLogger.debug(\"Dialog terminated\");\n  }\n}\n", "nl": "Process an asynchronously reported DialogTerminatedEvent"}
{"code": "public static String toString(DBIDs ids){\n  if (ids instanceof DBID) {\n    return DBIDFactory.FACTORY.toString((DBID)ids);\n  }\n  StringBuilder buf=new StringBuilder();\n  for (DBIDIter iter=ids.iter(); iter.valid(); iter.advance()) {\n    if (buf.length() > 0) {\n      buf.append(\", \");\n    }\n    buf.append(DBIDFactory.FACTORY.toString(iter));\n  }\n  return buf.toString();\n}\n", "nl": "Format a DBID as string."}
{"code": "public static void append(Path file,Reader reader,boolean writeBom) throws IOException {\n  appendBuffered(file,reader,Charset.defaultCharset().name(),writeBom);\n}\n", "nl": "Append the text supplied by the Reader at the end of the File, using a specified encoding. If the given charset is \"UTF-16BE\" or \"UTF-16LE\" (or an equivalent alias), <code>writeBom</code> is <code>true</code>, and the file doesn't already exist, the requisite byte order mark is written to the file before the text is appended."}
{"code": "public void addIDCondition(String id){\n  _specificityB++;\n  addCondition(Condition.createIDCondition(id));\n}\n", "nl": "the CSS condition #ID"}
{"code": "public double[] distributionForInstance(Instance instance) throws Exception {\n  int num_classes=(int)(snumClasses);\n  double[] ranking=new double[num_classes];\n  SortPair[] sortedActivations=ARTActivateCategories(instance);\n  java.util.Arrays.sort(sortedActivations);\n  double s0=sortedActivations[0].getValue();\n  double diff_act=s0 - sortedActivations[numCategories - 2].getValue();\n  int largest_activ=1;\n  double activ_change=0;\n  for (int i=1; i < sortedActivations.length; i++) {\n    activ_change=(s0 - sortedActivations[i].getValue()) / s0;\n    if (activ_change > threshold * diff_act) {\n      break;\n    }\n    largest_activ=largest_activ + 1;\n  }\n  double[] best_matches=new double[largest_activ];\n  java.util.Arrays.fill(best_matches,1);\n  best_matches[0]=s0;\n  for (int i=1; i < largest_activ; i++) {\n    best_matches[i]=sortedActivations[i].getValue();\n  }\n  double sum_mat=sumArray(best_matches);\n  int currentCategory=0;\n  this.neuronsactivated=new int[largest_activ];\n  this.neuronsactivity=new double[largest_activ];\n  for (int i=0; i < largest_activ; i++) {\n    this.neuronsactivity[i]=best_matches[i];\n    best_matches[i]=best_matches[i] / sum_mat;\n    currentCategory=sortedActivations[i].getOriginalIndex();\n    this.neuronsactivated[i]=currentCategory;\n    int[] s1=weightsB[currentCategory].getKeys();\n    int sit=weightsB[currentCategory].size();\n    int j=0;\n    for (int jt=0; jt < sit; jt++) {\n      j=s1[jt];\n      ranking[j]=ranking[j] + best_matches[i] * (Double)weightsB[currentCategory].get(j);\n    }\n  }\n  this.nrinstclassified+=1;\n  if (m_userankstoclass) {\n    return ARAMm_Ranking2Class(ranking);\n  }\n  return ranking;\n}\n", "nl": "Calculates the class membership probabilities for the given test  instance."}
{"code": "private int validate(File file) throws IOException {\n  MatrixReader reader=null;\n  try {\n    reader=new MatrixReader(file);\n    int count=0;\n    while (reader.hasNext()) {\n      if (reader.next().length > index) {\n        count++;\n      }\n else {\n        break;\n      }\n    }\n    if (count % (2 * P + 2) != 0) {\n      System.err.println(file + \" is incomplete\");\n    }\n    return count / (2 * P + 2);\n  }\n  finally {\n    if (reader != null) {\n      reader.close();\n    }\n  }\n}\n", "nl": "Ensures the model output file contains N*(2P+2) lines and returns N, the number of samples."}
{"code": "public static void trace(String method,String fileName,Object o){\n  if (SysProperties.TRACE_IO) {\n    System.out.println(\"IOUtils.\" + method + \" \"+ fileName+ \" \"+ o);\n  }\n}\n", "nl": "Trace input or output operations if enabled."}
{"code": "public BurlapRuntimeException(String message,Throwable rootCause){\n  super(message);\n  this.rootCause=rootCause;\n}\n", "nl": "Create the exception."}
{"code": "private int calculateOptimalCacheCharsThreshold(int numTermVectors,int numPostings){\n  if (numPostings == 0 && numTermVectors == 0) {\n    return 0;\n  }\n else   if (numTermVectors >= 2) {\n    return 0;\n  }\n else {\n    return getCacheFieldValCharsThreshold();\n  }\n}\n", "nl": "When cacheCharsThreshold is 0, loadFieldValues() only fetches one document at a time.  We override it to be 0 in two circumstances:"}
{"code": "public void create() throws IOException {\n  folder=createTemporaryFolderIn(parentFolder);\n}\n", "nl": "for testing purposes only. Do not use."}
{"code": "private boolean updateAnchorFromChildren(RecyclerView.State state,AnchorInfo anchorInfo){\n  if (getChildCount() == 0) {\n    return false;\n  }\n  final View focused=getFocusedChild();\n  if (focused != null && anchorInfo.isViewValidAsAnchor(focused,state)) {\n    anchorInfo.assignFromViewAndKeepVisibleRect(focused);\n    return true;\n  }\n  View referenceChild=anchorInfo.mLayoutFromEnd ? findReferenceChildClosestToEnd(state) : findReferenceChildClosestToStart(state);\n  if (referenceChild != null) {\n    anchorInfo.assignFromView(referenceChild);\n    if (!state.isPreLayout() && supportsPredictiveItemAnimations()) {\n      final boolean notVisible=mOrientationHelper.getDecoratedStart(referenceChild) >= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(referenceChild) < mOrientationHelper.getStartAfterPadding();\n      if (notVisible) {\n        anchorInfo.mCoordinate=anchorInfo.mLayoutFromEnd ? mOrientationHelper.getEndAfterPadding() : mOrientationHelper.getStartAfterPadding();\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "nl": "Finds an anchor child from existing Views. Most of the time, this is the view closest to start or end that has a valid position (e.g. not removed). <p> If a child has focus, it is given priority."}
{"code": "@SuppressWarnings(\"rawtypes\") public Iterator<T> preorder(){\n  if (root == null) {\n    return empty();\n  }\n  return new ValueExtractor<T>(new PreorderTraversal(root));\n}\n", "nl": "Use pre-order traversal over the tree."}
{"code": "public void update(final double key,final U value){\n  update(Util.doubleToLongArray(key),value);\n}\n", "nl": "Updates this sketch with a double key and U value. The value is passed to update() method of the Summary object associated with the key"}
{"code": "public void write(String text,int offset,int length){\n  buffer.append(text.substring(offset,offset + length));\n}\n", "nl": "Write a portion of a string."}
{"code": "public boolean endpointIsDiscovered(String key){\n  String value=getEndpointsMap().get(key.toUpperCase());\n  if (value == null) {\n    return false;\n  }\n  return new Boolean(value);\n}\n", "nl": "Returns true if the endpoint specified was discovered"}
{"code": "@Override public void executionUnitImported(final ExecutionUnit process,final Element element){\n  NodeList children=element.getChildNodes();\n  children=element.getChildNodes();\n  for (int i=0; i < children.getLength(); i++) {\n    Node child=children.item(i);\n    if (child instanceof Element) {\n      Element backgroundElement=(Element)child;\n      if (XML_TAG_BACKGROUND.equals(backgroundElement.getTagName())) {\n        String xStr=backgroundElement.getAttribute(XML_ATTRIBUTE_X_POSITION);\n        String yStr=backgroundElement.getAttribute(XML_ATTRIBUTE_Y_POSITION);\n        String wStr=backgroundElement.getAttribute(XML_ATTRIBUTE_WIDTH);\n        String hStr=backgroundElement.getAttribute(XML_ATTRIBUTE_HEIGHT);\n        String imgLocStr=backgroundElement.getAttribute(XML_ATTRIBUTE_LOCATION);\n        try {\n          int xLoc=Integer.parseInt(xStr);\n          int yLoc=Integer.parseInt(yStr);\n          int wLoc=Integer.parseInt(wStr);\n          int hLoc=Integer.parseInt(hStr);\n          ProcessBackgroundImage bgImg=new ProcessBackgroundImage(xLoc,yLoc,wLoc,hLoc,imgLocStr,process);\n          setBackgroundImage(bgImg);\n        }\n catch (        NullPointerException|IllegalArgumentException e) {\n        }\n      }\n    }\n  }\n}\n", "nl": "Extracts port spacings from the XML element."}
{"code": "public boolean init(){\n  BufferedReader fin=null;\n  String modelFile=taggerOpt.modelDir + File.separator + taggerOpt.modelFile;\n  try {\n    fin=new BufferedReader(new InputStreamReader(new FileInputStream(modelFile),\"UTF-8\"));\n    taggerMaps.readCpMaps(fin);\n    System.gc();\n    taggerMaps.readLbMaps(fin);\n    System.gc();\n    taggerDict.readDict(fin);\n    System.gc();\n    taggerFGen.readFeatures(fin);\n    System.gc();\n    fin.close();\n  }\n catch (  IOException e) {\n    System.out.println(\"Couldn't open model file: \" + modelFile);\n    System.out.println(e.toString());\n    return false;\n  }\n  if (lambda == null) {\n    int numFeatures=taggerFGen.numFeatures();\n    lambda=new double[numFeatures];\n    for (int i=0; i < numFeatures; i++) {\n      Feature f=(Feature)taggerFGen.features.get(i);\n      lambda[f.idx]=f.wgt;\n    }\n  }\n  if (taggerVtb != null) {\n    taggerVtb.init(this);\n  }\n  return true;\n}\n", "nl": "Inits the."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "@Override final public boolean isKeys(){\n  return true;\n}\n", "nl": "Instances are searchable and support duplicate keys."}
{"code": "public RuntimeMBeanException(java.lang.RuntimeException e){\n  super();\n  runtimeException=e;\n}\n", "nl": "Creates a <CODE>RuntimeMBeanException</CODE> that wraps the actual <CODE>java.lang.RuntimeException</CODE>."}
{"code": "public static File convertToRelativePath(File absolute) throws Exception {\n  File result;\n  String fileStr;\n  result=null;\n  if (File.separator.equals(\"\\\\\")) {\n    try {\n      fileStr=absolute.getPath();\n      fileStr=fileStr.substring(0,1).toLowerCase() + fileStr.substring(1);\n      result=createRelativePath(new File(fileStr));\n    }\n catch (    Exception e) {\n      result=createRelativePath(absolute);\n    }\n  }\n else {\n    result=createRelativePath(absolute);\n  }\n  return result;\n}\n", "nl": "Converts a File's absolute path to a path relative to the user (ie start) directory. Includes an additional workaround for Cygwin, which doesn't like upper case drive letters."}
{"code": "public void updateRecordSoft(int id) throws IOException {\n  if (!database.isOpen())   throw new IllegalStateException(\"don't access the table before opening the database\");\n  if (hardWriteMode)   throw new IllegalStateException(\"soft write attempted during hard write mode\");\n  if (id > lastTransactionInsertId)   throw new IllegalStateException(\"attempt to update a row past the last inserted row\");\n  if (id >= committedNextRowId)   return;\n  if (softModeSavedRows.get(id,false))   return;\n  softModeSavedRows.put(id,true);\nsynchronized (this) {\n    getRecord(tempRecordData,id);\n  }\n  Util.writeInt(rollBackOut,id);\n  rollBackOut.write(tempRecordData);\n}\n", "nl": "Both a soft write and a hard write must be done in order to update a record. All soft writes for a transaction must be done, then a soft commit and finally hard writes are performed. Hard writes must write to the same rows that the soft writes did."}
{"code": "private synchronized void reinitialize(){\n  if (plot == null) {\n    initializePlot();\n  }\n else {\n    final ActionEvent ev=new ActionEvent(this,ActionEvent.ACTION_PERFORMED,OVERVIEW_REFRESHING);\n    for (    ActionListener actionListener : actionListeners) {\n      actionListener.actionPerformed(ev);\n    }\n  }\n  for (  Pair<Element,Visualization> pair : vistoelem.values()) {\n    SVGUtil.removeFromParent(pair.first);\n  }\n  plotmap=arrangeVisualizations(ratio,1.0);\n  recalcViewbox();\n  final int thumbsize=(int)Math.max(screenwidth / plotmap.getWidth(),screenheight / plotmap.getHeight());\n  LayerMap oldlayers=vistoelem;\n  vistoelem=new LayerMap();\n  SVGUtil.removeFromParent(plotlayer);\n  SVGUtil.removeFromParent(hoverlayer);\n  plotlayer=plot.svgElement(SVGConstants.SVG_G_TAG);\n  hoverlayer=plot.svgElement(SVGConstants.SVG_G_TAG);\n  hoverlayer.setAttribute(SVGPlot.NO_EXPORT_ATTRIBUTE,SVGPlot.NO_EXPORT_ATTRIBUTE);\n  for (  Entry<PlotItem,double[]> e : plotmap.entrySet()) {\n    final double basex=e.getValue()[0];\n    final double basey=e.getValue()[1];\n    for (Iterator<PlotItem> iter=e.getKey().itemIterator(); iter.hasNext(); ) {\n      PlotItem it=iter.next();\n      boolean hasDetails=false;\n      Element g=plot.svgElement(SVGConstants.SVG_G_TAG);\n      SVGUtil.setAtt(g,SVGConstants.SVG_TRANSFORM_ATTRIBUTE,\"translate(\" + (basex + it.x) + \" \"+ (basey + it.y)+ \")\");\n      plotlayer.appendChild(g);\n      vistoelem.put(it,null,g,null);\n      for (      VisualizationTask task : it.tasks) {\n        if (!visibleInOverview(task)) {\n          continue;\n        }\n        hasDetails|=!task.hasAnyFlags(VisualizationTask.FLAG_NO_DETAIL);\n        Pair<Element,Visualization> pair=oldlayers.remove(it,task);\n        if (pair == null) {\n          pair=new Pair<>(null,null);\n          pair.first=plot.svgElement(SVGConstants.SVG_G_TAG);\n        }\n        if (pair.second == null) {\n          pair.second=embedOrThumbnail(thumbsize,it,task,pair.first);\n        }\n        g.appendChild(pair.first);\n        vistoelem.put(it,task,pair);\n      }\n      if (hasDetails && !single) {\n        Element hover=plot.svgRect(basex + it.x,basey + it.y,it.w,it.h);\n        SVGUtil.addCSSClass(hover,selcss.getName());\n        EventTarget targ=(EventTarget)hover;\n        targ.addEventListener(SVGConstants.SVG_MOUSEOVER_EVENT_TYPE,hoverer,false);\n        targ.addEventListener(SVGConstants.SVG_MOUSEOUT_EVENT_TYPE,hoverer,false);\n        targ.addEventListener(SVGConstants.SVG_CLICK_EVENT_TYPE,hoverer,false);\n        targ.addEventListener(SVGConstants.SVG_CLICK_EVENT_TYPE,new SelectPlotEvent(it),false);\n        hoverlayer.appendChild(hover);\n      }\n    }\n  }\n  for (  Pair<Element,Visualization> pair : oldlayers.values()) {\n    if (pair.second != null) {\n      pair.second.destroy();\n    }\n  }\n  plot.getRoot().appendChild(plotlayer);\n  plot.getRoot().appendChild(hoverlayer);\n  plot.updateStyleElement();\n  final ActionEvent ev=new ActionEvent(this,ActionEvent.ACTION_PERFORMED,OVERVIEW_REFRESHED);\n  for (  ActionListener actionListener : actionListeners) {\n    actionListener.actionPerformed(ev);\n  }\n}\n", "nl": "Refresh the overview plot."}
{"code": "public final int actualNumClasses(int bagIndex){\n  int returnValue=0;\n  int i;\n  for (i=0; i < m_perClass.length; i++) {\n    if (Utils.gr(m_perClassPerBag[bagIndex][i],0)) {\n      returnValue++;\n    }\n  }\n  return returnValue;\n}\n", "nl": "Returns number of classes actually occuring in given bag."}
{"code": "private int scanForEqualItem(final int pStart,final int pEnd,final int pGuess,final T pItem,final boolean pReturnSequenceEndIfNoEqualItemFound){\n  int i=pGuess - 1;\n  while ((i >= pStart) && (pItem.compareTo(this.mList.get(i)) == 0)) {\n    i--;\n  }\n  i++;\n  while (i < pEnd) {\n    final T item=this.mList.get(i);\n    if (i <= pGuess) {\n      if (pItem.equals(item)) {\n        return i;\n      }\n    }\n else {\n      if (pItem.compareTo(item) == 0) {\n        if (pItem.equals(item)) {\n          return i;\n        }\n      }\n else {\n        return ListUtils.encodeInsertionIndex(i);\n      }\n    }\n    i++;\n  }\n  if (pReturnSequenceEndIfNoEqualItemFound) {\n    return i;\n  }\n else {\n    return SortedList.INDEX_INVALID;\n  }\n}\n", "nl": "Scans for items around <code>pGuess</code> that fulfill <code>pItem.compareTo(item) == 0</code> and starting from the leftmost found, it returns the index of the first one that fulfills <code>pItem.equals(item)</code>."}
{"code": "private String[] parseCommand(String command){\n  if (command.startsWith(\"search\")) {\n    return command.trim().split(\" \",2);\n  }\n else   if (command.startsWith(\"create\")) {\n    return command.trim().split(\" \",3);\n  }\n else   if (command.startsWith(\"upload\")) {\n    return command.trim().split(\" \",3);\n  }\n  return command.trim().split(\" \");\n}\n", "nl": "Parses the command entered by the user into individual arguments."}
{"code": "public void addFrame(CCSpriteFrame frame){\n  frames_.add(frame);\n}\n", "nl": "Adds a frame to a CCAnimation."}
{"code": "private void layoutFrame(){\n  frame.setTitle(Messages.getString(\"MegaMek.SkinEditor.label\") + Messages.getString(\"ClientGUI.clientTitleSuffix\"));\n  frame.getContentPane().setLayout(new BorderLayout());\n  frame.getContentPane().add(this,BorderLayout.CENTER);\n  frame.validate();\n}\n", "nl": "Lays out the frame by setting this Client object to take up the full frame display area."}
{"code": "@SuppressWarnings(\"unchecked\") public static <T extends Packet>void registerOutListener(final Class<T> type,Player player,Predicate<T> listener){\n  NetworkManagerWrapper wrapper=wrapNetworkManager(player);\n  wrapper.registerOutgoingListener(type,listener);\n}\n", "nl": "Register a listener for an incoming packet type. The type may be abstract. The listeners registered will be fired in the inverse order that they were registered; last fired first, and the first fired last (with the default server handler last). Listeners that return false will not fire any other handlers afterwards. Also, remember packets are handled in a separate thread! Make sure to use schedulers if you need to call Bukkit-related code, or just synchronize your listener implementation (avoid blocking). This method also requires that the player's network manager to be wrapper first. If it is not already wrapped, this will be done first. This only works for outgoing (client-bound) packets."}
{"code": "public int maximumGap(int[] num){\n  if (num == null || num.length < 2)   return 0;\n  int n=num.length;\n  int min=num[0];\n  int max=num[0];\n  for (  int i : num) {\n    max=Math.max(max,i);\n    min=Math.min(min,i);\n  }\n  double dist=(double)(max - min) / (n - 1);\n  int[] uppers=new int[n - 1];\n  int[] lowers=new int[n - 1];\n  Arrays.fill(uppers,-1);\n  Arrays.fill(lowers,-1);\n  for (  int i : num) {\n    int idx=(i == max ? n - 2 : (int)((i - min) / dist));\n    if (lowers[idx] == -1 || i < lowers[idx])     lowers[idx]=i;\n    if (uppers[idx] == -1 || i > uppers[idx])     uppers[idx]=i;\n  }\n  int prevUpper=uppers[0];\n  int maxGap=uppers[0] - lowers[0];\n  for (int i=1; i < n - 1; i++) {\n    if (lowers[i] == -1)     continue;\n    maxGap=Math.max(maxGap,lowers[i] - prevUpper);\n    prevUpper=uppers[i];\n  }\n  return maxGap;\n}\n", "nl": "O(n) Time, O(n) Space Find max and min in one traverse Calculate bucket length and divide numbers into buckets Traverse buckets to find max gap"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_ptr_webview);\n  mPullRefreshWebView=(PullToRefreshWebView)findViewById(R.id.pull_refresh_webview);\n  mWebView=mPullRefreshWebView.getRefreshableView();\n  mWebView.getSettings().setJavaScriptEnabled(true);\n  mWebView.setWebViewClient(new SampleWebViewClient());\n  mWebView.loadUrl(\"http://www.google.com\");\n}\n", "nl": "Called when the activity is first created."}
{"code": "private void calculateItemFittingMetadata(int width){\n  int maxNumItemsPerRow=mMaxItemsPerRow;\n  int numItems=getChildCount();\n  for (int i=0; i < numItems; i++) {\n    LayoutParams lp=(LayoutParams)getChildAt(i).getLayoutParams();\n    lp.maxNumItemsOnRow=1;\n    for (int curNumItemsPerRow=maxNumItemsPerRow; curNumItemsPerRow > 0; curNumItemsPerRow--) {\n      if (lp.desiredWidth < width / curNumItemsPerRow) {\n        lp.maxNumItemsOnRow=curNumItemsPerRow;\n        break;\n      }\n    }\n  }\n}\n", "nl": "For each item, calculates the most dense row that fully shows the item's title."}
{"code": "public boolean releaseRow(int row){\n  if (row < 0) {\n    return false;\n  }\n else   if (m_openrows != null && m_openrows.containsKey(row)) {\n    return false;\n  }\n else   if (row == m_curid) {\n    --m_curid;\n  }\n else   if (row == m_firstid) {\n    ++m_firstid;\n  }\n else {\n    if (m_openrows == null)     m_openrows=new IntIntTreeMap(false);\n    m_openrows.put(row,row);\n  }\n  return true;\n}\n", "nl": "Release a row and mark it as free."}
{"code": "protected void addReactionPropertyDescriptor(Object object){\n  itemPropertyDescriptors.add(createItemPropertyDescriptor(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),getResourceLocator(),getString(\"_UI_ReactionFired_reaction_feature\"),getString(\"_UI_PropertyDescriptor_description\",\"_UI_ReactionFired_reaction_feature\",\"_UI_ReactionFired_type\"),SexecPackage.Literals.REACTION_FIRED__REACTION,true,false,true,null,null,null));\n}\n", "nl": "This adds a property descriptor for the Reaction feature. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void main(String[] args){\n  Scanner input=new Scanner(System.in);\n  int[] numbers=new int[5];\n  System.out.print(\"Enter five numbers: \");\n  for (int i=0; i < numbers.length; i++) {\n    numbers[i]=input.nextInt();\n  }\n  System.out.println(\"The greatest common divisor is \" + gcd(numbers));\n}\n", "nl": "Main method"}
{"code": "public int addHistogramPlot(String name,Color color,double[] sample,int n){\n  return ((Plot2DCanvas)plotCanvas).addHistogramPlot(name,color,sample,n);\n}\n", "nl": "Adds a plot of the statistical repartition of a sample, as a histogram."}
{"code": "public String go(){\n  StringWriter sw=new StringWriter();\n  try {\n    go(sw);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n  return sw.toString();\n}\n", "nl": "Writes the iCalendar objects to a string."}
{"code": "public static String normalizeUnsignedLong(String value){\n  return normalizeIntegerValue(value,\"0\",\"18446744073709551615\");\n}\n", "nl": "Normalizes an xsd:unsignedLong."}
{"code": "public ReceiveMessageResult receiveMessage(String queueUrl){\n  ReceiveMessageRequest receiveMessageRequest=new ReceiveMessageRequest(queueUrl);\n  return receiveMessage(receiveMessageRequest);\n}\n", "nl": "<p> Retrieves one or more messages, with a maximum limit of 10 messages, from the specified queue. Downloads the message payloads from Amazon S3 when necessary. Long poll support is enabled by using the <code>WaitTimeSeconds</code> parameter. For more information, see <a href= \"http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html\" > Amazon SQS Long Poll </a> in the <i>Amazon SQS Developer Guide</i> . </p> <p> Short poll is the default behavior where a weighted random set of machines is sampled on a <code>ReceiveMessage</code> call. This means only the messages on the sampled machines are returned. If the number of messages in the queue is small (less than 1000), it is likely you will get fewer messages than you requested per <code>ReceiveMessage</code> call. If the number of messages in the queue is extremely small, you might not receive any messages in a particular <code>ReceiveMessage</code> response; in which case you should repeat the request. </p> <p> For each message returned, the response includes the following: </p> <ul> <li> <p> Message body </p> </li> <li> <p> MD5 digest of the message body. For information about MD5, go to <a href=\"http://www.faqs.org/rfcs/rfc1321.html\"> http://www.faqs.org/rfcs/rfc1321.html </a> . </p> </li> <li> <p> Message ID you received when you sent the message to the queue. </p> </li> <li> <p> Receipt handle. </p> </li> <li> <p> Message attributes. </p> </li> <li> <p> MD5 digest of the message attributes. </p> </li> </ul> <p> The receipt handle is the identifier you must provide when deleting the message. For more information, see <a href= \"http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/ImportantIdentifiers.html\" > Queue and Message Identifiers </a> in the <i>Amazon SQS Developer Guide</i> . </p> <p> You can provide the <code>VisibilityTimeout</code> parameter in your request, which will be applied to the messages that Amazon SQS returns in the response. If you do not include the parameter, the overall visibility timeout for the queue is used for the returned messages. For more information, see <a href= \"http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html\" > Visibility Timeout </a> in the <i>Amazon SQS Developer Guide</i> . </p> <p> <b>NOTE:</b> Going forward, new attributes might be added. If you are writing code that calls this action, we recommend that you structure your code so that it can handle new attributes gracefully. </p>"}
{"code": "public void finish() throws IOException {\n  if (done) {\n    return;\n  }\n  def.finish();\n  while (!def.finished()) {\n    int byteCount=def.deflate(buf);\n    out.write(buf,0,byteCount);\n  }\n  done=true;\n}\n", "nl": "Writes any unwritten data to the underlying stream. Does not close the stream."}
{"code": "@Override protected MoveResult doTask() throws Exception {\n  e.start();\n  BuildResult historicalWritesBuildResult=null;\n  try {\n    if (resourceManager.isOverflowAllowed())     throw new IllegalStateException();\n    try {\n      final ILocalBTreeView src=getIndex(vmd.name);\n      historicalWritesBuildResult=resourceManager.buildIndexSegment(vmd.name,src,true,vmd.commitTime,null,null,e);\n      if (INFO)       log.info(\"Generated compact index segment from historical view: \" + historicalWritesBuildResult);\n    }\n  finally {\n      clearRefs();\n    }\n    final MoveResult moveResult=doAtomicUpdate(resourceManager,vmd.name,historicalWritesBuildResult,targetDataServiceUUID,newPartitionId,e);\n    if (INFO)     log.info(\"Successfully moved index partition: \" + summary);\n    return moveResult;\n  }\n  finally {\n    if (historicalWritesBuildResult != null) {\n      resourceManager.retentionSetRemove(historicalWritesBuildResult.segmentMetadata.getUUID());\n      resourceManager.deleteResource(historicalWritesBuildResult.segmentMetadata.getUUID(),false);\n    }\n    e.end();\n  }\n}\n", "nl": "Builds a compact index segment from the historical view as of the last commit time on the old journal and then submits an atomic update operation to move the source index partition to the target data service."}
{"code": "public void error(ServiceCoded sc){\n  if (sc != null) {\n    setServiceCode(sc.getServiceCode().getCode());\n    setMessage(sc.getMessage());\n  }\n  updateStatus(Status.error.name());\n  if (sc instanceof Exception) {\n    _log.info(\"Setting operation to error due to an exception {}\",ExceptionUtils.getExceptionMessage((Exception)sc));\n    _log.info(\"Caused by: {} \",(Exception)sc);\n  }\n}\n", "nl": "This method sets the status of the operation to \"error\""}
{"code": "@Bean public ObjectMapper objectMapper(){\n  return new ObjectMapper();\n}\n", "nl": "Jackson ObjectMapper"}
{"code": "public static byte[] reverseBytes(byte[] bytes){\n  byte[] buf=new byte[bytes.length];\n  for (int i=0; i < bytes.length; i++)   buf[i]=bytes[bytes.length - 1 - i];\n  return buf;\n}\n", "nl": "Returns a copy of the given byte array in reverse order."}
{"code": "public void quit(){\n  mQuit=true;\n  interrupt();\n}\n", "nl": "Forces this dispatcher to quit immediately.  If any requests are still in the queue, they are not guaranteed to be processed."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  Show s=getShow(stack);\n  if (s == null)   return new Float(0);\n  String rating=s.getRating();\n  if (rating == null)   return new Float(0);\n  float f=0;\n  for (int i=0; i < rating.length(); i++) {\n    if (rating.charAt(i) == '*')     f=f + 1.0f;\n else     if (rating.charAt(i) == '+')     f=f + 0.5f;\n  }\n  return new Float(f);\n}\n", "nl": "Returns the star rating for a Movie as a floating point number."}
{"code": "public XObject operate(XObject right) throws javax.xml.transform.TransformerException {\n  return (XString)right.xstr();\n}\n", "nl": "Apply the operation to two operands, and return the result."}
{"code": "protected void prepare(){\n  for (  ProcessInfoParameter para : getParameter()) {\n    String name=para.getParameterName();\n    if (para.getParameter() == null)     ;\n else     if (name.equals(PARAM_M_Warehouse_ID))     p_M_Warehouse_ID=para.getParameterAsInt();\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n  p_C_Invoice_ID=getRecord_ID();\n}\n", "nl": "Prepare - e.g., get Parameters."}
{"code": "@Deprecated public static File createTempDir() throws IOException {\n  return DefaultGroovyStaticMethods.createTempDir(null);\n}\n", "nl": "Creates a temporary directory in the default temporary directory (as specified by the system property <i>java.io.tmpdir</i>."}
{"code": "protected void fireTradeOrderStatusChanged(TradeOrder tradeOrder){\n  Object[] listeners=this.listenerList.getListenerList();\n  for (int i=listeners.length - 2; i >= 0; i-=2) {\n    if (listeners[i] == BrokerChangeListener.class) {\n      ((BrokerChangeListener)listeners[i + 1]).tradeOrderStatusChanged(tradeOrder);\n    }\n  }\n}\n", "nl": "Notifies all registered listeners that the brokerManagerModel has opened a trade position."}
{"code": "public ContentEncodingParser(String contentEncoding){\n  super(contentEncoding);\n}\n", "nl": "Creates a new instance of ContentEncodingParser"}
{"code": "public boolean isCreateField(){\n  return fCreateField;\n}\n", "nl": "Returns whether the field will be moved to extracted class. The default is <code>true</code>"}
{"code": "public static BigDecimal paidToDate(int p_C_Invoice_ID,int p_C_Currency_ID,int p_MultiplierAP,Timestamp DateAcct) throws SQLException {\n  if (p_C_Invoice_ID == 0 || p_C_Currency_ID == 0)   return null;\n  BigDecimal MultiplierAP=new BigDecimal((double)p_MultiplierAP);\n  if (p_MultiplierAP == 0)   MultiplierAP=Adempiere.ONE;\n  int C_ConversionType_ID=0;\n  BigDecimal paymentAmt=allocatedAmtToDate(p_C_Invoice_ID,p_C_Currency_ID,C_ConversionType_ID,MultiplierAP,DateAcct);\n  return Currency.round(paymentAmt,p_C_Currency_ID,null);\n}\n", "nl": "Get Invoice paid(allocated) amount. - invoicePaid"}
{"code": "public static void main(String... a) throws Exception {\n  TestBase.createCaller().init().test();\n}\n", "nl": "Run just this test."}
{"code": "public ExtractConstantRefactoring(ICompilationUnit unit,int selectionStart,int selectionLength){\n  Assert.isTrue(selectionStart >= 0);\n  Assert.isTrue(selectionLength >= 0);\n  fSelectionStart=selectionStart;\n  fSelectionLength=selectionLength;\n  fCu=unit;\n  fCuRewrite=null;\n  fLinkedProposalModel=null;\n  fConstantName=\"\";\n  fCheckResultForCompileProblems=true;\n}\n", "nl": "Creates a new extract constant refactoring"}
{"code": "public AuthenticationInfo(){\n  super(NAME);\n  parameters.setSeparator(COMMA);\n}\n", "nl": "Default contstructor."}
{"code": "public AsyncResult CreateMonitoredItemsAsync(RequestHeader RequestHeader,UnsignedInteger SubscriptionId,TimestampsToReturn TimestampsToReturn,MonitoredItemCreateRequest... ItemsToCreate){\n  CreateMonitoredItemsRequest req=new CreateMonitoredItemsRequest(RequestHeader,SubscriptionId,TimestampsToReturn,ItemsToCreate);\n  return channel.serviceRequestAsync(req);\n}\n", "nl": "Asynchronous CreateMonitoredItems service request."}
{"code": "public LogbackFactoryAccessor(ClassLoader cl) throws ClassNotFoundException, IllegalAccessException, InvocationTargetException {\n  Class clazz=cl.loadClass(\"org.slf4j.impl.StaticLoggerBinder\");\n  Method getSingleton=MethodUtils.getAccessibleMethod(clazz,\"getSingleton\",new Class[0]);\n  Object singleton=getSingleton.invoke(null);\n  Method getLoggerFactory=MethodUtils.getAccessibleMethod(clazz,\"getLoggerFactory\",new Class[0]);\n  Object loggerFactory=getLoggerFactory.invoke(singleton);\n  Class loggerFactoryClass=cl.loadClass(\"ch.qos.logback.classic.LoggerContext\");\n  if (!loggerFactoryClass.isInstance(loggerFactory)) {\n    throw new RuntimeException(\"The singleton SLF4J binding was not Logback\");\n  }\n  setTarget(loggerFactory);\n}\n", "nl": "Attempts to initialize a Logback logger factory via the given class loader."}
{"code": "public long toLong(){\n  return m_value.longValue();\n}\n", "nl": "Returns the long value of the address."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:34:28.581 -0500\",hash_original_method=\"34D447B50A8BF0311FD91158BAB8271D\",hash_generated_method=\"629A4461D3844C6A125DAA9A9D517CBA\") public PeriodicSync(Account account,String authority,Bundle extras,long period){\n  this.account=account;\n  this.authority=authority;\n  this.extras=new Bundle(extras);\n  this.period=period;\n}\n", "nl": "Creates a new PeriodicSync, copying the Bundle"}
{"code": "public boolean isPacked(){\n  String ext=getExtension().toLowerCase();\n  return (ext.equals(\"zip\") || ext.equals(\"rar\") || ext.equals(\"7z\")|| ext.matches(\"r\\\\d+\"));\n}\n", "nl": "is this a \"packed\" file? (zip, rar, whatsoever)."}
{"code": "public QQPlotDisplayPanel(QQPlot qqPlot){\n  this.qqPlot=qqPlot;\n  if (qqPlot == null) {\n    throw new NullPointerException(\"Given q-q plot must be null\");\n  }\n  this.addMouseMotionListener(new MouseMovementListener());\n  this.setToolTipText(\" \");\n}\n", "nl": "Constructs the histogram dipslay panel given the initial histogram to display."}
{"code": "private static JFreeChart createLineChart3D(){\n  Number[][] data=new Integer[][]{{new Integer(-3),new Integer(-2)},{new Integer(-1),new Integer(1)},{new Integer(2),new Integer(3)}};\n  CategoryDataset dataset=DatasetUtilities.createCategoryDataset(\"S\",\"C\",data);\n  return ChartFactory.createLineChart3D(\"Line Chart\",\"Domain\",\"Range\",dataset);\n}\n", "nl": "Create a line chart with sample data in the range -3 to +3."}
{"code": "public void complement(){\n  assert (opMode == Mode.POLAR_DENSE);\n  char t=(char)(CircleLookupTable.PHASE_RESOLUTION / 2);\n  for (int i=0; i < dimension; i++)   phaseAngles[i]+=t;\n}\n", "nl": "Transforms this vector into its complement. Assumes vector is in dense polar form."}
{"code": "public static JBBPOut BeginBin(final OutputStream out){\n  return new JBBPOut(out,DEFAULT_BYTE_ORDER,DEFAULT_BIT_ORDER);\n}\n", "nl": "Start a DSL session for a defined output stream and default parameters."}
{"code": "public static String unquoteIfJavaKeyword(String name){\n  String unquoted=unquote(name);\n  if (isJavaKeyword(unquoted))   return unquoted;\n  return name;\n}\n", "nl": "Removes dollar ($) prefix from the given name if it was a quoted Java keyword"}
{"code": "public static void assertJPost(String request,String content,String... tests) throws Exception {\n  assertJPost(request,content,JSONTestUtil.DEFAULT_DELTA,tests);\n}\n", "nl": "Validates the response from a POST request matches some JSON test expressions"}
{"code": "public FBXAException(String msg,int errorCode,Exception reason){\n  this(msg,errorCode);\n  this.reason=reason;\n  initCause(reason);\n}\n", "nl": "Create a new instance of <code>FBXAException</code> based around a message and with an underlying exception."}
{"code": "public void clear() throws SchedulerException {\n  try {\n    getRemoteScheduler().clear();\n  }\n catch (  RemoteException re) {\n    throw invalidateHandleCreateException(\"Error communicating with remote scheduler.\",re);\n  }\n}\n", "nl": "<p> Calls the equivalent method on the 'proxied' <code>QuartzScheduler</code>. </p>"}
{"code": "public void sendMessage(SIPMessage sipMessage) throws IOException {\n  long time=System.currentTimeMillis();\n  this.sendMessage(sipMessage,true);\n  if (this.sipStack.getStackLogger().isLoggingEnabled(ServerLogger.TRACE_MESSAGES))   logMessage(sipMessage,peerAddress,peerPort,time);\n}\n", "nl": "Return a formatted message to the client. We try to re-connect with the peer on the other end if possible."}
{"code": "public static boolean validateCardNumber(String cardNumber) throws NumberFormatException {\n  int sum=0, digit, addend=0;\n  boolean doubled=false;\n  for (int i=cardNumber.length() - 1; i >= 0; i--) {\n    digit=Integer.parseInt(cardNumber.substring(i,i + 1));\n    if (doubled) {\n      addend=digit * 2;\n      if (addend > 9) {\n        addend-=9;\n      }\n    }\n else {\n      addend=digit;\n    }\n    sum+=addend;\n    doubled=!doubled;\n  }\n  return (sum % 10) == 0;\n}\n", "nl": "Validates the credit card number using the Luhn algorithm"}
{"code": "private int addEntry(E entry){\n  entries[numEntries++]=entry;\n  return numEntries - 1;\n}\n", "nl": "Adds the specified entry to the entries array and increases the numEntries counter."}
{"code": "private static File createTempFileInSameDirectoryAs(File file) throws IOException {\n  File dir=file.getParentFile();\n  if (dir == null)   dir=new File(\".\");\n  return File.createTempFile(\"jartmp\",null,dir);\n}\n", "nl": "Creates a new empty temporary file in the same directory as the specified file.  A variant of File.createTempFile."}
{"code": "public void testGetLocalName() throws Throwable {\n  Document doc;\n  Element element;\n  Element qelement;\n  Attr attr;\n  Attr qattr;\n  String localElemName;\n  String localQElemName;\n  String localAttrName;\n  String localQAttrName;\n  doc=(Document)load(\"staff\",builder);\n  element=doc.createElementNS(\"http://www.w3.org/DOM/Test/elem\",\"elem\");\n  qelement=doc.createElementNS(\"http://www.w3.org/DOM/Test/elem\",\"qual:qelem\");\n  attr=doc.createAttributeNS(\"http://www.w3.org/DOM/Test/attr\",\"attr\");\n  qattr=doc.createAttributeNS(\"http://www.w3.org/DOM/Test/attr\",\"qual:qattr\");\n  localElemName=element.getLocalName();\n  localQElemName=qelement.getLocalName();\n  localAttrName=attr.getLocalName();\n  localQAttrName=qattr.getLocalName();\n  assertEquals(\"nodegetlocalname03_localElemName\",\"elem\",localElemName);\n  assertEquals(\"nodegetlocalname03_localQElemName\",\"qelem\",localQElemName);\n  assertEquals(\"nodegetlocalname03_localAttrName\",\"attr\",localAttrName);\n  assertEquals(\"nodegetlocalname03_localQAttrName\",\"qattr\",localQAttrName);\n}\n", "nl": "Runs the test case."}
{"code": "public int start_state(){\n  return 0;\n}\n", "nl": "Indicates start state."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public int size(){\n  return (tail - head) & (elements.length - 1);\n}\n", "nl": "Returns the number of elements in this deque."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(nodetextnodename.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-03-25 14:54:54.299 -0400\",hash_original_method=\"CCEBFF7F71B5744B0502DA0F73CE72D0\",hash_generated_method=\"218E19485147294D1EFF0EB93065B0E0\") public void addMimeType(String mimeType){\n  mMimeTypeList.add(mimeType);\n}\n", "nl": "Adds the specified MIME type to the list of MIME types this DRM plug-in supports."}
{"code": "public static void main(final String[] args) throws IOException {\n  final File directory=new File(args[0]);\n  final SequencesReader sr=SequencesReaderFactory.createDefaultSequencesReader(directory);\n  final ReferenceGenome male=new ReferenceGenome(sr,Sex.MALE);\n  System.out.println(\"male\");\n  System.out.println(male.toString());\n  System.out.println();\n  final ReferenceGenome female=new ReferenceGenome(sr,Sex.FEMALE);\n  System.out.println(\"female\");\n  System.out.println(female.toString());\n  System.out.println();\n  final ReferenceGenome either=new ReferenceGenome(sr,Sex.EITHER);\n  System.out.println(\"either\");\n  System.out.println(either.toString());\n  System.out.println();\n}\n", "nl": "Check that a reference.txt file inside an SDF directory is valid for both male and female."}
{"code": "@NonNull public AuthorizationResponse build(){\n  return new AuthorizationResponse(mRequest,mState,mTokenType,mAuthorizationCode,mAccessToken,mAccessTokenExpirationTime,mIdToken,mScope,Collections.unmodifiableMap(mAdditionalParameters));\n}\n", "nl": "Builds the Authorization object."}
{"code": "public boolean isProcessed(){\n  Object oo=get_Value(COLUMNNAME_Processed);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Processed."}
{"code": "public AffineTransformation reflect(double x,double y){\n  compose(reflectionInstance(x,y));\n  return this;\n}\n", "nl": "Updates the value of this transformation to that of a reflection transformation composed  with the current value."}
{"code": "public synchronized void reset(){\n  m_elapsed=0;\n}\n", "nl": "Resets the timer back to zero"}
{"code": "public PtAccessibility(Scenario sc,List<Integer> distanceCluster,int quadrantSegments,SortedMap<String,List<String>> activityCluster,String targetCoordinateSystem,int gridSize){\n  super(PtAccessibility.class.getSimpleName());\n  this.scenario=sc;\n  this.quadrantSegments=quadrantSegments;\n  this.distanceCluster=createClusterCircles(distanceCluster,this.quadrantSegments);\n  this.activityCluster=activityCluster;\n  this.activityCluster.put(\"unknown\",new ArrayList<String>());\n  this.targetCoordinateSystem=targetCoordinateSystem;\n  this.gridSize=gridSize;\n}\n", "nl": "This module creates circles around all used TransitStops within the specified distances for all modes  and writes one shapefile per distance-cluster. After that the activities will be clustered as specified and written to a shapefile. Out of the processed data a csv-file is generated, containing a table of the relative number of stops per mode within  the specified clusters."}
{"code": "public List<String> header(String key){\n  return headers.get(key);\n}\n", "nl": "Get header of option"}
{"code": "public static Stats of(int... values){\n  StatsAccumulator acummulator=new StatsAccumulator();\n  acummulator.addAll(values);\n  return acummulator.snapshot();\n}\n", "nl": "Returns statistics over a dataset containing the given values."}
{"code": "@SuppressWarnings(\"deprecation\") static HttpUriRequest createHttpRequest(Request<?> request,Map<String,String> additionalHeaders) throws AuthFailureError {\nswitch (request.getMethod()) {\ncase Method.DEPRECATED_GET_OR_POST:\n{\n      byte[] postBody=request.getPostBody();\n      if (postBody != null) {\n        HttpPost postRequest=new HttpPost(request.getUrl());\n        postRequest.addHeader(HEADER_CONTENT_TYPE,request.getPostBodyContentType());\n        HttpEntity entity;\n        entity=new ByteArrayEntity(postBody);\n        postRequest.setEntity(entity);\n        return postRequest;\n      }\n else {\n        return new HttpGet(request.getUrl());\n      }\n    }\ncase Method.GET:\n  return new HttpGet(request.getUrl());\ncase Method.DELETE:\nreturn new HttpDelete(request.getUrl());\ncase Method.POST:\n{\nHttpPost postRequest=new HttpPost(request.getUrl());\npostRequest.addHeader(HEADER_CONTENT_TYPE,request.getBodyContentType());\nsetEntityIfNonEmptyBody(postRequest,request);\nreturn postRequest;\n}\ncase Method.PUT:\n{\nHttpPut putRequest=new HttpPut(request.getUrl());\nputRequest.addHeader(HEADER_CONTENT_TYPE,request.getBodyContentType());\nsetEntityIfNonEmptyBody(putRequest,request);\nreturn putRequest;\n}\ndefault :\nthrow new IllegalStateException(\"Unknown request method.\");\n}\n}\n", "nl": "Creates the appropriate subclass of HttpUriRequest for passed in request."}
{"code": "public boolean[] doFrustumCheck(Vector3D[] frustumCorners,Vector3D frustumPos,double x,double y,double z){\n  Vector3D point=new Vector3D(x,y,z);\n  boolean c1=crossPlane(new Vector3D[]{frustumPos,frustumCorners[3],frustumCorners[0]},point);\n  boolean c2=crossPlane(new Vector3D[]{frustumPos,frustumCorners[0],frustumCorners[1]},point);\n  boolean c3=crossPlane(new Vector3D[]{frustumPos,frustumCorners[1],frustumCorners[2]},point);\n  boolean c4=crossPlane(new Vector3D[]{frustumPos,frustumCorners[2],frustumCorners[3]},point);\n  return new boolean[]{c1,c2,c3,c4};\n}\n", "nl": "Performs a frustum check."}
{"code": "Attributes parseAttributes() throws JasperException {\n  AttributesImpl attrs=new AttributesImpl();\n  reader.skipSpaces();\n  while (parseAttribute(attrs))   reader.skipSpaces();\n  return attrs;\n}\n", "nl": "Attributes ::= (S Attribute)* S?"}
{"code": "public synchronized void sort(final Comparator<String[]> comparator){\n  Check.notNull(comparator,\"comparator\");\n  Collections.sort(rows,comparator);\n}\n", "nl": "Sort the rows already added to this table with the given comparator. Does not affect rows added later."}
{"code": "public final void printLongString(CharSequence text) throws IOException {\n  if (text == null) {\n    appendAscii(\"null.string\");\n  }\n else {\n    appendAscii(TRIPLE_QUOTES);\n    printCodePoints(text,LONG_STRING_ESCAPE_CODES);\n    appendAscii(TRIPLE_QUOTES);\n  }\n}\n", "nl": "Print an Ion triple-quoted string"}
{"code": "public ST createStringTemplateInternally(CompiledST impl){\n  ST st=createStringTemplate(impl);\n  if (trackCreationEvents && st.debugState != null) {\n    st.debugState.newSTEvent=null;\n  }\n  return st;\n}\n", "nl": "Differentiate so we can avoid having creation events for regions, map operations, and other implicit \"new ST\" events during rendering."}
{"code": "public WrongClassTypeException(String message){\n  super(message);\n}\n", "nl": "Create a new <code>WrongClassTypeException</code> with a message text."}
{"code": "public boolean isUnicast(){\n  return unicast;\n}\n", "nl": "Normally event sources are multicast.  However there are some exceptions that are strictly unicast."}
{"code": "public void register(Kryo kryo){\n  kryo.register(IAgentStorageService.class);\n  kryo.register(IAgentService.class);\n  kryo.register(IKeepAliveService.class);\n  kryo.register(RegisterTCP.class);\n  kryo.register(RegisterUDP.class);\n  kryo.register(KeepAlive.class);\n  kryo.register(DiscoverHost.class);\n  kryo.register(Ping.class);\n  ObjectSpace.registerClasses(kryo);\n}\n", "nl": "Registers needed classes for network communication."}
{"code": "public static void startFinalizer(Class<?> finalizableReferenceClass,ReferenceQueue<Object> queue,PhantomReference<Object> frqReference){\n  if (!finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE)) {\n    throw new IllegalArgumentException(\"Expected \" + FINALIZABLE_REFERENCE + \".\");\n  }\n  Finalizer finalizer=new Finalizer(finalizableReferenceClass,queue,frqReference);\n  Thread thread=new Thread(finalizer);\n  thread.setName(Finalizer.class.getName());\n  thread.setDaemon(true);\n  try {\n    if (inheritableThreadLocals != null) {\n      inheritableThreadLocals.set(thread,null);\n    }\n  }\n catch (  Throwable t) {\n    logger.log(Level.INFO,\"Failed to clear thread local values inherited by reference finalizer thread.\",t);\n  }\n  thread.start();\n}\n", "nl": "Starts the Finalizer thread. FinalizableReferenceQueue calls this method reflectively."}
{"code": "public void testProcessString() throws ChessParseError {\n  Game game=new Game(null,new TimeControlData());\n  assertEquals(TextIO.startPosFEN,TextIO.toFEN(game.currPos()));\n  boolean res=game.processString(\"Nf3\");\n  assertEquals(true,res);\n  assertEquals(1,game.currPos().halfMoveClock);\n  assertEquals(1,game.currPos().fullMoveCounter);\n  res=game.processString(\"d5\");\n  assertEquals(true,res);\n  assertEquals(0,game.currPos().halfMoveClock);\n  assertEquals(2,game.currPos().fullMoveCounter);\n  game.undoMove();\n  assertEquals(1,game.currPos().halfMoveClock);\n  assertEquals(1,game.currPos().fullMoveCounter);\n  game.undoMove();\n  assertEquals(TextIO.startPosFEN,TextIO.toFEN(game.currPos()));\n  game.undoMove();\n  assertEquals(TextIO.startPosFEN,TextIO.toFEN(game.currPos()));\n  game.redoMove();\n  assertEquals(1,game.currPos().halfMoveClock);\n  assertEquals(1,game.currPos().fullMoveCounter);\n  game.redoMove();\n  assertEquals(0,game.currPos().halfMoveClock);\n  assertEquals(2,game.currPos().fullMoveCounter);\n  game.redoMove();\n  assertEquals(0,game.currPos().halfMoveClock);\n  assertEquals(2,game.currPos().fullMoveCounter);\n  game.newGame();\n  assertEquals(TextIO.startPosFEN,TextIO.toFEN(game.currPos()));\n  String fen=\"8/8/8/4k3/8/8/2p5/5K2 b - - 47 68\";\n  Position pos=TextIO.readFEN(fen);\n  game.setPos(TextIO.readFEN(fen));\n  assertEquals(pos,game.currPos());\n  res=game.processString(\"junk\");\n  assertEquals(false,res);\n  game.newGame();\n  res=game.processString(\"e7e5\");\n  assertEquals(false,res);\n}\n", "nl": "Test of processString method, of class Game."}
{"code": "public Builder considerExifParams(boolean considerExifParams){\n  this.considerExifParams=considerExifParams;\n  return this;\n}\n", "nl": "Sets whether ImageLoader will consider EXIF parameters of JPEG image (rotate, flip)"}
{"code": "public static String encodeBase64URLSafeString(byte[] binaryData){\n  return org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(binaryData);\n}\n", "nl": "Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The url-safe variation emits - and _ instead of + and / characters."}
{"code": "public void init(int WindowNo,FormFrame frame){\n  log.info(\"\");\n  m_WindowNo=WindowNo;\n  m_frame=frame;\n  Env.setContext(Env.getCtx(),m_WindowNo,\"IsSOTrx\",\"Y\");\n  try {\n    super.dynInit();\n    dynInit();\n    jbInit();\n    frame.getContentPane().add(mainPanel,BorderLayout.CENTER);\n    frame.setSize(1000,400);\n  }\n catch (  Exception ex) {\n    log.log(Level.SEVERE,\"init\",ex);\n  }\n}\n", "nl": "Initialize Panel"}
{"code": "public boolean absolute(int row) throws SQLException {\n  if (row == 0 || getType() == ResultSet.TYPE_FORWARD_ONLY) {\n    throw new SQLException(resBundle.handleGetObject(\"cachedrowsetimpl.absolute\").toString());\n  }\n  if (row > 0) {\n    if (row > numRows) {\n      afterLast();\n      return false;\n    }\n else {\n      if (absolutePos <= 0)       internalFirst();\n    }\n  }\n else {\n    if (cursorPos + row < 0) {\n      beforeFirst();\n      return false;\n    }\n else {\n      if (absolutePos >= 0)       internalLast();\n    }\n  }\n  while (absolutePos != row) {\n    if (absolutePos < row) {\n      if (!internalNext())       break;\n    }\n else {\n      if (!internalPrevious())       break;\n    }\n  }\n  notifyCursorMoved();\n  if (isAfterLast() || isBeforeFirst()) {\n    return false;\n  }\n else {\n    return true;\n  }\n}\n", "nl": "Moves this <code>CachedRowSetImpl</code> object's cursor to the row number specified. <p>If the number is positive, the cursor moves to an absolute row with respect to the beginning of the rowset.  The first row is row 1, the second is row 2, and so on.  For example, the following command, in which <code>crs</code> is a <code>CachedRowSetImpl</code> object, moves the cursor to the fourth row, starting from the beginning of the rowset. <PRE><code> crs.absolute(4); </code> </PRE> <P> If the number is negative, the cursor moves to an absolute row position with respect to the end of the rowset.  For example, calling <code>absolute(-1)</code> positions the cursor on the last row, <code>absolute(-2)</code> moves it on the next-to-last row, and so on. If the <code>CachedRowSetImpl</code> object <code>crs</code> has five rows, the following command moves the cursor to the fourth-to-last row, which in the case of a  rowset with five rows, is also the second row, counting from the beginning. <PRE><code> crs.absolute(-4); </code> </PRE> If the number specified is larger than the number of rows, the cursor will move to the position after the last row. If the number specified would move the cursor one or more rows before the first row, the cursor moves to the position before the first row. <P> Note: Calling <code>absolute(1)</code> is the same as calling the method <code>first()</code>.  Calling <code>absolute(-1)</code> is the same as calling <code>last()</code>."}
{"code": "protected void resetCutOffDay(long supplAdminKey) throws Exception {\n  resetCutOffDay(supplAdminKey,UserRoleType.SERVICE_MANAGER);\n}\n", "nl": "Reset the cutoffDay for the given supplier organization"}
{"code": "public String toString(){\n  return imgInfo.toString() + \" interlaced=\" + interlaced;\n}\n", "nl": "Basic info, for debugging."}
{"code": "public void addRateLimit(RateLimitType type,long retryAfter){\n  addRateLimit(type,null,retryAfter);\n}\n", "nl": "Adds a rate limit for the given type."}
{"code": "public static void reinitiate(){\n  CLIENT_INSTANCE=new FrequencyGrid();\n  SERVER_INSTANCE=new FrequencyGrid();\n}\n", "nl": "Called to re-initiate the grid. Used when server restarts or when player rejoins a world to clean up previously registered objects."}
{"code": "@Override public void addValueAtIndex(final IScope scope,final Object index,final V value){\n  setValueAtIndex(scope,index,value);\n}\n", "nl": "Method add()"}
{"code": "public Object pop(){\n  return stack.pop();\n}\n", "nl": "Returns the latest element from the stack, removes it."}
{"code": "protected void update(){\n  updateVisualizerMenus();\n  if (currentSubplot != null) {\n    showPlot(currentSubplot);\n  }\n  overview.lazyRefresh();\n}\n", "nl": "Refresh the overview"}
{"code": "protected void onFieldShort(final Object obj,final Field field,final Bin annotation,final boolean signed,final int value){\n}\n", "nl": "Notification about short field."}
{"code": "public static Geo center(GeoArray poly,Geo ret){\n  Geo c=poly.get(0,new Geo());\n  int size=poly.getSize();\n  for (int i=1; i < size; i++) {\n    poly.get(i,ret);\n    c=c.add(ret,c);\n  }\n  return c.normalize(ret);\n}\n", "nl": "Returns the center of the polygon poly."}
{"code": "private JMenu createViewMenu(){\n  JMenuItem menuItem;\n  JMenu menu;\n  menu=new JMenu(ResourceManager.translate(\"view.menu\"));\n  menu.setMnemonic(KeyStroke.getKeyStroke(ResourceManager.translate(\"view.menu.mnem\")).getKeyCode());\n  menu.getAccessibleContext().setAccessibleDescription(ResourceManager.translate(\"view.menu.description\"));\n  add(menu);\n  expandAllMenuItem=new JMenuItem(ResourceManager.translate(\"view.expand\"),KeyStroke.getKeyStroke(ResourceManager.translate(\"view.expand.mnem\")).getKeyCode());\n  expandAllMenuItem.setIcon(TDA.createImageIcon(\"Expanded.png\"));\n  expandAllMenuItem.setAccelerator(KeyStroke.getKeyStroke(ResourceManager.translate(\"view.expand.accel\")));\n  expandAllMenuItem.getAccessibleContext().setAccessibleDescription(ResourceManager.translate(\"view.expand.description\"));\n  expandAllMenuItem.addActionListener(listener);\n  expandAllMenuItem.setEnabled(false);\n  menu.add(expandAllMenuItem);\n  collapseAllMenuItem=new JMenuItem(ResourceManager.translate(\"view.collapse\"),KeyStroke.getKeyStroke(ResourceManager.translate(\"view.collapse.mnem\")).getKeyCode());\n  collapseAllMenuItem.setIcon(TDA.createImageIcon(\"Collapsed.png\"));\n  collapseAllMenuItem.setAccelerator(KeyStroke.getKeyStroke(ResourceManager.translate(\"view.collapse.accel\")));\n  collapseAllMenuItem.getAccessibleContext().setAccessibleDescription(ResourceManager.translate(\"view.collapse.description\"));\n  collapseAllMenuItem.setEnabled(false);\n  collapseAllMenuItem.addActionListener(listener);\n  menu.add(collapseAllMenuItem);\n  menu.addSeparator();\n  menuItem=new JCheckBoxMenuItem(ResourceManager.translate(\"view.showtoolbar\"),PrefManager.get().getShowToolbar());\n  menuItem.setMnemonic(KeyStroke.getKeyStroke(ResourceManager.translate(\"view.showtoolbar.mnem\")).getKeyCode());\n  menuItem.addActionListener(listener);\n  menuItem.setIcon(TDA.createImageIcon(\"Empty.gif\"));\n  menu.add(menuItem);\n  return (menu);\n}\n", "nl": "Build tools menu in the menu bar."}
{"code": "public short wIndex(){\n  return this.controlSetup.getShort(4);\n}\n", "nl": "Returns the index. Varies according to request, typically used to pass an index or offset"}
{"code": "public TransitionExpressionConfigAttribute(Expression authorizeExpression){\n  Assert.notNull(authorizeExpression,\"Expression must be set\");\n  this.authorizeExpression=authorizeExpression;\n}\n", "nl": "Instantiates a new transition expression config attribute."}
{"code": "@Override public Optional<ClientAppUserAccessToken> verifyAccessToken(@Nullable String rawAccessToken){\n  return ClientAppUserAccessToken.tryDecode(rawAccessToken,oauthSecret).filter(null);\n}\n", "nl": "unlike AccountAccessToken, which have two variations (one is in memory verify, the other is hit db for strong verify). ClientAppAccessToken are always check against db, but with one minute local caching window. So in worst cases, user or app revoke, the token require wait up to one minute to take effect when kaif deploy to multiple servers."}
{"code": "public void clearLoggersCache(){\n  loggers.clear();\n}\n", "nl": "Removes all currently cached loggers. Note that loggers still used by other objects will not be disposed or garbage collected - this method only affects internal logger service cache."}
{"code": "public void openChat() throws RcsGenericException {\n  try {\n    mGroupChatInf.openChat();\n  }\n catch (  Exception e) {\n    throw new RcsGenericException(e);\n  }\n}\n", "nl": "open the chat conversation.<br> Note: if it is an incoming pending chat session and the parameter IM SESSION START is 0 then the session is accepted now."}
{"code": "public void nodeRemoved(SessionEvent event){\n}\n", "nl": "Indicates that a node has been removed."}
{"code": "public ResponseFuture request(Object request) throws RemotingException {\n  return client.request(request);\n}\n", "nl": "Description: <br>"}
{"code": "public static ScalarOperator parseScalarBinaryOperator(String opcode,boolean arg1IsScalar,double constant) throws DMLRuntimeException {\n  if (opcode.equalsIgnoreCase(\"+\")) {\n    return new RightScalarOperator(Plus.getPlusFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"*\")) {\n    return new RightScalarOperator(Multiply.getMultiplyFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"-\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(Minus.getMinusFnObject(),constant);\n else     return new RightScalarOperator(Minus.getMinusFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"-nz\")) {\n    return new RightScalarOperator(MinusNz.getMinusNzFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"/\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(Divide.getDivideFnObject(),constant);\n else     return new RightScalarOperator(Divide.getDivideFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"%%\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(Modulus.getFnObject(),constant);\n else     return new RightScalarOperator(Modulus.getFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"%/%\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(IntegerDivide.getFnObject(),constant);\n else     return new RightScalarOperator(IntegerDivide.getFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"^\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(Power.getPowerFnObject(),constant);\n else     return new RightScalarOperator(Power.getPowerFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"max\")) {\n    return new RightScalarOperator(Builtin.getBuiltinFnObject(\"max\"),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"min\")) {\n    return new RightScalarOperator(Builtin.getBuiltinFnObject(\"min\"),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"log\") || opcode.equalsIgnoreCase(\"log_nz\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(Builtin.getBuiltinFnObject(opcode),constant);\n    return new RightScalarOperator(Builtin.getBuiltinFnObject(opcode),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\">\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(GreaterThan.getGreaterThanFnObject(),constant);\n    return new RightScalarOperator(GreaterThan.getGreaterThanFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\">=\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(GreaterThanEquals.getGreaterThanEqualsFnObject(),constant);\n    return new RightScalarOperator(GreaterThanEquals.getGreaterThanEqualsFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"<\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(LessThan.getLessThanFnObject(),constant);\n    return new RightScalarOperator(LessThan.getLessThanFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"<=\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(LessThanEquals.getLessThanEqualsFnObject(),constant);\n    return new RightScalarOperator(LessThanEquals.getLessThanEqualsFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"==\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(Equals.getEqualsFnObject(),constant);\n    return new RightScalarOperator(Equals.getEqualsFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"!=\")) {\n    if (arg1IsScalar)     return new LeftScalarOperator(NotEquals.getNotEqualsFnObject(),constant);\n    return new RightScalarOperator(NotEquals.getNotEqualsFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"*2\")) {\n    return new RightScalarOperator(Multiply2.getMultiply2FnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"^2\")) {\n    return new RightScalarOperator(Power2.getPower2FnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"1-*\")) {\n    return new RightScalarOperator(Minus1Multiply.getMinus1MultiplyFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"s-r\")) {\n    return new LeftScalarOperator(Minus.getMinusFnObject(),constant);\n  }\n else   if (opcode.equalsIgnoreCase(\"so\")) {\n    return new LeftScalarOperator(Divide.getDivideFnObject(),constant);\n  }\n  throw new DMLRuntimeException(\"Unknown binary opcode \" + opcode);\n}\n", "nl": "scalar-matrix operator"}
{"code": "protected String convertCharEntity(String charEntity){\n  try {\n    return HTMLUtils.convertCharEntity(charEntity,true,null);\n  }\n catch (  IllegalArgumentException iae) {\n    return super.convertCharEntity(charEntity);\n  }\n}\n", "nl": "Overrides XMLParser.convertCharEntity to add in HTML char entities"}
{"code": "public boolean isShutdown() throws SchedulerException {\n  try {\n    return getRemoteScheduler().isShutdown();\n  }\n catch (  RemoteException re) {\n    throw invalidateHandleCreateException(\"Error communicating with remote scheduler.\",re);\n  }\n}\n", "nl": "<p> Calls the equivalent method on the 'proxied' <code>QuartzScheduler</code>. </p>"}
{"code": "protected void overrideStylePropertyRemoved(CSSStylableElement e,String name){\n  Iterator i=cssNavigableDocumentListeners.keySet().iterator();\n  while (i.hasNext()) {\n    CSSNavigableDocumentListener l=(CSSNavigableDocumentListener)i.next();\n    l.overrideStylePropertyRemoved(e,name);\n  }\n}\n", "nl": "A property in the override style declaration has been removed."}
{"code": "public static String generateNewDomainRoid(String tld){\n  return createDomainRoid(ObjectifyService.allocateId(),tld);\n}\n", "nl": "Returns a newly allocated, globally unique domain repoId of the format HEX-TLD."}
{"code": "public boolean contains(String unicode){\n  if (unicode.length() == 1) {\n    int unicodeVal=unicode.charAt(0);\n    return contains(unicodeVal);\n  }\n  return false;\n}\n", "nl": "Returns true if the specified unicode value is within this range."}
{"code": "@POST @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Path(\"/{id}/protection/snapshot-sessions\") @CheckPermission(roles={Role.SYSTEM_ADMIN},acls={ACL.ANY}) public TaskList createConsistencyGroupSnapshotSession(@PathParam(\"id\") URI consistencyGroupId,SnapshotSessionCreateParam param){\n  BlockConsistencyGroup cg=queryObject(BlockConsistencyGroup.class,consistencyGroupId,true);\n  validateVolumesInReplicationGroups(cg,param.getVolumes(),_dbClient);\n  return getSnapshotSessionManager().createSnapshotSession(cg,param,getFullCopyManager());\n}\n", "nl": "Creates a consistency group snapshot session"}
{"code": "protected DTEDFrameCacheHandler(){\n  this(null);\n}\n", "nl": "The DTEDFrameCache must be set at some point."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:50.416 -0400\",hash_original_method=\"82AABA56BCAF4EA117FD967EA0C801E1\",hash_generated_method=\"45823FC2302E3887DFCEFEED7BEB9398\") public static int readSwappedUnsignedShort(InputStream input) throws IOException {\n  int value1=read(input);\n  int value2=read(input);\n  return (((value1 & 0xff) << 0) + ((value2 & 0xff) << 8));\n}\n", "nl": "Reads a unsigned short (16-bit) from an InputStream. The value is converted to the opposed endian system while reading."}
{"code": "private void appendSequenceText(CoordinateSequence seq,int level,boolean doIndent,Writer writer) throws IOException {\n  if (seq.size() == 0) {\n    writer.write(\"EMPTY\");\n  }\n else {\n    if (doIndent)     indent(level,writer);\n    writer.write(\"(\");\n    for (int i=0; i < seq.size(); i++) {\n      if (i > 0) {\n        writer.write(\", \");\n        if (coordsPerLine > 0 && i % coordsPerLine == 0) {\n          indent(level + 1,writer);\n        }\n      }\n      appendCoordinate(seq,i,writer);\n    }\n    writer.write(\")\");\n  }\n}\n", "nl": "Converts a <code>LineString</code> to &lt;LineString Text&gt; format, then appends it to the writer."}
{"code": "public void write(AnnotationsWriter writer) throws IOException {\n  writer.constValueIndex(getValue());\n}\n", "nl": "Writes the value."}
{"code": "@Override public void addText(String text){\n  current.appendChild(document.createTextNode(text));\n}\n", "nl": "Adds a text to current element of the DOM Document. Note: Multiple consecutives texts will be merged."}
{"code": "public boolean hasPositionExt(){\n  return hasExtension(GphotoPosition.class);\n}\n", "nl": "Returns whether it has the position of the photo in its album."}
{"code": "public static XorRelayedAddressAttribute createXorRelayedAddressAttribute(TransportAddress address,byte[] tranID){\n  XorRelayedAddressAttribute attribute=new XorRelayedAddressAttribute();\n  attribute.setAddress(address,tranID);\n  return attribute;\n}\n", "nl": "Creates a XorRelayedAddressAttribute of the specified type and with the specified address and port."}
{"code": "public static ProviderDownloadDialog newInstance(boolean dsp){\n  ProviderDownloadDialog fragment=new ProviderDownloadDialog();\n  Bundle bundle=new Bundle();\n  bundle.putBoolean(KEY_DSP,dsp);\n  fragment.setArguments(bundle);\n  return fragment;\n}\n", "nl": "Creates the fragment in the perspective of selecting a provider or DSP plugin download source"}
{"code": "public static CassandraApplicationConfig parse(byte[] bytes) throws IOException {\n  return MAPPER.readValue(bytes,CassandraApplicationConfig.class);\n}\n", "nl": "Parses a configuration from bytes."}
{"code": "public void test_propertyCache(){\n  final Properties properties=getProperties();\n  final Journal store=new Journal(properties);\n  final String namespace=\"test\";\n  try {\n{\n      final ByteBuffer b=ByteBuffer.allocate(4);\n      b.putInt(0);\n      b.flip();\n      store.write(b);\n      assertNotSame(0L,store.commit());\n    }\n{\n      assertNull(store.getResourceLocator().locate(namespace,ITx.UNISOLATED));\n      assertNull(store.getResourceLocator().locate(namespace,store.getLastCommitTime()));\n{\n        final long tx=store.newTx(ITx.READ_COMMITTED);\n        try {\n          assertNull(store.getResourceLocator().locate(namespace,store.getLastCommitTime()));\n        }\n  finally {\n          store.abort(tx);\n        }\n      }\n    }\n    MockRelation mockRelation=new MockRelation(store,namespace,ITx.UNISOLATED,properties);\n{\n      assertNull(store.getResourceLocator().locate(namespace,ITx.UNISOLATED));\n      assertNull(store.getResourceLocator().locate(namespace,store.getLastCommitTime()));\n{\n        final long tx=store.newTx(ITx.READ_COMMITTED);\n        try {\n          assertNull(store.getResourceLocator().locate(namespace,store.getLastCommitTime()));\n        }\n  finally {\n          store.abort(tx);\n        }\n      }\n    }\n    mockRelation.create();\n{\n      assertNotNull(store.getResourceLocator().locate(namespace,ITx.UNISOLATED));\n      assertTrue(store.getResourceLocator().locate(namespace,ITx.UNISOLATED) == mockRelation);\n      assertNull(store.getResourceLocator().locate(namespace,ITx.READ_COMMITTED));\n    }\n    final long priorCommitTime=store.getLastCommitTime();\n    final long lastCommitTime=store.commit();\n{\n      assertNotNull(store.getResourceLocator().locate(namespace,ITx.READ_COMMITTED));\n      assertTrue(((MockRelation)store.getResourceLocator().locate(namespace,ITx.READ_COMMITTED)) != mockRelation);\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"priorCommitTime=\" + priorCommitTime);\n      log.info(\"lastCommitTime =\" + lastCommitTime);\n    }\n    final long tx1=store.newTx(store.getLastCommitTime());\n    final long tx2=store.newTx(store.getLastCommitTime());\n    final long ts1=store.getLastCommitTime() - 1;\n    try {\n      assertTrue(tx1 != tx2);\n      assertTrue(ts1 != tx1);\n      assertTrue(ts1 != tx2);\n      assertTrue(ts1 > priorCommitTime);\n      final AbstractResource<?> view_un=(AbstractResource<?>)store.getResourceLocator().locate(namespace,ITx.UNISOLATED);\n      assertNotNull(view_un);\n      final AbstractResource<?> view_tx1=(AbstractResource<?>)store.getResourceLocator().locate(namespace,tx1);\n      assertNotNull(view_tx1);\n      final AbstractResource<?> view_tx2=(AbstractResource<?>)store.getResourceLocator().locate(namespace,tx2);\n      assertNotNull(view_tx2);\n      assertTrue(view_un != view_tx1);\n      assertTrue(view_un != view_tx2);\n      assertTrue(view_tx1 != view_tx2);\n      assertEquals(ITx.UNISOLATED,view_un.getTimestamp());\n      assertEquals(tx1,view_tx1.getTimestamp());\n      assertEquals(tx2,view_tx2.getTimestamp());\n      assertEquals(null,((MockRelation)view_un).getCommitTime());\n      assertEquals(Long.valueOf(lastCommitTime),((MockRelation)view_tx1).getCommitTime());\n      assertEquals(Long.valueOf(lastCommitTime),((MockRelation)view_tx2).getCommitTime());\n      final Properties p_un=view_un.getProperties();\n      final Properties p_tx1=view_tx1.getProperties();\n      final Properties p_tx2=view_tx2.getProperties();\n      assertTrue(p_un != p_tx1);\n      assertTrue(p_un != p_tx2);\n      assertTrue(p_tx1 != p_tx2);\n      final DefaultResourceLocator<?> locator=(DefaultResourceLocator<?>)store.getResourceLocator();\n      assertNull(locator.propertyCache.get(new NT(namespace,ITx.UNISOLATED)));\n      assertNull(locator.propertyCache.get(new NT(namespace,tx1)));\n      assertNull(locator.propertyCache.get(new NT(namespace,tx2)));\n      assertNull(locator.propertyCache.get(new NT(namespace,ts1)));\n      assertNotNull(locator.propertyCache.get(new NT(namespace,lastCommitTime)));\n      assertNull(locator.propertyCache.get(new NT(namespace,priorCommitTime)));\n    }\n  finally {\n      store.abort(tx1);\n      store.abort(tx2);\n    }\n  }\n  finally {\n    store.destroy();\n  }\n}\n", "nl": "Unit test for property caching for locatable resources."}
{"code": "public static void clearCache(){\n  cache.clear();\n}\n", "nl": "Clears the internal cache of downloaded timezone definitions."}
{"code": "public Boolean isWantAssertionsSigned(){\n  return wantAssertionsSigned;\n}\n", "nl": "Gets the value of the wantAssertionsSigned property."}
{"code": "public Map<String,Object> convertDataToObjects(Map<String,String> data){\n  Map<String,Object> results=new HashMap<>();\n  if (data != null) {\n    for (    String key : data.keySet()) {\n      results.put(key,data.get(key));\n    }\n  }\n  return results;\n}\n", "nl": "Internal conversion. This is needed to support the current SpringBoot actuator AuditEventRepository interface"}
{"code": "@Override public void close(){\n  try {\n    super.close();\n    if (!emptyPages.isEmpty() && header instanceof TreeIndexHeader) {\n      ((TreeIndexHeader)header).writeEmptyPages(emptyPages,file);\n    }\n    ((TreeIndexHeader)header).setLargestPageID(nextPageID);\n    header.writeHeader(file);\n    file.close();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "Closes this file."}
{"code": "@Override public String toString(){\n  return buf.toString();\n}\n", "nl": "Gets a copy of the contents of this writer as a string."}
{"code": "public void endEntity(String name) throws org.xml.sax.SAXException {\n}\n", "nl": "Report the end of an entity."}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Node nameNode;\n  CharacterData child;\n  String badString;\n  doc=(Document)load(\"staff\",false);\n  elementList=doc.getElementsByTagName(\"address\");\n  nameNode=elementList.item(0);\n  child=(CharacterData)nameNode.getFirstChild();\n{\n    boolean success=false;\n    try {\n      badString=child.substringData(-5,3);\n    }\n catch (    DOMException ex) {\n      success=(ex.code == DOMException.INDEX_SIZE_ERR);\n    }\n    assertTrue(\"throws_INDEX_SIZE_ERR\",success);\n  }\n}\n", "nl": "Runs the test case."}
{"code": "public void stateChanged(ChangeEvent e){\n  int index=tabbedPane.getSelectedIndex();\n  genForm.setSelectionActive(index == 0);\n}\n", "nl": "Change Listener (Tab changed)"}
{"code": "public String toString(){\n  StringBuffer sb=new StringBuffer(\"MInterestArea[\").append(get_ID()).append(\" - \").append(getName()).append(\"]\");\n  return sb.toString();\n}\n", "nl": "String representation"}
{"code": "public static PcRunner serializableInstance(){\n  return PcRunner.serializableInstance();\n}\n", "nl": "Generates a simple exemplar of this class to test serialization."}
{"code": "public int addItemToEnd(String productId,BigDecimal amount,BigDecimal quantity,BigDecimal unitPrice,Timestamp reservStart,BigDecimal reservLength,BigDecimal reservPersonsDbl,String accommodationMapId,String accommodationSpotId,HashMap<String,GenericValue> features,HashMap<String,Object> attributes,String prodCatalogId,ProductConfigWrapper configWrapper,String itemType,LocalDispatcher dispatcher,Boolean triggerExternalOps,Boolean triggerPriceRules,Boolean skipInventoryChecks,Boolean skipProductChecks) throws CartItemModifyException, ItemNotFoundException {\n  return addItemToEnd(ShoppingCartItem.makeItem(null,productId,amount,quantity,unitPrice,reservStart,reservLength,reservPersonsDbl,accommodationMapId,accommodationSpotId,null,null,features,attributes,prodCatalogId,configWrapper,itemType,null,dispatcher,this,triggerExternalOps,triggerPriceRules,null,skipInventoryChecks,skipProductChecks));\n}\n", "nl": "Add an accommodation(rental/aggregated)item to the shopping cart."}
{"code": "private JsonObject broadlinkExecuteCommand(JsonObject params){\n  if (mBlNetwork == null) {\n    Log.e(this.getClass().getSimpleName(),\"mBlNetwork is uninitialized, check app permissions\");\n    return null;\n  }\n  String responseString=mBlNetwork.requestDispatch(params.toString());\n  JsonObject responseJsonObject=new JsonParser().parse(responseString).getAsJsonObject();\n  Log.d(this.getClass().getSimpleName(),responseString);\n  return responseJsonObject;\n}\n", "nl": "Execute a Broadlink API with the given parameters"}
{"code": "public static PcRunner serializableInstance(){\n  return PcRunner.serializableInstance();\n}\n", "nl": "Generates a simple exemplar of this class to test serialization."}
{"code": "boolean containsNode(Node check){\n  if (this.nodes != null) {\n    return nodes.contains(check);\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Safely checks to see if the provided Node participates in the PartitionedRegion return true if the Node participates in the PartitionedRegion"}
{"code": "public void skippedEntity(String name) throws SAXException {\n}\n", "nl": "Adapt a SAX2 skipped entity event."}
{"code": "private ValueBuffer combineChunks(final LinkedList<ValueBuffer> coll){\n  final ValueBuffer b;\n  if (coll.size() == 1) {\n    b=coll.getFirst();\n  }\n else {\n    int nvalues=0;\n    for (    ValueBuffer t : coll)     nvalues+=t.nvalues;\n    final List<IMemoryManager> contexts=new LinkedList<IMemoryManager>();\n    final LinkedHashMap<byte[],Bucket> addrMap=new LinkedHashMap<byte[],Bucket>();\n    for (    ValueBuffer t : coll) {\n      contexts.addAll(t.contexts);\n      nvalues+=t.nvalues;\n      for (      Bucket bucket : t.addrMap.values()) {\n        final Bucket tmp=addrMap.get(bucket.key);\n        if (tmp == null) {\n          addrMap.put(bucket.key,bucket);\n        }\n else {\n          tmp.addrs.addAll(bucket.addrs);\n        }\n      }\n    }\n    b=new ValueBuffer(contexts,nvalues,addrMap);\n  }\n  return b;\n}\n", "nl": "Combine chunks from the queue into a single chunk."}
{"code": "public void resetToCheckpoint(){\n  if (checkPoint != -1) {\n    current_item=checkPoint;\n  }\n  checkPoint=-1;\n}\n", "nl": "used to store end of PDF components"}
{"code": "void addParsedQuery(ParserRuleContext currentContext,Query<O> parsedQuery){\n  ParserRuleContext parentContext=getParentContextOfType(currentContext,getAndOrNotContextClasses());\n  Collection<Query<O>> childrenOfParent=this.childQueries.get(parentContext);\n  if (childrenOfParent == null) {\n    childrenOfParent=new ArrayList<Query<O>>();\n    this.childQueries.put(parentContext,childrenOfParent);\n  }\n  childrenOfParent.add(parsedQuery);\n  numQueriesParsed++;\n}\n", "nl": "Adds the given query to a list of child queries which have not yet been wrapped in a parent query."}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:34:02.455 -0500\",hash_original_method=\"A486C536CC2BBF7E5EE5092C736031C8\",hash_generated_method=\"70FFFC2D075451B0F1CD7FCCB9EFC19E\") private Combined(){\n}\n", "nl": "This utility class cannot be instantiated"}
{"code": "public DeclutterMatrix(int width,int height,int x_pix_interval,int y_pix_interval){\n  this.width=width;\n  this.height=height;\n  if (x_pix_interval != 0) {\n    this.x_pix_interval=x_pix_interval;\n  }\n else {\n    x_pix_interval=1;\n  }\n  if (y_pix_interval != 0) {\n    this.y_pix_interval=y_pix_interval;\n  }\n else {\n    y_pix_interval=1;\n  }\n  this.matrix=null;\n  this.maxx=(this.width / this.x_pix_interval) - 1;\n  this.maxy=(this.height / this.y_pix_interval) - 1;\n  create();\n  Debug.message(\"declutter\",\"Decluttering matrix created.\" + \"  Width = \" + width + \" Height = \"+ height);\n}\n", "nl": "Construct a new DeclutterMatrix, given the screen dimensions and the size of the matrix cells"}
{"code": "private DSSUtils(){\n}\n", "nl": "This class is an utility class and cannot be instantiated."}
{"code": "public void testRead(){\n  int count=1024;\n  byte[] wData=getWData(count);\n  ByteFifoBuffer instance=new ByteFifoBuffer(count);\n  instance.write(wData,count);\n  byte[] readBuff=new byte[count];\n  int expResult=count;\n  int result=instance.read(readBuff,count);\n  assertEquals(expResult,result);\n  assertArrayEquals(wData,readBuff);\n}\n", "nl": "Test of Read method, of class ByteFifoBuffer."}
{"code": "public static int hashIntArray(int[] array){\n  int intHash=0;\n  for (int i=0; i < array.length && i < 4; i++) {\n    intHash+=array[i] << (8 * i);\n  }\n  return intHash & 0x7FFFFFFF;\n}\n", "nl": "Returns hash code for array of integers"}
{"code": "public RepositoryStateMachinePersist(StateMachineContextRepository<S,E,StateMachineContext<S,E>> repository){\n  this.repository=repository;\n}\n", "nl": "Instantiates a new repository state machine persist."}
{"code": "public void addOffset(int off){\n  prep(SIZEOF_INT,0);\n  assert off <= offset();\n  off=offset() - off + SIZEOF_INT;\n  putInt(off);\n}\n", "nl": "Adds on offset, relative to where it will be written."}
{"code": "public MysqlPooledConnection(com.mysql.jdbc.Connection connection){\n  this.logicalHandle=null;\n  this.physicalConn=connection;\n  this.connectionEventListeners=new HashMap<ConnectionEventListener,ConnectionEventListener>();\n  this.exceptionInterceptor=this.physicalConn.getExceptionInterceptor();\n}\n", "nl": "Construct a new MysqlPooledConnection and set instance variables"}
{"code": "@Override public RabbitGroup makeNewGroup(String name){\n  return groupRepository.insert(new RabbitGroup(name));\n}\n", "nl": "Make new rabbit group"}
{"code": "public boolean hasStatement(Resource subj,IRI pred,Value obj,Resource... contexts) throws RepositoryException {\n  if (isAllContext(contexts)) {\n    return super.hasStatement(subj,pred,obj,isIncludeInferred(),getReadContexts());\n  }\n else {\n    return super.hasStatement(subj,pred,obj,isIncludeInferred(),contexts);\n  }\n}\n", "nl": "Checks whether the repository contains statements with a specific subject, predicate and/or object, optionally in the specified contexts."}
{"code": "public ImageInfo withSize(int cols,int rows){\n  return new ImageInfo(cols > 0 ? cols : this.cols,rows > 0 ? rows : this.rows,this.bitDepth,this.alpha,this.greyscale,this.indexed);\n}\n", "nl": "returns a copy with different size"}
{"code": "public CannotFindMethodException(SpecialInvokeExpr invoke,SootMethod method){\n  super(String.format(\"Cannot find or resolve %s in %s.\",invoke,method));\n}\n", "nl": "Create new exception for a special invoke."}
{"code": "private ManagedObjectReference createVm() throws Exception {\n  ManagedObjectReference folder=getVmFolder();\n  ManagedObjectReference resourcePool=getResourcePoolForVm();\n  ManagedObjectReference datastore=getDatastore();\n  String datastoreName=this.get.entityProp(datastore,\"name\");\n  VirtualMachineConfigSpec spec=buildVirtualMachineConfigSpec(datastoreName);\n  populateCloudConfig(spec);\n  ManagedObjectReference vmTask=getVimPort().createVMTask(folder,spec,resourcePool,null);\n  TaskInfo info=waitTaskEnd(vmTask);\n  if (info.getState() == TaskInfoState.ERROR) {\n    MethodFault fault=info.getError().getFault();\n    if (fault instanceof FileAlreadyExists) {\n      return null;\n    }\n else {\n      return VimUtils.rethrow(info.getError());\n    }\n  }\n  return (ManagedObjectReference)info.getResult();\n}\n", "nl": "Creates a VM in vsphere. This method will block until the CreateVM_Task completes. The path to the .vmx file is explicitly set and its existence is iterpreted as if the VM has been successfully created and returns null."}
{"code": "protected void cleanup(){\n  ArrayList<Long> deleteList;\n  long valueReplace;\nsynchronized (this) {\n    if (incrementRecords.size() <= FLUSH_COUNTER) {\n      return;\n    }\n    valueReplace=value.get();\n    deleteList=new ArrayList<>(incrementRecords);\n    incrementRecords.clear();\n  }\n  long newRecordID=-1;\n  long txCleanup=storage.generateID();\n  try {\n    for (    Long value1 : deleteList) {\n      storage.deleteIncrementRecord(txCleanup,value1);\n    }\n    if (recordID >= 0) {\n      storage.deletePageCounter(txCleanup,recordID);\n    }\n    newRecordID=storage.storePageCounter(txCleanup,subscriptionID,valueReplace);\n    if (logger.isTraceEnabled()) {\n      logger.trace(\"Replacing page-counter record = \" + recordID + \" by record = \"+ newRecordID+ \" on subscriptionID = \"+ this.subscriptionID+ \" for queue = \"+ this.subscription.getQueue().getName());\n    }\n    storage.commit(txCleanup);\n  }\n catch (  Exception e) {\n    newRecordID=recordID;\n    ActiveMQServerLogger.LOGGER.problemCleaningPagesubscriptionCounter(e);\n    try {\n      storage.rollback(txCleanup);\n    }\n catch (    Exception ignored) {\n    }\n  }\n finally {\n    recordID=newRecordID;\n  }\n}\n", "nl": "This method should always be called from a single threaded executor"}
{"code": "public void performCirculize(Way way){\n  if (way.getNodes().size() < 3)   return;\n  createCheckpoint(R.string.undo_action_circulize);\n  int[] center=centroid(map.getWidth(),map.getHeight(),viewBox,way);\n  getDelegator().circulizeWay(center,way);\n  map.invalidate();\n}\n", "nl": "Arrange way points in a circle"}
{"code": "public static String executeCommand(List<String> cmdArray) throws IOException, InterruptedException {\n  ProcessBuilder builder=new ProcessBuilder(cmdArray);\n  builder.redirectErrorStream(true);\n  Process process=builder.start();\n  try (InputStream is=process.getInputStream();Scanner scanner=new Scanner(is).useDelimiter(\"$\")){\n    String output=scanner.hasNext() ? scanner.next() : \"\";\n    process.waitFor();\n    int exitValue=process.exitValue();\n    if (exitValue != 0) {\n      throw new IllegalArgumentException(String.format(\"Command execution failed with status: %d\\n%s\",exitValue,output));\n    }\n    return output;\n  }\n }\n", "nl": "Execute a command and return all the output."}
{"code": "public ExpressionException(ExpressionParsingException cause){\n  super(cause.getMessage(),cause);\n  if (cause.getErrorContext() != null) {\n    errorLine=cause.getErrorContext().getStart().getLine();\n  }\n else {\n    errorLine=-1;\n  }\n}\n", "nl": "Creates an ExpressionException with the cause, associated error message and unknown line for where the error happened."}
{"code": "public static IntervalCategoryDataset createDataset(){\n  TaskSeries s1=new TaskSeries(\"Scheduled\");\n  s1.add(new Task(\"Write Proposal\",new SimpleTimePeriod(date(1,Calendar.APRIL,2001),date(5,Calendar.APRIL,2001))));\n  s1.add(new Task(\"Obtain Approval\",new SimpleTimePeriod(date(9,Calendar.APRIL,2001),date(9,Calendar.APRIL,2001))));\n  s1.add(new Task(\"Requirements Analysis\",new SimpleTimePeriod(date(10,Calendar.APRIL,2001),date(5,Calendar.MAY,2001))));\n  s1.add(new Task(\"Design Phase\",new SimpleTimePeriod(date(6,Calendar.MAY,2001),date(30,Calendar.MAY,2001))));\n  s1.add(new Task(\"Design Signoff\",new SimpleTimePeriod(date(2,Calendar.JUNE,2001),date(2,Calendar.JUNE,2001))));\n  s1.add(new Task(\"Alpha Implementation\",new SimpleTimePeriod(date(3,Calendar.JUNE,2001),date(31,Calendar.JULY,2001))));\n  s1.add(new Task(\"Design Review\",new SimpleTimePeriod(date(1,Calendar.AUGUST,2001),date(8,Calendar.AUGUST,2001))));\n  s1.add(new Task(\"Revised Design Signoff\",new SimpleTimePeriod(date(10,Calendar.AUGUST,2001),date(10,Calendar.AUGUST,2001))));\n  s1.add(new Task(\"Beta Implementation\",new SimpleTimePeriod(date(12,Calendar.AUGUST,2001),date(12,Calendar.SEPTEMBER,2001))));\n  s1.add(new Task(\"Testing\",new SimpleTimePeriod(date(13,Calendar.SEPTEMBER,2001),date(31,Calendar.OCTOBER,2001))));\n  s1.add(new Task(\"Final Implementation\",new SimpleTimePeriod(date(1,Calendar.NOVEMBER,2001),date(15,Calendar.NOVEMBER,2001))));\n  s1.add(new Task(\"Signoff\",new SimpleTimePeriod(date(28,Calendar.NOVEMBER,2001),date(30,Calendar.NOVEMBER,2001))));\n  TaskSeries s2=new TaskSeries(\"Actual\");\n  s2.add(new Task(\"Write Proposal\",new SimpleTimePeriod(date(1,Calendar.APRIL,2001),date(5,Calendar.APRIL,2001))));\n  s2.add(new Task(\"Obtain Approval\",new SimpleTimePeriod(date(9,Calendar.APRIL,2001),date(9,Calendar.APRIL,2001))));\n  s2.add(new Task(\"Requirements Analysis\",new SimpleTimePeriod(date(10,Calendar.APRIL,2001),date(15,Calendar.MAY,2001))));\n  s2.add(new Task(\"Design Phase\",new SimpleTimePeriod(date(15,Calendar.MAY,2001),date(17,Calendar.JUNE,2001))));\n  s2.add(new Task(\"Design Signoff\",new SimpleTimePeriod(date(30,Calendar.JUNE,2001),date(30,Calendar.JUNE,2001))));\n  s2.add(new Task(\"Alpha Implementation\",new SimpleTimePeriod(date(1,Calendar.JULY,2001),date(12,Calendar.SEPTEMBER,2001))));\n  s2.add(new Task(\"Design Review\",new SimpleTimePeriod(date(12,Calendar.SEPTEMBER,2001),date(22,Calendar.SEPTEMBER,2001))));\n  s2.add(new Task(\"Revised Design Signoff\",new SimpleTimePeriod(date(25,Calendar.SEPTEMBER,2001),date(27,Calendar.SEPTEMBER,2001))));\n  s2.add(new Task(\"Beta Implementation\",new SimpleTimePeriod(date(27,Calendar.SEPTEMBER,2001),date(30,Calendar.OCTOBER,2001))));\n  s2.add(new Task(\"Testing\",new SimpleTimePeriod(date(31,Calendar.OCTOBER,2001),date(17,Calendar.NOVEMBER,2001))));\n  s2.add(new Task(\"Final Implementation\",new SimpleTimePeriod(date(18,Calendar.NOVEMBER,2001),date(5,Calendar.DECEMBER,2001))));\n  s2.add(new Task(\"Signoff\",new SimpleTimePeriod(date(10,Calendar.DECEMBER,2001),date(11,Calendar.DECEMBER,2001))));\n  TaskSeriesCollection collection=new TaskSeriesCollection();\n  collection.add(s1);\n  collection.add(s2);\n  return collection;\n}\n", "nl": "Creates a sample dataset for a Gantt chart."}
{"code": "public Iterator<Bucket> buckets(){\n  return map.values().iterator();\n}\n", "nl": "Visit all buckets in the hash index."}
{"code": "public JsonObjectRequest(String url,Listener<JSONObject> listener,ErrorListener errorListener){\n  super(Method.GET,url,null,listener,errorListener);\n}\n", "nl": "Creates a new request."}
{"code": "@Override public void render(final int text_fill_type,final Graphics2D g2,final float scaling,final boolean isFormGlyph){\n  if (cached_current_path != null) {\n    final GeneralPath[] paths=cached_current_path.get();\n    for (    final GeneralPath path : paths) {\n      if (path == null) {\n        break;\n      }\n      if ((text_fill_type == GraphicsState.FILL)) {\n        if (isStroked) {\n          final Paint fillPaint=g2.getPaint();\n          if (!(fillPaint instanceof PdfTexturePaint) && ((Color)strokePaint).getRGB() != ((Color)fillPaint).getRGB() && strokedPositions.containsKey(String.valueOf((int)g2.getTransform().getTranslateX()) + '-' + (int)g2.getTransform().getTranslateY())) {\n            g2.setPaint(strokePaint);\n            g2.draw(path);\n            g2.setPaint(fillPaint);\n          }\n        }\n        g2.fill(path);\n      }\n      if (text_fill_type == GraphicsState.STROKE) {\n        g2.draw(path);\n        strokePaint=g2.getPaint();\n        strokedPositions.put(String.valueOf((int)g2.getTransform().getTranslateX()) + '-' + (int)g2.getTransform().getTranslateY(),\"x\");\n      }\n    }\n  }\n}\n", "nl": "turn shape commands into a Shape object, storing info for later. Has to be done this way because we need the winding rule to initialise the shape in Java, and it could be set awywhere in the command stream"}
{"code": "public Bindings add(String property,JComboBox combo){\n  combo.addActionListener(this);\n  return add(new JComboBoxBinding(property,combo,0));\n}\n", "nl": "Handles JComboBox"}
{"code": "public AsyncHttpClient(boolean fixNoHttpResponseException,int httpPort,int httpsPort){\n  this(getDefaultSchemeRegistry(fixNoHttpResponseException,httpPort,httpsPort));\n}\n", "nl": "Creates new AsyncHttpClient using given params"}
{"code": "protected void selectRenderables(DrawContext dc){\n  ArrayList<GraticuleTile> tileList=getVisibleTiles(dc);\n  if (tileList.size() > 0) {\n    for (    GraticuleTile gz : tileList) {\n      gz.selectRenderables(dc);\n    }\n  }\n}\n", "nl": "Select the visible grid elements"}
{"code": "public static Element addChildElementNSElement(Element element,String childElementName,Document document,String nameSpaceUrl){\n  Element newElement=document.createElementNS(nameSpaceUrl,childElementName);\n  element.appendChild(newElement);\n  return element;\n}\n", "nl": "Creates a child element with the given namespace supportive name and appends it to the element child node list."}
{"code": "public DifferentialEvolution(double CR,double F){\n  this.CR=CR;\n  this.F=F;\n}\n", "nl": "Constructs a differential evolution operator with the specified crossover rate and scaling factor."}
{"code": "public static MethodIdentifier ofStatic(final String containingClass,final String methodName,final String returnType,final String... parameterTypes){\n  return of(containingClass,methodName,returnType,true,parameterTypes);\n}\n", "nl": "Creates an identifier of a static method."}
{"code": "private void writeQName(javax.xml.namespace.QName qname,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  java.lang.String namespaceURI=qname.getNamespaceURI();\n  if (namespaceURI != null) {\n    java.lang.String prefix=xmlWriter.getPrefix(namespaceURI);\n    if (prefix == null) {\n      prefix=generatePrefix(namespaceURI);\n      xmlWriter.writeNamespace(prefix,namespaceURI);\n      xmlWriter.setPrefix(prefix,namespaceURI);\n    }\n    if (prefix.trim().length() > 0) {\n      xmlWriter.writeCharacters(prefix + \":\" + org.apache.axis2.databinding.utils.ConverterUtil.convertToString(qname));\n    }\n else {\n      xmlWriter.writeCharacters(org.apache.axis2.databinding.utils.ConverterUtil.convertToString(qname));\n    }\n  }\n else {\n    xmlWriter.writeCharacters(org.apache.axis2.databinding.utils.ConverterUtil.convertToString(qname));\n  }\n}\n", "nl": "method to handle Qnames"}
{"code": "@Deprecated public ServiceRequestBufferImp(){\n  super(SrbMetaData.SRB_VERSION_2);\n}\n", "nl": "Creates an empty service request buffer."}
{"code": "private static float[] rgbToHLS(int rgb,float[] hls){\n  float r=((rgb & 0xFF0000) >> 16) / 255.0f;\n  float g=((rgb & 0xFF00) >> 8) / 255.0f;\n  float b=(rgb & 0xFF) / 255.0f;\n  float max=Math.max(Math.max(r,g),b);\n  float min=Math.min(Math.min(r,g),b);\n  float l=(max + min) / 2.0f;\n  float s=0;\n  float h=0;\n  if (max != min) {\n    float delta=max - min;\n    s=(l <= .5f) ? (delta / (max + min)) : (delta / (2.0f - max - min));\n    if (r == max) {\n      h=(g - b) / delta;\n    }\n else     if (g == max) {\n      h=2.0f + (b - r) / delta;\n    }\n else {\n      h=4.0f + (r - g) / delta;\n    }\n    h*=60.0f;\n    if (h < 0) {\n      h+=360.0f;\n    }\n  }\n  if (hls == null) {\n    hls=new float[3];\n  }\n  hls[0]=h;\n  hls[1]=l;\n  hls[2]=s;\n  return hls;\n}\n", "nl": "Converts from RGB color space to HLS colorspace."}
{"code": "private void updateProgress(int progress){\n  if (myHost != null && progress != previousProgress) {\n    myHost.updateProgress(progress);\n  }\n  previousProgress=progress;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public String toString(){\n  return String.format(\"key '%s' for %s\",name,owner);\n}\n", "nl": "This returns a string representation of this key. It contains the name and the declaring class for the method or field. This is primarily used for debugging purposes."}
{"code": "public static Calendar parse(String dateString,final int timezoneOffset) throws ParseException {\n  Calendar cal=Calendar.getInstance(UTCtimeZone);\n  if (\"now\".equals(dateString))   return cal;\n  if (\"hour\".equals(dateString)) {\n    cal.setTime(oneHourAgo());\n    return cal;\n  }\n  if (\"day\".equals(dateString)) {\n    cal.setTime(oneDayAgo());\n    return cal;\n  }\n  if (\"week\".equals(dateString)) {\n    cal.setTime(oneWeekAgo());\n    return cal;\n  }\n  dateString=dateString.replaceAll(\"_\",\" \");\n  int p=-1;\n  if ((p=dateString.indexOf(':')) > 0) {\n    if (dateString.indexOf(':',p + 1) > 0) synchronized (secondDateFormat) {\n      cal.setTime(secondDateFormat.parse(dateString));\n    }\n else synchronized (minuteDateFormat) {\n      cal.setTime(minuteDateFormat.parse(dateString));\n    }\n  }\n else synchronized (dayDateFormat) {\n    cal.setTime(dayDateFormat.parse(dateString));\n  }\n  cal.add(Calendar.MINUTE,timezoneOffset);\n  return cal;\n}\n", "nl": "parse a date string for a given time zone"}
{"code": "public boolean translateFile(String relFilepath){\n  assert loadedLng != null;\n  assert mainTransLists != null;\n  boolean result=false;\n  if (mainTransLists.containsKey(relFilepath)) {\n    Switchboard sb=Switchboard.getSwitchboard();\n    if (sb != null) {\n      final String htRootPath=sb.getConfig(SwitchboardConstants.HTROOT_PATH,SwitchboardConstants.HTROOT_PATH_DEFAULT);\n      final File sourceDir=new File(sb.getAppPath(),htRootPath);\n      final File destDir=new File(sb.getDataPath(\"locale.translated_html\",\"DATA/LOCALE/htroot\"),loadedLng);\n      final File sourceFile=new File(sourceDir,relFilepath);\n      final File destFile=new File(destDir,relFilepath);\n      result=translateFile(sourceFile,destFile,mainTransLists.get(relFilepath));\n    }\n  }\n  return result;\n}\n", "nl": "Translates one file. The relFilepath is the file name as given in the translation source lists. The source (english) file is expected under htroot path. The destination file is under DATA/LOCALE and calculated using the language of loaded data."}
{"code": "public Polynomial(double[] a){\n  order=a.length - 1;\n  this.a=new double[a.length];\n  System.arraycopy(a,0,this.a,0,a.length);\n}\n", "nl": "Instantiates a new polynomial from a double array containing the coefficients."}
{"code": "private double calculateLogLikelihood(){\n  double logL=0;\n  if (!isValidate(indexVariable.getValues())) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  for (int i=0; i < trees.size(); i++) {\n    MaskableSpeciationModel model=speciationModels.get(i);\n    if (i > 0) {\n      SpeciationModel mask=speciationModels.get(indexVariable.getValue(i - 1));\n      if (model != mask) {\n        model.mask(mask);\n      }\n else {\n        model.unmask();\n      }\n    }\n    logL+=model.calculateTreeLogLikelihood(trees.get(i));\n  }\n  Double maxI=(double)(int)getMaxIndex(indexVariable.getValues());\n  maxIndexVariable.setValue(0,maxI);\n  return logL;\n}\n", "nl": "Calculates the log likelihood of this set of coalescent intervals, given a demographic model."}
{"code": "private LinkTableConfiguration(Builder builder){\n  setColumnPathes(builder.getColumnPathes());\n  setLinkTypeIds(builder.getLinkTypeIds());\n  setScopeIds(builder.getScopeIds());\n}\n", "nl": "Use LinkTableConfiguration.Builder to create instances of this class."}
{"code": "public static CustomChannel run(AdSenseHost service,String adClientId) throws Exception {\n  System.out.println(\"=================================================================\");\n  System.out.printf(\"Adding custom channel to ad client %s\\n\",adClientId);\n  System.out.println(\"=================================================================\");\n  CustomChannel newCustomChannel=new CustomChannel().setName(\"Sample Channel #\" + AdSenseHostSample.getUniqueName());\n  CustomChannel customChannel=service.customchannels().insert(adClientId,newCustomChannel).execute();\n  System.out.printf(\"Custom channel with id \\\"%s\\\", code \\\"%s\\\" and name \\\"%s\\\" was created.\\n\",customChannel.getId(),customChannel.getCode(),customChannel.getName());\n  System.out.println();\n  return customChannel;\n}\n", "nl": "Runs this sample."}
{"code": "public boolean hasAnyFlags(int bits){\n  return (flags & bits) != 0;\n}\n", "nl": "Update if any oft these flags is set."}
{"code": "boolean needsAltMetafactory(){\n  return tree.targets.length() > 1 || isSerializable() || bridges.length() > 1;\n}\n", "nl": "does this functional expression need to be created using alternate metafactory?"}
{"code": "@Override public void doInit() throws ResourceException {\n  super.doInit();\n  String resourceId=resolveResourceId(getRequest());\n  RestManager restManager=RestManager.getRestManager(SolrRequestInfo.getRequestInfo());\n  managedResource=restManager.getManagedResourceOrNull(resourceId);\n  if (managedResource == null) {\n    int lastSlashAt=resourceId.lastIndexOf('/');\n    if (lastSlashAt != -1) {\n      String parentResourceId=resourceId.substring(0,lastSlashAt);\n      log.info(\"Resource not found for {}, looking for parent: {}\",resourceId,parentResourceId);\n      managedResource=restManager.getManagedResourceOrNull(parentResourceId);\n      if (managedResource != null) {\n        if (!(managedResource instanceof ManagedResource.ChildResourceSupport)) {\n          String errMsg=String.format(Locale.ROOT,\"%s does not support child resources!\",managedResource.getResourceId());\n          throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST,errMsg);\n        }\n        childId=resourceId.substring(lastSlashAt + 1);\n        log.info(\"Found parent resource {} for child: {}\",parentResourceId,childId);\n      }\n    }\n  }\n  if (managedResource == null) {\n    if (Method.PUT.equals(getMethod()) || Method.POST.equals(getMethod())) {\n      managedResource=restManager.endpoint;\n    }\n else {\n      throw new ResourceException(Status.CLIENT_ERROR_NOT_FOUND,\"No REST managed resource registered for path \" + resourceId);\n    }\n  }\n  log.info(\"Found ManagedResource [\" + managedResource + \"] for \"+ resourceId);\n}\n", "nl": "Initialize objects needed to handle a request to the REST API. Specifically, we lookup the RestManager using the ThreadLocal SolrRequestInfo and then dynamically locate the ManagedResource associated with the request URI."}
{"code": "public void testSingleChar() throws Exception {\n  CharacterRunAutomaton single=new CharacterRunAutomaton(new RegExp(\".\").toAutomaton());\n  Analyzer a=new MockAnalyzer(random(),single,false);\n  assertAnalyzesTo(a,\"foobar\",new String[]{\"f\",\"o\",\"o\",\"b\",\"a\",\"r\"},new int[]{0,1,2,3,4,5},new int[]{1,2,3,4,5,6});\n  checkRandomData(random(),a,100);\n}\n", "nl": "Test a configuration where each character is a term"}
{"code": "public static void main(String[] argv){\n  ArgsBaratine args=new ArgsBaratine(argv);\n  args.doMain();\n}\n", "nl": "The main start of the baratine server."}
{"code": "protected int addHeaderToOutput(byte[] msg,AbstractMRMessage m){\n  return 0;\n}\n", "nl": "Add header to the outgoing byte stream."}
{"code": "@Override public void mouseDoubleClick(int x,int y,int mouseButton){\n  if (mouseButton != 1) {\n    return;\n  }\n  if ((tape != null) || (path != null)) {\n    return;\n  }\n  if ((lastSelection != null) && ((lastSelection instanceof Landmark) || (lastSelection instanceof Tool) || (lastSelection instanceof Waypoint))) {\n    MapElement mElement=(MapElement)lastSelection;\n    mElement.getState().openAnnotation();\n  }\n}\n", "nl": "Mouse button was double-clicked"}
{"code": "public MLOutput execute(String dmlScriptFilePath,boolean parsePyDML,String configFilePath) throws IOException, DMLException, ParseException {\n  return compileAndExecuteScript(dmlScriptFilePath,null,false,parsePyDML,configFilePath);\n}\n", "nl": "Experimental: Execute DML script without any arguments if parsePyDML=true, using specified config path."}
{"code": "@Override public void writeXML(@WillClose Writer out) throws IOException {\n  assert project != null;\n  bugsPopulated();\n  XMLOutput xmlOutput;\n  if (withMessages && cloud != null) {\n    cloud.bugsPopulated();\n    cloud.initiateCommunication();\n    cloud.waitUntilIssueDataDownloaded();\n    String token=SystemProperties.getProperty(\"findbugs.cloud.token\");\n    if (token != null && token.trim().length() > 0) {\n      LOGGER.info(\"Cloud token specified - uploading new issues, if necessary...\");\n      cloud.waitUntilNewIssuesUploaded();\n    }\n    xmlOutput=new OutputStreamXMLOutput(out,\"http://findbugs.sourceforge.net/xsl/default.xsl\");\n  }\n else {\n    xmlOutput=new OutputStreamXMLOutput(out);\n  }\n  writeXML(xmlOutput);\n}\n", "nl": "Write the BugCollection to given output stream as XML. The output stream will be closed, even if an exception is thrown."}
{"code": "public Pattern createPattern(){\n  PatternImpl pattern=new PatternImpl();\n  return pattern;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void clean(int size){\n  if (fifo.size() > size) {\n    while (size > 0) {\n      fifo.removeElementAt(0);\n      nbObjects--;\n      size--;\n    }\n  }\n}\n", "nl": "clean FIFO"}
{"code": "public boolean needsUpgrading(final DatabaseVersion fromVersion){\n  return fromVersion.getString().equals(\"4.0.0\") || fromVersion.getString().equals(\"5.0.0\");\n}\n", "nl": "Checks whether a given database version needs upgrading."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase N4JSPackage.CAST_EXPRESSION__EXPRESSION:\n    return basicSetExpression(null,msgs);\ncase N4JSPackage.CAST_EXPRESSION__TARGET_TYPE_REF:\n  return basicSetTargetTypeRef(null,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected ExifTag addTag(ExifTag tag,int ifdId){\n  if (tag != null && ExifTag.isValidIfd(ifdId)) {\n    IfdData ifdData=getOrCreateIfdData(ifdId);\n    return ifdData.setTag(tag);\n  }\n  return null;\n}\n", "nl": "Adds the given ExifTag to the given IFD and returns an existing ExifTag with the same TID or null if none exist."}
{"code": "@Override public void removeListener(final IEventLayerListener e){\n}\n", "nl": "Method removeMouseListener()"}
{"code": "public void pushOntoIntStack(Interpreter interpreter,int val){\n  interpreter.intStack().push(val);\n}\n", "nl": "Pushes a value onto the top of the int stack of the interpreter."}
{"code": "public UnsupportedClassVersionError(){\n  super();\n}\n", "nl": "Constructs a <code>UnsupportedClassVersionError</code> with no detail message."}
{"code": "public SendableTextMessage.SendableTextMessageBuilder disableNotification(boolean disableNotification){\n  this.disableNotification=disableNotification;\n  return this;\n}\n", "nl": "*Optional Sets whether or not to disable any notification this message might usually cause. Defaults to False"}
{"code": "public boolean areEqual(final AnnotatedTypeMirror type1,final AnnotatedTypeMirror type2){\n  return AtmCombo.accept(type1,type2,new VisitHistory(),this);\n}\n", "nl": "Returns true if type1 and type2 are structurally equivalent. With one exception, type1.getClass().equals(type2.getClass()) must be true.  However, because the Checker Framework sometimes \"infers\" Typevars to be Wildcards, we allow the combination Wildcard,Typevar.  In this case, the two types are \"equal\" if their bounds are."}
{"code": "public void addProperty(String key,Object token){\n  deprecationCrutch.addProperty(key,token);\n  Object o=this.get(key);\n  if (o instanceof String) {\n    Vector v=new Vector(2);\n    v.addElement(o);\n    v.addElement(token);\n    put(key,v);\n  }\n else   if (o instanceof Vector) {\n    ((Vector)o).addElement(token);\n  }\n else {\n    if (token instanceof String && ((String)token).indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n      PropertiesTokenizer tokenizer=new PropertiesTokenizer((String)token);\n      while (tokenizer.hasMoreTokens()) {\n        String value=tokenizer.nextToken();\n        addStringProperty(key,value);\n      }\n    }\n else {\n      if (!containsKey(key)) {\n        keysAsListed.add(key);\n      }\n      put(key,token);\n    }\n  }\n}\n", "nl": "Add a property to the configuration. If it already exists then the value stated here will be added to the configuration entry. For example, if resource.loader = file is already present in the configuration and you addProperty(\"resource.loader\", \"classpath\") Then you will end up with a Vector like the following: [\"file\", \"classpath\"]"}
{"code": "public static void printMagnitudes(){\n  printMagnitudes(System.out);\n}\n", "nl": "Prints the relative magnitudes of the collected timer data to the standard output stream."}
{"code": "public PrefixStringMatcher(String[] prefixes){\n  super();\n  for (int i=0; i < prefixes.length; i++)   addPatternForward(prefixes[i]);\n}\n", "nl": "Creates a new <code>PrefixStringMatcher</code> which will match <code>String</code>s with any prefix in the supplied array. Zero-length <code>Strings</code> are ignored."}
{"code": "@Override protected EClass eStaticClass(){\n  return UmplePackage.eINSTANCE.getInlineAssociationEnd_();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean hasLocalInterestBeenComputed(){\n  return this.hasLocalInterestBeenComputed;\n}\n", "nl": "returns true if local interest has been computed"}
{"code": "public void testDeletePackage2(){\n  int originalAppIdValue=mAppIdValue;\n  int originalContentTypeValue=mContentTypeValue;\n  try {\n    IWapPushManager iwapman=getInterface();\n    iwapman.addPackage(Integer.toString(mAppIdValue),Integer.toString(mContentTypeValue),mPackageName,mClassName,0,false,false);\n    assertFalse(iwapman.deletePackage(Integer.toString(mAppIdValue + 10),Integer.toString(mContentTypeValue),mPackageName,mClassName));\n    assertFalse(iwapman.deletePackage(Integer.toString(mAppIdValue),Integer.toString(mContentTypeValue + 20),mPackageName,mClassName));\n    assertFalse(iwapman.deletePackage(Integer.toString(mAppIdValue + 10),Integer.toString(mContentTypeValue + 20),mPackageName,mClassName));\n    iwapman.deletePackage(Integer.toString(mAppIdValue),Integer.toString(mContentTypeValue),mPackageName,mClassName);\n  }\n catch (  RemoteException e) {\n    assertTrue(false);\n  }\n}\n", "nl": "Deleting invalid package test"}
{"code": "public void evaluate(EvolutionState state,Individual ind,int subpopulation,int threadnum){\n  if (ind.evaluated)   return;\n  VectorSpeciesCGP s=(VectorSpeciesCGP)ind.species;\n  VectorIndividualCGP ind2=(VectorIndividualCGP)ind;\n  float diff=0f;\n  Float[] inputs=new Float[2];\n  float fn=0f;\n  for (int i=0; i < testPoints.length; i++) {\n    inputs[0]=testPoints[i];\n    inputs[1]=1.0f;\n    Object[] outputs=Evaluator.evaluate(state,threadnum,inputs,ind2);\n    if (function == 1)     fn=function1(testPoints[i]);\n else     if (function == 2)     fn=function2(testPoints[i]);\n else     if (function == 3)     fn=function3(testPoints[i]);\n    diff+=Math.abs((Float)outputs[0] - fn);\n  }\n  ((FitnessCGP)ind.fitness).setFitness(state,diff,diff <= 0.01);\n  ind.evaluated=true;\n}\n", "nl": "Evaluate the CGP and compute fitness"}
{"code": "public ProcessingInstruction createProcessingInstruction(String target,String data) throws DOMException {\n  error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);\n  return null;\n}\n", "nl": "Unimplemented. See org.w3c.dom.Document"}
{"code": "public SegmentIntersectionDetector(LineIntersector li){\n  this.li=li;\n}\n", "nl": "Creates an intersection finder using a given LineIntersector."}
{"code": "public static boolean isFileExist(String filePath){\n  if (Handler_String.isBlank(filePath)) {\n    return false;\n  }\n  File file=new File(filePath);\n  return (file.exists() && file.isFile());\n}\n", "nl": "Indicates if this file represents a file on the underlying file system."}
{"code": "@Override public final void write(byte[] source,int offset,int len){\n  if (this.overflowBuf != null) {\n    this.overflowBuf.write(source,offset,len);\n    return;\n  }\n  while (len > 0) {\n    int remainingSpace=this.buffer.capacity() - this.buffer.position();\n    if (remainingSpace == 0) {\n      realFlush(false);\n      if (this.overflowBuf != null) {\n        this.overflowBuf.write(source,offset,len);\n        return;\n      }\n    }\n else {\n      int chunkSize=remainingSpace;\n      if (len < chunkSize) {\n        chunkSize=len;\n      }\n      this.buffer.put(source,offset,chunkSize);\n      offset+=chunkSize;\n      len-=chunkSize;\n    }\n  }\n}\n", "nl": "override OutputStream's write()"}
{"code": "public static void addView(Context context,View view){\n  addView(context,view,createDefaultLayoutParams());\n}\n", "nl": "Adds a child view with the specified layout parameters."}
{"code": "public Object generate(Element element,ElementMetadata<?,?> metadata){\n  Path bound=path.toAbsolute(metadata);\n  element=getFinalElement(bound,element);\n  if (element == null) {\n    return null;\n  }\n  if (bound.selectsAttribute()) {\n    return generateAttributeValue(element,bound.getSelectedElement(),bound.getSelectedAttributeKey(),bound.getSelectedAttribute());\n  }\n else {\n    return generateTextValue(element,bound.getSelectedElement());\n  }\n}\n", "nl": "Generate a text value through the path.  If the path ends in an element, the value will be the text content of the final element.  If the path ends in an attribute, the value will be the value of that attribute."}
{"code": "protected void fireAncestorMoved(JComponent source,int id,Container ancestor,Container ancestorParent){\n  Object[] listeners=listenerList.getListenerList();\n  for (int i=listeners.length - 2; i >= 0; i-=2) {\n    if (listeners[i] == AncestorListener.class) {\n      AncestorEvent ancestorEvent=new AncestorEvent(source,id,ancestor,ancestorParent);\n      ((AncestorListener)listeners[i + 1]).ancestorMoved(ancestorEvent);\n    }\n  }\n}\n", "nl": "Notify all listeners that have registered interest for notification on this event type.  The event instance is lazily created using the parameters passed into the fire method."}
{"code": "@Override public Set<K> keySet(){\n  HashSet<K> set=new HashSet<K>();\n  for (  Segment<K,V> s : segments) {\n    set.addAll(s.keySet());\n  }\n  return set;\n}\n", "nl": "Get the set of keys for resident entries."}
{"code": "public int tableLength(){\n  return ByteArray.readU16bit(info,0);\n}\n", "nl": "Returns <code>line_number_table_length</code>. This represents the number of entries in the table."}
{"code": "public TetradMatrix pruneEdgesByResampling(TetradMatrix data){\n  TetradMatrix X=new TetradMatrix(data.transpose().toArray());\n  int npieces=10;\n  int cols=X.columns();\n  int rows=X.rows();\n  int piecesize=(int)Math.floor(cols / npieces);\n  List<TetradMatrix> bpieces=new ArrayList<>();\n  List<TetradVector> diststdpieces=new ArrayList<>();\n  List<TetradVector> cpieces=new ArrayList<>();\n  for (int p=0; p < npieces; p++) {\n    int p0=(p) * piecesize;\n    int p1=(p + 1) * piecesize - 1;\n    int[] range=range(p0,p1);\n    TetradMatrix Xp=X;\n    TetradVector Xpm=new TetradVector(rows);\n    for (int i=0; i < rows; i++) {\n      double sum=0.0;\n      for (int j=0; j < Xp.columns(); j++) {\n        sum+=Xp.get(i,j);\n      }\n      Xpm.set(i,sum / Xp.columns());\n    }\n    for (int i=0; i < rows; i++) {\n      for (int j=0; j < Xp.columns(); j++) {\n        Xp.set(i,j,Xp.get(i,j) - Xpm.get(i));\n      }\n    }\n    TetradMatrix Xpt=Xp.transpose();\n    TetradMatrix cov=Xp.times(Xpt);\n    for (int i=0; i < cov.rows(); i++) {\n      for (int j=0; j < cov.columns(); j++) {\n        cov.set(i,j,cov.get(i,j) / Xp.columns());\n      }\n    }\n    boolean posDef=LingUtils.isPositiveDefinite(cov);\n    if (!posDef) {\n      System.out.println(\"Covariance matrix is not positive definite.\");\n    }\n    TetradMatrix sqrt=cov.sqrt();\n    ;\n    TetradMatrix I=TetradMatrix.identity(rows);\n    TetradMatrix AI=I.copy();\n    TetradMatrix invSqrt=sqrt.inverse();\n    QRDecomposition qr=new QRDecomposition(invSqrt.getRealMatrix());\n    RealMatrix r=qr.getR();\n    TetradVector newestdisturbancestd=new TetradVector(rows);\n    for (int t=0; t < rows; t++) {\n      newestdisturbancestd.set(t,1.0 / Math.abs(r.getEntry(t,t)));\n    }\n    for (int s=0; s < rows; s++) {\n      for (int t=0; t < min(s,cols); t++) {\n        r.setEntry(s,t,r.getEntry(s,t) / r.getEntry(s,s));\n      }\n    }\n    TetradMatrix bnewest=TetradMatrix.identity(rows);\n    bnewest=bnewest.minus(new TetradMatrix(r));\n    TetradVector cnewest=new TetradMatrix(r).times(Xpm);\n    bpieces.add(bnewest);\n    diststdpieces.add(newestdisturbancestd);\n    cpieces.add(cnewest);\n  }\n  TetradMatrix means=new TetradMatrix(rows,rows);\n  TetradMatrix stds=new TetradMatrix(rows,rows);\n  TetradMatrix BFinal=new TetradMatrix(rows,rows);\n  for (int i=0; i < rows; i++) {\n    for (int j=0; j < rows; j++) {\n      double sum=0.0;\n      for (int y=0; y < npieces; y++) {\n        sum+=bpieces.get(y).get(i,j);\n      }\n      double themean=sum / (npieces);\n      double sumVar=0.0;\n      for (int y=0; y < npieces; y++) {\n        sumVar+=Math.pow((bpieces.get(y).get(i,j)) - themean,2);\n      }\n      double thestd=Math.sqrt(sumVar / (npieces));\n      means.set(i,j,themean);\n      stds.set(i,j,thestd);\n      if (Math.abs(themean) < threshold * thestd) {\n        BFinal.set(i,j,0);\n      }\n else {\n        BFinal.set(i,j,themean);\n      }\n    }\n  }\n  return BFinal;\n}\n", "nl": "This is the method used in Patrik's code."}
{"code": "private String createIndentation(int numChars){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < numChars; i++)   sb.append(\" \");\n  return sb.toString();\n}\n", "nl": "Adds spaces to create indentation."}
{"code": "public void firePropertyChangedEvent(){\n  for (  WorldListener listener : listenerList) {\n    listener.propertyChanged();\n  }\n}\n", "nl": "Fire a property changed event."}
{"code": "@Override protected void beforeShow(){\n  super.beforeShow();\n  m_Option=CANCEL_OPTION;\n}\n", "nl": "Hook method just before the dialog is made visible."}
{"code": "protected void fireTreeNodesChanged(Object source,Object[] path,int[] childIndices,Object[] children){\n  Object[] listeners=listenerList.getListenerList();\n  TreeModelEvent e=null;\n  for (int i=listeners.length - 2; i >= 0; i-=2) {\n    if (listeners[i] == TreeModelListener.class) {\n      if (e == null)       e=new TreeModelEvent(source,path,childIndices,children);\n      ((TreeModelListener)listeners[i + 1]).treeNodesChanged(e);\n    }\n  }\n}\n", "nl": "Notifies all listeners that have registered interest for notification on this event type.  The event instance  is lazily created using the parameters passed into  the fire method."}
{"code": "String renameTypeDesc(String desc){\n  if (desc == null) {\n    return null;\n  }\n  return renameType(Type.getType(desc));\n}\n", "nl": "Renames a type descriptor, e.g. \"Lcom.package.MyClass;\" If the type doesn't need to be renamed, returns the input string as-is."}
{"code": "public void addAlias(String field,float tiebreaker,Map<String,Float> fieldBoosts){\n  Alias a=new Alias();\n  a.tie=tiebreaker;\n  a.fields=fieldBoosts;\n  aliases.put(field,a);\n}\n", "nl": "Add an alias to this query parser."}
{"code": "private void cloneReachableNonHiddenAncestorMethods(SootClass ancestor){\n  if (ClassCloner.isClonedClass(ancestor)) {\n    logger.error(\"Cloning method from clone: {}\",ancestor);\n    droidsafe.main.Main.exit(1);\n  }\n  for (  SootMethod ancestorM : ancestor.getMethods()) {\n    if (ancestorM.isAbstract() || ancestorM.isPhantom() || !ancestorM.isConcrete()|| SootUtils.isRuntimeStubMethod(ancestorM))     continue;\n    if (ancestorM.isStatic())     continue;\n    if (!cloneAllMethods && !PTABridge.v().getReachableMethods().contains(ancestorM))     continue;\n    if (containsMethod(ancestorM.getSignature())) {\n      continue;\n    }\n    if (ancestorM.isFinal())     ancestorM.setModifiers(ancestorM.getModifiers() ^ Modifier.FINAL);\n    try {\n      cloneMethod(ancestorM,ancestorM.getName());\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Clone non-static ancestor methods that are not hidden by virtual dispatch and that are reachable based on a pta run."}
{"code": "public void writeExif(InputStream jpegStream,String exifOutFileName) throws FileNotFoundException, IOException {\n  if (jpegStream == null || exifOutFileName == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=null;\n  try {\n    s=getExifWriterStream(exifOutFileName);\n    doExifStreamIO(jpegStream,s);\n    s.flush();\n  }\n catch (  IOException e) {\n    closeSilently(s);\n    throw e;\n  }\n  s.close();\n}\n", "nl": "Writes the tags from this ExifInterface object into a jpeg stream, removing prior exif tags."}
{"code": "public boolean isPrimary(){\n  return primary;\n}\n", "nl": "Gets whether the effect is a primary beacon effect."}
{"code": "public boolean applyOptions() throws IOException {\n  URLHandlerSettings.IMAGE_VIEWER.setValue(_viewerField.getText());\n  return false;\n}\n", "nl": "Applies the options currently set in this <tt>PaneItem</tt>."}
{"code": "public void testAlgorithmParameterGenerator08(){\n  if (!DSASupported) {\n    fail(validAlgName + \" algorithm is not supported\");\n    return;\n  }\n  try {\n    AlgorithmParameterGenerator.getInstance(null,validProvider);\n    fail(\"NullPointerException or NoSuchAlgorithmException should be thrown\");\n  }\n catch (  NullPointerException e) {\n  }\ncatch (  NoSuchAlgorithmException e) {\n  }\n  for (int i=0; i < invalidValues.length; i++) {\n    try {\n      AlgorithmParameterGenerator.getInstance(invalidValues[i],validProvider);\n      fail(\"NoSuchAlgorithmException must be thrown (algorithm: \".concat(invalidValues[i]).concat(\")\"));\n    }\n catch (    NoSuchAlgorithmException e) {\n    }\n  }\n}\n", "nl": "Test for <code>getInstance(String algorithm, Provider provider)</code> method Assertion: throws NullPointerException must be thrown is null throws NoSuchAlgorithmException must be thrown if algorithm is not available"}
{"code": "public static int[] reduce(int[] n1){\n  for (int i=0; i < n1.length; i++) {\n    if (n1[i] != 0) {\n      if (i == 0)       return copy(n1);\n      int[] newVal=new int[n1.length - i];\n      extract(newVal,0,n1,i,n1.length - i);\n      return newVal;\n    }\n  }\n  return new int[]{0};\n}\n", "nl": "Strip leading zeros to reduce. Always returns a new copy of the value, never the input even when no zeros."}
{"code": "@CanIgnoreReturnValue @Deprecated @Override public ImmutableSet<V> replaceValues(K key,Iterable<? extends V> values){\n  throw new UnsupportedOperationException();\n}\n", "nl": "Guaranteed to throw an exception and leave the multimap unmodified."}
{"code": "public static void deleteDirectory(final File directory){\n  final File[] filesInTestDir=directory.listFiles();\n  if (filesInTestDir != null) {\n    for (    final File eachFile : filesInTestDir) {\n      eachFile.delete();\n    }\n  }\n  directory.delete();\n}\n", "nl": "Deletes directory's content and then deletes directory itself. Deleting is not recursive."}
{"code": "public static int testIfRead5Snippet(int a){\n  if (a < 0) {\n    container.a=10;\n  }\n  return container.a;\n}\n", "nl": "Here the read should float to the end."}
{"code": "public void cancel(){\n  mTN.hide();\n  try {\n    getService().cancelToast(mContext.getPackageName(),mTN);\n  }\n catch (  RemoteException e) {\n  }\n}\n", "nl": "Close the view if it's showing, or don't show it if it isn't showing yet. You do not normally have to call this.  Normally view will disappear on its own after the appropriate duration."}
{"code": "public MatsimNetworkReader(Network network){\n  this(new IdentityTransformation(),network);\n}\n", "nl": "Creates a new reader for MATSim network files."}
{"code": "boolean nextRow(){\n  currRowSeq++;\n  if (rows == 0 || currRowSubimg >= rows - 1) {\n    if (pass == 7) {\n      ended=true;\n      return false;\n    }\n    setPass(pass + 1);\n    if (rows == 0) {\n      currRowSeq--;\n      return nextRow();\n    }\n    setRow(0);\n  }\n else {\n    setRow(currRowSubimg + 1);\n  }\n  return true;\n}\n", "nl": "Skips passes with no rows. Return false is no more rows"}
{"code": "public EmbeddedSingleNodeKafkaCluster(Properties brokerConfig){\n  this.brokerConfig=new Properties();\n  this.brokerConfig.putAll(brokerConfig);\n}\n", "nl": "Creates and starts a Kafka cluster."}
{"code": "public static void main(String[] args){\n  Scanner input=new Scanner(System.in);\n  System.out.print(\"Enter three sides of the triangle: \");\n  double side1=input.nextDouble();\n  double side2=input.nextDouble();\n  double side3=input.nextDouble();\n  System.out.print(\"Enter a color: \");\n  String color=input.next();\n  System.out.print(\"Is the triangle filled (true / false)? \");\n  boolean filled=input.nextBoolean();\n  Triangle triangle=new Triangle(side1,side2,side3,color,filled);\n  System.out.println(triangle);\n}\n", "nl": "Main method"}
{"code": "@Override public String toString(){\n  StringBuilder stringBuilder=new StringBuilder();\n  stringBuilder.append(String.format(\"%nLocalName : %s\",this.getLocalName()));\n  stringBuilder.append(String.format(\"%nNamespaceURI : %s\",this.getNamespaceURI()));\n  return stringBuilder.toString();\n}\n", "nl": "toString() method of DOMNodeElementTuple"}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "protected void Literal() throws javax.xml.transform.TransformerException {\n  int last=m_token.length() - 1;\n  char c0=m_tokenChar;\n  char cX=m_token.charAt(last);\n  if (((c0 == '\\\"') && (cX == '\\\"')) || ((c0 == '\\'') && (cX == '\\''))) {\n    int tokenQueuePos=m_queueMark - 1;\n    m_ops.m_tokenQueue.setElementAt(null,tokenQueuePos);\n    Object obj=new XString(m_token.substring(1,last));\n    m_ops.m_tokenQueue.setElementAt(obj,tokenQueuePos);\n    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH),tokenQueuePos);\n    m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);\n    nextToken();\n  }\n else {\n    error(XPATHErrorResources.ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,new Object[]{m_token});\n  }\n}\n", "nl": "The value of the Literal is the sequence of characters inside the \" or ' characters>. Literal  ::=  '\"' [^\"]* '\"' | \"'\" [^']* \"'\""}
{"code": "public void handleEvent(Event evt){\n  handleDOMSubtreeModifiedEvent((MutationEvent)evt);\n}\n", "nl": "Handles 'DOMSubtreeModified' event type."}
{"code": "public title addElement(String hashcode,String element){\n  addElementToRegistry(hashcode,element);\n  return (this);\n}\n", "nl": "Adds an Element to the element."}
{"code": "private List<Substitution<ReferenceType>> collectSubstitutions(List<TypeVariable> typeParameters,Substitution<ReferenceType> substitution){\n  List<TypeVariable> genericParameters=new ArrayList<>();\n  List<TypeVariable> nongenericParameters=new ArrayList<>();\n  List<TypeVariable> captureParameters=new ArrayList<>();\n  for (  TypeVariable variable : typeParameters) {\n    if (variable.hasGenericBound()) {\n      genericParameters.add(variable);\n    }\n else {\n      if (variable.isCaptureVariable()) {\n        captureParameters.add(variable);\n      }\n else {\n        nongenericParameters.add(variable);\n      }\n    }\n  }\n  List<Substitution<ReferenceType>> substitutionList=new ArrayList<>();\n  if (!genericParameters.isEmpty()) {\n    TypeCheck typeCheck=TypeCheck.forParameters(genericParameters);\n    if (!nongenericParameters.isEmpty()) {\n      List<List<ReferenceType>> nonGenCandidates=getCandidateTypeLists(nongenericParameters);\n      if (nonGenCandidates.isEmpty()) {\n        return new ArrayList<>();\n      }\n      ListEnumerator<ReferenceType> enumerator=new ListEnumerator<>(nonGenCandidates);\n      while (enumerator.hasNext()) {\n        Substitution<ReferenceType> initialSubstitution=substitution.extend(Substitution.forArgs(nongenericParameters,enumerator.next()));\n        List<TypeVariable> parameters=new ArrayList<>();\n        for (        TypeVariable variable : genericParameters) {\n          TypeVariable param=(TypeVariable)variable.apply(initialSubstitution);\n          parameters.add(param);\n        }\n        substitutionList.addAll(collectSubstitutions(parameters,initialSubstitution));\n      }\n    }\n else {\n      substitutionList=getInstantiations(genericParameters,substitution,typeCheck);\n    }\n    if (substitutionList.isEmpty()) {\n      return substitutionList;\n    }\n  }\n else   if (!nongenericParameters.isEmpty()) {\n    substitution=selectAndExtend(nongenericParameters,substitution);\n    if (substitution == null) {\n      return new ArrayList<>();\n    }\n    substitutionList.add(substitution);\n  }\n  if (!captureParameters.isEmpty()) {\n    List<Substitution<ReferenceType>> substList=new ArrayList<>();\n    if (substitutionList.isEmpty()) {\n      substList.add(selectAndExtend(captureParameters,substitution));\n    }\n else {\n      for (      Substitution<ReferenceType> s : substitutionList) {\n        substList.add(selectAndExtend(captureParameters,s));\n      }\n    }\n    substitutionList=substList;\n  }\n  return substitutionList;\n}\n", "nl": "Recursive function to collect the list of substitutions that extend a substitution for the given type parameters."}
{"code": "private void updateProgress(int progress){\n  if (myHost != null && progress != previousProgress) {\n    myHost.updateProgress(progress);\n  }\n  previousProgress=progress;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public Period plusDays(int days){\n  if (days == 0) {\n    return this;\n  }\n  int[] values=getValues();\n  getPeriodType().addIndexedField(this,PeriodType.DAY_INDEX,values,days);\n  return new Period(values,getPeriodType());\n}\n", "nl": "Returns a new period plus the specified number of days added. <p> This period instance is immutable and unaffected by this method call."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:07.354 -0500\",hash_original_method=\"537B18CC29F2C70486994281CB29500B\",hash_generated_method=\"6A482BE6A74E58339F6E34A315D068FB\") public PathHeader createPathHeader(Address address){\n  if (address == null)   throw new NullPointerException(\"null address!\");\n  Path path=new Path();\n  path.setAddress(address);\n  return path;\n}\n", "nl": "PATH header"}
{"code": "public void test_INSERT_veryLargeLiteral() throws Exception {\n  final Graph g=new LinkedHashModel();\n  final URI s=new URIImpl(\"http://www.bigdata.com/\");\n  final URI p=RDFS.LABEL;\n  final Literal o=getVeryLargeLiteral();\n  final Statement stmt=new StatementImpl(s,p,o);\n  g.add(stmt);\n  assertEquals(1L,doInsertByBody(\"POST\",RDFFormat.RDFXML,g,null));\n  final Graph g2;\n{\n    final String queryStr=\"DESCRIBE <\" + s.stringValue() + \">\";\n    final GraphQuery query=cxn.prepareGraphQuery(QueryLanguage.SPARQL,queryStr);\n    g2=asGraph(query.evaluate());\n  }\n  assertEquals(1,g2.size());\n  assertTrue(g2.match(s,p,o).hasNext());\n}\n", "nl": "Test of insert and retrieval of a large literal."}
{"code": "public static void testFulkersonBFS(){\n  FlowNetworkArray network=new FlowNetworkArray(6,0,5,edges.iterator());\n  FordFulkerson ffa=new FordFulkerson(network,new BFS_SearchArray(network));\n  ffa.compute();\n  validate(network);\n}\n", "nl": "Run in debugger to validate augmenting paths..."}
{"code": "public BaseAdapterHelper linkify(int viewId){\n  TextView view=retrieveView(viewId);\n  Linkify.addLinks(view,Linkify.ALL);\n  return this;\n}\n", "nl": "Add links into a TextView."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:06.772 -0500\",hash_original_method=\"D0F10B1E844DBE54E1C95079D90DDAB9\",hash_generated_method=\"D470C4BE1EF8CCE32AD669400786EA9D\") public Reader retrieveArticleBody(String articleId,ArticlePointer pointer) throws IOException {\n  return __retrieve(NNTPCommand.BODY,articleId,pointer);\n}\n", "nl": "Retrieves an article body from the NNTP server.  The article is referenced by its unique article identifier (including the enclosing &lt and &gt). The article number and identifier contained in the server reply are returned through an ArticlePointer.  The <code> articleId </code> field of the ArticlePointer cannot always be trusted because some NNTP servers do not correctly follow the RFC 977 reply format. <p> A DotTerminatedMessageReader is returned from which the article can be read.  If the article does not exist, null is returned. <p> You must not issue any commands to the NNTP server (i.e., call any other methods) until you finish reading the message from the returned Reader instance. The NNTP protocol uses the same stream for issuing commands as it does for returning results.  Therefore the returned Reader actually reads directly from the NNTP connection.  After the end of message has been reached, new commands can be executed and their replies read.  If you do not follow these requirements, your program will not work properly. <p>"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:48.386 -0400\",hash_original_method=\"F3793FD3E2505AD035424F13E8FC4E3E\",hash_generated_method=\"A58E4C50621A1951F80865295014D02B\") public String decode(String pString,String charset) throws DecoderException, UnsupportedEncodingException {\n  if (pString == null) {\n    return null;\n  }\n  return new String(decode(pString.getBytes(StringEncodings.US_ASCII)),charset);\n}\n", "nl": "Decodes a URL safe string into its original form using the  specified encoding. Escaped characters are converted back  to their original representation."}
{"code": "public double norm2(){\n  return s[0];\n}\n", "nl": "Two norm"}
{"code": "protected void testPut() throws Throwable {\n  Operation op=Operation.createPut(URI.create(echoServiceUri));\n  testEchoOperation(op);\n}\n", "nl": "Tests that PUT method is correctly forwarded to JS and response is correctly forwarded back"}
{"code": "public static Number[] createNumberArray(double[] data){\n  Number[] result=new Number[data.length];\n  for (int i=0; i < data.length; i++) {\n    result[i]=new Double(data[i]);\n  }\n  return result;\n}\n", "nl": "Constructs an array of Number objects from an array of doubles."}
{"code": "public boolean attempt(ObjectReference old,ObjectReference val,Offset offset){\n  return this.plus(offset).attempt(old,val);\n}\n", "nl": "Attempt an atomic store operation. This must be associated with a related call to prepare."}
{"code": "public GuildMemberUpdateHandler(ImplDiscordAPI api){\n  super(api,true,\"GUILD_MEMBER_UPDATE\");\n}\n", "nl": "Creates a new instance of this class."}
{"code": "public static void makeAdvancedBoundingBlock(World world,int x,int y,int z,Coord4D orig){\n  world.setBlock(x,y,z,MekanismBlocks.BoundingBlock,1,0);\n  if (!world.isRemote) {\n    ((TileEntityAdvancedBoundingBlock)world.getTileEntity(x,y,z)).setMainLocation(orig.xCoord,orig.yCoord,orig.zCoord);\n  }\n}\n", "nl": "Places a fake advanced bounding block at the defined location."}
{"code": "private void synchronizeThreads(final TargetProcessThread oldThread,final TargetProcessThread newThread){\n  if (oldThread != null) {\n    oldThread.removeListener(m_internalThreadListener);\n  }\n  if (newThread == null) {\n    CDebuggerPainter.clearDebuggerHighlighting(m_graph);\n  }\n else {\n    newThread.addListener(m_internalThreadListener);\n  }\n}\n", "nl": "Keeps listeners on the active thread."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public static byte[] decodeHex(final char[] data) throws IllegalArgumentException {\n  final int len=data.length;\n  if ((len & 0x01) != 0) {\n    throw new IllegalArgumentException(\"Odd number of characters.\");\n  }\n  final byte[] out=new byte[len >> 1];\n  for (int i=0, j=0; j < len; i++) {\n    int f=toDigit(data[j],j) << 4;\n    j++;\n    f=f | toDigit(data[j],j);\n    j++;\n    out[i]=(byte)(f & 0xFF);\n  }\n  return out;\n}\n", "nl": "Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The returned array will be half the length of the passed array, as it takes two characters to represent any given byte. An exception is thrown if the passed char array has an odd number of elements."}
{"code": "public StorageUnitEntity createStorageUnitEntity(String storageName,String storagePlatform,BusinessObjectDataKey businessObjectDataKey,Boolean businessObjectDataLatestVersion,String businessObjectDataStatusCode,String storageUnitStatus,String storageDirectoryPath){\n  StorageEntity storageEntity=storageDao.getStorageByName(storageName);\n  if (storageEntity == null) {\n    storageEntity=storageDaoTestHelper.createStorageEntity(storageName,storagePlatform);\n  }\n  BusinessObjectDataEntity businessObjectDataEntity=businessObjectDataDao.getBusinessObjectDataByAltKey(businessObjectDataKey);\n  if (businessObjectDataEntity == null) {\n    businessObjectDataEntity=businessObjectDataDaoTestHelper.createBusinessObjectDataEntity(businessObjectDataKey,businessObjectDataLatestVersion,businessObjectDataStatusCode);\n  }\n  return createStorageUnitEntity(storageEntity,businessObjectDataEntity,storageUnitStatus,storageDirectoryPath);\n}\n", "nl": "Creates and persists a new storage unit entity."}
{"code": "protected void appendAndPush(StylesheetHandler handler,ElemTemplateElement elem) throws org.xml.sax.SAXException {\n  handler.pushElemTemplateElement(elem);\n}\n", "nl": "Append the current template element to the current template element, and then push it onto the current template element stack."}
{"code": "void createFbo(){\n  fbo=glGenFramebuffers();\n  glBindFramebuffer(GL_FRAMEBUFFER,fbo);\n  glBindTexture(GL_TEXTURE_2D,depthTexture);\n  glDrawBuffer(GL_NONE);\n  glReadBuffer(GL_NONE);\n  glFramebufferTexture2D(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_TEXTURE_2D,depthTexture,0);\n  int fboStatus=glCheckFramebufferStatus(GL_FRAMEBUFFER);\n  if (fboStatus != GL_FRAMEBUFFER_COMPLETE) {\n    throw new AssertionError(\"Could not create FBO: \" + fboStatus);\n  }\n  glBindTexture(GL_TEXTURE_2D,0);\n  glBindFramebuffer(GL_FRAMEBUFFER,0);\n}\n", "nl": "Create the FBO to render the depth values of the light-render into the depth texture."}
{"code": "public NexradLayer(){\n  setName(\"Nexrad\");\n}\n", "nl": "Construct the DateLayer."}
{"code": "@Deprecated protected void prioritizeCandidates(){\nsynchronized (localCandidates) {\n    LocalCandidate[] candidates=new LocalCandidate[localCandidates.size()];\n    localCandidates.toArray(candidates);\n    for (    Candidate<?> cand : candidates) {\n      cand.computePriority();\n    }\n    Arrays.sort(candidates,candidatePrioritizer);\n    localCandidates.clear();\n    for (    LocalCandidate cand : candidates)     localCandidates.add(cand);\n  }\n}\n", "nl": "Computes the priorities of all <tt>Candidate</tt>s and then sorts them accordingly."}
{"code": "public Pkcs12SignatureToken(String password,File pkcs12File){\n  this(password.toCharArray(),pkcs12File);\n}\n", "nl": "Creates a SignatureTokenConnection with the provided password and path to PKCS#12 file object."}
{"code": "private void addToFavorites(){\n  for (  String game : list.getSelectedValuesList()) {\n    favorites.add(game);\n  }\n  saveFavorites();\n  update();\n}\n", "nl": "Adds the currently selected games to the favorites."}
{"code": "private void serverClientMessage() throws Exception {\n  Ignite ignite=grid(SERVER_NODE_IDX);\n  ClusterGroup grp=ignite.cluster().forClients();\n  assert grp.nodes().size() > 0;\n  registerListenerAndSendMessages(ignite,grp);\n}\n", "nl": "Server sends a message and client receives it."}
{"code": "public void snackBarDismiss(@StringRes int id){\n  snackBar.dismiss(id);\n}\n", "nl": "Use it to programmatically dismiss a SnackBar message."}
{"code": "public void aggregateTimerData(TimerData timerData){\n  super.aggregateInvocationAwareData(timerData);\n  this.setCount(this.getCount() + timerData.getCount());\n  this.setDuration(this.getDuration() + timerData.getDuration());\n  this.calculateMax(timerData.getMax());\n  this.calculateMin(timerData.getMin());\n  if (timerData.isCpuMetricDataAvailable()) {\n    this.setCpuDuration(this.getCpuDuration() + timerData.getCpuDuration());\n    this.calculateCpuMax(timerData.getCpuMax());\n    this.calculateCpuMin(timerData.getCpuMin());\n  }\n  if (timerData.isExclusiveTimeDataAvailable()) {\n    this.addExclusiveDuration(timerData.getExclusiveDuration());\n    this.setExclusiveCount(this.getExclusiveCount() + timerData.getExclusiveCount());\n    this.calculateExclusiveMax(timerData.getExclusiveMax());\n    this.calculateExclusiveMin(timerData.getExclusiveMin());\n  }\n  this.charting=this.charting | timerData.isCharting();\n}\n", "nl": "Aggregates the values given in the supplied timer data parameter to the objects data."}
{"code": "public void prepareForSend(){\n  if (size() == 1) {\n    TextModel text=get(0).getText();\n    if (text != null) {\n      text.cloneText();\n    }\n  }\n}\n", "nl": "Make sure the text in slide 0 is no longer holding onto a reference to the text in the message text box."}
{"code": "public ConnectionConfig(jmri.jmrix.SerialPortAdapter p){\n  super(p);\n}\n", "nl": "Ctor for an object being created during load process; Swing init is deferred."}
{"code": "public static byte[] hexStringToByteArray(String strA){\n  ByteArrayOutputStream result=new ByteArrayOutputStream();\n  byte sum=(byte)0x00;\n  boolean nextCharIsUpper=true;\n  for (int i=0; i < strA.length(); i++) {\n    char c=strA.charAt(i);\nswitch (Character.toUpperCase(c)) {\ncase '0':\n      if (nextCharIsUpper) {\n        sum=(byte)0x00;\n        nextCharIsUpper=false;\n      }\n else {\n        sum|=(byte)0x00;\n        result.write(sum);\n        nextCharIsUpper=true;\n      }\n    break;\ncase '1':\n  if (nextCharIsUpper) {\n    sum=(byte)0x10;\n    nextCharIsUpper=false;\n  }\n else {\n    sum|=(byte)0x01;\n    result.write(sum);\n    nextCharIsUpper=true;\n  }\nbreak;\ncase '2':\nif (nextCharIsUpper) {\nsum=(byte)0x20;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x02;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '3':\nif (nextCharIsUpper) {\nsum=(byte)0x30;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x03;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '4':\nif (nextCharIsUpper) {\nsum=(byte)0x40;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x04;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '5':\nif (nextCharIsUpper) {\nsum=(byte)0x50;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x05;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '6':\nif (nextCharIsUpper) {\nsum=(byte)0x60;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x06;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '7':\nif (nextCharIsUpper) {\nsum=(byte)0x70;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x07;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '8':\nif (nextCharIsUpper) {\nsum=(byte)0x80;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x08;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '9':\nif (nextCharIsUpper) {\nsum=(byte)0x90;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x09;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'A':\nif (nextCharIsUpper) {\nsum=(byte)0xA0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0A;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'B':\nif (nextCharIsUpper) {\nsum=(byte)0xB0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0B;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'C':\nif (nextCharIsUpper) {\nsum=(byte)0xC0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0C;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'D':\nif (nextCharIsUpper) {\nsum=(byte)0xD0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0D;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'E':\nif (nextCharIsUpper) {\nsum=(byte)0xE0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0E;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'F':\nif (nextCharIsUpper) {\nsum=(byte)0xF0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0F;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ndefault :\nbreak;\n}\n}\nif (!nextCharIsUpper) {\nthrow new RuntimeException(\"The String did not contain an equal number of hex digits\");\n}\nreturn result.toByteArray();\n}\n", "nl": "Converts readable hex-String to byteArray"}
{"code": "boolean hasMoreReferralExceptions(){\n  if (debug)   System.out.println(\"LdapReferralException.hasMoreReferralExceptions\");\n  return (nextReferralEx != null);\n}\n", "nl": "Tests if there are any referral exceptions remaining to be processed."}
{"code": "private void saveDescendantState(UIComponent component,FacesContext context){\n  Map<String,SavedState> saved=(Map<String,SavedState>)getStateHelper().get(PropertyKeys.saved);\n  if (component instanceof EditableValueHolder) {\n    EditableValueHolder input=(EditableValueHolder)component;\n    SavedState state=null;\n    String clientId=component.getClientId(context);\n    if (saved == null) {\n      state=new SavedState();\n    }\n    if (state == null) {\n      state=saved.get(clientId);\n      if (state == null) {\n        state=new SavedState();\n      }\n    }\n    state.setValue(input.getLocalValue());\n    state.setValid(input.isValid());\n    state.setSubmittedValue(input.getSubmittedValue());\n    state.setLocalValueSet(input.isLocalValueSet());\n    if (state.hasDeltaState()) {\n      getStateHelper().put(PropertyKeys.saved,clientId,state);\n    }\n else     if (saved != null) {\n      getStateHelper().remove(PropertyKeys.saved,clientId);\n    }\n  }\n else   if (component instanceof UIForm) {\n    UIForm form=(UIForm)component;\n    String clientId=component.getClientId(context);\n    SavedState state=null;\n    if (saved == null) {\n      state=new SavedState();\n    }\n    if (state == null) {\n      state=saved.get(clientId);\n      if (state == null) {\n        state=new SavedState();\n      }\n    }\n    state.setSubmitted(form.isSubmitted());\n    if (state.hasDeltaState()) {\n      getStateHelper().put(PropertyKeys.saved,clientId,state);\n    }\n else     if (saved != null) {\n      getStateHelper().remove(PropertyKeys.saved,clientId);\n    }\n  }\n  if (component.getChildCount() > 0) {\n    for (    UIComponent uiComponent : component.getChildren()) {\n      saveDescendantState(uiComponent,context);\n    }\n  }\n  if (component.getFacetCount() > 0) {\n    for (    UIComponent facet : component.getFacets().values()) {\n      saveDescendantState(facet,context);\n    }\n  }\n}\n", "nl": "<p>Save state information for the specified component and its descendants.</p>"}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public Icon(String id,String sourcePath,SVGResource svgResource){\n  this.id=id;\n  this.sourcePath=sourcePath;\n  this.svgResource=svgResource;\n  this.imageResource=null;\n}\n", "nl": "Creates new icon."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:57:11.304 -0500\",hash_original_method=\"B05B09390509B455A836B09E2A65E5D4\",hash_generated_method=\"B303ADC082E4C769878DBBA7904F78F9\") private Object awaitNanos(Node node,Slot slot,long nanos){\n  int spins=TIMED_SPINS;\n  long lastTime=0;\n  Thread w=null;\n  for (; ; ) {\n    Object v=node.get();\n    if (v != null)     return v;\n    long now=System.nanoTime();\n    if (w == null)     w=Thread.currentThread();\n else     nanos-=now - lastTime;\n    lastTime=now;\n    if (nanos > 0) {\n      if (spins > 0)       --spins;\n else       if (node.waiter == null)       node.waiter=w;\n else       if (w.isInterrupted())       tryCancel(node,slot);\n else       LockSupport.parkNanos(node,nanos);\n    }\n else     if (tryCancel(node,slot) && !w.isInterrupted())     return scanOnTimeout(node);\n  }\n}\n", "nl": "Waits for (at index 0) and gets the hole filled in by another thread.  Fails if timed out or interrupted before hole filled. Same basic logic as untimed version, but a bit messier."}
{"code": "public RoutingInfo(Object o){\n  this.text=o.toString();\n}\n", "nl": "Creates a routing info based on any object. Object's toString() method's output is used as the info text."}
{"code": "public UITab(IBurpExtenderCallbacks callbacks){\n  this.callbacks=callbacks;\n  this.main=new UIMain(callbacks);\n  callbacks.customizeUiComponent(main);\n  callbacks.addSuiteTab(this);\n}\n", "nl": "Create a new Tab."}
{"code": "private void disposeOptionalControls(String groupId){\n  if (optionalControls.containsKey(groupId)) {\n    for (    Control c : optionalControls.get(groupId)) {\n      c.dispose();\n    }\n    optionalControls.remove(groupId);\n  }\n  mainComposite.layout(true,true);\n}\n", "nl": "Disposes all optional controls that belong to the specified group ID."}
{"code": "public void testBug7033() throws Exception {\n  if (!this.DISABLED_testBug7033) {\n    Connection big5Conn=null;\n    Statement big5Stmt=null;\n    PreparedStatement big5PrepStmt=null;\n    String testString=\"\\u5957 \\u9910\";\n    try {\n      Properties props=new Properties();\n      props.setProperty(\"useUnicode\",\"true\");\n      props.setProperty(\"characterEncoding\",\"Big5\");\n      big5Conn=getConnectionWithProps(props);\n      big5Stmt=big5Conn.createStatement();\n      byte[] foobar=testString.getBytes(\"Big5\");\n      System.out.println(Arrays.toString(foobar));\n      this.rs=big5Stmt.executeQuery(\"select 1 as '\\u5957 \\u9910'\");\n      String retrString=this.rs.getMetaData().getColumnName(1);\n      assertTrue(testString.equals(retrString));\n      big5PrepStmt=big5Conn.prepareStatement(\"select 1 as '\\u5957 \\u9910'\");\n      this.rs=big5PrepStmt.executeQuery();\n      retrString=this.rs.getMetaData().getColumnName(1);\n      assertTrue(testString.equals(retrString));\n    }\n  finally {\n      if (this.rs != null) {\n        this.rs.close();\n        this.rs=null;\n      }\n      if (big5Stmt != null) {\n        big5Stmt.close();\n      }\n      if (big5PrepStmt != null) {\n        big5PrepStmt.close();\n      }\n      if (big5Conn != null) {\n        big5Conn.close();\n      }\n    }\n  }\n}\n", "nl": "Tests fix for BUG#7033 - PreparedStatements don't encode Big5 (and other multibyte) character sets correctly in static SQL strings."}
{"code": "public void saveQuery(final HTTPRepository repository,final String queryName,final String userName,final boolean shared,final QueryLanguage queryLanguage,final String queryText,final boolean infer,final int rowsPerPage) throws RDF4JException {\n  if (QueryLanguage.SPARQL != queryLanguage && QueryLanguage.SERQL != queryLanguage) {\n    throw new RepositoryException(\"May only save SPARQL or SeRQL queries, not\" + queryLanguage.toString());\n  }\n  if (0 != rowsPerPage && 10 != rowsPerPage && 20 != rowsPerPage && 50 != rowsPerPage && 100 != rowsPerPage && 200 != rowsPerPage) {\n    throw new RepositoryException(\"Illegal value for rows per page: \" + rowsPerPage);\n  }\n  this.checkQueryText(queryText);\n  final QueryStringBuilder save=new QueryStringBuilder(SAVE);\n  save.replaceURI(REPOSITORY,repository.getRepositoryURL());\n  save.replaceURI(QUERY,\"urn:uuid:\" + UUID.randomUUID());\n  save.replaceQuote(QUERY_NAME,queryName);\n  this.replaceUpdateFields(save,userName,shared,queryLanguage,queryText,infer,rowsPerPage);\n  updateQueryRepository(save.toString());\n}\n", "nl": "Save a query. UNSAFE from an injection point of view. It is the responsibility of the calling code to call checkAccess() with the full credentials first."}
{"code": "public Cache(int pref_size,int size){\n  cache_size=size;\n  prefix_size=pref_size;\n  hashes=new long[cache_size];\n  hashes_idx=new long[cache_size];\n  encodings=new byte[cache_size][];\n  cache=new Object[cache_size];\n}\n", "nl": "Creates the Cache object."}
{"code": "Block createNextBlock(@Nullable final Address to,final long version,@Nullable TransactionOutPoint prevOut,final long time,final byte[] pubKey,final Coin coinbaseValue,final int height){\n  Block b=new Block(params,version);\n  b.setDifficultyTarget(difficultyTarget);\n  b.addCoinbaseTransaction(pubKey,coinbaseValue,height);\n  if (to != null) {\n    Transaction t=new Transaction(params);\n    t.addOutput(new TransactionOutput(params,t,FIFTY_COINS,to));\n    TransactionInput input;\n    if (prevOut == null) {\n      input=new TransactionInput(params,t,Script.createInputScript(EMPTY_BYTES,EMPTY_BYTES));\n      byte[] counter=new byte[32];\n      counter[0]=(byte)txCounter;\n      counter[1]=(byte)(txCounter++ >> 8);\n      input.getOutpoint().setHash(Sha256Hash.wrap(counter));\n    }\n else {\n      input=new TransactionInput(params,t,Script.createInputScript(EMPTY_BYTES,EMPTY_BYTES),prevOut);\n    }\n    t.addInput(input);\n    b.addTransaction(t);\n  }\n  b.setPrevBlockHash(getHash());\n  if (getTimeSeconds() >= time)   b.setTime(getTimeSeconds() + 1);\n else   b.setTime(time);\n  b.solve();\n  try {\n    b.verifyHeader();\n  }\n catch (  VerificationException e) {\n    throw new RuntimeException(e);\n  }\n  if (b.getVersion() != version) {\n    throw new RuntimeException();\n  }\n  return b;\n}\n", "nl": "Returns a solved block that builds on top of this one. This exists for unit tests. In this variant you can specify a public key (pubkey) for use in generating coinbase blocks."}
{"code": "public String stem(String word){\n  if (word.length() > 2) {\n    return recodeEnding(removeEnding(word.toLowerCase()));\n  }\n else {\n    return word.toLowerCase();\n  }\n}\n", "nl": "Returns the stemmed version of the given word. Word is converted to lower case before stemming."}
{"code": "@Override public <T>T[] toArray(T[] array){\n  return newArray(array);\n}\n", "nl": "Returns all the elements in an array, and the type of the result array is the type of the argument array. If the argument array is big enough, the elements from the queue will be stored in it(element immediately following the end of the queue is set to null, if any); otherwise, it will return a new array with the size of the argument array and size of the queue."}
{"code": "public AttributeList(final int size){\n  attributeList=new ArrayList<GetterSetter<E>>(size);\n  for (int i=0; i < size; i++) {\n    attributeList.add(i,new GetterSetter<E>());\n  }\n}\n", "nl": "Construct the list."}
{"code": "public static void main(String[] args){\n  String[] a=StdIn.readAllStrings();\n  int n=a.length;\n  sort(a);\n  for (int i=0; i < n; i++)   StdOut.println(a[i]);\n}\n", "nl": "Reads in a sequence of extended ASCII strings from standard input; MSD radix sorts them; and prints them to standard output in ascending order."}
{"code": "public static FetchVersionResponse send(InternalDistributedMember recipient,LocalRegion r,Object key) throws RemoteOperationException {\n  FetchVersionResponse response=new FetchVersionResponse(r.getSystem(),recipient);\n  RemoteFetchVersionMessage msg=new RemoteFetchVersionMessage(recipient,r.getFullPath(),response,key);\n  Set<?> failures=r.getDistributionManager().putOutgoing(msg);\n  if (failures != null && failures.size() > 0) {\n    throw new RemoteOperationException(LocalizedStrings.GetMessage_FAILED_SENDING_0.toLocalizedString(msg));\n  }\n  return response;\n}\n", "nl": "Send RemoteFetchVersionMessage to the recipient for the given key"}
{"code": "public static void e(String message,Throwable cause){\n  Log.e(LOG_TAG,\"[\" + message + \"]\",cause);\n}\n", "nl": "<p><b>ERROR:</b> This level of logging should be used when something fatal has happened, i.e. something that will have user-visible consequences and won't be recoverable without explicitly deleting some data, uninstalling applications, wiping the data partitions or reflashing the entire phone (or worse). Issues that justify some logging at the ERROR level are typically good candidates to be reported to a statistics-gathering server.</p> <p/> <p><b>This level is always logged.</b></p>"}
{"code": "GridJettyRestHandler(GridRestProtocolHandler hnd,IgniteClosure<String,Boolean> authChecker,IgniteLogger log){\n  assert hnd != null;\n  assert log != null;\n  this.hnd=hnd;\n  this.log=log;\n  this.authChecker=authChecker;\n  this.jsonMapper=new GridJettyObjectMapper();\n  try {\n    initDefaultPage();\n    if (log.isDebugEnabled())     log.debug(\"Initialized default page.\");\n  }\n catch (  IOException e) {\n    U.warn(log,\"Failed to initialize default page: \" + e.getMessage());\n  }\n  try {\n    initFavicon();\n    if (log.isDebugEnabled())     log.debug(favicon != null ? \"Initialized favicon, size: \" + favicon.length : \"Favicon is null.\");\n  }\n catch (  IOException e) {\n    U.warn(log,\"Failed to initialize favicon: \" + e.getMessage());\n  }\n}\n", "nl": "Creates new HTTP requests handler."}
{"code": "public void prepareTaskWorkDir(File path) throws IgniteCheckedException {\n  try {\n    if (path.exists())     throw new IOException(\"Task local directory already exists: \" + path);\n    if (!path.mkdir())     throw new IOException(\"Failed to create directory: \" + path);\n    for (    File resource : rsrcSet) {\n      File symLink=new File(path,resource.getName());\n      try {\n        Files.createSymbolicLink(symLink.toPath(),resource.toPath());\n      }\n catch (      IOException e) {\n        String msg=\"Unable to create symlink \\\"\" + symLink + \"\\\" to \\\"\"+ resource+ \"\\\".\";\n        if (U.isWindows() && e instanceof FileSystemException)         msg+=\"\\n\\nAbility to create symbolic links is required!\\n\" + \"On Windows platform you have to grant permission 'Create symbolic links'\\n\" + \"to your user or run the Accelerator as Administrator.\\n\";\n        throw new IOException(msg,e);\n      }\n    }\n  }\n catch (  IOException e) {\n    throw new IgniteCheckedException(\"Unable to prepare local working directory for the task \" + \"[jobId=\" + jobId + \", path=\"+ path+ ']',e);\n  }\n}\n", "nl": "Prepares working directory for the task. <ul> <li>Creates working directory.</li> <li>Creates symbolic links to all job resources in working directory.</li> </ul>"}
{"code": "public static Map<Unit,Unit> mapTransportsToLoad(final Collection<Unit> units,final Collection<Unit> transports){\n  final List<Unit> canBeTransported=sortByTransportCostDescending(units);\n  final List<Unit> canTransport=sortByTransportCapacityDescendingThenMovesDescending(transports);\n  final Map<Unit,Unit> mapping=new HashMap<>();\n  final IntegerMap<Unit> addedLoad=new IntegerMap<>();\n  for (  final Unit unit : canBeTransported) {\n    final Optional<Unit> transport=loadUnitIntoFirstAvailableTransport(unit,canTransport,mapping,addedLoad);\n    if (transport.isPresent()) {\n      canTransport.remove(transport.get());\n      canTransport.add(transport.get());\n    }\n  }\n  return mapping;\n}\n", "nl": "Returns a map of unit -> transport. Tries to load units evenly across all transports."}
{"code": "public long skipBytes(long n) throws IOException {\n  return checkInputFile().skipBytes((int)n);\n}\n", "nl": "Skip over n bytes in the input file"}
{"code": "public static InputStream openStream(File file) throws FileNotFoundException, IOException {\n  return openStream(file.getAbsolutePath());\n}\n", "nl": "Return an input stream with BOM consumed..."}
{"code": "private void revokeCameraPolicy(org.wso2.emm.agent.beans.Operation operation){\n  if (!operation.isEnabled()) {\n    devicePolicyManager.setCameraDisabled(deviceAdmin,false);\n  }\n}\n", "nl": "Revokes camera policy on the device."}
{"code": "public int tileYToY(int ty){\n  return ty * tileHeight + tileGridYOffset;\n}\n", "nl": "Converts a vertical tile index into the Y coordinate of its upper left pixel.  This is a convenience method.  No attempt is made to detect out-of-range indices."}
{"code": "public DataTable createPairwiseDataTable(boolean showSymetrical){\n  return new DataTablePairwiseMatrixExtractionAdapter(this,this.rowNames,this.columnNames,new String[]{firstAttributeName,secondAttributeName,name},showSymetrical);\n}\n", "nl": "This creates a pairwise data table. If isSymetrical is true, only the pairs of one triangle of the matrix are returned."}
{"code": "public boolean offerFirst(E e){\n  addFirst(e);\n  return true;\n}\n", "nl": "Inserts the specified element at the front of this list."}
{"code": "@SuppressWarnings(\"unchecked\") public void fillSettings(Properties mapping){\n  for (  String key : mapping.stringPropertyNames()) {\n    if (key.equalsIgnoreCase(\"horizon\")) {\n      horizon=Integer.parseInt(mapping.getProperty(key));\n    }\n else     if (key.equalsIgnoreCase(\"discount\")) {\n      discountFactor=Double.parseDouble(mapping.getProperty(key));\n    }\n else     if (key.equalsIgnoreCase(\"gui\")) {\n      showGUI=Boolean.parseBoolean(mapping.getProperty(key));\n    }\n else     if (key.equalsIgnoreCase(\"user\")) {\n      userInput=mapping.getProperty(key);\n    }\n else     if (key.equalsIgnoreCase(\"speech_user\")) {\n      userSpeech=mapping.getProperty(key);\n    }\n else     if (key.equalsIgnoreCase(\"speech_system\")) {\n      systemSpeech=mapping.getProperty(key);\n    }\n else     if (key.equalsIgnoreCase(\"floor\")) {\n      floor=mapping.getProperty(key);\n    }\n else     if (key.equalsIgnoreCase(\"system\")) {\n      systemOutput=mapping.getProperty(key);\n    }\n else     if (key.equalsIgnoreCase(\"monitor\")) {\n      String[] split=mapping.getProperty(key).split(\",\");\n      for (int i=0; i < split.length; i++) {\n        if (split[i].trim().length() > 0) {\n          varsToMonitor.add(split[i].trim());\n        }\n      }\n    }\n else     if (key.equalsIgnoreCase(\"samples\")) {\n      nbSamples=Integer.parseInt(mapping.getProperty(key));\n    }\n else     if (key.equalsIgnoreCase(\"timeout\")) {\n      maxSamplingTime=Integer.parseInt(mapping.getProperty(key));\n    }\n else     if (key.equalsIgnoreCase(\"discretisation\")) {\n      discretisationBuckets=Integer.parseInt(mapping.getProperty(key));\n    }\n else     if (key.equalsIgnoreCase(\"recording\")) {\n      if (mapping.getProperty(key).trim().equalsIgnoreCase(\"last\")) {\n        recording=Recording.LAST_INPUT;\n      }\n else       if (mapping.getProperty(key).trim().equalsIgnoreCase(\"all\")) {\n        recording=Recording.ALL;\n      }\n else {\n        recording=Recording.NONE;\n      }\n    }\n else     if (key.equalsIgnoreCase(\"connect\")) {\n      String[] splits=mapping.getProperty(key).split(\",\");\n      for (      String split : splits) {\n        if (split.contains(\":\")) {\n          String address=split.split(\":\")[0];\n          int port=Integer.parseInt(split.split(\":\")[1]);\n          remoteConnections.put(address,port);\n        }\n else {\n          log.warning(\"address of remote connection must contain port\");\n        }\n      }\n    }\n else     if (key.equalsIgnoreCase(\"modules\") || key.equalsIgnoreCase(\"module\")) {\n      String[] split=mapping.getProperty(key).split(\",\");\n      for (int i=0; i < split.length; i++) {\n        if (split[i].trim().length() > 0) {\n          Class<?> clazz;\n          try {\n            clazz=Class.forName(split[i].trim());\n            for (int j=0; j < clazz.getInterfaces().length; j++) {\n              if (Module.class.isAssignableFrom(clazz.getInterfaces()[j]) && !modules.contains(clazz)) {\n                modules.add((Class<Module>)clazz);\n              }\n            }\n            if (!modules.contains(clazz)) {\n              log.warning(\"class \" + split[i].trim() + \" is not a module\");\n              log.fine(\"interfaces \" + Arrays.asList(clazz.getInterfaces()));\n            }\n          }\n catch (          ClassNotFoundException e) {\n            log.warning(\"class not found: \" + split[i].trim());\n          }\n        }\n      }\n    }\n else {\n      params.put(key,mapping.getProperty(key));\n    }\n  }\n  explicitSettings.addAll(mapping.stringPropertyNames());\n}\n", "nl": "Fills the current settings with the values provided as argument. Existing values are overridden."}
{"code": "public static BranchCoverageTestFitness createBranchCoverageTestFitness(ControlDependency cd){\n  return createBranchCoverageTestFitness(cd.getBranch(),cd.getBranchExpressionValue());\n}\n", "nl": "Create a fitness function for branch coverage aimed at executing the given ControlDependency."}
{"code": "protected boolean hasAttemptRemaining(){\n  return mCurrentRetryCount <= mMaxNumRetries;\n}\n", "nl": "Returns true if this policy has attempts remaining, false otherwise."}
{"code": "protected PropertyImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public TestResult start(String[] args) throws Exception {\n  String testCase=\"\";\n  String method=\"\";\n  boolean wait=false;\n  for (int i=0; i < args.length; i++) {\n    if (args[i].equals(\"-wait\")) {\n      wait=true;\n    }\n else     if (args[i].equals(\"-c\")) {\n      testCase=extractClassName(args[++i]);\n    }\n else     if (args[i].equals(\"-m\")) {\n      String arg=args[++i];\n      int lastIndex=arg.lastIndexOf('.');\n      testCase=arg.substring(0,lastIndex);\n      method=arg.substring(lastIndex + 1);\n    }\n else     if (args[i].equals(\"-v\")) {\n      System.err.println(\"JUnit \" + Version.id() + \" by Kent Beck and Erich Gamma\");\n    }\n else {\n      testCase=args[i];\n    }\n  }\n  if (testCase.equals(\"\")) {\n    throw new Exception(\"Usage: TestRunner [-wait] testCaseName, where name is the name of the TestCase class\");\n  }\n  try {\n    if (!method.equals(\"\")) {\n      return runSingleMethod(testCase,method,wait);\n    }\n    Test suite=getTest(testCase);\n    return doRun(suite,wait);\n  }\n catch (  Exception e) {\n    throw new Exception(\"Could not create and run test suite: \" + e);\n  }\n}\n", "nl": "Starts a test run. Analyzes the command line arguments and runs the given test suite."}
{"code": "public static int compareVersions(String version1,String version2,String split){\n  String[] components1=version1.split(split);\n  String[] components2=version2.split(split);\n  int length=Math.min(components1.length,components2.length);\n  for (int i=0; i < length; i++) {\n    int result=new Integer(components1[i]).compareTo(Integer.parseInt(components2[i]));\n    if (result != 0) {\n      return result;\n    }\n  }\n  return Integer.compare(components1.length,components2.length);\n}\n", "nl": "Compare two versions string, splitted by VERSION_SPLIT static var. Version 1 is old if -1."}
{"code": "public CourseComponent find(Filter<CourseComponent> matcher){\n  if (matcher.apply(this))   return this;\n  if (!isContainer())   return null;\n  CourseComponent found=null;\n  for (  CourseComponent c : children) {\n    found=c.find(matcher);\n    if (found != null)     return found;\n  }\n  return null;\n}\n", "nl": "recursively find the first node by matcher. return null if get nothing."}
{"code": "protected boolean isGzipCompression(){\n  return usegzip;\n}\n", "nl": "Get GZIP compression flag."}
{"code": "@Override public boolean equals(Object obj){\n  if (obj instanceof UnResolvedCallSite) {\n    UnResolvedCallSite cs=(UnResolvedCallSite)obj;\n    return methodRef.equals(cs.methodRef) && bcIndex == cs.bcIndex;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Determine if two call sites are the same.  Exact match: no wild cards."}
{"code": "@Override public String toString(){\n  return \"cudaDeviceProp[\" + createString(\",\") + \"]\";\n}\n", "nl": "Returns a String representation of this object."}
{"code": "private void arrangeAgentDeparture(final MobsimAgent agent){\n  double now=this.getSimTimer().getTimeOfDay();\n  String mode=agent.getMode();\n  Id<Link> linkId=agent.getCurrentLinkId();\n  events.processEvent(new PersonDepartureEvent(now,agent.getId(),linkId,mode));\n  for (  DepartureHandler departureHandler : this.departureHandlers) {\n    if (departureHandler.handleDeparture(now,agent,linkId)) {\n      return;\n    }\n  }\n}\n", "nl": "Informs the simulation that the specified agent wants to depart from its current activity. The simulation can then put the agent onto its vehicle on a link or teleport it to its destination."}
{"code": "private void remove(){\n  before.after=after;\n  after.before=before;\n}\n", "nl": "Removes this entry from the linked list."}
{"code": "public void clearBookmarkedURLS(){\n  bookmarkedURLS.clear();\n}\n", "nl": "Removes all BookmarkedURLs from user's bookmarks."}
{"code": "public static DoubleMatrix[] jblas_fullSVD(double[][] A){\n  return org.jblas.Singular.fullSVD(new DoubleMatrix(A));\n}\n", "nl": "Compute a singular-value decomposition of A."}
{"code": "private void leaveBusy(){\n  busyLock.readLock().unlock();\n}\n", "nl": "Leaves busy state."}
{"code": "private void isiDeleteFS(IsilonApi isi,FileDeviceInputOutput args) throws IsilonException {\n  isiDeleteExports(isi,args);\n  isiDeleteShares(isi,args);\n  if (args.getFsExtensions() != null && args.getFsExtensions().containsKey(QUOTA)) {\n    isi.deleteQuota(args.getFsExtensions().get(QUOTA));\n    args.getFsExtensions().remove(QUOTA);\n  }\n  isiDeleteSnapshots(isi,args);\n  isiDeleteQuotaDirs(isi,args);\n  isi.deleteDir(args.getFsMountPath(),true);\n  isiDeleteSnapshotSchedules(isi,args);\n}\n", "nl": "Deleting a file share: - deletes existing exports and smb shares for the file share (only created by storage os)"}
{"code": "@Override public void drawItem(Graphics2D g2,XYItemRendererState state,Rectangle2D dataArea,PlotRenderingInfo info,XYPlot plot,ValueAxis domainAxis,ValueAxis rangeAxis,XYDataset dataset,int series,int item,CrosshairState crosshairState,int pass){\n  PlotOrientation orientation=plot.getOrientation();\n  if (orientation == PlotOrientation.HORIZONTAL) {\n    drawHorizontalItem(g2,dataArea,info,plot,domainAxis,rangeAxis,dataset,series,item,crosshairState,pass);\n  }\n else   if (orientation == PlotOrientation.VERTICAL) {\n    drawVerticalItem(g2,dataArea,info,plot,domainAxis,rangeAxis,dataset,series,item,crosshairState,pass);\n  }\n}\n", "nl": "Draws the visual representation of a single data item."}
{"code": "public boolean isMissingDataNotificationEnabled(){\n  return missingDataNotificationEnabled;\n}\n", "nl": "Returns the missingDataNotificationEnabled."}
{"code": "public static TranBlob createBlob(InputStream stream) throws IOException {\n  return new TranBlob(new BlobImpl(stream,stream.available()),false);\n}\n", "nl": "Create a new <tt>Blob</tt>. The returned object will be initially immutable."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:13.678 -0400\",hash_original_method=\"BC19E5D6974D4B9B20F25E42BD4200C9\",hash_generated_method=\"862EAF4E6CE0FFE06A4D15D2B126DC2E\") protected ForkJoinWorkerThread(ForkJoinPool pool){\n  super(\"aForkJoinWorkerThread\");\n  this.pool=pool;\n  this.workQueue=pool.registerWorker(this);\n}\n", "nl": "Creates a ForkJoinWorkerThread operating in the given pool."}
{"code": "public static String convertISO8601DurationToNormalTime(String isoTime){\n  String formattedTime=new String();\n  if (isoTime.contains(\"H\") && isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('H'));\n    String minutes=isoTime.substring(isoTime.indexOf('H') + 1,isoTime.indexOf('M'));\n    String seconds=isoTime.substring(isoTime.indexOf('M') + 1,isoTime.indexOf('S'));\n    formattedTime=hours + \":\" + formatTo2Digits(minutes)+ \":\"+ formatTo2Digits(seconds);\n  }\n else   if (!isoTime.contains(\"H\") && isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String minutes=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('M'));\n    String seconds=isoTime.substring(isoTime.indexOf('M') + 1,isoTime.indexOf('S'));\n    formattedTime=minutes + \":\" + formatTo2Digits(seconds);\n  }\n else   if (isoTime.contains(\"H\") && !isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('H'));\n    String seconds=isoTime.substring(isoTime.indexOf('H') + 1,isoTime.indexOf('S'));\n    formattedTime=hours + \":00:\" + formatTo2Digits(seconds);\n  }\n else   if (isoTime.contains(\"H\") && isoTime.contains(\"M\") && !isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('H'));\n    String minutes=isoTime.substring(isoTime.indexOf('H') + 1,isoTime.indexOf('M'));\n    formattedTime=hours + \":\" + formatTo2Digits(minutes)+ \":00\";\n  }\n else   if (!isoTime.contains(\"H\") && !isoTime.contains(\"M\") && isoTime.contains(\"S\")) {\n    String seconds=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('S'));\n    formattedTime=\"0:\" + formatTo2Digits(seconds);\n  }\n else   if (!isoTime.contains(\"H\") && isoTime.contains(\"M\") && !isoTime.contains(\"S\")) {\n    String minutes=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('M'));\n    formattedTime=minutes + \":00\";\n  }\n else   if (isoTime.contains(\"H\") && !isoTime.contains(\"M\") && !isoTime.contains(\"S\")) {\n    String hours=isoTime.substring(isoTime.indexOf('T') + 1,isoTime.indexOf('H'));\n    formattedTime=hours + \":00:00\";\n  }\n  return formattedTime;\n}\n", "nl": "Converting ISO8601 formatted duration to normal readable time"}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static void assertEqualsToString(String expected,TreeLayout<StringTreeNode> actual){\n  String actualString=toString(actual);\n  assertEquals(expected,actualString);\n}\n", "nl": "Check if toString(actuals) is the expected string."}
{"code": "@Override public ODataResponse readEntitySimpleProperty(GetSimplePropertyUriInfo uri_info,String content_type) throws ODataException {\n  Object value=readPropertyValue(uri_info);\n  EdmProperty target=uri_info.getPropertyPath().get(uri_info.getPropertyPath().size() - 1);\n  return EntityProvider.writeProperty(content_type,target,value);\n}\n", "nl": "Writes a Property eg: http://dhus.gael.fr/odata/v1/Products('8')/Name/"}
{"code": "@Bean public CacheManager listAdministratorsCacheManager(){\n  CacheBuilder<Object,Object> cacheBuilder=CacheBuilder.newBuilder().expireAfterWrite(1,TimeUnit.MINUTES).maximumSize(1000);\n  GuavaCacheManager cacheManager=new GuavaCacheManager(\"listAdministrators\");\n  cacheManager.setCacheBuilder(cacheBuilder);\n  return cacheManager;\n}\n", "nl": "administrators cache, refresh every one minutes. no need to distribute if we have multiple web servers (user just not see new administrators)"}
{"code": "public void cacheUnit(UnitInterface unit){\n  allUnits.add(unit);\n}\n", "nl": "add new unit to cache"}
{"code": "public void cancel(){\n  mCancel=true;\n}\n", "nl": "cannot guarantee immediately cancel"}
{"code": "public String toCommaSeparatedString(){\n  String result=\"\";\n  for (int i=0; i < contents.size(); i++) {\n    if (result.equals(\"\")) {\n      result=contents.elementAt(i);\n    }\n else {\n      result=result + \", \" + contents.elementAt(i);\n    }\n  }\n  return result;\n}\n", "nl": "Returns the comma-separated list of all the elements of the list. It returns \"\" if the set is empty."}
{"code": "public void start() throws BaleenException {\n  if (!isRunning()) {\n    LOGGER.debug(\"Starting pipeline {}\",name);\n    try {\n      if (engine.isProcessing()) {\n        LOGGER.info(\"Resuming pipeline {}\",name);\n        engine.resume();\n      }\n else {\n        LOGGER.info(\"Beginning processing on pipeline {}\",name);\n        engine.process();\n      }\n      metrics.getCounter(\"started\").inc();\n    }\n catch (    ResourceInitializationException e) {\n      throw new BaleenException(\"Error starting pipeline\",e);\n    }\n  }\n else {\n    LOGGER.debug(\"Pipeline {} is already running, and so cannot be started\",name);\n  }\n}\n", "nl": "Start the pipeline processing."}
{"code": "public XACacheLoaderTxn(String str){\n  this.tableName=str;\n}\n", "nl": "Creates a new instance of XACacheLoaderTxn"}
{"code": "public static TestConfiguration buildDefaultConfiguration(String testSourcePath,Iterable<File> testSourceFiles,Iterable<String> processors,List<String> options,boolean shouldEmitDebugInfo){\n  String classPath=getDefaultClassPath();\n  File outputDir=getOutputDirFromProperty();\n  TestConfigurationBuilder builder=getDefaultConfigurationBuilder(testSourcePath,outputDir,classPath,testSourceFiles,processors,options,shouldEmitDebugInfo);\n  return builder.validateThenBuild(true);\n}\n", "nl": "This is the default configuration used by Checker Framework JUnit tests."}
{"code": "public RenderableLayer(){\n}\n", "nl": "Creates a new <code>RenderableLayer</code> with a null <code>delegateOwner</code>"}
{"code": "public static MethodScope make(Method m){\n  return new MethodScope(m);\n}\n", "nl": "Factory method. Takes a <tt>Method</tt> object and creates a scope for it."}
{"code": "@Override public ResultSet executeQuery() throws SQLException {\n  try {\n    int id=getNextId(TraceObject.RESULT_SET);\n    if (isDebugEnabled()) {\n      debugCodeAssign(\"ResultSet\",TraceObject.RESULT_SET,id,\"executeQuery()\");\n    }\n    batchIdentities=null;\nsynchronized (session) {\n      checkClosed();\n      closeOldResultSet();\n      ResultInterface result;\n      boolean scrollable=resultSetType != ResultSet.TYPE_FORWARD_ONLY;\n      boolean updatable=resultSetConcurrency == ResultSet.CONCUR_UPDATABLE;\n      try {\n        setExecutingStatement(command);\n        result=command.executeQuery(maxRows,scrollable);\n      }\n  finally {\n        setExecutingStatement(null);\n      }\n      resultSet=new JdbcResultSet(conn,this,result,id,closedByResultSet,scrollable,updatable,cachedColumnLabelMap);\n    }\n    return resultSet;\n  }\n catch (  Exception e) {\n    throw logAndConvert(e);\n  }\n}\n", "nl": "Executes a query (select statement) and returns the result set. If another result set exists for this statement, this will be closed (even if this statement fails)."}
{"code": "public void delete(Project project){\n  if (!security.hasRight(AccessRight.DELETE_PROJECT) && !security.isOwner(project)) {\n    messages.warn(\"You do not have permission to delete this project.\");\n  }\n else {\n    try {\n      new ProjectDao().delete(project);\n      messages.info(\"Project \" + project.getName() + \" has been removed.\");\n      projectEvent.fire(new ModifiedProjectMessage(project,this));\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "deletes a project"}
{"code": "public static void logResult(ResultObject resultObject){\n  logResult(resultObject,out);\n}\n", "nl": "Writes the result string from the given result object in the result file."}
{"code": "public void add(final Object eKey,final Object element){\n  if ((!_elements.containsKey(eKey)) && (getType() != TYPE_UNSYNCHRONIZED_MOV)) {\n    _elementOrder.add(eKey);\n  }\n  _elements.put(eKey,element);\n}\n", "nl": "Adds element with the key into the Ordered List."}
{"code": "private boolean cleanupStaleProtectionSetVolumes(URI protectionSetURI){\n  ProtectionSet protectionSet=dbClient.queryObject(ProtectionSet.class,protectionSetURI);\n  boolean protectionSetRemoved=false;\n  if (protectionSet != null) {\n    StringSet protectionSetVolumes=protectionSet.getVolumes();\n    StringSet volumesToRemove=new StringSet();\n    if (protectionSetVolumes != null) {\n      Iterator<String> volumesItr=protectionSetVolumes.iterator();\n      while (volumesItr.hasNext()) {\n        String volumeUriStr=volumesItr.next();\n        Volume volume=dbClient.queryObject(Volume.class,URI.create(volumeUriStr));\n        if (volume == null) {\n          volumesToRemove.add(volumeUriStr);\n          log.info(\"Removing stale Volume {} referenced by ProtectionSet {}.\",volumeUriStr,protectionSet.getId());\n        }\n      }\n      if (protectionSetVolumes.size() == volumesToRemove.size()) {\n        log.info(\"ProtectionSet {} has no volume references so it is being removed.\",protectionSet.getId());\n        dbClient.markForDeletion(protectionSet);\n        protectionSetRemoved=true;\n      }\n else {\n        protectionSetVolumes.removeAll(volumesToRemove);\n        dbClient.persistObject(protectionSet);\n      }\n    }\n  }\n  return protectionSetRemoved;\n}\n", "nl": "Cleans up stale ProtectionSet volume references. Meaning, volumes referenced by the ProtectionSet that no longer exist in the DB will be removed. Also, if the ProtectionSet ends up containing zero volumes after this operation, the ProtectionSet itself will be removed from the DB."}
{"code": "public void testDoubleSignedZero() throws IOException {\n  Directory dir=newDirectory();\n  RandomIndexWriter writer=new RandomIndexWriter(random(),dir);\n  Document doc=new Document();\n  doc.add(new DoubleDocValuesField(\"value\",+0D));\n  doc.add(newStringField(\"value\",\"+0\",Field.Store.YES));\n  writer.addDocument(doc);\n  doc=new Document();\n  doc.add(new DoubleDocValuesField(\"value\",-0D));\n  doc.add(newStringField(\"value\",\"-0\",Field.Store.YES));\n  writer.addDocument(doc);\n  doc=new Document();\n  IndexReader ir=writer.getReader();\n  writer.close();\n  IndexSearcher searcher=newSearcher(ir);\n  Sort sort=new Sort(new SortField(\"value\",SortField.Type.DOUBLE));\n  TopDocs td=searcher.search(new MatchAllDocsQuery(),10,sort);\n  assertEquals(2,td.totalHits);\n  assertEquals(\"-0\",searcher.doc(td.scoreDocs[0].doc).get(\"value\"));\n  assertEquals(\"+0\",searcher.doc(td.scoreDocs[1].doc).get(\"value\"));\n  ir.close();\n  dir.close();\n}\n", "nl": "Tests sorting on type double with +/- zero"}
{"code": "public static void vibrate(Context context,int vibrateMilliSec){\n  Vibrator v=(Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);\n  v.vibrate(vibrateMilliSec);\n}\n", "nl": "Vibrates the device."}
{"code": "public static void main(String[] args) throws IOException {\n  Source source;\n  if (args.length == 0) {\n    source=Source.newBuilder(new InputStreamReader(System.in)).name(\"<stdin>\").mimeType(SLLanguage.MIME_TYPE).build();\n  }\n else {\n    source=Source.newBuilder(new File(args[0])).build();\n  }\n  executeSource(source,System.in,System.out);\n}\n", "nl": "The main entry point."}
{"code": "public boolean isGroupChatAutoAccepted(){\n  return readBoolean(RcsSettingsData.AUTO_ACCEPT_GROUP_CHAT);\n}\n", "nl": "Is group chat invitation auto accepted"}
{"code": "public static double beta(double a,double b){\n  double try_x;\n  double try_y;\n  do {\n    try_x=Math.pow(raw(),1 / a);\n    try_y=Math.pow(raw(),1 / b);\n  }\n while ((try_x + try_y) > 1);\n  return try_x / (try_x + try_y);\n}\n", "nl": "Generate a random number from a beta random variable."}
{"code": "public String toEPL(EPStatementFormatter formatter){\n  StringWriter writer=new StringWriter();\n  toEPL(formatter,writer);\n  return writer.toString();\n}\n", "nl": "Rendering using the provided formatter."}
{"code": "public VerletParticle3D(ReadonlyVec3D v,float w){\n  this(v.x(),v.y(),v.z(),w);\n}\n", "nl": "Creates particle with weight w at the position of the passed in vector"}
{"code": "public AsyncHttpClient(int httpPort,int httpsPort){\n  this(false,httpPort,httpsPort);\n}\n", "nl": "Creates a new AsyncHttpClient."}
{"code": "public static void komlToBinary(String koml,String binary) throws Exception {\n  Object o;\n  checkKOML();\n  o=KOML.read(koml);\n  if (o == null)   throw new Exception(\"Failed to deserialize object from XML file '\" + koml + \"'!\");\n  writeBinary(binary,o);\n}\n", "nl": "converts a KOML file into a binary one"}
{"code": "protected Location(LocationPK locationId){\n  Assert.notNull(locationId,\"Creation of Location with locationId null\");\n  this.locationId=locationId;\n}\n", "nl": "Create a new Location with the business key."}
{"code": "@Override protected void onPause(){\n  super.onPause();\n  if (mPreview != null) {\n    mPreview.stop();\n  }\n}\n", "nl": "Stops the camera."}
{"code": "protected void mergeFeatures(KMLAbstractContainer sourceContainer){\n  List<KMLAbstractFeature> featuresListCopy=new ArrayList<KMLAbstractFeature>(this.getFeatures().size());\n  Collections.copy(featuresListCopy,this.getFeatures());\n  for (  KMLAbstractFeature sourceFeature : sourceContainer.getFeatures()) {\n    String id=sourceFeature.getId();\n    if (!WWUtil.isEmpty(id)) {\n      for (      KMLAbstractFeature existingFeature : featuresListCopy) {\n        String currentId=existingFeature.getId();\n        if (!WWUtil.isEmpty(currentId) && currentId.equals(id))         this.getFeatures().remove(existingFeature);\n      }\n    }\n    this.getFeatures().add(sourceFeature);\n  }\n}\n", "nl": "Merge a list of incoming features with the current list. If an incoming feature has the same ID as an existing one, replace the existing one, otherwise add the incoming one."}
{"code": "public ChooserIntentBuilder priority(String... packageNames){\n  mIntent.putExtra(BottomSheetChooserActivity.EXTRA_PRIORITY_PACKAGES,new ArrayList<>(Arrays.asList(packageNames)));\n  return this;\n}\n", "nl": "Sets the items which should be listed first in the chooser. First item in the list will be shown first. If history is enabled, history items will appear before the priority items."}
{"code": "public static _ItemType fromString(final String value) throws SOAPSerializationException {\n  return (_ItemType)Enumeration.fromString(value,_ItemType.VALUES_TO_INSTANCES);\n}\n", "nl": "Gets the specific enumeration value in this class appropriate for the given XML attribute value.  If no value is known, null is returned (_DEFAULT is not used; that value is for when the attribute is not present)."}
{"code": "public void registerElementNode(double version,String uri,String localName,Class<? extends FXGNode> nodeClass){\n  scanner.registerElementNode(version,uri,localName,nodeClass);\n}\n", "nl": "Registers a custom FXGNode for a particular type of element encountered  while parsing an FXG document. This method must be called prior to parsing."}
{"code": "@SuppressWarnings(\"deprecation\") private View makeAndAddView(int position,int childrenBottomOrTop,boolean flow,boolean selected){\n  View child;\n  int childrenLeft;\n  if (!mDataChanged) {\n    child=mRecycler.getActiveView(position);\n    if (child != null) {\n      if (ViewDebug.TRACE_RECYCLER) {\n        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());\n      }\n      childrenLeft=getItemLeft(position);\n      setupChild(child,position,childrenBottomOrTop,flow,childrenLeft,selected,true);\n      return child;\n    }\n  }\n  onItemAddedToList(position,flow);\n  childrenLeft=getItemLeft(position);\n  child=obtainView(position,mIsScrap);\n  setupChild(child,position,childrenBottomOrTop,flow,childrenLeft,selected,mIsScrap[0]);\n  return child;\n}\n", "nl": "Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin."}
{"code": "private byte[] generateNonce(){\n  byte[] nonce=new byte[32];\n  SecureRandom secureRandom=new SecureRandom();\n  secureRandom.nextBytes(nonce);\n  return nonce;\n}\n", "nl": "For simplicity, we generate the nonce in the client. However, it should be generated on the server for anti-replay protection."}
{"code": "public void withdraw(double amount){\n  if (amount < getBalance()) {\n    setBalance(getBalance() - amount);\n  }\n else   System.out.println(\"Error! Savings account overdrawn transtaction rejected\");\n}\n", "nl": "Decrease balance by amount"}
{"code": "public static int orientationIndex(Coordinate p1,Coordinate p2,Coordinate q){\n  int index=orientationIndexFilter(p1,p2,q);\n  if (index <= 1)   return index;\n  DD dx1=DD.valueOf(p2.x).selfAdd(-p1.x);\n  DD dy1=DD.valueOf(p2.y).selfAdd(-p1.y);\n  DD dx2=DD.valueOf(q.x).selfAdd(-p2.x);\n  DD dy2=DD.valueOf(q.y).selfAdd(-p2.y);\n  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n}\n", "nl": "Returns the index of the direction of the point <code>q</code> relative to a vector specified by <code>p1-p2</code>."}
{"code": "public static byte[] accDecoderPktOpsMode(int addr,int active,int outputChannel,int cvNum,int data){\n  if (addr < 1 || addr > 511) {\n    log.error(\"invalid address \" + addr);\n    throw new IllegalArgumentException();\n  }\n  if (active < 0 || active > 1) {\n    log.error(\"invalid active (C) bit \" + addr);\n    return null;\n  }\n  if (outputChannel < 0 || outputChannel > 7) {\n    log.error(\"invalid output channel \" + addr);\n    return null;\n  }\n  if (cvNum < 1 || cvNum > 1023) {\n    log.error(\"invalid CV number \" + cvNum);\n    return null;\n  }\n  if (data < 0 || data > 255) {\n    log.error(\"invalid data \" + data);\n    return null;\n  }\n  int lowAddr=addr & 0x3F;\n  int highAddr=((~addr) >> 6) & 0x07;\n  int lowCVnum=(cvNum - 1) & 0xFF;\n  int highCVnum=((cvNum - 1) >> 8) & 0x03;\n  byte[] retVal=new byte[6];\n  retVal[0]=(byte)(0x80 | lowAddr);\n  retVal[1]=(byte)(0x80 | (highAddr << 4) | (active << 3)| outputChannel & 0x07);\n  retVal[2]=(byte)(0xEC | highCVnum);\n  retVal[3]=(byte)(lowCVnum);\n  retVal[4]=(byte)(0xFF & data);\n  retVal[5]=(byte)(retVal[0] ^ retVal[1] ^ retVal[2]^ retVal[3]^ retVal[4]);\n  return retVal;\n}\n", "nl": "From the NMRA RP: Basic Accessory Decoder Packet address for operations mode programming 10AAAAAA 0 1AAACDDD 0 1110CCVV 0 VVVVVVVV 0 DDDDDDDD Where DDD is used to indicate the output whose CVs are being modified and C=1. If CDDD= 0000 then the CVs refer to the entire decoder. The resulting packet would be {preamble} 10AAAAAA 0 1AAACDDD 0 (1110CCVV 0 VVVVVVVV 0 DDDDDDDD) 0 EEEEEEEE 1 Accessory Decoder Address (Configuration Variable Access Instruction) Error Byte"}
{"code": "static private byte[] toBytes(Vector octs){\n  ByteArrayOutputStream bOut=new ByteArrayOutputStream();\n  for (int i=0; i != octs.size(); i++) {\n    try {\n      DEROctetString o=(DEROctetString)octs.elementAt(i);\n      bOut.write(o.getOctets());\n    }\n catch (    ClassCastException e) {\n      throw new IllegalArgumentException(octs.elementAt(i).getClass().getName() + \" found in input should only contain DEROctetString\");\n    }\ncatch (    IOException e) {\n      throw new IllegalArgumentException(\"exception converting octets \" + e.toString());\n    }\n  }\n  return bOut.toByteArray();\n}\n", "nl": "convert a vector of octet strings into a single byte string"}
{"code": "public static double computeArea(Point a,Point b){\n  if (a.getTimestamp() == b.getTimestamp()) {\n    return 0;\n  }\n  if (a.getTimestamp() > b.getTimestamp()) {\n    return computeArea(b,a);\n  }\n  final double x1=a.getTimestamp();\n  final double x2=b.getTimestamp();\n  final double y1=a.getValue();\n  final double y2=b.getValue();\n  if (sameSign(y1,y2)) {\n    final double area=areaPositivePoints(x1,Math.abs(y1),x2,Math.abs(y2));\n    return Math.copySign(area,y1);\n  }\n else {\n    final double interceptsX=computeInterceptsX(x1,x2,y1,y2);\n    final double area1=areaPositivePoints(x1,Math.abs(y1),interceptsX,0);\n    final double area2=areaPositivePoints(interceptsX,0,x2,Math.abs(y2));\n    return Math.copySign(area1,y1) + Math.copySign(area2,y2);\n  }\n}\n", "nl": "Compute the area that two data points form with the X-axis. The area is positive above the X-axis and negative below."}
{"code": "public static CommitLogBucket loadBucket(Key<CommitLogBucket> bucketKey){\n  CommitLogBucket bucket=ofy().load().key(bucketKey).now();\n  return bucket == null ? new CommitLogBucket.Builder().setBucketNum(bucketKey.getId()).build() : bucket;\n}\n", "nl": "Returns the loaded bucket for the given key, or a new object if the bucket doesn't exist."}
{"code": "private void selectAttributeSetInstance(){\n  int m_warehouse_id=getM_Warehouse_ID();\n  int m_product_id=getM_Product_ID();\n  if (m_product_id <= 0)   return;\n  MProduct product=MProduct.get(getCtx(),m_product_id);\n  MWarehouse wh=MWarehouse.get(getCtx(),m_warehouse_id);\n  String title=product.get_Translation(MProduct.COLUMNNAME_Name) + \" - \" + wh.get_Translation(MWarehouse.COLUMNNAME_Name);\n  PAttributeInstance pai=new PAttributeInstance(m_frame,title,m_warehouse_id,0,m_product_id,0);\n  if (pai.getM_AttributeSetInstance_ID() != -1) {\n    fAttrSetInstance_ID.setText(pai.getM_AttributeSetInstanceName());\n    fAttrSetInstance_ID.setValue(new Integer(pai.getM_AttributeSetInstance_ID()));\n  }\n else {\n    fAttrSetInstance_ID.setValue(Integer.valueOf(0));\n  }\n}\n", "nl": "filter by Attribute Set Instance"}
{"code": "public void reallocateMigratingInContainers(){\n  for (  Container container : getContainersMigratingIn()) {\n    if (!getContainerList().contains(container)) {\n      getContainerList().add(container);\n    }\n    if (!getContainerScheduler().getContainersMigratingIn().contains(container.getUid())) {\n      getContainerScheduler().getContainersMigratingIn().add(container.getUid());\n    }\n    getContainerRamProvisioner().allocateRamForContainer(container,container.getCurrentRequestedRam());\n    getContainerBwProvisioner().allocateBwForContainer(container,container.getCurrentRequestedBw());\n    getContainerScheduler().allocatePesForContainer(container,container.getCurrentRequestedMips());\n    setSize(getSize() - container.getSize());\n  }\n}\n", "nl": "Reallocate migrating in containers."}
{"code": "public Matrix(Matrix copy){\n  if (copy == null) {\n    return;\n  }\n  scaleX=copy.scaleX;\n  scaleY=copy.scaleY;\n  skew0=copy.skew0;\n  skew1=copy.skew1;\n  translateX=copy.translateX;\n  translateY=copy.translateY;\n}\n", "nl": "Copy another matrix"}
{"code": "public void actionPerformed(ActionEvent e){\n  DataModel dataModel=getDataEditor().getSelectedDataModel();\n  DataSet dataSet=(DataSet)dataModel;\n  List<Node> variables=new LinkedList<>();\n  for (int j=0; j < dataSet.getNumColumns(); j++) {\n    variables.add(dataSet.getVariable(j));\n  }\n  DataSet newDataSet=new ColtDataSet(0,variables);\n  int newRow=-1;\n  ROWS:   for (int i=0; i < dataSet.getNumRows(); i++) {\n    for (int j=0; j < dataSet.getNumColumns(); j++) {\n      Node variable=dataSet.getVariable(j);\n      if (((Variable)variable).isMissingValue(dataSet.getObject(i,j))) {\n        continue ROWS;\n      }\n    }\n    newRow++;\n    for (int j=0; j < dataSet.getNumColumns(); j++) {\n      newDataSet.setObject(newRow,j,dataSet.getObject(i,j));\n    }\n  }\n  DataModelList list=new DataModelList();\n  list.add(newDataSet);\n  getDataEditor().reset(list);\n  getDataEditor().selectFirstTab();\n}\n", "nl": "Performs the action of loading a session from a file."}
{"code": "public final double rootRelativeSquaredError(){\n  if (m_NoPriors) {\n    return Double.NaN;\n  }\n  return 100.0 * rootMeanSquaredError() / rootMeanPriorSquaredError();\n}\n", "nl": "Returns the root relative squared error if the class is numeric."}
{"code": "public MatFileFilter(String[] names){\n  this();\n  for (  String name : names) {\n    addArrayName(name);\n  }\n}\n", "nl": "Create filter instance and add array names."}
{"code": "public static void create(Context context,int id,CharSequence title,CharSequence content,int smallIcon,boolean ongoing,boolean autoCancel,PendingIntent pendingIntent){\n  create(context,id,title,content,null,smallIcon,smallIcon,ongoing,autoCancel,Notification.VISIBILITY_PUBLIC,pendingIntent);\n}\n", "nl": "Create Notification"}
{"code": "protected void clearEditInfo(){\n  m_editFlag=FolderEditFlag.NONE;\n}\n", "nl": "Limpia el flag de estado del nodo"}
{"code": "public void move(java.awt.event.MouseEvent e){\n}\n", "nl": "Called to set the OffsetGrabPoint to the current mouse location, and update the OffsetGrabPoint with all the other GrabPoint locations, so everything can shift smoothly. Should also set the OffsetGrabPoint to the movingPoint. Should be called only once at the beginning of the general movement, in order to set the movingPoint. After that, redraw(e) should just be called, and the movingPoint will make the adjustments to the graphic that are needed."}
{"code": "public void addProtocolLines(String scriptName,Reader reader,ProtocolInteractor session) throws Exception {\n  final BufferedReader bufferedReader;\n  if (reader instanceof BufferedReader) {\n    bufferedReader=(BufferedReader)reader;\n  }\n else {\n    bufferedReader=new BufferedReader(reader);\n  }\n  doAddProtocolLines(session,scriptName,bufferedReader);\n}\n", "nl": "Reads ProtocolElements from the supplied Reader and adds them to the ProtocolSession."}
{"code": "public static _Fields findByThriftIdOrThrow(int fieldId){\n  _Fields fields=findByThriftId(fieldId);\n  if (fields == null)   throw new IllegalArgumentException(\"Field \" + fieldId + \" doesn't exist!\");\n  return fields;\n}\n", "nl": "Find the _Fields constant that matches fieldId, throwing an exception if it is not found."}
{"code": "private static void encodePatterns(IPath[] patterns,String tag,Map parameters){\n  if (patterns != null && patterns.length > 0) {\n    StringBuffer rule=new StringBuffer(10);\n    for (int i=0, max=patterns.length; i < max; i++) {\n      if (i > 0)       rule.append('|');\n      rule.append(patterns[i]);\n    }\n    parameters.put(tag,String.valueOf(rule));\n  }\n}\n", "nl": "Encode some patterns into XML parameter tag"}
{"code": "public synchronized AddressbookEntry remove(String name){\n  AddressbookEntry removedEntry=entries.remove(StringUtil.toLowerCase(name));\n  if (removedEntry != null) {\n    saveOnChange();\n  }\n  return removedEntry;\n}\n", "nl": "Removes the entry for the given name."}
{"code": "public WrongExpectedVersionException(String message){\n  super(message);\n}\n", "nl": "Creates a new instance with the specified error message."}
{"code": "public Filter removeAttribute(String attribute){\n  try {\n    remove(attribute);\n  }\n catch (  NullPointerException exc) {\n  }\n  return (this);\n}\n", "nl": "Get rid of a current filter."}
{"code": "public static double entropyConditionedOnRows(double[][] train,double[][] test,double numClasses){\n  double returnValue=0, trainSumForRow, testSumForRow, testSum=0;\n  for (int i=0; i < test.length; i++) {\n    trainSumForRow=0;\n    testSumForRow=0;\n    for (int j=0; j < test[0].length; j++) {\n      returnValue-=test[i][j] * Math.log(train[i][j] + 1);\n      trainSumForRow+=train[i][j];\n      testSumForRow+=test[i][j];\n    }\n    testSum=testSumForRow;\n    returnValue+=testSumForRow * Math.log(trainSumForRow + numClasses);\n  }\n  return returnValue / (testSum * log2);\n}\n", "nl": "Computes conditional entropy of the columns given the rows of the test matrix with respect to the train matrix. Uses a Laplace prior. Does NOT normalize the entropy."}
{"code": "public SAML2StatusCodeInvalidException(){\n}\n", "nl": "Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized."}
{"code": "public static FillMode parseFillMode(FXGNode node,String value,String name,FillMode defaultValue){\n  if (FXG_FILLMODE_CLIP_VALUE.equals(value)) {\n    return FillMode.CLIP;\n  }\n else   if (FXG_FILLMODE_REPEAT_VALUE.equals(value)) {\n    return FillMode.REPEAT;\n  }\n else   if (FXG_FILLMODE_SCALE_VALUE.equals(value)) {\n    return FillMode.SCALE;\n  }\n else {\n    if (((AbstractFXGNode)node).isVersionGreaterThanCompiler()) {\n      FXGLog.getLogger().log(FXGLogger.WARN,\"DefaultAttributeValue\",null,((AbstractFXGNode)node).getDocumentName(),node.getStartLine(),node.getStartColumn(),defaultValue,name);\n      return defaultValue;\n    }\n else {\n      throw new FXGException(node.getStartLine(),node.getStartColumn(),\"UnknownFillMode\",value);\n    }\n  }\n}\n", "nl": "Convert an FXG String value to a fillMode enumeration."}
{"code": "private StringPart createStringPart(final String name,final String value){\n  final StringPart stringPart=new StringPart(name,value);\n  stringPart.setTransferEncoding(null);\n  stringPart.setContentType(null);\n  return stringPart;\n}\n", "nl": "Utility method for creating string parts, since we need to remove transferEncoding and content type to behave like a browser"}
{"code": "protected void afterShow(){\n}\n", "nl": "Hook method just after the dialog was made visible."}
{"code": "boolean ancestorIsOk(ElemTemplateElement child){\n  while (child.getParentElem() != null && !(child.getParentElem() instanceof ElemExsltFunction)) {\n    ElemTemplateElement parent=child.getParentElem();\n    if (parent instanceof ElemExsltFuncResult || parent instanceof ElemVariable || parent instanceof ElemParam|| parent instanceof ElemMessage)     return true;\n    child=parent;\n  }\n  return false;\n}\n", "nl": "Verify that a literal result belongs to a result element, a variable,  or a parameter."}
{"code": "public static void removeJavaNoOpLogger(Collection<Handler> rmvHnds){\n  Logger log=Logger.getLogger(\"\");\n  for (  Handler h : log.getHandlers())   log.removeHandler(h);\n  if (!F.isEmpty(rmvHnds)) {\n    for (    Handler h : rmvHnds)     log.addHandler(h);\n  }\n}\n", "nl": "Removes previously added no-op handler for root java logger."}
{"code": "protected void validate() throws IllegalStateException {\n}\n", "nl": "Checks the attributes to see if there are any problems.  Default implementation does nothing, though generally this is discouraged unless there really are no restrictions."}
{"code": "@Override public void beforeFileMovement(@NotNull VirtualFileMoveEvent event){\n  MasonSettings masonSettings=MasonSettings.getInstance(getProject());\n  List<VirtualFile> componentsRoots=masonSettings.getComponentsRootsVirtualFiles();\n  if (componentsRoots.isEmpty()) {\n    return;\n  }\n  VirtualFile movedFile=event.getFile();\n  Set<VirtualFile> rootsSet=new THashSet<VirtualFile>(componentsRoots);\n  if (movedFile.isDirectory()) {\n    if (VfsUtil.isUnder(movedFile,rootsSet) || containsAtLeastOneFile(movedFile,componentsRoots)) {\n      movedFile.putUserData(FORCE_REINDEX,true);\n    }\n  }\n else   if (movedFile.getFileType() instanceof MasonFileType) {\n    if (VfsUtil.isUnder(movedFile,rootsSet)) {\n      movedFile.putUserData(FORCE_REINDEX,true);\n    }\n  }\n}\n", "nl": "Fired before the movement of a file is processed."}
{"code": "public boolean isFirstRun(){\n  return mIsFirstRun;\n}\n", "nl": "Return true if this is the first time the app was opened."}
{"code": "public String toString(){\n  StringBuffer sb=new StringBuffer();\n  sb.append(\"Differences:[ size: \" + size());\n  sb.append(StringUtil.getNewlineStr());\n  if (size() > 0) {\n    for (int i=0; i < size(); i++) {\n      sb.append(get(i).toString());\n      sb.append(StringUtil.getNewlineStr());\n    }\n  }\n else {\n    sb.append(\"XML Nodes are identical, No differences found\");\n  }\n  sb.append(StringUtil.getNewlineStr());\n  sb.append(\"]\");\n  return sb.toString();\n}\n", "nl": "Gets the String representation of the object."}
{"code": "private void checkSoftwareInterruptGeneration(){\n  if (((getStatusIM() & 0b11) == 1) && ((getCauseIP() & 0b11) == 1) & (isStatusIESet())) {\n    if (interruptController != null) {\n      interruptController.request(new TxInterruptRequest(Type.SOFTWARE_INTERRUPT));\n    }\n  }\n}\n", "nl": "if Status<IM>[1:0] == 1 and Cause<IP>[1:0] and Status<IE> == 1, generate a software interrupt request"}
{"code": "public void verifyNewVolumesCanBeCreatedInConsistencyGroup(BlockConsistencyGroup consistencyGroup,List<Volume> cgVolumes){\n  if (!canConsistencyGroupBeModified(consistencyGroup,cgVolumes)) {\n    throw APIException.badRequests.cantCreateNewVolumesInCGActiveFullCopies(consistencyGroup.getLabel());\n  }\n}\n", "nl": "Verify that new volumes can be created in the passed consistency group."}
{"code": "public static final Token newToken(int ofKind){\nswitch (ofKind) {\ndefault :\n    return new Token();\n}\n}\n", "nl": "Returns a new Token object, by default. However, if you want, you can create and return subclass objects based on the value of ofKind. Simply add the cases to the switch for all those special cases. For example, if you have a subclass of Token called IDToken that you want to create if ofKind is ID, simlpy add something like : case MyParserConstants.ID : return new IDToken(); to the following switch statement. Then you can cast matchedToken variable to the appropriate type and use it in your lexical actions."}
{"code": "public static long allocatePool(){\n  long poolPtr=GridUnsafe.allocateMemory(POOL_HDR_LEN);\n  GridUnsafe.setMemory(poolPtr,POOL_HDR_LEN,(byte)0);\n  flags(poolPtr + POOL_HDR_OFF_MEM_1,FLAG_POOLED);\n  flags(poolPtr + POOL_HDR_OFF_MEM_2,FLAG_POOLED);\n  flags(poolPtr + POOL_HDR_OFF_MEM_3,FLAG_POOLED);\n  return poolPtr;\n}\n", "nl": "Allocate pool memory."}
{"code": "private int hashUri(String path){\n  Pattern pattern=Pattern.compile(\"entries/([^/?]+)\");\n  Matcher m=pattern.matcher(path);\n  return m.find() ? m.group(0).hashCode() : 0;\n}\n", "nl": "The URI will be relative to servlet. e.g: entries/key1?foo=123"}
{"code": "public NecronomiconInfusionRitual(String unlocalizedName,int bookType,int dimension,float requiredEnergy,ItemStack item,Object sacrifice,Object... offerings){\n  this(unlocalizedName,bookType,dimension,requiredEnergy,false,item,sacrifice,offerings);\n}\n", "nl": "A Necronomicon Infusion Ritual"}
{"code": "public static DefaultListAdapter adapt(List list,RichObjectWrapper wrapper){\n  return list instanceof AbstractSequentialList ? new DefaultListAdapterWithCollectionSupport(list,wrapper) : new DefaultListAdapter(list,wrapper);\n}\n", "nl": "Factory method for creating new adapter instances."}
{"code": "private int[] multWithElement(int[] a,int element){\n  int degree=computeDegree(a);\n  if (degree == -1 || element == 0) {\n    return new int[1];\n  }\n  if (element == 1) {\n    return IntUtils.clone(a);\n  }\n  int[] result=new int[degree + 1];\n  for (int i=degree; i >= 0; i--) {\n    result[i]=field.mult(a[i],element);\n  }\n  return result;\n}\n", "nl": "Compute the product of a polynomial a with an element from the finite field <tt>GF(2^m)</tt>."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-03-25 15:47:23.611 -0400\",hash_original_method=\"6B975B236D38733D8D97A87E4CBCD8AE\",hash_generated_method=\"652F22B5F8BD6D8D5D9F214EE134C943\") private void positionChildren(int menuWidth,int menuHeight){\n  if (mHorizontalDivider != null)   mHorizontalDividerRects.clear();\n  if (mVerticalDivider != null)   mVerticalDividerRects.clear();\n  final int numRows=mLayoutNumRows;\n  final int numRowsMinus1=numRows - 1;\n  final int numItemsForRow[]=mLayout;\n  int itemPos=0;\n  View child;\n  IconMenuView.LayoutParams childLayoutParams=null;\n  float itemLeft;\n  float itemTop=0;\n  float itemWidth;\n  final float itemHeight=(menuHeight - mHorizontalDividerHeight * (numRows - 1)) / (float)numRows;\n  for (int row=0; row < numRows; row++) {\n    itemLeft=0;\n    itemWidth=(menuWidth - mVerticalDividerWidth * (numItemsForRow[row] - 1)) / (float)numItemsForRow[row];\n    for (int itemPosOnRow=0; itemPosOnRow < numItemsForRow[row]; itemPosOnRow++) {\n      child=getChildAt(itemPos);\n      child.measure(MeasureSpec.makeMeasureSpec((int)itemWidth,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec((int)itemHeight,MeasureSpec.EXACTLY));\n      childLayoutParams=(IconMenuView.LayoutParams)child.getLayoutParams();\n      childLayoutParams.left=(int)itemLeft;\n      childLayoutParams.right=(int)(itemLeft + itemWidth);\n      childLayoutParams.top=(int)itemTop;\n      childLayoutParams.bottom=(int)(itemTop + itemHeight);\n      itemLeft+=itemWidth;\n      itemPos++;\n      if (mVerticalDivider != null) {\n        mVerticalDividerRects.add(new Rect((int)itemLeft,(int)itemTop,(int)(itemLeft + mVerticalDividerWidth),(int)(itemTop + itemHeight)));\n      }\n      itemLeft+=mVerticalDividerWidth;\n    }\n    if (childLayoutParams != null) {\n      childLayoutParams.right=menuWidth;\n    }\n    itemTop+=itemHeight;\n    if ((mHorizontalDivider != null) && (row < numRowsMinus1)) {\n      mHorizontalDividerRects.add(new Rect(0,(int)itemTop,menuWidth,(int)(itemTop + mHorizontalDividerHeight)));\n      itemTop+=mHorizontalDividerHeight;\n    }\n  }\n}\n", "nl": "The positioning algorithm that gets called from onMeasure.  It just computes positions for each child, and then stores them in the child's layout params."}
{"code": "public String value(){\n  String value=this.config.value(this.cluster);\n  if (value.isEmpty()) {\n    value=this.cluster;\n  }\n  return value;\n}\n", "nl": "Gets the adequate tag value from config. Defaults to cluster name."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:01:00.016 -0500\",hash_original_method=\"DB6BBF789AE77B5AE6E5E06EC389C87F\",hash_generated_method=\"0C5447B0DE727866D45AF7AE8D3E7ED1\") public KeyUsage(byte[] encoding) throws IOException {\n  super(encoding);\n  this.keyUsage=(boolean[])ASN1.decode(encoding);\n}\n", "nl": "Creates the extension object on the base of its encoded form."}
{"code": "public final void partChannel(String channel,String reason){\n  this.sendRawLine(\"PART \" + channel + \" :\"+ reason);\n}\n", "nl": "Parts a channel, giving a reason."}
{"code": "public void afterBean(final @Observes AfterBeanDiscovery afterBeanDiscovery,BeanManager beanManager){\n  afterBeanDiscovery.addBean(new ApplicationProducer());\n  afterBeanDiscovery.addBean(new ApplicationMapProducer());\n  afterBeanDiscovery.addBean(new CompositeComponentProducer());\n  afterBeanDiscovery.addBean(new ComponentProducer());\n  afterBeanDiscovery.addBean(new FlashProducer());\n  afterBeanDiscovery.addBean(new FlowMapProducer());\n  afterBeanDiscovery.addBean(new HeaderMapProducer());\n  afterBeanDiscovery.addBean(new HeaderValuesMapProducer());\n  afterBeanDiscovery.addBean(new InitParameterMapProducer());\n  afterBeanDiscovery.addBean(new RequestParameterMapProducer());\n  afterBeanDiscovery.addBean(new RequestParameterValuesMapProducer());\n  afterBeanDiscovery.addBean(new RequestProducer());\n  afterBeanDiscovery.addBean(new RequestMapProducer());\n  afterBeanDiscovery.addBean(new ResourceHandlerProducer());\n  afterBeanDiscovery.addBean(new ExternalContextProducer());\n  afterBeanDiscovery.addBean(new FacesContextProducer());\n  afterBeanDiscovery.addBean(new RequestCookieMapProducer());\n  afterBeanDiscovery.addBean(new SessionProducer());\n  afterBeanDiscovery.addBean(new SessionMapProducer());\n  afterBeanDiscovery.addBean(new ViewMapProducer());\n  afterBeanDiscovery.addBean(new ViewProducer());\n  afterBeanDiscovery.addBean(new DataModelClassesMapProducer());\n  for (  Type type : managedPropertyTargetTypes) {\n    afterBeanDiscovery.addBean(new ManagedPropertyProducer(type,beanManager));\n  }\n}\n", "nl": "After bean discovery."}
{"code": "public boolean isExternal(){\n  return external;\n}\n", "nl": "Returns if this component should have its bounds handled by an external source and not this layout manager. <p> For a more thorough explanation of what this constraint does see the white paper or cheat Sheet at www.migcomponents.com."}
{"code": "public static boolean isWifiEnabled(Context context){\n  WifiManager wifiManager=(WifiManager)context.getSystemService(Context.WIFI_SERVICE);\n  return (wifiManager != null && wifiManager.isWifiEnabled());\n}\n", "nl": "Check if WIFI connection is enabled"}
{"code": "public boolean isStatic(){\n  unsupportedIn2();\n  return this.isStatic;\n}\n", "nl": "Returns whether this import declaration is a static import (added in JLS3 API)."}
{"code": "public boolean isEnforcesTodaysHistoricFixings(){\n  return enforcesTodaysHistoricFixings;\n}\n", "nl": "Enforce today's historic fixings //TODO: Q ? Should this be at Settings level ?"}
{"code": "public ListEditor(Vector<String> model){\n  this.listeners=new Vector<ListDataListener>();\n  setLayout(new GridBagLayout());\n  editor=new LimeTextField(\"\");\n  editor.setColumns(DEFAULT_COLUMNS);\n  editor.setPreferredSize(new Dimension(500,20));\n  editor.setMaximumSize(new Dimension(500,20));\n  GridBagConstraints gbc=new GridBagConstraints();\n  gbc.fill=GridBagConstraints.BOTH;\n  gbc.anchor=GridBagConstraints.NORTHWEST;\n  gbc.weightx=1;\n  add(editor,gbc);\n  Action addAction=new AddAction();\n  addButton=new JButton(addAction);\n  GUIUtils.bindKeyToAction(editor,KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),addAction);\n  gbc=new GridBagConstraints();\n  gbc.anchor=GridBagConstraints.NORTHWEST;\n  gbc.insets=new Insets(0,ButtonRow.BUTTON_SEP,0,0);\n  add(addButton,gbc);\n  Action removeAction=new RemoveAction();\n  removeButton=new JButton(removeAction);\n  removeButton.setEnabled(false);\n  gbc.gridwidth=GridBagConstraints.REMAINDER;\n  add(removeButton,gbc);\n  list=new JList<Object>();\n  list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  list.addListSelectionListener(new ListListener());\n  GUIUtils.bindKeyToAction(list,KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0),removeAction);\n  JScrollPane scrollPane=new JScrollPane(list,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n  setModel(model);\n  scrollPane.setPreferredSize(new Dimension(500,50));\n  scrollPane.setMaximumSize(new Dimension(500,50));\n  gbc=new GridBagConstraints();\n  gbc.insets=new Insets(ButtonRow.BUTTON_SEP,0,0,0);\n  gbc.gridwidth=GridBagConstraints.REMAINDER;\n  gbc.anchor=GridBagConstraints.NORTHWEST;\n  gbc.fill=GridBagConstraints.BOTH;\n  gbc.weighty=1;\n  add(scrollPane,gbc);\n}\n", "nl": "Creates a new list editor with the given underlying model. New elements are added to the tail of the list by default."}
{"code": "public void complainAboutUnknownAttributes(String elementXpath,String... knownAttributes){\n  SortedMap<String,SortedSet<String>> problems=new TreeMap<>();\n  NodeList nodeList=getNodeList(elementXpath,false);\n  for (int i=0; i < nodeList.getLength(); ++i) {\n    Element element=(Element)nodeList.item(i);\n    Set<String> unknownAttributes=getUnknownAttributes(element,knownAttributes);\n    if (null != unknownAttributes) {\n      String elementName=element.getNodeName();\n      SortedSet<String> allUnknownAttributes=problems.get(elementName);\n      if (null == allUnknownAttributes) {\n        allUnknownAttributes=new TreeSet<>();\n        problems.put(elementName,allUnknownAttributes);\n      }\n      allUnknownAttributes.addAll(unknownAttributes);\n    }\n  }\n  if (problems.size() > 0) {\n    StringBuilder message=new StringBuilder();\n    for (    Map.Entry<String,SortedSet<String>> entry : problems.entrySet()) {\n      if (message.length() > 0) {\n        message.append(\", \");\n      }\n      message.append('<');\n      message.append(entry.getKey());\n      for (      String attributeName : entry.getValue()) {\n        message.append(' ');\n        message.append(attributeName);\n        message.append(\"=\\\"...\\\"\");\n      }\n      message.append('>');\n    }\n    message.insert(0,\"Unknown attribute(s) on element(s): \");\n    String msg=message.toString();\n    SolrException.log(log,msg);\n    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,msg);\n  }\n}\n", "nl": "Logs an error and throws an exception if any of the element(s) at the given elementXpath contains an attribute name that is not among knownAttributes."}
{"code": "@Override public double variance(){\n  return Double.NaN;\n}\n", "nl": "The Cauchy distribution is unique in that it does not have a variance value (undefined)."}
{"code": "private static CInliningResult inlineFunctionSilently(final JFrame parent,final IViewContainer viewContainer,final ZyGraph graph,final INaviCodeNode node,final INaviInstruction instruction,final INaviFunction function){\n  final INaviFunction inlineFunction=prepareFunctionInlining(parent,node,instruction,function,viewContainer);\n  if (inlineFunction == null) {\n    return null;\n  }\n else   if (inlineFunction.getBasicBlockCount() == 0) {\n    return null;\n  }\n else {\n    try {\n      if (!inlineFunction.isLoaded()) {\n        inlineFunction.load();\n      }\n      return CInliningHelper.inlineCodeNode(graph.getRawView(),node,instruction,inlineFunction);\n    }\n catch (    final CouldntLoadDataException e) {\n      exceptionDialog(parent,inlineFunction,e);\n    }\n  }\n  return null;\n}\n", "nl": "Inlines a node without prompting the user for anything."}
{"code": "@Override public String toString(){\n  return this.name;\n}\n", "nl": "Returns a string representing the object."}
{"code": "@Nullable static ValidationResult create(final CommandLineFile file){\n  final Command command=file.findRealCommand();\n  if (command == null) {\n    return null;\n  }\n  final ValidationResultImpl validationLayout=new ValidationResultImpl(command);\n  file.acceptChildren(validationLayout);\n  return validationLayout;\n}\n", "nl": "Creates validation result by file"}
{"code": "public boolean isConsumesForecast(){\n  Object oo=get_Value(COLUMNNAME_IsConsumesForecast);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Is Consumes Forecast."}
{"code": "public static SnmpEngineId createEngineId(InetAddress address,int port) throws IllegalArgumentException {\n  int suniana=42;\n  if (address == null)   throw new IllegalArgumentException(\"InetAddress is null.\");\n  return createEngineId(address,port,suniana);\n}\n", "nl": "Generates a unique engine Id. The engine Id unicity is based on the host IP address and port. The IP address used is the passed one. The creation algorithm uses the SUN Microsystems IANA number (42)."}
{"code": "private void recordStats(){\n  long finalizationPendingCount=memoryMXBean.getObjectPendingFinalizationCount();\n  MemoryUsage heap=memoryMXBean.getHeapMemoryUsage();\n  MemoryUsage nonHeap=memoryMXBean.getNonHeapMemoryUsage();\n  Map<String,Long> metrics=Maps.newHashMap();\n  metrics.put(\"pending-finalization-count\",finalizationPendingCount);\n  recordMemoryUsage(\"heap.total\",heap,metrics);\n  recordMemoryUsage(\"nonheap.total\",nonHeap,metrics);\n  for (  GarbageCollectorMXBean gcMXBean : gcMXBeans) {\n    String gcName=gcMXBean.getName().replace(\" \",\"_\");\n    metrics.put(\"gc.\" + gcName + \".count\",gcMXBean.getCollectionCount());\n    final long time=gcMXBean.getCollectionTime();\n    final long prevTime=gcTimes.get(gcMXBean).get();\n    final long runtime=time - prevTime;\n    metrics.put(\"gc.\" + gcName + \".time\",time);\n    metrics.put(\"gc.\" + gcName + \".runtime\",runtime);\n    if (runtime > 0) {\n      gcTimes.get(gcMXBean).set(time);\n    }\n  }\n  long loadedClassCount=classLoadingMXBean.getLoadedClassCount();\n  long totalLoadedClassCount=classLoadingMXBean.getTotalLoadedClassCount();\n  long unloadedClassCount=classLoadingMXBean.getUnloadedClassCount();\n  metrics.put(\"loaded-class-count\",loadedClassCount);\n  metrics.put(\"total-loaded-class-count\",totalLoadedClassCount);\n  metrics.put(\"unloaded-class-count\",unloadedClassCount);\n  for (  MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {\n    String type=poolTypeToMetricName(memoryPoolMXBean.getType());\n    String name=poolNameToMetricName(memoryPoolMXBean.getName());\n    String prefix=type + '.' + name;\n    MemoryUsage usage=memoryPoolMXBean.getUsage();\n    recordMemoryUsage(prefix,usage,metrics);\n  }\n  recordGaugeValues(metrics);\n}\n", "nl": "Records all memory statistics"}
{"code": "public int deleteByExample(UserExample example) throws SQLException {\n  int rows=sqlMapClient.delete(\"t_user.ibatorgenerated_deleteByExample\",example);\n  return rows;\n}\n", "nl": "This method was generated by Apache iBATIS ibator. This method corresponds to the database table t_user"}
{"code": "public static void main(String[] args) throws Exception {\n  ICluster alice=Cluster.joinAwait(ImmutableMap.of(\"name\",\"Alice\"));\n  System.out.println(now() + \" Alice join members: \" + alice.members());\n  alice.listenMembership().subscribe(null);\n  ICluster bob=Cluster.joinAwait(ImmutableMap.of(\"name\",\"Bob\"),alice.address());\n  System.out.println(now() + \" Bob join members: \" + bob.members());\n  bob.listenMembership().subscribe(null);\n  ICluster carol=Cluster.joinAwait(ImmutableMap.of(\"name\",\"Carol\"),alice.address(),bob.address());\n  System.out.println(now() + \" Carol join members: \" + carol.members());\n  carol.listenMembership().subscribe(null);\n  Future<Void> shutdownFuture=bob.shutdown();\n  shutdownFuture.get();\n  long maxRemoveTimeout=MembershipConfig.DEFAULT_SUSPECT_TIMEOUT + 3 * FailureDetectorConfig.DEFAULT_PING_INTERVAL;\n  Thread.sleep(maxRemoveTimeout);\n}\n", "nl": "Main method."}
{"code": "public static String toBinaryString(byte[] input){\n  String result=\"\";\n  int i;\n  for (i=0; i < input.length; i++) {\n    int e=input[i];\n    for (int ii=0; ii < 8; ii++) {\n      int b=(e >>> ii) & 1;\n      result+=b;\n    }\n    if (i != input.length - 1) {\n      result+=\" \";\n    }\n  }\n  return result;\n}\n", "nl": "Convert a byte array to the corresponding bit string."}
{"code": "public BranchLookup(PlanNode input,TableNode source,TableNode branch,List<TableSource> tables){\n  this(input,source,source,branch,tables);\n  assert (source == branch.getParent());\n}\n", "nl": "Lookup an immediate child of the starting point."}
{"code": "public int optInt(String key){\n  return optInt(key,0);\n}\n", "nl": "Get an optional int value associated with a key, or zero if there is no such key or if the value is not a number. If the value is a string, an attempt will be made to evaluate it as a number."}
{"code": "public String path(){\n  return this.uri.getPath();\n}\n", "nl": "Get path part of the HREF."}
{"code": "private byte[] generateRandomData(){\n  byte[] data=new byte[10 * Settings.BUFFER_SIZE + 271];\n  PRNG.getRandom().nextBytes(data);\n  return data;\n}\n", "nl": "Returns the data used to test the redirect stream."}
{"code": "public String readUntil(char c){\n  int ix=data.indexOf(c,pos);\n  if (ix == -1)   throw new RuntimeException(\"readUntil did not find character '\" + c + \"'\");\n  return readN(data.indexOf(c,pos) - pos);\n}\n", "nl": "Read until the next char is c, and return the string."}
{"code": "public final void expectAtLeastOneResult(ResultSet rs) throws AdeInternalException, SQLException {\n  if (!rs.next()) {\n    throw new AdeInternalException(\"Expecting at least one row from \" + m_sql);\n  }\n}\n", "nl": "Verifies given result set contains at least one row. Issues a standard error if not. This row is then ready to be obtained from the result set (next() already called)"}
{"code": "public static boolean exists(final String file){\n  return exists(file,false);\n}\n", "nl": "Use this to check whether or not a file exists on the filesystem."}
{"code": "@Override public void write(String str){\n  write(str.toCharArray());\n}\n", "nl": "Writes the characters from the specified string to the target."}
{"code": "private <T>IsilonList<T> list(URI url,String key,Class<T> c,String resumeToken) throws IsilonException {\n  ClientResponse resp=null;\n  try {\n    URI getUrl=url;\n    if (resumeToken != null && !resumeToken.isEmpty()) {\n      getUrl=getUrl.resolve(\"?resume=\" + resumeToken);\n    }\n    resp=_client.get(getUrl);\n    JSONObject obj=resp.getEntity(JSONObject.class);\n    IsilonList<T> ret=new IsilonList<T>();\n    if (resp.getStatus() == 200) {\n      sLogger.debug(\"list {} : Output from Server: {} \",key,obj.get(key).toString());\n      JSONArray array=obj.getJSONArray(key);\n      for (int i=0; i < array.length(); i++) {\n        JSONObject exp=array.getJSONObject(i);\n        ret.add(new Gson().fromJson(SecurityUtils.sanitizeJsonString(exp.toString()),c));\n      }\n      if (obj.has(\"resume\") && !obj.getString(\"resume\").equals(\"null\")) {\n        ret.setToken(obj.getString(\"resume\"));\n      }\n    }\n else {\n      processErrorResponse(\"list\",key,resp.getStatus(),obj);\n    }\n    return ret;\n  }\n catch (  IsilonException ie) {\n    throw ie;\n  }\ncatch (  Exception e) {\n    String response=String.format(\"%1$s\",(resp == null) ? \"\" : resp);\n    throw IsilonException.exceptions.listResourcesFailedOnIsilonArray(key,response,e);\n  }\n finally {\n    if (resp != null) {\n      resp.close();\n    }\n  }\n}\n", "nl": "Generic list resources implementation"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:57.973 -0400\",hash_original_method=\"85142D2E9E15EB93CC97B3004876EC03\",hash_generated_method=\"57EBD7EEA30AC5594D23024CA2FA7FFF\") public FileAlterationObserver(String directoryName){\n  this(new File(directoryName));\n}\n", "nl": "Construct an observer for the specified directory."}
{"code": "protected final void EMIT_LongUnary(Instruction s,Operand result,Operand value1,boolean negOrNot){\n  Operand lhs, lowlhs;\n  boolean needsMove=!value1.similar(result);\n  if (result.isRegister()) {\n    Register lhsReg=result.asRegister().getRegister();\n    Register lowlhsReg=regpool.getSecondReg(lhsReg);\n    lowlhs=new RegisterOperand(lowlhsReg,TypeReference.Int);\n    lhs=new RegisterOperand(lhsReg,TypeReference.Int);\n  }\n else {\n    if (VM.VerifyAssertions)     opt_assert(result.isMemory());\n    lowlhs=setSize(result.asMemory(),DW);\n    lhs=lowlhs.copy();\n    lhs.asMemory().disp=lhs.asMemory().disp.plus(4);\n  }\n  if (needsMove) {\n    Operand rhs1, lowrhs1;\n    if (value1.isRegister()) {\n      Register rhs1Reg=value1.asRegister().getRegister();\n      Register lowrhs1Reg=regpool.getSecondReg(rhs1Reg);\n      lowrhs1=new RegisterOperand(lowrhs1Reg,TypeReference.Int);\n      rhs1=new RegisterOperand(rhs1Reg,TypeReference.Int);\n    }\n else {\n      if (VM.VerifyAssertions)       opt_assert(value1.isMemory());\n      lowrhs1=setSize(value1.asMemory(),DW);\n      rhs1=lowrhs1.copy();\n      rhs1.asMemory().disp=rhs1.asMemory().disp.plus(4);\n    }\n    EMIT(CPOS(s,MIR_Move.create(IA32_MOV,lowlhs.copy(),lowrhs1)));\n    EMIT(CPOS(s,MIR_Move.create(IA32_MOV,lhs.copy(),rhs1)));\n  }\n  if (negOrNot) {\n    EMIT(CPOS(s,MIR_UnaryAcc.create(IA32_NEG,lowlhs)));\n    EMIT(CPOS(s,MIR_UnaryAcc.create(IA32_NOT,lhs)));\n    EMIT(CPOS(s,MIR_BinaryAcc.create(IA32_SBB,lhs.copy(),IC(-1))));\n  }\n else {\n    EMIT(CPOS(s,MIR_UnaryAcc.create(IA32_NOT,lowlhs)));\n    EMIT(CPOS(s,MIR_UnaryAcc.create(IA32_NOT,lhs)));\n  }\n}\n", "nl": "Creates the MIR instruction for LONG_NEG or LONG_NOT"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public String authenticate(String username,String password,String resource) throws XMPPException {\n  String selectedMechanism=null;\n  for (  String mechanism : mechanismsPreferences) {\n    if (implementedMechanisms.containsKey(mechanism) && serverMechanisms.contains(mechanism)) {\n      selectedMechanism=mechanism;\n      break;\n    }\n  }\n  if (selectedMechanism != null) {\n    try {\n      Class<? extends SASLMechanism> mechanismClass=implementedMechanisms.get(selectedMechanism);\n      Constructor<? extends SASLMechanism> constructor=mechanismClass.getConstructor(SASLAuthentication.class);\n      currentMechanism=constructor.newInstance(this);\n      currentMechanism.authenticate(username,connection.getServiceName(),password);\nsynchronized (this) {\n        if (!saslNegotiated && !saslFailed) {\n          try {\n            wait(30000);\n          }\n catch (          InterruptedException e) {\n          }\n        }\n      }\n      if (saslFailed) {\n        if (errorCondition != null) {\n          throw new XMPPException(\"SASL authentication \" + selectedMechanism + \" failed: \"+ errorCondition);\n        }\n else {\n          throw new XMPPException(\"SASL authentication failed using mechanism \" + selectedMechanism);\n        }\n      }\n      if (saslNegotiated) {\n        return bindResourceAndEstablishSession(resource);\n      }\n else {\n        return new NonSASLAuthentication(connection).authenticate(username,password,resource);\n      }\n    }\n catch (    XMPPException e) {\n      throw e;\n    }\ncatch (    Exception e) {\n      e.printStackTrace();\n      return new NonSASLAuthentication(connection).authenticate(username,password,resource);\n    }\n  }\n else {\n    return new NonSASLAuthentication(connection).authenticate(username,password,resource);\n  }\n}\n", "nl": "Performs SASL authentication of the specified user. If SASL authentication was successful then resource binding and session establishment will be performed. This method will return the full JID provided by the server while binding a resource to the connection.<p> The server may assign a full JID with a username or resource different than the requested by this method."}
{"code": "public ScreenCapturePixelMatrixEditor(){\n  super();\n  initComponents();\n  layoutComponents();\n}\n", "nl": "Create a new screen capture pixel matrix editor."}
{"code": "public void startAnimation(){\n  resetAnimation();\n}\n", "nl": "Starts the progress bar animation. (This is an alias of resetAnimation() so it does the same thing.)"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public static String hmac(String data,String key) throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException {\n  SecretKeySpec keySpec=new SecretKeySpec(key.getBytes(\"UTF-8\"),\"HmacSHA256\");\n  Mac mac=Mac.getInstance(\"HmacSHA256\");\n  mac.init(keySpec);\n  return Hash.toHexString(mac.doFinal(data.getBytes(\"UTF-8\")));\n}\n", "nl": "calculates the hamc"}
{"code": "public void visitLocalVariable(String name,String desc,String signature,Label start,Label end,int index){\n  if (mv != null) {\n    mv.visitLocalVariable(name,desc,signature,start,end,index);\n  }\n}\n", "nl": "Visits a local variable declaration."}
{"code": "public static final boolean exists(String code){\n  return mapping.containsKey(code.toLowerCase());\n}\n", "nl": "see if the given country in alpha-2 country code exists"}
{"code": "public XMLElement(String fullName,String systemID,int lineNr){\n  this(fullName,null,systemID,lineNr);\n}\n", "nl": "Creates an empty element."}
{"code": "public boolean hasMatch(){\n  return _match != null;\n}\n", "nl": "Accessor to use to see if any formats matched well enough with the input data."}
{"code": "@Override public void execute(String[] params,Server server,Conversation conversation,IRCService service) throws CommandException {\n  if (params.length == 2) {\n    service.getConnection(server.getId()).joinChannel(params[1]);\n  }\n else   if (params.length == 3) {\n    service.getConnection(server.getId()).joinChannel(params[1],params[2]);\n  }\n else {\n    throw new CommandException(service.getString(R.string.invalid_number_of_params));\n  }\n}\n", "nl": "Execute /join"}
{"code": "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n  stream.defaultReadObject();\n  this.backgroundPaint=SerialUtilities.readPaint(stream);\n}\n", "nl": "Provides serialization support."}
{"code": "BitMatrix buildFunctionPattern(){\n  int dimension=getDimensionForVersion();\n  BitMatrix bitMatrix=new BitMatrix(dimension);\n  bitMatrix.setRegion(0,0,9,9);\n  bitMatrix.setRegion(dimension - 8,0,8,9);\n  bitMatrix.setRegion(0,dimension - 8,9,8);\n  int max=alignmentPatternCenters.length;\n  for (int x=0; x < max; x++) {\n    int i=alignmentPatternCenters[x] - 2;\n    for (int y=0; y < max; y++) {\n      if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {\n        continue;\n      }\n      bitMatrix.setRegion(alignmentPatternCenters[y] - 2,i,5,5);\n    }\n  }\n  bitMatrix.setRegion(6,9,1,dimension - 17);\n  bitMatrix.setRegion(9,6,dimension - 17,1);\n  if (versionNumber > 6) {\n    bitMatrix.setRegion(dimension - 11,0,3,6);\n    bitMatrix.setRegion(0,dimension - 11,6,3);\n  }\n  return bitMatrix;\n}\n", "nl": "See ISO 18004:2006 Annex E"}
{"code": "public SnapshotsStatusRequestBuilder addSnapshots(String... snapshots){\n  request.snapshots(ObjectArrays.concat(request.snapshots(),snapshots,String.class));\n  return this;\n}\n", "nl": "Adds additional snapshots to the list of snapshots to return"}
{"code": "public static void encodeToFile(byte[] dataToEncode,String filename) throws java.io.IOException {\n  if (dataToEncode == null) {\n    throw new NullPointerException(\"Data to encode was null.\");\n  }\n  Base64.OutputStream bos=null;\n  try {\n    bos=new Base64.OutputStream(new java.io.FileOutputStream(filename),Base64.ENCODE);\n    bos.write(dataToEncode);\n  }\n catch (  java.io.IOException e) {\n    throw e;\n  }\n finally {\n    try {\n      bos.close();\n    }\n catch (    Exception e) {\n    }\n  }\n}\n", "nl": "Convenience method for encoding data to a file. <p>As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.</p>"}
{"code": "public static ComponentUI createUI(JComponent list){\n  return new PaletteListUI();\n}\n", "nl": "Returns a new instance of PaletteListUI.  PaletteListUI delegates are allocated one per JList."}
{"code": "public DbUtils() throws Exception {\n  super();\n}\n", "nl": "initializes the object."}
{"code": "default boolean matches(Repository repository,T entity){\n  return matches(entity);\n}\n", "nl": "Defines a predicate for matching entities"}
{"code": "public MultiStep(Steppable step,int n,boolean countdown){\n  if (n < 0)   n=0;\n  this.n=n;\n  this.step=step;\n  this.countdown=countdown;\n  current=n;\n}\n", "nl": "If countdown is true, then we call step.step(...) once every N times we're stepped. if countdown is false, then we call step.step(...) N times every time we're stepped."}
{"code": "public void generateOptimizedNonBooleanEqual(BlockScope currentScope,BranchLabel trueLabel,BranchLabel falseLabel,boolean valueRequired){\n  Constant inline;\n  if ((inline=this.right.constant) != Constant.NotAConstant) {\n    if ((((this.left.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_int) && (inline.intValue() == 0)) {\n      this.left.generateCode(currentScope,valueRequired);\n      return;\n    }\n  }\n  if ((inline=this.left.constant) != Constant.NotAConstant) {\n    if ((((this.left.implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4) == T_int) && (inline.intValue() == 0)) {\n      this.right.generateCode(currentScope,valueRequired);\n      return;\n    }\n  }\n  if (this.right instanceof NullLiteral) {\n    if (this.left instanceof NullLiteral) {\n      return;\n    }\n else     if (this.left instanceof NullLiteral) {\n      this.right.generateCode(currentScope,valueRequired);\n      return;\n    }\n    this.left.generateCode(currentScope,valueRequired);\n    this.right.generateCode(currentScope,valueRequired);\n  }\n}\n", "nl": "Boolean generation for == with non-boolean operands"}
{"code": "private void addProducedBindings(final TermNode t,final Set<IVariable<?>> producedBindings){\n  if (t instanceof VarNode) {\n    producedBindings.add(((VarNode)t).getValueExpression());\n  }\n else   if (t instanceof ConstantNode) {\n    final ConstantNode cNode=(ConstantNode)t;\n    final Constant<?> c=(Constant<?>)cNode.getValueExpression();\n    final IVariable<?> var=c.getVar();\n    if (var != null) {\n      producedBindings.add(var);\n    }\n  }\n}\n", "nl": "This handles the special case where we've wrapped a Var with a Constant because we know it's bound, perhaps by the exogenous bindings. If we don't handle this case then we get the join vars wrong."}
{"code": "public boolean isSingleSided(){\n  return isSingleSided;\n}\n", "nl": "Tests whether the buffer is to be generated on a single side only."}
{"code": "public IdentityHashMap(Map<? extends K,? extends V> m){\n  this((int)((1 + m.size()) * 1.1));\n  putAll(m);\n}\n", "nl": "Constructs a new identity hash map containing the keys-value mappings in the specified map."}
{"code": "public boolean isTwoDigitMode(){\n  return twoDigitMode;\n}\n", "nl": "When set to true days will be rendered as 2 digits with 0 preceding single digit days"}
{"code": "public void bitAnd() throws IOException {\n  print(\"bitAnd\",null);\n}\n", "nl": "Description of the Method"}
{"code": "public VerletParticle3D lock(){\n  isLocked=true;\n  return this;\n}\n", "nl": "Locks/immobilizes particle in space"}
{"code": "private boolean logIfDefined(Object objToLog){\n  if (objToLog != null && !(objToLog instanceof Undefined)) {\n    logger.info(Context.toString(objToLog));\n    return true;\n  }\n else   return false;\n}\n", "nl": "Logs object's Context.toString(...) representation to INFO stream if it's defined."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase GamlPackage.STATEMENT__KEY:\n    return KEY_EDEFAULT == null ? key != null : !KEY_EDEFAULT.equals(key);\ncase GamlPackage.STATEMENT__FIRST_FACET:\n  return FIRST_FACET_EDEFAULT == null ? firstFacet != null : !FIRST_FACET_EDEFAULT.equals(firstFacet);\ncase GamlPackage.STATEMENT__EXPR:\nreturn expr != null;\ncase GamlPackage.STATEMENT__FACETS:\nreturn facets != null && !facets.isEmpty();\ncase GamlPackage.STATEMENT__BLOCK:\nreturn block != null;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public boolean supports(String view){\n  return getScriptEngine(view) != null;\n}\n", "nl": "What extensions does the view engine support."}
{"code": "public static Vector<String> string2vector(final String string){\n  Vector<String> v;\n  if (string != null) {\n    v=new Vector<String>(Arrays.asList(CommonPattern.COMMA.split(string,0)));\n  }\n else {\n    v=new Vector<String>();\n  }\n  return v;\n}\n", "nl": "Simple conversion of a comma separated list to a Vector containing the order of the substrings."}
{"code": "public ProgressHelper(Executor executor){\n  super();\n  this.executor=executor;\n  statistics=new DescriptiveStatistics(25);\n  listeners=EventListenerSupport.create(ProgressListener.class);\n}\n", "nl": "Constructs a new progress helper for generating progress reports for the given executor."}
{"code": "public boolean inMethod(){\n  return false;\n}\n", "nl": "Will return false since this is an inline tag."}
{"code": "@Inject public ProjectSelectionDialog(N4JSProjectContentProvider n4jsProjectContentProvider){\n  super(UIUtils.getShell());\n  this.setContentProvider(n4jsProjectContentProvider);\n  this.setLabelProvider(new N4JSProjectLabelProvider());\n  this.setInput(ResourcesPlugin.getWorkspace().getRoot());\n  this.setHelpAvailable(false);\n}\n", "nl": "Create a new project selection dialog"}
{"code": "void initToken(){\n  buffer=new StringBuilder();\n}\n", "nl": "Initialize the tokenizer."}
{"code": "private static final String decode(Set<? extends Integer> src){\n  if (src == null || src.isEmpty())   return \"\";\n  StringBuilder buffer=new StringBuilder();\n  for (  Integer i : src) {\n    buffer.append(i.toString()).append(';');\n  }\n  if (buffer.length() > 0) {\n    buffer.setLength(buffer.length() - 1);\n  }\n  return buffer.toString();\n}\n", "nl": "Separates each field of the array by a semicolon    "}
{"code": "public void spritePause(boolean pause){\n  mSpriteSheet.setSpritePause(pause);\n}\n", "nl": "indicates whether to start the SpriteAnimation paused."}
{"code": "public Point center(){\n  return rect.center;\n}\n", "nl": "Get the center of the rectangle"}
{"code": "@DataProvider(name=\"classProvider\") public Object[][] classprovider(){\n  return TESTING_CLASSES;\n}\n", "nl": "Provides classes to be tested."}
{"code": "private void stickyEventCommand(@NonNull MessageEvent messageEvent,@NonNull byte[] objectArray,@NonNull String className){\n  if (className.equals(String.class.getName())) {\n    String action=new String(objectArray);\n    Log.d(WearBusTools.BUSWEAR_TAG,\"syncEvent action: \" + action);\n    if (action.equals(WearBusTools.ACTION_STICKY_CLEAR_ALL)) {\n      removeAllStickyEventsLocal();\n    }\n else {\n      Class classTmp=getClassForName(className);\n      removeStickyEventLocal(classTmp);\n    }\n  }\n else {\n    if (messageEvent.getPath().startsWith(WearBusTools.PREFIX_CLASS)) {\n      Class classTmp=getClassForName(className);\n      removeStickyEventLocal(classTmp);\n    }\n else {\n      Object obj=WearBusTools.getSendSimpleObject(objectArray,className);\n      if (obj == null) {\n        obj=findParcel(objectArray,className);\n      }\n      if (obj != null) {\n        removeStickyEventLocal(obj);\n      }\n    }\n  }\n}\n", "nl": "Method used to find which command and if class/object is needed to retrieve it and call local method."}
{"code": "public ExtraProvider overrideImage(Uri image){\n  this.overriddenImage=image;\n  return this;\n}\n", "nl": "Provide a specific image for the linked package name."}
{"code": "@Override public Edge readEdge(final InputStream inputStream,final Function<Attachable<Edge>,Edge> edgeAttachMethod) throws IOException {\n  throw Io.Exceptions.readerFormatIsForFullGraphSerializationOnly(this.getClass());\n}\n", "nl": "This method is not supported for this reader."}
{"code": "private void checkState(State st,String msg){\n  if (state != st) {\n    throw new IllegalStateException(msg + \" at \" + st+ \" state\");\n  }\n}\n", "nl": "Checks if the current state is the specified one."}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public void spaceVertical(ArrayList<Integer> nodes){\n  if (m_bNeedsUndoAction) {\n    addUndoAction(new spaceVerticalAction(nodes));\n  }\n  int nMinY=-1;\n  int nMaxY=-1;\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nY=getPositionY(nodes.get(iNode));\n    if (nY < nMinY || iNode == 0) {\n      nMinY=nY;\n    }\n    if (nY > nMaxY || iNode == 0) {\n      nMaxY=nY;\n    }\n  }\n  for (int iNode=0; iNode < nodes.size(); iNode++) {\n    int nNode=nodes.get(iNode);\n    m_nPositionY.set(nNode,(int)(nMinY + iNode * (nMaxY - nMinY) / (nodes.size() - 1.0)));\n  }\n}\n", "nl": "space out set of nodes evenly between top and bottom most node in the list"}
{"code": "public void onCancelRealtimeBars(Contract contract){\n  if (m_realTimeBarsRequests.containsKey(contract.getId())) {\nsynchronized (m_realTimeBarsRequests) {\n      m_realTimeBarsRequests.remove(contract.getId());\n    }\n  }\n}\n", "nl": "Method onCancelRealtimeBars."}
{"code": "protected TEnumImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static String parseCharset(Map<String,String> headers){\n  String contentType=headers.get(HTTP.CONTENT_TYPE);\n  if (contentType != null) {\n    String[] params=contentType.split(\";\");\n    for (int i=1; i < params.length; i++) {\n      String[] pair=params[i].trim().split(\"=\");\n      if (pair.length == 2) {\n        if (pair[0].equals(\"charset\")) {\n          return pair[1];\n        }\n      }\n    }\n  }\n  return HTTP.DEFAULT_CONTENT_CHARSET;\n}\n", "nl": "Returns the charset specified in the Content-Type of this header, or the HTTP default (ISO-8859-1) if none can be found."}
{"code": "public synchronized void clear(){\n  m_Results.clear();\n  m_Suffixes.clear();\n  m_Ordered.clear();\n}\n", "nl": "Empties the history."}
{"code": "protected byte[] computeSHAdigest(final byte[] value){\n  try {\n    return MessageDigest.getInstance(\"SHA\").digest(value);\n  }\n catch (  Exception e) {\n    throw new UnsupportedOperationException(e.toString());\n  }\n}\n", "nl": "Returns the SHA-1 message digest of the given value."}
{"code": "public static Quantity toQuantity(final Supply supply,final int divisibility){\n  return new Quantity(supply.getRaw() * getMultipler(divisibility));\n}\n", "nl": "Converts a supply to a quantity."}
{"code": "public static int randGaussian(final int mean,final int sd){\n  return (int)(rand.nextGaussian() * sd + mean);\n}\n", "nl": "Generates a normally distributed random number and rounds it."}
{"code": "public static long rotateLeft(long lng,int distance){\n  if (distance == 0) {\n    return lng;\n  }\n  return ((lng << distance) | (lng >>> (-distance)));\n}\n", "nl": "<p> Rotates the bits of <code>lng</code> to the left by the <code>distance</code> bits. </p>"}
{"code": "public Picker quality(int minPixel,int maxPixel){\n  mSelectionSpec.setMinPixels(minPixel);\n  mSelectionSpec.setMaxPixels(maxPixel);\n  return this;\n}\n", "nl": "Sets the limitation of a selectable image quality by pixel count within the specified range."}
{"code": "ValueImpl readValue(){\n  byte typeKey=readByte();\n  return readUntaggedValue(typeKey);\n}\n", "nl": "Read a value, first byte describes type of value to read."}
{"code": "private void removeMapping(TreeStateNode node){\n  treePathMapping.remove(node.getTreePath());\n}\n", "nl": "Removes the mapping for a previously added node."}
{"code": "public Cookie(final String domain,final String name,final String value){\n  this(domain,name,value,null,null,false);\n}\n", "nl": "Creates a cookie with the given name, value and domain attribute."}
{"code": "public static Short valueOf(String string,int radix) throws NumberFormatException {\n  return valueOf(parseShort(string,radix));\n}\n", "nl": "Parses the specified string as a signed short value using the specified radix."}
{"code": "public synchronized UDAudio seekTo(Integer position){\n  if (position != null) {\n    final MediaPlayer player=getMediaPlayer();\n    if (player != null) {\n      try {\n        player.seekTo(position);\n      }\n catch (      Exception e) {\n        e.printStackTrace();\n      }\n    }\n  }\n  return this;\n}\n", "nl": "seek to position"}
{"code": "public boolean toOutline(){\n  int corners=vertices.size();\n  int maxSegs=corners * 3;\n  List<Vec2D> newVerts=new ArrayList<Vec2D>(corners);\n  Vec2D[] segments=new Vec2D[maxSegs];\n  Vec2D[] segEnds=new Vec2D[maxSegs];\n  float[] segAngles=new float[maxSegs];\n  Vec2D start=vertices.get(0).copy();\n  float lastAngle=MathUtils.PI;\n  float a, b, c, d, e, f;\n  double angleDif, bestAngleDif;\n  int i, j=corners - 1, segs=0;\n  if (corners > maxSegs) {\n    return false;\n  }\n  for (i=0; i < corners; i++) {\n    Vec2D pi=vertices.get(i);\n    Vec2D pj=vertices.get(j);\n    if (!pi.equals(pj)) {\n      segments[segs]=pi;\n      segEnds[segs++]=pj;\n    }\n    j=i;\n    if (pi.y > start.y || (pi.y == start.y && pi.x < start.x)) {\n      start.set(pi);\n    }\n  }\n  if (segs == 0) {\n    return false;\n  }\n  for (i=0; i < segs - 1; i++) {\n    for (j=i + 1; j < segs; j++) {\n      Line2D li=new Line2D(segments[i],segEnds[i]);\n      Line2D lj=new Line2D(segments[j],segEnds[j]);\n      LineIntersection isec=li.intersectLine(lj);\n      if (isec.getType() == Type.INTERSECTING) {\n        Vec2D ipos=isec.getPos();\n        if (!ipos.equals(segments[i]) && !ipos.equals(segEnds[i])) {\n          if (segs == maxSegs) {\n            return false;\n          }\n          segments[segs]=segments[i].copy();\n          segEnds[segs++]=ipos.copy();\n          segments[i]=ipos.copy();\n        }\n        if (!ipos.equals(segments[j]) && !ipos.equals(segEnds[j])) {\n          if (segs == maxSegs) {\n            return false;\n          }\n          segments[segs]=segments[j].copy();\n          segEnds[segs++]=ipos.copy();\n          segments[j]=ipos.copy();\n        }\n      }\n    }\n  }\n  for (i=0; i < segs; i++) {\n    segAngles[i]=segEnds[i].sub(segments[i]).positiveHeading();\n  }\n  c=start.x;\n  d=start.y;\n  a=c - 1;\n  b=d;\n  e=0;\n  f=0;\n  newVerts.add(new Vec2D(c,d));\n  corners=1;\n  while (true) {\n    bestAngleDif=MathUtils.TWO_PI;\n    for (i=0; i < segs; i++) {\n      if (segments[i].x == c && segments[i].y == d && (segEnds[i].x != a || segEnds[i].y != b)) {\n        angleDif=lastAngle - segAngles[i];\n        while (angleDif >= MathUtils.TWO_PI) {\n          angleDif-=MathUtils.TWO_PI;\n        }\n        while (angleDif < 0) {\n          angleDif+=MathUtils.TWO_PI;\n        }\n        if (angleDif < bestAngleDif) {\n          bestAngleDif=angleDif;\n          e=segEnds[i].x;\n          f=segEnds[i].y;\n        }\n      }\n      if (segEnds[i].x == c && segEnds[i].y == d && (segments[i].x != a || segments[i].y != b)) {\n        angleDif=lastAngle - segAngles[i] + MathUtils.PI;\n        while (angleDif >= MathUtils.TWO_PI) {\n          angleDif-=MathUtils.TWO_PI;\n        }\n        while (angleDif < 0) {\n          angleDif+=MathUtils.TWO_PI;\n        }\n        if (angleDif < bestAngleDif) {\n          bestAngleDif=angleDif;\n          e=segments[i].x;\n          f=segments[i].y;\n        }\n      }\n    }\n    if (corners > 1 && c == newVerts.get(0).x && d == newVerts.get(0).y && e == newVerts.get(1).x && f == newVerts.get(1).y) {\n      corners--;\n      vertices=newVerts;\n      return true;\n    }\n    if (bestAngleDif == MathUtils.TWO_PI || corners == maxSegs) {\n      return false;\n    }\n    lastAngle-=bestAngleDif + MathUtils.PI;\n    newVerts.add(new Vec2D(e,f));\n    corners++;\n    a=c;\n    b=d;\n    c=e;\n    d=f;\n  }\n}\n", "nl": "Attempts to remove all internal self-intersections and creates a new polygon only consisting of perimeter vertices. Ported from: http://alienryderflex.com/polygon_perimeter/"}
{"code": "final String PrintVersion(String str){\n  StringBuffer buf=new StringBuffer(str.length());\n  for (int i=0; i < str.length(); i++) {\nswitch (str.charAt(i)) {\ncase '\\\"':\n      buf.append(\"\\\\\\\"\");\n    break;\ncase '\\\\':\n  buf.append(\"\\\\\\\\\");\nbreak;\ncase '\\t':\nbuf.append(\"\\\\t\");\nbreak;\ncase '\\n':\nbuf.append(\"\\\\n\");\nbreak;\ncase '\\f':\nbuf.append(\"\\\\f\");\nbreak;\ncase '\\r':\nbuf.append(\"\\\\r\");\nbreak;\ndefault :\nbuf.append(str.charAt(i));\nbreak;\n}\n}\n;\nreturn buf.toString();\n}\n", "nl": "toString() modified 23 Aug 2007 by LL to call PrintVersion so strings   with special characters are printed properly.                         "}
{"code": "public boolean isLeaf(){\n  if (below != null) {\n    return false;\n  }\n  if (above != null) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Determines if node is a leaf node (i.e., has no children)."}
{"code": "public OutputDistribution(String var){\n  this.baseVar=var.replace(\"'\",\"\");\n  this.primes=var.replace(baseVar,\"\");\n  inputRules=new ArrayList<AnchoredRule>();\n}\n", "nl": "Creates the output distribution for the output variable label"}
{"code": "private static void processNotifications() throws Exception {\n  try (final Statement statement=Database.INSTANCE.getListenerConnection().createStatement();final ResultSet result_set=statement.executeQuery(Config.INSTANCE.sql.getProperty(\"sql.jpgagent.dummy\"))){\n    Config.INSTANCE.logger.debug(\"Kill jobs begin.\");\n    final PGConnection pg_connection=Database.INSTANCE.getListenerConnection().unwrap(PGConnection.class);\n    final PGNotification notifications[]=pg_connection.getNotifications();\n    if (null != notifications) {\n      for (      PGNotification notification : notifications) {\n        if (notification.getName().equals(\"jpgagent_kill_job\")) {\n          int job_id=Integer.valueOf(notification.getParameter());\n          if (job_future_map.containsKey(job_id)) {\n            Config.INSTANCE.logger.info(\"Killing job_id: {}.\",job_id);\n            job_future_map.get(job_id).cancel(true);\n          }\n else {\n            Config.INSTANCE.logger.info(\"Kill request for job_id: {} was submitted, but the job was not running.\",job_id);\n          }\n        }\n      }\n    }\n  }\n }\n", "nl": "Processes notifications which may have been issued on channels that jpgAgent is listening on."}
{"code": "public ZipShort(byte[] bytes,int offset){\n  value=(bytes[offset + 1] << 8) & 0xFF00;\n  value+=(bytes[offset] & 0xFF);\n}\n", "nl": "Create instance from the two bytes starting at offset."}
{"code": "public static <T>T createRetrofitService(final Class<T> clazz,final String endPoint){\n  final RestAdapter restAdapter=new RestAdapter.Builder().setEndpoint(endPoint).build();\n  T service=restAdapter.create(clazz);\n  return service;\n}\n", "nl": "Creates a retrofit service from an arbitrary class (clazz)"}
{"code": "public final boolean matchAction(String action){\n  return hasAction(action);\n}\n", "nl": "Match this filter against an Intent's action.  If the filter does not specify any actions, the match will always fail."}
{"code": "public static void renameFileReferencee(PsiElement element,String newPackageName){\n  if (element instanceof PerlNamespaceElement) {\n    PerlPsiUtil.renameElement(element,newPackageName);\n  }\n}\n", "nl": "Renames file referencee element. Specific method required, cause somewhere we should put package name, and somewhere filename"}
{"code": "private BakedBezierInterpolator(){\n  super();\n}\n", "nl": "Use getInstance instead of instantiating."}
{"code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof RC5ParameterSpec)) {\n    return false;\n  }\n  RC5ParameterSpec ps=(RC5ParameterSpec)obj;\n  return (version == ps.version) && (rounds == ps.rounds) && (wordSize == ps.wordSize)&& (Arrays.equals(iv,ps.iv));\n}\n", "nl": "Compares the specified object with this <code>RC5ParameterSpec</code> instance."}
{"code": "public static boolean isSameAnno(FeatureStructure aFirstFS,FeatureStructure aSeconFS){\n  for (  Feature f : getAllFeatures(aFirstFS)) {\n    if (isBasicFeature(f)) {\n      continue;\n    }\n    if (!isLinkMode(aFirstFS,f)) {\n      try {\n        FeatureStructure attachFs1=aFirstFS.getFeatureValue(f);\n        FeatureStructure attachFs2=aSeconFS.getFeatureValue(f);\n        if (!isSameAnno(attachFs1,attachFs2)) {\n          return false;\n        }\n      }\n catch (      Exception e) {\n      }\n      if (getFeatureValue(aFirstFS,f) == null && getFeatureValue(aSeconFS,f) == null) {\n        continue;\n      }\n      if (getFeatureValue(aFirstFS,f) == null && getFeatureValue(aSeconFS,f) != null) {\n        return false;\n      }\n      if (getFeatureValue(aFirstFS,f) != null && getFeatureValue(aSeconFS,f) == null) {\n        return false;\n      }\n      if (!getFeatureValue(aFirstFS,f).equals(getFeatureValue(aSeconFS,f))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Return true if these two annotations agree on every non slot features"}
{"code": "ServerSessionContext registerIndexQuery(long index,Runnable query){\n  List<Runnable> queries=this.indexQueries.computeIfAbsent(index,null);\n  queries.add(query);\n  return this;\n}\n", "nl": "Registers a session index query."}
{"code": "public <T extends Number & Comparable>NumberRange by(T stepSize){\n  return new NumberRange(NumberRange.comparableNumber((Number)from),NumberRange.comparableNumber((Number)to),stepSize,inclusive);\n}\n", "nl": "Creates a new NumberRange with the same <code>from</code> and <code>to</code> as this IntRange but with a step size of <code>stepSize</code>."}
{"code": "public X509Name(String dirName){\n  this(DefaultReverse,DefaultLookUp,dirName);\n}\n", "nl": "Takes an X509 dir name as a string of the format \"C=AU, ST=Victoria\", or some such, converting it into an ordered set of name attributes."}
{"code": "public boolean isAllowedToDelete(PlatformUser user){\n  if (user.equals(getPlatformUser())) {\n    return true;\n  }\n  Organization org=getPlatformUser().getOrganization();\n  if (user.isOrganizationAdmin() && user.getOrganization().equals(org)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "The given user is allowed to delete this review if the user is <ul> <li>the creator of the review</li> <li>a administrator of the organization which the creator belongs to</li> </ul>"}
{"code": "public Rational(Rational R){\n  this.N=new Polynomial(R.N);\n  this.D=new Polynomial(R.D);\n}\n", "nl": "Constructs a new rational function by copying an existing rational function object."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase ImPackage.DELEGATING_GETTER_DECLARATION__DELEGATION_BASE_TYPE:\n    setDelegationBaseType((SymbolTableEntryOriginal)null);\n  return;\ncase ImPackage.DELEGATING_GETTER_DECLARATION__DELEGATION_SUPER_CLASS_STEPS:\nsetDelegationSuperClassSteps(DELEGATION_SUPER_CLASS_STEPS_EDEFAULT);\nreturn;\ncase ImPackage.DELEGATING_GETTER_DECLARATION__DELEGATION_TARGET:\nsetDelegationTarget((SymbolTableEntryOriginal)null);\nreturn;\ncase ImPackage.DELEGATING_GETTER_DECLARATION__DELEGATION_TARGET_IS_ABSTRACT:\nsetDelegationTargetIsAbstract(DELEGATION_TARGET_IS_ABSTRACT_EDEFAULT);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private List<BigtableSource> splitIntoBundlesBasedOnSamples(long desiredBundleSizeBytes,List<SampleRowKeysResponse> sampleRowKeys){\n  if (sampleRowKeys.isEmpty()) {\n    logger.info(\"Not splitting source {} because no sample row keys are available.\",this);\n    return Collections.singletonList(this);\n  }\n  logger.info(\"About to split into bundles of size {} with sampleRowKeys length {} first element {}\",desiredBundleSizeBytes,sampleRowKeys.size(),sampleRowKeys.get(0));\n  ByteKey lastEndKey=ByteKey.EMPTY;\n  long lastOffset=0;\n  ImmutableList.Builder<BigtableSource> splits=ImmutableList.builder();\n  for (  SampleRowKeysResponse response : sampleRowKeys) {\n    ByteKey responseEndKey=ByteKey.of(response.getRowKey());\n    long responseOffset=response.getOffsetBytes();\n    checkState(responseOffset >= lastOffset,\"Expected response byte offset %s to come after the last offset %s\",responseOffset,lastOffset);\n    if (!range.overlaps(ByteKeyRange.of(lastEndKey,responseEndKey))) {\n      lastOffset=responseOffset;\n      lastEndKey=responseEndKey;\n      continue;\n    }\n    ByteKey splitStartKey=lastEndKey;\n    if (splitStartKey.compareTo(range.getStartKey()) < 0) {\n      splitStartKey=range.getStartKey();\n    }\n    ByteKey splitEndKey=responseEndKey;\n    if (!range.containsKey(splitEndKey)) {\n      splitEndKey=range.getEndKey();\n    }\n    long sampleSizeBytes=responseOffset - lastOffset;\n    List<BigtableSource> subSplits=splitKeyRangeIntoBundleSizedSubranges(sampleSizeBytes,desiredBundleSizeBytes,ByteKeyRange.of(splitStartKey,splitEndKey));\n    splits.addAll(subSplits);\n    lastEndKey=responseEndKey;\n    lastOffset=responseOffset;\n  }\n  if (!lastEndKey.isEmpty() && (range.getEndKey().isEmpty() || lastEndKey.compareTo(range.getEndKey()) < 0)) {\n    splits.add(this.withStartKey(lastEndKey).withEndKey(range.getEndKey()));\n  }\n  List<BigtableSource> ret=splits.build();\n  logger.info(\"Generated {} splits. First split: {}\",ret.size(),ret.get(0));\n  return ret;\n}\n", "nl": "Helper that splits this source into bundles based on Cloud Bigtable sampled row keys."}
{"code": "public boolean isVerbose(){\n  return verbose;\n}\n", "nl": "True iff verbose output should be printed."}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  Element element;\n  String elementId=\"---\";\n  doc=(Document)load(\"staffNS\",false);\n  element=doc.getElementById(elementId);\n  assertNull(\"documentgetelementbyid01\",element);\n}\n", "nl": "Runs the test case."}
{"code": "private static void updateNetwork(WifiManager wifiManager,WifiConfiguration config){\n  Integer foundNetworkID=findNetworkInExistingConfig(wifiManager,config.SSID);\n  if (foundNetworkID != null) {\n    Log.i(TAG,\"Removing old configuration for network \" + config.SSID);\n    wifiManager.removeNetwork(foundNetworkID);\n    wifiManager.saveConfiguration();\n  }\n  int networkId=wifiManager.addNetwork(config);\n  if (networkId >= 0) {\n    if (wifiManager.enableNetwork(networkId,true)) {\n      Log.i(TAG,\"Associating to network \" + config.SSID);\n      wifiManager.saveConfiguration();\n    }\n else {\n      Log.w(TAG,\"Failed to enable network \" + config.SSID);\n    }\n  }\n else {\n    Log.w(TAG,\"Unable to add network \" + config.SSID);\n  }\n}\n", "nl": "Update the network: either create a new network or modify an existing network"}
{"code": "int queue(byte[] buffer,int offset,int len,boolean bCtrl){\n  int available_space;\n  available_space=m_sbuf.getWriteRemaining();\n  if (len > available_space) {\n    assert !bCtrl;\n    len=available_space;\n  }\n  SSegment back=null;\n  if (!m_slist.isEmpty()) {\n    back=m_slist.get(m_slist.size() - 1);\n  }\n  if (back != null && (back.bCtrl == bCtrl) && (back.xmit == 0)) {\n    back.len+=len;\n  }\n else {\n    long snd_buffered;\n    snd_buffered=m_sbuf.getBuffered();\n    SSegment sseg=new SSegment(m_snd_una + snd_buffered,len,bCtrl);\n    if (logger.isLoggable(Level.FINEST)) {\n      logger.log(Level.FINEST,debugName + \" enqueued send segment seq: \" + sseg.seq+ \" len: \"+ sseg.len);\n    }\n    m_slist.add(sseg);\n  }\n  int written=m_sbuf.write(buffer,offset,len);\n  return written;\n}\n", "nl": "Enqueues data segment in the send buffer"}
{"code": "private void populateMap(final AccessProfile accessProfile){\n  _logger.debug(\"Populating input attributes in the map.\");\n  _keyMap.put(VNXFileConstants.DEVICETYPE,accessProfile.getSystemType());\n  _keyMap.put(VNXFileConstants.DBCLIENT,_dbClient);\n  _keyMap.put(VNXFileConstants.USERNAME,accessProfile.getUserName());\n  _keyMap.put(VNXFileConstants.USER_PASS_WORD,accessProfile.getPassword());\n  _keyMap.put(VNXFileConstants.URI,getServerUri(accessProfile));\n  _keyMap.put(VNXFileConstants.PORTNUMBER,accessProfile.getPortNumber());\n  _keyMap.put(Constants._Stats,new LinkedList<Stat>());\n  _keyMap.put(Constants.ACCESSPROFILE,accessProfile);\n  _keyMap.put(Constants._serialID,accessProfile.getserialID());\n  _keyMap.put(Constants._nativeGUIDs,Sets.newHashSet());\n  _keyMap.put(VNXFileConstants.AUTHURI,getLoginUri(accessProfile));\n  String globalCacheKey=accessProfile.getserialID() + Constants._minusDelimiter + Constants._File;\n  _keyMap.put(Constants._globalCacheKey,globalCacheKey);\n  _keyMap.put(Constants.PROPS,accessProfile.getProps());\n  if (executor != null) {\n    executor.setKeyMap(_keyMap);\n    _logger.debug(\"Map set on executor....\");\n  }\n}\n", "nl": "Construct the map of input attributes which will be used during the execution and processing the result."}
{"code": "public static void dropTables(Connection conn){\n  try {\n    Statement stmt=conn.createStatement();\n    try {\n      stmt.execute(\"DROP TABLE Unpaidorder\");\n    }\n catch (    SQLException ex) {\n    }\n    try {\n      stmt.execute(\"DROP TABLE Customer\");\n    }\n catch (    SQLException ex) {\n    }\n    try {\n      stmt.execute(\"DROP TABLE Coffee\");\n    }\n catch (    SQLException ex) {\n    }\n  }\n catch (  SQLException ex) {\n    System.out.println(\"ERROR: \" + ex.getMessage());\n    ex.printStackTrace();\n  }\n}\n", "nl": "The dropTables method drops any existing in case the database already exists."}
{"code": "protected int mapDragOperationFromModifiers(MouseEvent e){\n  int mods=e.getModifiersEx();\n  int btns=mods & ButtonMask;\n  if (!(btns == InputEvent.BUTTON1_DOWN_MASK || btns == InputEvent.BUTTON2_DOWN_MASK)) {\n    return DnDConstants.ACTION_NONE;\n  }\n  return SunDragSourceContextPeer.convertModifiersToDropAction(mods,getSourceActions());\n}\n", "nl": "determine the drop action from the event"}
{"code": "OutputStream saveUploadedFileDetails(final String name,final long size,final String mimeType,final SoftwareModule selectedSw){\n  File tempFile=null;\n  try {\n    tempFile=File.createTempFile(\"spUiArtifactUpload\",null);\n    @SuppressWarnings(\"squid:S2095\") final OutputStream out=new FileOutputStream(tempFile);\n    final String currentBaseSoftwareModuleKey=HawkbitCommonUtil.getFormattedNameVersion(selectedSw.getName(),selectedSw.getVersion());\n    final CustomFile customFile=new CustomFile(name,size,tempFile.getAbsolutePath(),selectedSw.getName(),selectedSw.getVersion(),mimeType);\n    artifactUploadState.getFileSelected().add(customFile);\n    processBtn.setEnabled(false);\n    if (!artifactUploadState.getBaseSwModuleList().keySet().contains(currentBaseSoftwareModuleKey)) {\n      artifactUploadState.getBaseSwModuleList().put(currentBaseSoftwareModuleKey,selectedSw);\n    }\n    return out;\n  }\n catch (  final FileNotFoundException e) {\n    LOG.error(\"Upload failed {}\",e);\n    throw new ArtifactUploadFailedException(i18n.get(\"message.file.not.found\"));\n  }\ncatch (  final IOException e) {\n    LOG.error(\"Upload failed {}\",e);\n    throw new ArtifactUploadFailedException(i18n.get(\"message.upload.failed\"));\n  }\n}\n", "nl": "Save uploaded file details."}
{"code": "public static void main(String[] args){\n  try {\n    Stemming.useStemmer(new IteratedLovinsStemmer(),args);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Runs the stemmer with the given options"}
{"code": "private StreamUtil(){\n  instanceNotAllowed(getClass());\n}\n", "nl": "Utility classes should not be instantiated."}
{"code": "public static boolean isLocalAssetUri(Uri uri){\n  final String scheme=getSchemeOrNull(uri);\n  return LOCAL_ASSET_SCHEME.equals(scheme);\n}\n", "nl": "Check if uri represents local asset"}
{"code": "private boolean checkForIndex(File aIndexFolder){\n  File[] files=aIndexFolder.listFiles();\n  if (files == null) {\n    return false;\n  }\n  boolean result=false;\n  for (  File file : files) {\n    if (file.isFile() && file.getName().startsWith(\"segments\")) {\n      result=true;\n      break;\n    }\n  }\n  return result;\n}\n", "nl": "Checks if the folder is a Lucence index"}
{"code": "public void unpair(BluetoothAdapter adapter,BluetoothDevice device){\n  int mask=PairReceiver.STATE_NONE_FLAG;\n  long start=-1;\n  String methodName=String.format(\"unpair(device=%s)\",device);\n  if (!adapter.isEnabled()) {\n    fail(String.format(\"%s bluetooth not enabled\",methodName));\n  }\n  PairReceiver receiver=getPairReceiver(device,0,null,mask);\n  int state=device.getBondState();\nswitch (state) {\ncase BluetoothDevice.BOND_NONE:\n    assertFalse(adapter.getBondedDevices().contains(device));\n  removeReceiver(receiver);\nreturn;\ncase BluetoothDevice.BOND_BONDING:\nstart=System.currentTimeMillis();\nassertTrue(device.removeBond());\nbreak;\ncase BluetoothDevice.BOND_BONDED:\nassertTrue(adapter.getBondedDevices().contains(device));\nstart=System.currentTimeMillis();\nassertTrue(device.removeBond());\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"%s invalid state: state=%d\",methodName,state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < PAIR_UNPAIR_TIMEOUT) {\nif (device.getBondState() == BluetoothDevice.BOND_NONE && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.getBondedDevices().contains(device));\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"%s completed in %d ms\",methodName,(finish - start)));\n}\n else {\nwriteOutput(String.format(\"%s completed\",methodName));\n}\nremoveReceiver(receiver);\nreturn;\n}\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"%s timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",methodName,state,BluetoothDevice.BOND_BONDED,firedFlags,mask));\n}\n", "nl": "Deletes a pairing with a remote device and checks to make sure that the devices are unpaired and that the correct actions were broadcast."}
{"code": "public boolean isBannedMethod(SootMethod m){\n  return banned_methods.contains(m);\n}\n", "nl": "Used by the specification create to check if a method is legal to put in the  spec.  Must check the method, and all superclass definitions of the method."}
{"code": "public TextComponent(String text,BaseComponent... extras){\n  this.text=text;\n  this.setExtra(Arrays.asList(extras));\n}\n", "nl": "Construct new TextComponent with given string and extra components."}
{"code": "public MemberCube(TClassifier tClassifier,MemberCollector memberCollector){\n  this.memberMatrixesByName=new HashMap<>();\n  addMembers(MemberMatrix.OWNED,tClassifier.getOwnedMembers());\n  if (tClassifier instanceof TClass) {\n    addMembers(MemberMatrix.INHERITED,memberCollector.inheritedMembers((TClass)tClassifier));\n  }\n  addMembers(MemberMatrix.IMPLEMENTED,memberCollector.membersOfImplementedInterfaces(tClassifier));\n}\n", "nl": "Creates the cube for the given classifier, using the passed member collector. The latter is passed as argument as it needed DI."}
{"code": "private void addMembers(List<String> newMembers){\n  if (newMembers.isEmpty()) {\n    return;\n  }\n  int startIndex=-1;\n  int endIndex=-1;\n  for (  String name : newMembers) {\n    Member member=new Member(name);\n    member.setChangeListener(healthListener);\n    memberMap.put(name,member);\n    memberList.add(member);\n    int index=memberList.indexOf(member);\n    if (startIndex == -1) {\n      startIndex=index;\n      endIndex=index;\n    }\n else {\n      startIndex=Math.min(startIndex,index);\n      endIndex=Math.max(endIndex,index);\n    }\n  }\n  fireIntervalAdded(this,startIndex,endIndex);\n}\n", "nl": "Add a group of new members."}
{"code": "public static void init(){\n  init(\"es\");\n}\n", "nl": "loads the language files"}
{"code": "public void delete(ScriptGroup group){\n  if (!currentTestPlan.getScriptGroups().remove(group)) {\n    messages.warn(\"Could not remove Script Group \" + group.getName() + \".\");\n  }\n else {\n    messages.info(\"Script Group \" + group.getName() + \" has been removed.\");\n  }\n}\n", "nl": "Deletes the script group from the workload. This does not persist the changes to the database."}
{"code": "@Override public URI toPropertyURI(final String property){\n  return toURI(property);\n}\n", "nl": "Override to allow for colons in the id without URLEncoding them."}
{"code": "@POST @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @CheckPermission(roles={Role.TENANT_ADMIN},acls={ACL.OWN,ACL.ALL}) @Path(\"/{id}/restore\") public TaskResourceRep restore(@PathParam(\"id\") URI id,@QueryParam(\"syncDirection\") String syncDirection){\n  ArgValidator.checkFieldUriType(id,BlockSnapshot.class,\"id\");\n  BlockSnapshot snapshot=(BlockSnapshot)queryResource(id);\n  if (syncDirection != null) {\n    validateSyncDirection(syncDirection);\n  }\n  Volume parentVolume=_permissionsHelper.getObjectById(snapshot.getParent(),Volume.class);\n  checkForPendingTasks(Arrays.asList(parentVolume.getTenant().getURI()),Arrays.asList(parentVolume));\n  StorageSystem storage=_permissionsHelper.getObjectById(parentVolume.getStorageController(),StorageSystem.class);\n  if (storage.checkIfVmax3()) {\n    if (snapshot.getSettingsInstance() == null) {\n      throw APIException.badRequests.snapshotNullSettingsInstance(snapshot.getLabel());\n    }\n  }\n  if (Type.openstack.name().equalsIgnoreCase(storage.getSystemType())) {\n    throw APIException.methodNotAllowed.notSupportedWithReason(String.format(\"Snapshot restore is not possible on third-party storage systems\"));\n  }\n  BlockServiceApi blockServiceApiImpl=BlockService.getBlockServiceImpl(parentVolume,_dbClient);\n  blockServiceApiImpl.validateRestoreSnapshot(snapshot,parentVolume);\n  String taskId=UUID.randomUUID().toString();\n  Operation op=new Operation();\n  op.setResourceType(ResourceOperationTypeEnum.RESTORE_VOLUME_SNAPSHOT);\n  _dbClient.createTaskOpStatus(BlockSnapshot.class,snapshot.getId(),taskId,op);\n  snapshot.getOpStatus().put(taskId,op);\n  blockServiceApiImpl.restoreSnapshot(snapshot,parentVolume,syncDirection,taskId);\n  auditOp(OperationTypeEnum.RESTORE_VOLUME_SNAPSHOT,true,AuditLogManager.AUDITOP_BEGIN,id.toString(),parentVolume.getId().toString(),snapshot.getStorageController().toString());\n  return toTask(snapshot,taskId,op);\n}\n", "nl": "Call will restore this snapshot to the volume that it is associated with. If this snapshot was created from a volume in a consistency group, then all related snapshots will be restored to their respective volumes."}
{"code": "public void testMultivariateTEforCoupledDataFromFile() throws Exception {\n  ArrayFileReader afr=new ArrayFileReader(\"demos/data/4ColsPairedOneStepNoisyDependence-1.txt\");\n  double[][] data=afr.getDouble2DMatrix();\n  double[] col0=MatrixUtils.selectColumn(data,0);\n  double[] col1=MatrixUtils.selectColumn(data,1);\n  double[] col2=MatrixUtils.selectColumn(data,2);\n  double[] col3=MatrixUtils.selectColumn(data,3);\n  col0=MatrixUtils.normaliseIntoNewArray(col0);\n  col1=MatrixUtils.normaliseIntoNewArray(col1);\n  col2=MatrixUtils.normaliseIntoNewArray(col2);\n  col3=MatrixUtils.normaliseIntoNewArray(col3);\n  int kNNs=4;\n  double expectedFromTRENTOOL0to2=0.1400645;\n  double expectedFromTRENTOOL2to0=-0.0181459;\n  double expectedFromTRENTOOL1to3=0.1639186;\n  double expectedFromTRENTOOL3to1=0.0036976;\n  TransferEntropyCalculatorKraskov teCalc=new TransferEntropyCalculatorKraskov();\n  teCalc.setProperty(ConditionalMutualInfoCalculatorMultiVariateKraskov.PROP_K,Integer.toString(kNNs));\n  teCalc.setProperty(ConditionalMutualInfoCalculatorMultiVariateKraskov.PROP_NORMALISE,\"false\");\n  teCalc.setProperty(ConditionalMutualInfoCalculatorMultiVariateKraskov.PROP_ADD_NOISE,\"0\");\n  System.out.println(\"Kraskov Cond MI as TE - multivariate coupled data 1, k=2,l=2\");\n  System.out.println(\"  (0->2)\");\n  teCalc.initialise(2,1,2,1,1);\n  teCalc.setObservations(col0,col2);\n  double result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\" %.5f\\n\",result);\n  assertEquals(expectedFromTRENTOOL0to2,result,0.000001);\n  System.out.println(\"  (2->0):\");\n  teCalc.initialise(2,1,2,1,1);\n  teCalc.setObservations(col2,col0);\n  result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\" %.5f\\n\",result);\n  assertEquals(expectedFromTRENTOOL2to0,result,0.000001);\n  System.out.println(\"  (1->3):\");\n  teCalc.initialise(2,1,2,1,1);\n  teCalc.setObservations(col1,col3);\n  result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\" %.5f\\n\",result);\n  assertEquals(expectedFromTRENTOOL1to3,result,0.000001);\n  System.out.println(\"  (3->1):\");\n  teCalc.initialise(2,1,2,1,1);\n  teCalc.setObservations(col3,col1);\n  result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\" %.5f\\n\",result);\n  assertEquals(expectedFromTRENTOOL3to1,result,0.000001);\n  double expectedFromTRENTOOL0to1_k1l1=0.0072169;\n  double expectedFromTRENTOOL1to2_k1l1=0.0011738;\n  System.out.println(\"  (0->1) but with k=1,l=1:\");\n  teCalc.initialise(1,1,1,1,1);\n  teCalc.setObservations(col0,col1);\n  result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\" %.5f\\n\",result);\n  assertEquals(expectedFromTRENTOOL0to1_k1l1,result,0.000001);\n  System.out.println(\"  (1->2) but with k=1,l=1:\");\n  teCalc.initialise(1,1,1,1,1);\n  teCalc.setObservations(col1,col2);\n  result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\" %.5f\\n\",result);\n  assertEquals(expectedFromTRENTOOL1to2_k1l1,result,0.000001);\n}\n", "nl": "Test the computed multivariate TE against that calculated by Wibral et al.'s TRENTOOL on the same data. It's multivariate because we use embedding dimension 2 on both source and destination. To run TRENTOOL (http://www.trentool.de/) for this  data, run its TEvalues.m matlab script on the multivariate source and dest data sets as: TEvalues(source, dest, 2, 1, 1, kraskovK, 0) with these values ensuring source-dest lag 1, history k=2, history embedding dimension l=2 on source as well. embedding lag 1, no dynamic correlation exclusion"}
{"code": "public Set<String> addContent(String variable,Value value){\n  if (!paused) {\n    curState.addToState(new Assignment(variable,value));\n    return update();\n  }\n else {\n    log.info(\"system is paused, ignoring \" + variable + \"=\"+ value);\n    return Collections.emptySet();\n  }\n}\n", "nl": "Adds the content (expressed as a pair of variable=value) to the current dialogue state, and subsequently updates the dialogue state."}
{"code": "public void testGetSpeed_one(){\n  testSpeed(1,1);\n}\n", "nl": "Tests when the slow speed and the normal speed are both one."}
{"code": "public BasicCondition(String variable,String value,Relation relation){\n  this.variable=Template.create(variable);\n  this.templateValue=Template.create(value);\n  groundValue=(templateValue.isUnderspecified()) ? null : ValueFactory.create(value);\n  this.relation=relation;\n}\n", "nl": "Creates a new basic condition, given a variable label, an expected value, and a relation to hold between the variable and its value"}
{"code": "public String[] validBaudRates(){\n  return new String[]{\"19,200 bps\"};\n}\n", "nl": "Get an array of valid baud rates. This is currently only 19,200 bps"}
{"code": "static double slowCos(final double x,final double result[]){\n  final double xs[]=new double[2];\n  final double ys[]=new double[2];\n  final double facts[]=new double[2];\n  final double as[]=new double[2];\n  split(x,xs);\n  ys[0]=ys[1]=0.0;\n  for (int i=FACT.length - 1; i >= 0; i--) {\n    splitMult(xs,ys,as);\n    ys[0]=as[0];\n    ys[1]=as[1];\n    if ((i & 1) != 0) {\n      continue;\n    }\n    split(FACT[i],as);\n    splitReciprocal(as,facts);\n    if ((i & 2) != 0) {\n      facts[0]=-facts[0];\n      facts[1]=-facts[1];\n    }\n    splitAdd(ys,facts,as);\n    ys[0]=as[0];\n    ys[1]=as[1];\n  }\n  if (result != null) {\n    result[0]=ys[0];\n    result[1]=ys[1];\n  }\n  return ys[0] + ys[1];\n}\n", "nl": "For x between 0 and pi/4 compute cosine using Talor series cos(x) = 1 - x^2/2! + x^4/4! ..."}
{"code": "public synchronized void add(double minValue,double maxValue){\n  super.add(minValue);\n  mMaxValues.add(maxValue);\n}\n", "nl": "Adds new values to the series"}
{"code": "public NecronomiconSummonRitual(String unlocalizedName,int bookType,float requiredEnergy,Class<? extends EntityLivingBase> entity,Object... offerings){\n  this(unlocalizedName,bookType,-1,requiredEnergy,entity,offerings);\n}\n", "nl": "A Necronomicon Ritual"}
{"code": "public AssertionFailedException(Exception ex){\n  super(Messages.getString(\"AssertionFailedException.0\") + ex.toString() + Messages.getString(\"AssertionFailedException.1\"));\n}\n", "nl": "Creates an AssertionFailedException for the given exception that should never have been thrown."}
{"code": "@Override public void handlePatch(Operation op){\n  setOperationHandlerInvokeTimeStat(op);\n  if (!op.hasBody()) {\n    op.fail(new IllegalArgumentException(\"body is required\"));\n    return;\n  }\n  EnumerationContext ctx=new EnumerationContext(op);\n  AdapterUtils.validateEnumRequest(ctx.enumRequest);\n  if (ctx.enumRequest.isMockRequest) {\n    op.complete();\n    AdapterUtils.sendPatchToEnumerationTask(this,ctx.enumRequest.taskReference);\n    return;\n  }\n  handleEnumerationRequest(ctx);\n}\n", "nl": "The REST PATCH request handler. This is the entry of starting an enumeration."}
{"code": "public Polygon2D add(float x,float y){\n  return add(new Vec2D(x,y));\n}\n", "nl": "Adds a new vertex to the polygon (builder pattern)."}
{"code": "public static void filledPolygon(double[] x,double[] y){\n  if (x == null)   throw new NullPointerException();\n  if (y == null)   throw new NullPointerException();\n  int n1=x.length;\n  int n2=y.length;\n  if (n1 != n2)   throw new IllegalArgumentException(\"arrays must be of the same length\");\n  int n=n1;\n  GeneralPath path=new GeneralPath();\n  path.moveTo((float)scaleX(x[0]),(float)scaleY(y[0]));\n  for (int i=0; i < n; i++)   path.lineTo((float)scaleX(x[i]),(float)scaleY(y[i]));\n  path.closePath();\n  offscreen.fill(path);\n  draw();\n}\n", "nl": "Draws a polygon with the vertices  (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ..., (<em>x</em><sub><em>n</em>&minus;1</sub>, <em>y</em><sub><em>n</em>&minus;1</sub>)."}
{"code": "@POST @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @CheckPermission(roles={Role.TENANT_ADMIN}) public TaskResourceRep createHost(HostCreateParam createParam,@QueryParam(\"validate_connection\") @DefaultValue(\"false\") final Boolean validateConnection){\n  URI tid=createParam.getTenant();\n  if ((tid == null) || tid.toString().isEmpty()) {\n    _log.error(\"The tenant id is missing\");\n    throw APIException.badRequests.requiredParameterMissingOrEmpty(\"tenant\");\n  }\n  TenantOrg tenant=_permissionsHelper.getObjectById(tid,TenantOrg.class);\n  ArgValidator.checkEntity(tenant,tid,isIdEmbeddedInURL(tid),true);\n  validateHostData(createParam,tid,null,validateConnection);\n  Host host=createNewHost(tenant,createParam);\n  host.setRegistrationStatus(RegistrationStatus.REGISTERED.toString());\n  _dbClient.createObject(host);\n  auditOp(OperationTypeEnum.CREATE_HOST,true,null,host.auditParameters());\n  return doDiscoverHost(host);\n}\n", "nl": "Creates a new host for the tenant organization. Discovery is initiated after the host is created."}
{"code": "public boolean hasEdge(DigraphNode node){\n  return outNodes.contains(node);\n}\n", "nl": "Returns <code>true</code> if an edge exists between this node and the given node."}
{"code": "@Override @Deprecated public Condition duplicate(){\n  return this;\n}\n", "nl": "Since the condition cannot be altered after creation we can just return the condition object itself."}
{"code": "public E elementAt(int index){\n  return delegate.elementAt(index);\n}\n", "nl": "Returns the component at the specified index. Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is negative or not less than the size of the list. <blockquote> <b>Note:</b> Although this method is not deprecated, the preferred method to use is <code>get(int)</code>, which implements the <code>List</code> interface defined in the 1.2 Collections framework. </blockquote>"}
{"code": "void addFillComponents(Container panel,int[] cols,int[] rows){\n  Dimension filler=new Dimension(10,10);\n  boolean filled_cell_11=false;\n  CellConstraints cc=new CellConstraints();\n  if (cols.length > 0 && rows.length > 0) {\n    if (cols[0] == 1 && rows[0] == 1) {\n      panel.add(Box.createRigidArea(filler),cc.xy(1,1));\n      filled_cell_11=true;\n    }\n  }\n  for (int index=0; index < cols.length; index++) {\n    if (cols[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(cols[index],1));\n  }\n  for (int index=0; index < rows.length; index++) {\n    if (rows[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(1,rows[index]));\n  }\n}\n", "nl": "Adds fill components to empty cells in the first row and first column of the grid. This ensures that the grid spacing will be the same as shown in the designer."}
{"code": "@Deprecated public void visitMethodInsn(int opcode,String owner,String name,String desc){\n  if (api >= Opcodes.ASM5) {\n    boolean itf=opcode == Opcodes.INVOKEINTERFACE;\n    visitMethodInsn(opcode,owner,name,desc,itf);\n    return;\n  }\n  if (mv != null) {\n    mv.visitMethodInsn(opcode,owner,name,desc);\n  }\n}\n", "nl": "Visits a method instruction. A method instruction is an instruction that invokes a method."}
{"code": "@Override public void registerOutParameter(int parameterIndex,int sqlType,String typeName) throws SQLException {\n  registerOutParameter(parameterIndex);\n}\n", "nl": "Registers the given OUT parameter."}
{"code": "private final Throwable unwrapFutureThrowable(Future<?> ft){\n  if (ft.isDone() && !ft.isCancelled()) {\n    try {\n      ft.get();\n    }\n catch (    ExecutionException ee) {\n      return ee.getCause();\n    }\ncatch (    InterruptedException ie) {\n      Thread.currentThread().interrupt();\n    }\n  }\n  return null;\n}\n", "nl": "Get the reason of a task's abnormal completion. Callers may cancel and reschedule tasks, so a task completed by cancellation is not an error."}
{"code": "protected static boolean placeAnimalIntoWorld(final DomesticAnimal animal,final Player player){\n  final StendhalRPZone playerZone=player.getZone();\n  if (animal.has(\"zoneid\") && animal.has(\"x\") && animal.has(\"y\")) {\n    final StendhalRPZone zone=SingletonRepository.getRPWorld().getZone(animal.get(\"zoneid\"));\n    if (zone == playerZone) {\n      if (StendhalRPAction.placeat(zone,animal,animal.getX(),animal.getY())) {\n        return true;\n      }\n    }\n  }\n  return StendhalRPAction.placeat(playerZone,animal,player.getX(),player.getY());\n}\n", "nl": "Places a domestic animal in the world. If it matches it's owner's zone, then try to keep it's position."}
{"code": "@Override public int K(final Object ex,final FormObject formObj,final int actionID){\n  if (showMethods) {\n    System.out.println(\"DefaultActionHandler.K()\");\n  }\n  return javascript.execute(formObj,PdfDictionary.K,actionID,getKeyPressed(ex));\n}\n", "nl": "when user types a keystroke K action on - [javascript] keystroke in textfield or combobox modifys the list box selection (can access the keystroke for validity and reject or modify)"}
{"code": "protected FileMetadata buildFileMetadata(FileInfo fileInfo) throws IOException {\n  String filePathStr=fileInfo.getFilePath();\n  LOG.debug(\"file {}\",filePathStr);\n  FileMetadata fileMetadata=new FileMetadata(filePathStr);\n  Path path=new Path(filePathStr);\n  fileMetadata.setFileName(path.getName());\n  FileStatus status=fs.getFileStatus(path);\n  fileMetadata.setDirectory(status.isDirectory());\n  fileMetadata.setFileLength(status.getLen());\n  if (!status.isDirectory()) {\n    int noOfBlocks=(int)((status.getLen() / blockSize) + (((status.getLen() % blockSize) == 0) ? 0 : 1));\n    if (fileMetadata.getDataOffset() >= status.getLen()) {\n      noOfBlocks=0;\n    }\n    fileMetadata.setNumberOfBlocks(noOfBlocks);\n    populateBlockIds(fileMetadata);\n  }\n  return fileMetadata;\n}\n", "nl": "Creates file-metadata and populates no. of blocks in the metadata."}
{"code": "public Map<URI,List<URI>> addSourceVolumeFullCopies(){\n  List<URI> fullCopies=Lists.newArrayList();\n  Map<URI,List<URI>> fullCopiesMap=new HashMap<>();\n  for (  URI volumeId : uris(volumeIds)) {\n    List<URI> volumeFullCopies=getFullCopies(volumeId);\n    fullCopies.addAll(volumeFullCopies);\n    fullCopiesMap.put(volumeId,volumeFullCopies);\n  }\n  if (!fullCopies.isEmpty()) {\n    BlockStorageUtils.addVolumesToConsistencyGroup(consistencyGroup,fullCopies);\n  }\n  return fullCopiesMap;\n}\n", "nl": "Adds all source volumes' full copies to the consistency group"}
{"code": "@Override public String toString(){\n  StringBuilder sb=new StringBuilder();\n  sb.append(getClass().getSimpleName()).append(\"(id=\").append(id).append(\",records=\").append(sizeRecords()).append(\",bytes=\").append(sizeBytes()).append(\")\");\n  return sb.toString();\n}\n", "nl": "NOTE: Use for debugging only please."}
{"code": "public boolean isAbstract(String className) throws IllegalArgumentException {\n  checkClass(className);\n  ClassNode node=getClassNode(className);\n  return (node.access & Opcodes.ACC_ABSTRACT) == Opcodes.ACC_ABSTRACT;\n}\n", "nl": "Is the given class name representing an abstract class in the SUT?"}
{"code": "@Override protected void reset(){\n  super.reset();\n  m_Initialized=false;\n}\n", "nl": "resets the filter, i.e., m_NewBatch to true and m_FirstBatchDone to false."}
{"code": "@Override public Serializable saveState(){\n  final BaseDelegateState state=new BaseDelegateState();\n  state.m_startBaseStepsFinished=m_startBaseStepsFinished;\n  state.m_endBaseStepsFinished=m_endBaseStepsFinished;\n  return state;\n}\n", "nl": "Returns the state of the Delegate. All classes should super.saveState if they override this."}
{"code": "public void testRandomCompositeIds() throws Exception {\n  DocRouter router=DocRouter.getDocRouter(CompositeIdRouter.NAME);\n  DocCollection coll=createCollection(TestUtil.nextInt(random(),1,10),router);\n  StringBuilder idBuilder=new StringBuilder();\n  for (int i=0; i < 10000; ++i) {\n    idBuilder.setLength(0);\n    int numParts=TestUtil.nextInt(random(),1,30);\n    for (int part=0; part < numParts; ++part) {\nswitch (random().nextInt(5)) {\ncase 0:\n        idBuilder.append('!');\n      break;\ncase 1:\n    idBuilder.append('/');\n  break;\ncase 2:\nidBuilder.append(TestUtil.nextInt(random(),-100,1000));\nbreak;\ndefault :\n{\nint length=TestUtil.nextInt(random(),1,10);\nchar[] str=new char[length];\nTestUtil.randomFixedLengthUnicodeString(random(),str,0,length);\nidBuilder.append(str);\nbreak;\n}\n}\n}\nString id=idBuilder.toString();\ntry {\nSlice targetSlice=router.getTargetSlice(id,null,null,coll);\nassertNotNull(targetSlice);\n}\n catch (Exception e) {\nthrow new Exception(\"Exception routing id '\" + id + \"'\",e);\n}\n}\n}\n", "nl": "Make sure CompositeIdRouter can route random IDs without throwing exceptions"}
{"code": "public void remove(String name){\n  if (impl.formalArguments == null) {\n    if (impl.hasFormalArgs) {\n      throw new IllegalArgumentException(\"no such attribute: \" + name);\n    }\n    return;\n  }\n  FormalArgument arg=impl.formalArguments.get(name);\n  if (arg == null) {\n    throw new IllegalArgumentException(\"no such attribute: \" + name);\n  }\n  locals[arg.index]=EMPTY_ATTR;\n}\n", "nl": "Remove an attribute value entirely (can't remove attribute definitions)."}
{"code": "public void writeExternal(ObjectOutput out) throws IOException {\n  ref.write(out,true);\n}\n", "nl": "Write out external representation for remote ref."}
{"code": "@Override public Map<String,OperationDeclaration> operationsMap(){\n  return operationsMap;\n}\n", "nl": "Returns the operations of the port, mapped by their names."}
{"code": "private boolean zzRefill() throws java.io.IOException {\n  return zzCurrentPos >= s.offset + s.count;\n}\n", "nl": "Refills the input buffer."}
{"code": "@Override public void emitTuple(HashMap<K,Integer> tuple){\n  least.emit(tuple);\n}\n", "nl": "Emits tuple on port \"least\""}
{"code": "protected void initInfo(int record_id,String value){\n  label1.setText(Msg.translate(Env.getCtx(),m_queryColumns.get(0).toString()));\n  textField1.addActionListener(this);\n  if (m_queryColumns.size() > 1) {\n    label2.setText(Msg.translate(Env.getCtx(),m_queryColumns.get(1).toString()));\n    textField2.addActionListener(this);\n  }\n else {\n    label2.setVisible(false);\n    textField2.setVisible(false);\n  }\n  if (m_queryColumns.size() > 2) {\n    label3.setText(Msg.translate(Env.getCtx(),m_queryColumns.get(2).toString()));\n    textField3.addActionListener(this);\n  }\n else {\n    label3.setVisible(false);\n    textField3.setVisible(false);\n  }\n  if (m_queryColumns.size() > 3) {\n    label4.setText(Msg.translate(Env.getCtx(),m_queryColumns.get(3).toString()));\n    textField4.addActionListener(this);\n  }\n else {\n    label4.setVisible(false);\n    textField4.setVisible(false);\n  }\n  if (record_id != 0) {\n    fieldID=record_id;\n  }\n else {\n    if (value != null && value.length() > 0) {\n      textField1.setValue(value);\n    }\n  }\n  return;\n}\n", "nl": "General Init"}
{"code": "public static boolean hasPermission(@NonNull Context context,@NonNull String permission){\n  return ContextCompat.checkSelfPermission(context,permission) == PackageManager.PERMISSION_GRANTED;\n}\n", "nl": "Returns whether the application has access to a specific permission."}
{"code": "public Truncate(double min,double max){\n  super(Number.class,Number.class);\n  this.min=min;\n  this.max=max;\n}\n", "nl": "Constructs a new node for truncating a number within a range."}
{"code": "public ForEachFaceletsITCase(String name){\n  super(name);\n}\n", "nl": "Construct a new instance of this test case."}
{"code": "public void testContinuousMode() throws Exception {\n  depMode=DeploymentMode.CONTINUOUS;\n  processTest(false);\n}\n", "nl": "Test GridDeploymentMode.CONTINOUS mode."}
{"code": "public String next(int n) throws JSONException {\n  if (n == 0) {\n    return \"\";\n  }\n  char[] chars=new char[n];\n  int pos=0;\n  while (pos < n) {\n    chars[pos]=this.next();\n    if (this.end()) {\n      throw this.syntaxError(\"Substring bounds error\");\n    }\n    pos+=1;\n  }\n  return new String(chars);\n}\n", "nl": "Get the next n characters."}
{"code": "int encrypt(byte[] plain,int plainOffset,int plainLen,byte[] cipher,int cipherOffset){\n  if ((plainLen % blockSize) != 0) {\n    throw new ProviderException(\"Internal error in input buffering\");\n  }\n  int endIndex=plainOffset + plainLen;\n  for (; plainOffset < endIndex; plainOffset+=blockSize, cipherOffset+=blockSize) {\n    for (int i=0; i < blockSize; i++) {\n      k[i]=(byte)(plain[i + plainOffset] ^ r[i]);\n    }\n    embeddedCipher.encryptBlock(k,0,cipher,cipherOffset);\n    System.arraycopy(cipher,cipherOffset,r,0,blockSize);\n  }\n  return plainLen;\n}\n", "nl": "Performs encryption operation. <p>The input plain text <code>plain</code>, starting at <code>plainOffset</code> and ending at <code>(plainOffset + plainLen - 1)</code>, is encrypted. The result is stored in <code>cipher</code>, starting at <code>cipherOffset</code>."}
{"code": "public MentionDetector(JCas jCas,DependencyGraph dependencyGraph){\n  this.jCas=jCas;\n  this.dependencyGraph=dependencyGraph;\n}\n", "nl": "Create a new mention detector using the specified JCas and DependencyGraph"}
{"code": "public boolean isDelegationTargetIsAbstract(){\n  return delegationTargetIsAbstract;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public Object clone() throws CloneNotSupportedException {\n  DefaultTreeSelectionModel clone=(DefaultTreeSelectionModel)super.clone();\n  clone.changeSupport=null;\n  if (selection != null) {\n    int selLength=selection.length;\n    clone.selection=new TreePath[selLength];\n    System.arraycopy(selection,0,clone.selection,0,selLength);\n  }\n  clone.listenerList=new EventListenerList();\n  clone.listSelectionModel=(DefaultListSelectionModel)listSelectionModel.clone();\n  clone.uniquePaths=new Hashtable<TreePath,Boolean>();\n  clone.lastPaths=new Hashtable<TreePath,Boolean>();\n  clone.tempPaths=new TreePath[1];\n  return clone;\n}\n", "nl": "Returns a clone of this object with the same selection. This method does not duplicate selection listeners and property listeners."}
{"code": "public ExponetialDecay(){\n  this(1e-4);\n}\n", "nl": "Creates a new decay rate that decays down to 1e-4"}
{"code": "String readCountryName(Element el) throws IOException {\n  NodeList list=el.getElementsByTagName(\"country\");\n  if (list == null || list.getLength() == 0)   throw new IOException(\"Country name should be given\");\n  return list.item(0).getNodeValue();\n}\n", "nl": "read field countryname"}
{"code": "public void processFinished() throws OperatorException {\n}\n", "nl": "Called at the end of the process. The default implementation does nothing."}
{"code": "@Override protected Scalar parseScalar(Scalar s){\n  if (s.val.length < 1)   throw new IllegalArgumentException(\"Scalar must have 1 dimension.\");\n  return new Scalar(s.val[0]);\n}\n", "nl": "Parse a scalar value into the colorspace"}
{"code": "public void addCredentials(HomeserverConnectionConfig config){\n  if (null != config && config.getCredentials() != null) {\n    SharedPreferences prefs=mContext.getSharedPreferences(PREFS_LOGIN,Context.MODE_PRIVATE);\n    SharedPreferences.Editor editor=prefs.edit();\n    ArrayList<HomeserverConnectionConfig> configs=getCredentialsList();\n    configs.add(config);\n    ArrayList<JSONObject> serialized=new ArrayList<>(configs.size());\n    try {\n      for (      HomeserverConnectionConfig c : configs) {\n        serialized.add(c.toJson());\n      }\n    }\n catch (    JSONException e) {\n      throw new RuntimeException(\"Failed to serialize connection config\");\n    }\n    String ser=new JSONArray(serialized).toString();\n    Log.d(LOG_TAG,\"Storing \" + serialized.size() + \" credentials\");\n    editor.putString(PREFS_KEY_CONNECTION_CONFIGS,ser);\n    editor.apply();\n  }\n}\n", "nl": "Add a credentials to the credentials list"}
{"code": "@Override public int compareTo(@Nullable ObsValue other){\n  if (other == null)   return 1;\n  int result=0;\n  result=Integer.compare(getTypeOrdering(),other.getTypeOrdering());\n  if (result != 0)   return result;\n  if (uuid != null) {\n    result=Integer.compare(getUuidOrdering(),other.getUuidOrdering());\n    if (result != 0)     return result;\n    result=uuid.compareTo(other.uuid);\n  }\n else   if (number != null) {\n    result=Double.compare(number,other.number);\n  }\n else   if (text != null) {\n    result=text.compareTo(other.text);\n  }\n else   if (date != null) {\n    result=date.compareTo(other.date);\n  }\n else   if (instant != null) {\n    result=instant.compareTo(other.instant);\n  }\n  return result;\n}\n", "nl": "Compares ObsValue instances according to a total ordering such that: - All non-null values are greater than null. - The lowest value is the \"false\" Boolean value (encoded as the coded concept for \"No\"). - Next are all coded values, ordered from least severe to most severe (if they can be interpreted as having a severity); or from first to last (if they can be interpreted as having a typical temporal sequence). - Next is the \"true\" Boolean value (encoded as the coded concept for \"Yes\"). - Next are all numeric values, ordered from least to greatest. - Next are all text values, ordered lexicographically from A to Z. - Next are all date values, ordered from least to greatest. - Next are all instant values, ordered from least to greatest."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase UmplePackage.PARAMETER_LIST___PARAMETER_1:\n    return ((InternalEList<?>)getParameter_1()).basicRemove(otherEnd,msgs);\ncase UmplePackage.PARAMETER_LIST___ANONYMOUS_PARAMETER_LIST_11:\n  return ((InternalEList<?>)getAnonymous_parameterList_1_1()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@SuppressWarnings(\"unchecked\") private Volume performRPVolumeIngestion(IngestionRequestContext parentRequestContext,RecoverPointVolumeIngestionContext rpVolumeContext,UnManagedVolume unManagedVolume,Volume volume){\n  _logger.info(\"starting RecoverPoint volume ingestion for UnManagedVolume {}\",unManagedVolume.forDisplay());\n  if (null == volume) {\n    IngestStrategy ingestStrategy=ingestStrategyFactory.buildIngestStrategy(unManagedVolume,IngestStrategyFactory.DISREGARD_PROTECTION);\n    volume=(Volume)ingestStrategy.ingestBlockObjects(rpVolumeContext,VolumeIngestionUtil.getBlockObjectClass(unManagedVolume));\n    _logger.info(\"Ingestion ended for unmanagedvolume {}\",unManagedVolume.getNativeGuid());\n    if (null == volume) {\n      throw IngestionException.exceptions.generalVolumeException(unManagedVolume.getLabel(),\"check the logs for more details\");\n    }\n  }\n else {\n    if (markUnManagedVolumeInactive(parentRequestContext,volume)) {\n      _logger.info(\"All the related replicas and parent of unManagedVolume {} have been ingested \",unManagedVolume.getNativeGuid());\n      unManagedVolume.setInactive(true);\n      parentRequestContext.getUnManagedVolumesToBeDeleted().add(unManagedVolume);\n    }\n else {\n      _logger.info(\"Not all the parent/replicas of unManagedVolume {} have been ingested , hence marking as internal\",unManagedVolume.getNativeGuid());\n      volume.addInternalFlags(INTERNAL_VOLUME_FLAGS);\n    }\n  }\n  rpVolumeContext.setManagedBlockObject(volume);\n  if (null != _dbClient.queryObject(Volume.class,volume.getId())) {\n    rpVolumeContext.addDataObjectToUpdate(volume,unManagedVolume);\n  }\n else {\n    rpVolumeContext.addBlockObjectToCreate(volume);\n  }\n  return volume;\n}\n", "nl": "Perform RP volume ingestion. Typically this involves finding the proper ingestion orchestrator for the volume type (minus the fact it's RP, which got us to this code in the first place), then calling block ingest on that orchestrator."}
{"code": "public HDTVFilter(boolean matchPasses){\n  super(matchPasses);\n}\n", "nl": "Creates a new instance of HDTVFilter"}
{"code": "@Override public Toolbar build(){\n  ToolbarSearch toolbar=new ToolbarSearch(mContext);\n  toolbar.setData(mAutoCompletionEnabled,mAutoCompletionDynamic,mAutoCompletionSuggestions,mAutoCompletionMode,mThreshold,mOnSearchListener,mOnSearchDynamicListener);\n  return toolbar;\n}\n", "nl": "Build the Toolbar to be the Search Toolbar."}
{"code": "public synchronized TCPConnection openConnection() throws IOException {\n  int id;\n  do {\n    lastID=(++lastID) & 0x7FFF;\n    id=lastID;\n    if (orig)     id|=0x8000;\n  }\n while (connectionTable.get(id) != null);\n  MultiplexConnectionInfo info=new MultiplexConnectionInfo(id);\n  info.in=new MultiplexInputStream(this,info,2048);\n  info.out=new MultiplexOutputStream(this,info,2048);\nsynchronized (connectionTable) {\n    if (!alive)     throw new IOException(\"Multiplexer connection dead\");\n    if (numConnections >= maxConnections)     throw new IOException(\"Cannot exceed \" + maxConnections + \" simultaneous multiplexed connections\");\n    connectionTable.put(id,info);\n    ++numConnections;\n  }\nsynchronized (dataOut) {\n    try {\n      dataOut.writeByte(OPEN);\n      dataOut.writeShort(id);\n      dataOut.flush();\n    }\n catch (    IOException e) {\n      multiplexLog.log(Log.BRIEF,\"exception: \",e);\n      shutDown();\n      throw e;\n    }\n  }\n  return new TCPConnection(channel,info.in,info.out);\n}\n", "nl": "Initiate a new multiplexed connection through the underlying connection."}
{"code": "public V remove(Object key){\nsynchronized (this) {\n    Map<K,V> newMap=new HashMap<K,V>(internalMap);\n    V val=newMap.remove(key);\n    internalMap=newMap;\n    return val;\n  }\n}\n", "nl": "Removed the value and key from this map based on the provided key."}
{"code": "public void defineLocal() throws IOException {\n  print(\"defineLocal\",null);\n}\n", "nl": "Description of the Method"}
{"code": "public void testIntbyInt2(){\n  byte aBytes[]={-1,-1,-1,-1};\n  byte bBytes[]={-1,-1,-1,-1};\n  int aSign=1;\n  int bSign=1;\n  byte rBytes[]={0,-1,-1,-1,-2,0,0,0,1};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.multiply(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n", "nl": "Multiply two numbers of 4 bytes length."}
{"code": "private Object createRmiProxy(URI endpoint){\n  RmiProxyFactoryBean proxyFactory=new RmiProxyFactoryBean();\n  proxyFactory.setServiceInterface(_endpointInterface);\n  proxyFactory.setServiceUrl(endpoint.toString());\n  proxyFactory.setRefreshStubOnConnectFailure(true);\n  proxyFactory.setCacheStub(false);\n  proxyFactory.afterPropertiesSet();\n  Object rmiProxy=proxyFactory.getObject();\n  _proxyMap.putIfAbsent(endpoint,rmiProxy);\n  return rmiProxy;\n}\n", "nl": "Creates and caches RMI proxy"}
{"code": "public TBGraph(final LiveExprNode tf){\n  this.tf=tf;\n  this.initCnt=0;\n  final TBPar initTerms=new TBPar(1);\n  initTerms.addElement(tf);\n  final TBParVec pars=initTerms.particleClosure();\n  for (int i=0; i < pars.size(); i++) {\n    final TBGraphNode gn=new TBGraphNode(pars.parAt(i));\n    this.addElement(gn);\n  }\n  this.setInitCnt(this.size());\n  for (int i=0; i < this.size(); i++) {\n    final TBGraphNode gnSrc=(TBGraphNode)this.elementAt(i);\n    final TBPar imps=gnSrc.getPar().impliedSuccessors();\n    final TBParVec succs=imps.particleClosure();\n    for (int j=0; j < succs.size(); j++) {\n      final TBPar par=succs.parAt(j);\n      final TBGraphNode gnDst=findOrCreateNode(par);\n      gnSrc.nexts.addElement(gnDst);\n    }\n  }\n  for (int i=0; i < this.size(); i++) {\n    this.getNode(i).setIndex(i);\n  }\n}\n", "nl": "Given a starting TBGraphNode, constructTableau constructs the tableau for it. Read MP for details. It returns a list of all the nodes in the tableau graph."}
{"code": "private UserTransaction startUserTransaction(){\n  if (wrapInUserTransaction == false) {\n    return null;\n  }\n  UserTransaction userTransaction=null;\n  try {\n    userTransaction=UserTransactionHelper.lookupUserTransaction();\n    userTransaction.begin();\n  }\n catch (  Throwable t) {\n    UserTransactionHelper.returnUserTransaction(userTransaction);\n    userTransaction=null;\n    getLog().error(\"Failed to start UserTransaction for plugin: \" + getName(),t);\n  }\n  return userTransaction;\n}\n", "nl": "If <em>wrapInUserTransaction</em> is true, starts a new UserTransaction  and returns it. Otherwise, or if establishing the transaction fail, it  will return null."}
{"code": "public ClientBuilderForConnector forServer(String uri,@Nullable String version){\n  configBuilder.withDockerHost(URI.create(uri).toString()).withApiVersion(version);\n  return this;\n}\n", "nl": "Method to setup url and docker-api version. Convenient for test-connection purposes and quick requests"}
{"code": "public static boolean invertM(float[] mInv,int mInvOffset,float[] m,int mOffset){\n  float src0=m[mOffset], src4=m[mOffset + 1], src8=m[mOffset + 2], src12=m[mOffset + 3], src1=m[mOffset + 4], src5=m[mOffset + 5], src9=m[mOffset + 6], src13=m[mOffset + 7], src2=m[mOffset + 8], src6=m[mOffset + 9], src10=m[mOffset + 10], src14=m[mOffset + 11], src3=m[mOffset + 12], src7=m[mOffset + 13], src11=m[mOffset + 14], src15=m[mOffset + 15];\n  float tmp0=src10 * src15, tmp1=src11 * src14, tmp2=src9 * src15, tmp3=src11 * src13, tmp4=src9 * src14, tmp5=src10 * src13, tmp6=src8 * src15, tmp7=src11 * src12, tmp8=src8 * src14, tmp9=src10 * src12, tmp10=src8 * src13, tmp11=src9 * src12;\n  float dst0=tmp0 * src5 + tmp3 * src6 + tmp4 * src7;\n  dst0-=tmp1 * src5 + tmp2 * src6 + tmp5 * src7;\n  float dst1=tmp1 * src4 + tmp6 * src6 + tmp9 * src7;\n  dst1-=tmp0 * src4 + tmp7 * src6 + tmp8 * src7;\n  float dst2=tmp2 * src4 + tmp7 * src5 + tmp10 * src7;\n  dst2-=tmp3 * src4 + tmp6 * src5 + tmp11 * src7;\n  float dst3=tmp5 * src4 + tmp8 * src5 + tmp11 * src6;\n  dst3-=tmp4 * src4 + tmp9 * src5 + tmp10 * src6;\n  float dst4=tmp1 * src1 + tmp2 * src2 + tmp5 * src3;\n  dst4-=tmp0 * src1 + tmp3 * src2 + tmp4 * src3;\n  float dst5=tmp0 * src0 + tmp7 * src2 + tmp8 * src3;\n  dst5-=tmp1 * src0 + tmp6 * src2 + tmp9 * src3;\n  float dst6=tmp3 * src0 + tmp6 * src1 + tmp11 * src3;\n  dst6-=tmp2 * src0 + tmp7 * src1 + tmp10 * src3;\n  float dst7=tmp4 * src0 + tmp9 * src1 + tmp10 * src2;\n  dst7-=tmp5 * src0 + tmp8 * src1 + tmp11 * src2;\n  tmp0=src2 * src7;\n  tmp1=src3 * src6;\n  tmp2=src1 * src7;\n  tmp3=src3 * src5;\n  tmp4=src1 * src6;\n  tmp5=src2 * src5;\n  tmp6=src0 * src7;\n  tmp7=src3 * src4;\n  tmp8=src0 * src6;\n  tmp9=src2 * src4;\n  tmp10=src0 * src5;\n  tmp11=src1 * src4;\n  float dst8=tmp0 * src13 + tmp3 * src14 + tmp4 * src15;\n  dst8-=tmp1 * src13 + tmp2 * src14 + tmp5 * src15;\n  float dst9=tmp1 * src12 + tmp6 * src14 + tmp9 * src15;\n  dst9-=tmp0 * src12 + tmp7 * src14 + tmp8 * src15;\n  float dst10=tmp2 * src12 + tmp7 * src13 + tmp10 * src15;\n  dst10-=tmp3 * src12 + tmp6 * src13 + tmp11 * src15;\n  float dst11=tmp5 * src12 + tmp8 * src13 + tmp11 * src14;\n  dst11-=tmp4 * src12 + tmp9 * src13 + tmp10 * src14;\n  float dst12=tmp2 * src10 + tmp5 * src11 + tmp1 * src9;\n  dst12-=tmp4 * src11 + tmp0 * src9 + tmp3 * src10;\n  float dst13=tmp8 * src11 + tmp0 * src8 + tmp7 * src10;\n  dst13-=tmp6 * src10 + tmp9 * src11 + tmp1 * src8;\n  float dst14=tmp6 * src9 + tmp11 * src11 + tmp3 * src8;\n  dst14-=tmp10 * src11 + tmp2 * src8 + tmp7 * src9;\n  float dst15=tmp10 * src10 + tmp4 * src8 + tmp9 * src9;\n  dst15-=tmp8 * src9 + tmp11 * src10 + tmp5 * src8;\n  float det=src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;\n  if (det == 0.0f) {\n  }\n  det=1.0f / det;\n  mInv[mInvOffset + 0]=dst0 * det;\n  mInv[mInvOffset + 1]=dst1 * det;\n  mInv[mInvOffset + 2]=dst2 * det;\n  mInv[mInvOffset + 3]=dst3 * det;\n  mInv[mInvOffset + 4]=dst4 * det;\n  mInv[mInvOffset + 5]=dst5 * det;\n  mInv[mInvOffset + 6]=dst6 * det;\n  mInv[mInvOffset + 7]=dst7 * det;\n  mInv[mInvOffset + 8]=dst8 * det;\n  mInv[mInvOffset + 9]=dst9 * det;\n  mInv[mInvOffset + 10]=dst10 * det;\n  mInv[mInvOffset + 11]=dst11 * det;\n  mInv[mInvOffset + 12]=dst12 * det;\n  mInv[mInvOffset + 13]=dst13 * det;\n  mInv[mInvOffset + 14]=dst14 * det;\n  mInv[mInvOffset + 15]=dst15 * det;\n  return true;\n}\n", "nl": "Inverts a 4 x 4 matrix."}
{"code": "public void addSuffix(String suffix,boolean selected){\n  if (suffixAction == null) {\n    suffixAction=new UpdateSuffixListAction(listModel);\n  }\n  final JCheckBox cb=(JCheckBox)suffixList.add(new JCheckBox(suffix));\n  cb.setOpaque(false);\n  checkboxes.addElement(cb);\n  cb.setSelected(selected);\n  cb.addActionListener(suffixAction);\n  if (selected) {\n    listModel.addSuffix(suffix);\n  }\n  cb.addFocusListener(listFocusListener);\n}\n", "nl": "Adds the suffix."}
{"code": "public boolean isAccessibilityEnabled(){\n  return isTouchExplorationEnabled() || containsGoogleAccessibilityService();\n}\n", "nl": "Returns whether a touch exploration is enabled or a Google accessibility service is enabled."}
{"code": "public void removeCondition(AbstractCondition condition){\n  Node<AbstractCondition> node=getNode(condition);\n  if (node != null) {\n    if (node.getParent() == null) {\n      getRootNodes().remove(node);\n    }\n else {\n      node.getParent().getChildren().remove(node);\n    }\n  }\n}\n", "nl": "Removes a node with condition from the tree. Do nothing if condition is not in the tree."}
{"code": "public final void println(float f) throws IOException {\n  println(String.valueOf(f));\n}\n", "nl": "Prints a float followed by a newline."}
{"code": "public MergingLexer(final Lexer original,final MergeTuple... mergeTuples){\n  super(original);\n  this.mergeFunction=new LexerMergeFunction(mergeTuples);\n}\n", "nl": "Create a merging lexer which works with the merge definitions given in the mergeTuples parameter."}
{"code": "@SuppressWarnings(\"static-access\") private void resetOptionAttemptTranslations(){\n  m_optionAttemptTranslations.setSelected(s_parameters.isAttemptTranslation());\n}\n", "nl": "resets the attempt translations checkbox"}
{"code": "private void updateProgress(int progress){\n  if (myHost != null) {\n    myHost.updateProgress(progress);\n  }\n else {\n    System.out.println(\"Progress: \" + progress + \"%\");\n  }\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "@Override public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  final JComponent popup=(JComponent)c;\n  final Image hShadowBg=(Image)popup.getClientProperty(ShadowPopupFactory.PROP_HORIZONTAL_BACKGROUND);\n  if (hShadowBg != null) {\n    g.drawImage(hShadowBg,x,y + height - 5,c);\n  }\n  final Image vShadowBg=(Image)popup.getClientProperty(ShadowPopupFactory.PROP_VERTICAL_BACKGROUND);\n  if (vShadowBg != null) {\n    g.drawImage(vShadowBg,x + width - 5,y,c);\n  }\n  g.drawImage(SHADOW,x + 5,y + height - 5,x + 10,y + height,0,6,5,11,null,c);\n  g.drawImage(SHADOW,x + 10,y + height - 5,x + width - 5,y + height,5,6,6,11,null,c);\n  g.drawImage(SHADOW,x + width - 5,y + 5,x + width,y + 10,6,0,11,5,null,c);\n  g.drawImage(SHADOW,x + width - 5,y + 10,x + width,y + height - 5,6,5,11,6,null,c);\n  g.drawImage(SHADOW,x + width - 5,y + height - 5,x + width,y + height,6,6,11,11,null,c);\n}\n", "nl": "Paints the border for the specified component with the specified position and size."}
{"code": "public int calcHash(char[] buffer,int start,int len){\n  int hash=_hashSeed;\n  for (int i=0; i < len; ++i) {\n    hash=(hash * HASH_MULT) + (int)buffer[i];\n  }\n  return (hash == 0) ? 1 : hash;\n}\n", "nl": "Implementation of a hashing method for variable length Strings. Most of the time intention is that this calculation is done by caller during parsing, not here; however, sometimes it needs to be done for parsed \"String\" too."}
{"code": "private void sendTrackBroadcast(int actionId,long trackId){\n  Intent intent=new Intent().setAction(getString(actionId)).putExtra(getString(R.string.track_id_broadcast_extra),trackId);\n  sendBroadcast(intent,getString(R.string.permission_notification_value));\n  if (PreferencesUtils.getBoolean(this,R.string.allow_access_key,PreferencesUtils.ALLOW_ACCESS_DEFAULT)) {\n    sendBroadcast(intent,getString(R.string.broadcast_notifications_permission));\n  }\n}\n", "nl": "Sends track broadcast."}
{"code": "public static HappySQL mysql(String dbHost,String userName,String password,String dbName) throws ClassNotFoundException, SQLException {\n  return new HappyMySQL(dbHost,userName,password,dbName);\n}\n", "nl": "Creates an instance of a HappySQL object."}
{"code": "public double logMarginalLikelihoodAICM(List<Double> v){\n  double sum=0;\n  final int size=v.size();\n  for (int i=0; i < size; i++)   sum+=v.get(i);\n  double mean=sum / (double)size;\n  double var=0;\n  for (int i=0; i < size; i++)   var+=(v.get(i) - mean) * (v.get(i) - mean);\n  var/=(double)size - 1;\n  return 2 * var - 2 * mean;\n}\n", "nl": "Calculates the AICM of a model using method-of-moments from Raftery et al. (2007)"}
{"code": "public void addIdentity(DiscoverInfo.Identity identity){\n  identities.add(identity);\n  renewEntityCapsVersion();\n}\n", "nl": "Add an identity to the client."}
{"code": "public static RegexMatcher buildRegexMatcher(Map<String,String> operatorProperties) throws PlanGenException, DataFlowException, IOException {\n  String regex=OperatorBuilderUtils.getRequiredProperty(REGEX,operatorProperties);\n  PlanGenUtils.planGenAssert(!regex.trim().isEmpty(),\"regex is empty\");\n  List<Attribute> attributeList=OperatorBuilderUtils.constructAttributeList(operatorProperties);\n  RegexPredicate regexPredicate=new RegexPredicate(regex,attributeList,DataConstants.getTrigramAnalyzer());\n  RegexMatcher regexMatcher=new RegexMatcher(regexPredicate);\n  Integer limitInt=OperatorBuilderUtils.findLimit(operatorProperties);\n  if (limitInt != null) {\n    regexMatcher.setLimit(limitInt);\n  }\n  Integer offsetInt=OperatorBuilderUtils.findOffset(operatorProperties);\n  if (offsetInt != null) {\n    regexMatcher.setOffset(offsetInt);\n  }\n  return regexMatcher;\n}\n", "nl": "Builds a RegexMatcher according to operatorProperties."}
{"code": "public Signature sign(final byte[] salt){\n  final Signer signer=new Signer(this.keyPair);\n  return signer.sign(this.getPayload(salt));\n}\n", "nl": "Signs information about this identity with its private key."}
{"code": "public synchronized boolean isLockOwner(Connection conn,String lockName){\n  lockName=lockName.intern();\n  return getThreadLocks().contains(lockName);\n}\n", "nl": "Determine whether the calling thread owns a lock on the identified resource."}
{"code": "@Override public void finish() throws IOException {\n  if (out == null) {\n    throw new IOException(\"Stream is closed\");\n  }\n  if (cDir == null) {\n    return;\n  }\n  if (entries.isEmpty()) {\n    throw new ZipException(\"No entries\");\n  }\n  if (currentEntry != null) {\n    closeEntry();\n  }\n  int cdirSize=cDir.size();\n  writeLong(cDir,ENDSIG);\n  writeShort(cDir,0);\n  writeShort(cDir,0);\n  writeShort(cDir,entries.size());\n  writeShort(cDir,entries.size());\n  writeLong(cDir,cdirSize);\n  writeLong(cDir,offset);\n  writeShort(cDir,commentBytes.length);\n  if (commentBytes.length > 0) {\n    cDir.write(commentBytes);\n  }\n  cDir.writeTo(out);\n  cDir=null;\n}\n", "nl": "Indicates that all entries have been written to the stream. Any terminal information is written to the underlying stream."}
{"code": "public static RandomMixedRunner serializableInstance(){\n  return new RandomMixedRunner(Dag.serializableInstance(),new Parameters());\n}\n", "nl": "Generates a simple exemplar of this class to test serialization."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException {\n  if (desc.getUuid() == null || desc.getName() == null) {\n    throw new IllegalArgumentException();\n  }\n  String name=desc.getName();\n  if (!cubeDescMap.containsKey(name)) {\n    throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\");\n  }\n  try {\n    desc.init(config);\n  }\n catch (  Exception e) {\n    logger.warn(\"Broken cube desc \" + desc,e);\n    desc.addError(e.getMessage());\n    return desc;\n  }\n  CubeMetadataValidator validator=new CubeMetadataValidator();\n  ValidateContext context=validator.validate(desc);\n  if (!context.ifPass()) {\n    return desc;\n  }\n  desc.setSignature(desc.calculateSignature());\n  String path=desc.getResourcePath();\n  getStore().putResource(path,desc,CUBE_DESC_SERIALIZER);\n  CubeDesc ndesc=loadCubeDesc(path,false);\n  cubeDescMap.put(ndesc.getName(),desc);\n  return ndesc;\n}\n", "nl": "Update CubeDesc with the input. Broadcast the event into cluster"}
{"code": "public static boolean isAppletAvailable(String applet){\n  return RootTools.isAppletAvailable(applet,\"\");\n}\n", "nl": "This will let you know if an applet is available from BusyBox <p/>"}
{"code": "public static String toShortString(ClusterNode n){\n  return \"ClusterNode [id=\" + n.id() + \", order=\"+ n.order()+ \", addr=\"+ n.addresses()+ \", daemon=\"+ n.isDaemon()+ ']';\n}\n", "nl": "Short node representation."}
{"code": "public ByteBuffer readBinary() throws IOException {\n  _messageReader.next();\n  return _messageReader.getBinary();\n}\n", "nl": "This method will be used our InputStream implementation to continually retrieve binary messages."}
{"code": "public static byte[] decode(String s) throws Base64DecoderException {\n  byte[] bytes=s.getBytes();\n  return decode(bytes,bytes.length);\n}\n", "nl": "Decodes data from Base64 notation."}
{"code": "private void writeAttribute(java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "public void testBindPlacement03(){\n  new Helper(){\n{\n      given=select(varNode(x),where(stmtPatternWithVar(\"x1\"),stmtPatternWithVarOptional(\"y1\"),stmtPatternWithVar(\"y1\"),stmtPatternWithVars(\"y1\",\"z1\"),assignmentWithVar(\"z1\",\"y1\")));\n      expected=select(varNode(x),where(stmtPatternWithVar(\"x1\"),stmtPatternWithVarOptional(\"y1\"),stmtPatternWithVar(\"y1\"),assignmentWithVar(\"z1\",\"y1\"),stmtPatternWithVars(\"y1\",\"z1\")));\n    }\n  }\n.testWhileIgnoringExplainHints();\n}\n", "nl": "Test complex pattern, including inter- and intra-partition reordering, with focus on BIND and ASSIGNMENT nodes."}
{"code": "public String urlTipText(){\n  return \"The URL of the database\";\n}\n", "nl": "Returns the tip text for this property."}
{"code": "public final void writeLong(long v){\n  tempBuffer[0]=(byte)(v >>> 56);\n  tempBuffer[1]=(byte)(v >>> 48);\n  tempBuffer[2]=(byte)(v >>> 40);\n  tempBuffer[3]=(byte)(v >>> 32);\n  tempBuffer[4]=(byte)(v >>> 24);\n  tempBuffer[5]=(byte)(v >>> 16);\n  tempBuffer[6]=(byte)(v >>> 8);\n  tempBuffer[7]=(byte)(v >>> 0);\n  write(tempBuffer,0,8);\n}\n", "nl": "Writes a <code>long</code> to the underlying output stream as eight bytes, high byte first. In no exception is thrown, the counter <code>written</code> is incremented by <code>8</code>."}
{"code": "public SunCertPathBuilderException(Throwable cause){\n  super(cause);\n}\n", "nl": "Constructs a <code>SunCertPathBuilderException</code> that wraps the specified throwable. This allows any exception to be converted into a <code>SunCertPathBuilderException</code>, while retaining information about the cause, which may be useful for debugging. The detail message is set to (<code>cause==null ? null : cause.toString()</code>) (which typically contains the class and detail message of cause)."}
{"code": "public static boolean isValid(String wwnString){\n  if (wwnString.length() != 18) {\n    return false;\n  }\n  Pattern pattern=Pattern.compile(\"^([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\");\n  Matcher matcher=pattern.matcher(wwnString);\n  boolean found=false;\n  while (matcher.find()) {\n    found=true;\n  }\n  return found;\n}\n", "nl": "validates that the passed in string represents a valid WWN. WWN must be in the 60060160-6c4a-2200 WWN format"}
{"code": "protected void addStatePropertyDescriptor(Object object){\n  itemPropertyDescriptors.add(createItemPropertyDescriptor(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),getResourceLocator(),getString(\"_UI_TraceStateExited_state_feature\"),getString(\"_UI_PropertyDescriptor_description\",\"_UI_TraceStateExited_state_feature\",\"_UI_TraceStateExited_type\"),SexecPackage.Literals.TRACE_STATE_EXITED__STATE,true,false,true,null,null,null));\n}\n", "nl": "This adds a property descriptor for the State feature. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static double rRSErawFitness(boolean useTrainingData,GEPIndividual ind,int chromosomeNum){\n  double sumOfSquaredRelativeError=0.0;\n  double expectedResult;\n  double result;\n  double relativeError;\n  GEPDependentVariable dv;\n  if (useTrainingData)   dv=GEPDependentVariable.trainingData;\n else   dv=GEPDependentVariable.testingData;\n  double dvValues[]=dv.getDependentVariableValues(chromosomeNum);\n  double dvSumOfSquaredRelativeError=dv.getDependentVariableSumOfSquaredRelativeError(chromosomeNum);\n  for (int i=0; i < dvValues.length; i++) {\n    expectedResult=dvValues[i];\n    result=ind.eval(chromosomeNum,useTrainingData,i);\n    if (expectedResult == 0.0) {\n      expectedResult=RELATIVE_ERROR_ZERO_FACTOR;\n      result+=RELATIVE_ERROR_ZERO_FACTOR;\n      System.err.println(\"Warning: expected result (test value) is 0 in rRSE fitness calculation. Adjusting to avoid division by zero.\");\n    }\n    relativeError=(result - expectedResult) / expectedResult;\n    sumOfSquaredRelativeError+=relativeError * relativeError;\n  }\n  if (dvSumOfSquaredRelativeError == 0.0) {\n    dvSumOfSquaredRelativeError=RELATIVE_ERROR_ZERO_FACTOR;\n    System.err.println(\"Warning: sum of squared relative error for dependent variable is 0 in rRSE fitness calculation. Adjusting to avoid division by zero.\");\n  }\n  return (sumOfSquaredRelativeError / dvSumOfSquaredRelativeError);\n}\n", "nl": "Calculates the 'raw' fitness for the rRSE (relative RSE) type  fitness (before the normalization from 0 to max value is done)."}
{"code": "public static void clear(){\n  responseHeaderDB.clear();\n  try {\n    fileDB.clear();\n  }\n catch (  final IOException e) {\n    ConcurrentLog.logException(e);\n  }\n  try {\n    fileDBunbuffered.clear();\n  }\n catch (  final IOException e) {\n    ConcurrentLog.logException(e);\n  }\n}\n", "nl": "clear the cache"}
{"code": "@Override public void transmitPartialDiff(final Task<Diff> result){\n  writeOutput(result);\n}\n", "nl": "Receives a partial DiffTask Transmission."}
{"code": "public boolean useEnergy(double amount){\n  if (canUseEnergy(amount) && !FMLCommonHandler.instance().getEffectiveSide().isClient()) {\n    energyStored-=amount;\n    return true;\n  }\n  return false;\n}\n", "nl": "Use the specified amount of energy, if available."}
{"code": "public static String encodeWebSafe(byte[] source,boolean doPadding){\n  return encode(source,0,source.length,WEBSAFE_ALPHABET,doPadding);\n}\n", "nl": "Encodes a byte array into web safe Base64 notation."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(elementsetattributenodens04.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public void createDefaultColumnsFromModel(){\n  DataLineModel<?,?> dlm=(DataLineModel<?,?>)dataModel;\n  if (dlm != null) {\n    TableColumnModel cm=getColumnModel();\n    while (cm.getColumnCount() > 0) {\n      cm.removeColumn(cm.getColumn(0));\n    }\n    for (int i=0; i < dlm.getColumnCount(); i++) {\n      TableColumn newColumn=dlm.getTableColumn(i);\n      if (newColumn != null) {\n        addColumn(newColumn);\n      }\n    }\n  }\n}\n", "nl": "Overrides JTable's default implementation in order to add LimeTableColumn columns."}
{"code": "public static Map duplicateMap(Map map,boolean doKeysLower,boolean deepCopy) throws PageException {\n  if (doKeysLower) {\n    Map newMap;\n    try {\n      newMap=(Map)ClassUtil.loadInstance(map.getClass());\n    }\n catch (    ClassException e) {\n      newMap=new HashMap();\n    }\n    boolean inside=ThreadLocalDuplication.set(map,newMap);\n    try {\n      Iterator it=map.keySet().iterator();\n      while (it.hasNext()) {\n        Object key=it.next();\n        if (deepCopy)         newMap.put(StringUtil.toLowerCase(Caster.toString(key)),duplicate(map.get(key),deepCopy));\n else         newMap.put(StringUtil.toLowerCase(Caster.toString(key)),map.get(key));\n      }\n    }\n  finally {\n      if (!inside)       ThreadLocalDuplication.reset();\n    }\n    return newMap;\n  }\n  return duplicateMap(map,deepCopy);\n}\n", "nl": "duplicate a map"}
{"code": "public static _Fields findByName(String name){\n  return byName.get(name);\n}\n", "nl": "Find the _Fields constant that matches name, or null if its not found."}
{"code": "public synchronized void clearYTextLabels(int scale){\n  mYTextLabels.get(scale).clear();\n}\n", "nl": "Clears the existing text labels on the Y axis."}
{"code": "@SuppressWarnings(\"unchecked\") @Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase N4JSPackage.NEW_EXPRESSION__TYPE_ARGS:\n    getTypeArgs().clear();\n  getTypeArgs().addAll((Collection<? extends TypeRef>)newValue);\nreturn;\ncase N4JSPackage.NEW_EXPRESSION__CALLEE:\nsetCallee((Expression)newValue);\nreturn;\ncase N4JSPackage.NEW_EXPRESSION__ARGUMENTS:\ngetArguments().clear();\ngetArguments().addAll((Collection<? extends Argument>)newValue);\nreturn;\ncase N4JSPackage.NEW_EXPRESSION__WITH_ARGS:\nsetWithArgs((Boolean)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected void assertArrayEquals(Object[] expected,Object[] value){\n  String message=\"expected array: \" + InvokerHelper.toString(expected) + \" value array: \"+ InvokerHelper.toString(value);\n  assertNotNull(message + \": expected should not be null\",expected);\n  assertNotNull(message + \": value should not be null\",value);\n  assertEquals(message,expected.length,value.length);\n  for (int i=0, size=expected.length; i < size; i++) {\n    assertEquals(\"value[\" + i + \"] when \"+ message,expected[i],value[i]);\n  }\n}\n", "nl": "Asserts that the arrays are equivalent and contain the same values"}
{"code": "private Finished(byte[] verifyData,InetSocketAddress peerAddress){\n  super(peerAddress);\n  this.verifyData=Arrays.copyOf(verifyData,verifyData.length);\n}\n", "nl": "Called when reconstructing byteArray."}
{"code": "public boolean matchesThisPacket(DatapathId switchDpid,OFPort inPort,Ethernet packet,AllowDropPair adp){\n  IPacket pkt=packet.getPayload();\n  IPv4 pkt_ip=null;\n  TCP pkt_tcp=null;\n  UDP pkt_udp=null;\n  TransportPort pkt_tp_src=TransportPort.NONE;\n  TransportPort pkt_tp_dst=TransportPort.NONE;\n  if (any_dpid == false && !dpid.equals(switchDpid))   return false;\n  if (any_in_port == false && !in_port.equals(inPort))   return false;\n  if (action == FirewallRule.FirewallAction.DROP) {\n    if (!OFPort.ANY.equals(this.in_port)) {\n      adp.drop.setExact(MatchField.IN_PORT,this.in_port);\n    }\n  }\n else {\n    if (!OFPort.ANY.equals(this.in_port)) {\n      adp.allow.setExact(MatchField.IN_PORT,this.in_port);\n    }\n  }\n  if (any_dl_src == false && !dl_src.equals(packet.getSourceMACAddress()))   return false;\n  if (action == FirewallRule.FirewallAction.DROP) {\n    if (!MacAddress.NONE.equals(this.dl_src)) {\n      adp.drop.setExact(MatchField.ETH_SRC,this.dl_src);\n    }\n  }\n else {\n    if (!MacAddress.NONE.equals(this.dl_src)) {\n      adp.allow.setExact(MatchField.ETH_SRC,this.dl_src);\n    }\n  }\n  if (any_dl_dst == false && !dl_dst.equals(packet.getDestinationMACAddress()))   return false;\n  if (action == FirewallRule.FirewallAction.DROP) {\n    if (!MacAddress.NONE.equals(this.dl_dst)) {\n      adp.drop.setExact(MatchField.ETH_DST,this.dl_dst);\n    }\n  }\n else {\n    if (!MacAddress.NONE.equals(this.dl_dst)) {\n      adp.allow.setExact(MatchField.ETH_DST,this.dl_dst);\n    }\n  }\n  if (any_dl_type == false) {\n    if (dl_type.equals(EthType.ARP)) {\n      if (packet.getEtherType() != EthType.ARP)       return false;\n else {\n        if (action == FirewallRule.FirewallAction.DROP) {\n          if (!EthType.NONE.equals(this.dl_type)) {\n            adp.drop.setExact(MatchField.ETH_TYPE,this.dl_type);\n          }\n        }\n else {\n          if (!EthType.NONE.equals(this.dl_type)) {\n            adp.allow.setExact(MatchField.ETH_TYPE,this.dl_type);\n          }\n        }\n      }\n    }\n else     if (dl_type.equals(EthType.IPv4)) {\n      if (packet.getEtherType() != EthType.IPv4)       return false;\n else {\n        if (action == FirewallRule.FirewallAction.DROP) {\n          if (!IpProtocol.NONE.equals(this.nw_proto)) {\n            adp.drop.setExact(MatchField.IP_PROTO,this.nw_proto);\n          }\n        }\n else {\n          if (!IpProtocol.NONE.equals(this.nw_proto)) {\n            adp.allow.setExact(MatchField.IP_PROTO,this.nw_proto);\n          }\n        }\n        pkt_ip=(IPv4)pkt;\n        if (any_nw_src == false && !nw_src_prefix_and_mask.matches(pkt_ip.getSourceAddress()))         return false;\n        if (action == FirewallRule.FirewallAction.DROP) {\n          if (!IPv4AddressWithMask.NONE.equals(this.nw_src_prefix_and_mask)) {\n            adp.drop.setMasked(MatchField.IPV4_SRC,nw_src_prefix_and_mask);\n          }\n        }\n else {\n          if (!IPv4AddressWithMask.NONE.equals(this.nw_src_prefix_and_mask)) {\n            adp.allow.setMasked(MatchField.IPV4_SRC,nw_src_prefix_and_mask);\n          }\n        }\n        if (any_nw_dst == false && !nw_dst_prefix_and_mask.matches(pkt_ip.getDestinationAddress()))         return false;\n        if (action == FirewallRule.FirewallAction.DROP) {\n          if (!IPv4AddressWithMask.NONE.equals(this.nw_dst_prefix_and_mask)) {\n            adp.drop.setMasked(MatchField.IPV4_DST,nw_dst_prefix_and_mask);\n          }\n        }\n else {\n          if (!IPv4AddressWithMask.NONE.equals(this.nw_dst_prefix_and_mask)) {\n            adp.allow.setMasked(MatchField.IPV4_DST,nw_dst_prefix_and_mask);\n          }\n        }\n        if (any_nw_proto == false) {\n          if (nw_proto.equals(IpProtocol.TCP)) {\n            if (!pkt_ip.getProtocol().equals(IpProtocol.TCP)) {\n              return false;\n            }\n else {\n              pkt_tcp=(TCP)pkt_ip.getPayload();\n              pkt_tp_src=pkt_tcp.getSourcePort();\n              pkt_tp_dst=pkt_tcp.getDestinationPort();\n            }\n          }\n else           if (nw_proto.equals(IpProtocol.UDP)) {\n            if (!pkt_ip.getProtocol().equals(IpProtocol.UDP)) {\n              return false;\n            }\n else {\n              pkt_udp=(UDP)pkt_ip.getPayload();\n              pkt_tp_src=pkt_udp.getSourcePort();\n              pkt_tp_dst=pkt_udp.getDestinationPort();\n            }\n          }\n else           if (nw_proto.equals(IpProtocol.ICMP)) {\n            if (!pkt_ip.getProtocol().equals(IpProtocol.ICMP)) {\n              return false;\n            }\n else {\n            }\n          }\n          if (action == FirewallRule.FirewallAction.DROP) {\n            if (!IpProtocol.NONE.equals(this.nw_proto)) {\n              adp.drop.setExact(MatchField.IP_PROTO,this.nw_proto);\n            }\n          }\n else {\n            if (!IpProtocol.NONE.equals(this.nw_proto)) {\n              adp.allow.setExact(MatchField.IP_PROTO,this.nw_proto);\n            }\n          }\n          if (pkt_tcp != null || pkt_udp != null) {\n            if (tp_src.getPort() != 0 && tp_src.getPort() != pkt_tp_src.getPort()) {\n              return false;\n            }\n            if (action == FirewallRule.FirewallAction.DROP) {\n              if (pkt_tcp != null) {\n                if (!TransportPort.NONE.equals(this.tp_src)) {\n                  adp.drop.setExact(MatchField.TCP_SRC,this.tp_src);\n                }\n              }\n else {\n                if (!TransportPort.NONE.equals(this.tp_src)) {\n                  adp.drop.setExact(MatchField.UDP_SRC,this.tp_src);\n                }\n              }\n            }\n else {\n              if (pkt_tcp != null) {\n                if (!TransportPort.NONE.equals(this.tp_src)) {\n                  adp.allow.setExact(MatchField.TCP_SRC,this.tp_src);\n                }\n              }\n else {\n                if (!TransportPort.NONE.equals(this.tp_src)) {\n                  adp.allow.setExact(MatchField.UDP_SRC,this.tp_src);\n                }\n              }\n            }\n            if (tp_dst.getPort() != 0 && tp_dst.getPort() != pkt_tp_dst.getPort()) {\n              return false;\n            }\n            if (action == FirewallRule.FirewallAction.DROP) {\n              if (pkt_tcp != null) {\n                if (!TransportPort.NONE.equals(this.tp_dst)) {\n                  adp.drop.setExact(MatchField.TCP_DST,this.tp_dst);\n                }\n              }\n else {\n                if (!TransportPort.NONE.equals(this.tp_dst)) {\n                  adp.drop.setExact(MatchField.UDP_DST,this.tp_dst);\n                }\n              }\n            }\n else {\n              if (pkt_tcp != null) {\n                if (!TransportPort.NONE.equals(this.tp_dst)) {\n                  adp.allow.setExact(MatchField.TCP_DST,this.tp_dst);\n                }\n              }\n else {\n                if (!TransportPort.NONE.equals(this.tp_dst)) {\n                  adp.allow.setExact(MatchField.UDP_DST,this.tp_dst);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n else {\n      return false;\n    }\n  }\n  if (action == FirewallRule.FirewallAction.DROP) {\n    if (!EthType.NONE.equals(this.dl_type)) {\n      adp.drop.setExact(MatchField.ETH_TYPE,this.dl_type);\n    }\n  }\n else {\n    if (!EthType.NONE.equals(this.dl_type)) {\n      adp.allow.setExact(MatchField.ETH_TYPE,this.dl_type);\n    }\n  }\n  return true;\n}\n", "nl": "Checks if this rule is a match for the incoming packet's MatchFields"}
{"code": "public boolean isResizeInProgress(){\n  return resizeStarted;\n}\n", "nl": "Returns whether actual resizing has taken place."}
{"code": "@Override public AsyncFuture<Void> transform(Void result) throws Exception {\n  return sink.stop();\n}\n", "nl": "Stop the underlying sink."}
{"code": "protected Boolean isMaxMessageSizeExceeded() throws MessagingException {\n  Boolean isMaxMessageSizeExceeded;\n  if (null == (isMaxMessageSizeExceeded=isMaxMessageSizeExceededBasic())) {\n    updateMaxMessageSizeExceeded();\n    return isMaxMessageSizeExceeded();\n  }\n  return isMaxMessageSizeExceeded;\n}\n", "nl": "Returns the maxMessageSizeExceeded, lazily initialised as required."}
{"code": "@Override public int size(){\n  return super.size() + ((this.buffer == null) ? 0 : this.buffer.size());\n}\n", "nl": "the number of BLOBs in the heap"}
{"code": "@Override public int compareTo(BerkeleyLocation that){\n  if (this == that || this.equals(that))   return 0;\n  if (this.getStart() != null && that.getStart() != null) {\n    if (this.getStart() < that.getStart())     return -1;\n    if (this.getStart() > that.getStart())     return 1;\n  }\n  if (this.getEnd() != null && that.getEnd() != null) {\n    if (this.getEnd() < that.getEnd())     return -1;\n    if (this.getEnd() > that.getEnd())     return 1;\n  }\n  if (this.getEnvelopeStart() != null && that.getEnvelopeStart() != null) {\n    if (this.getEnvelopeStart() < that.getEnvelopeStart())     return -1;\n    if (this.getEnvelopeStart() > that.getEnvelopeStart())     return 1;\n  }\n  if (this.getEnvelopeEnd() != null && that.getEnvelopeEnd() != null) {\n    if (this.getEnvelopeEnd() < that.getEnvelopeEnd())     return -1;\n    if (this.getEnvelopeEnd() > that.getEnvelopeEnd())     return 1;\n  }\n  if (this.getHmmStart() != null && that.getHmmStart() != null) {\n    if (this.getHmmStart() < that.getHmmStart())     return -1;\n    if (this.getHmmStart() > that.getHmmStart())     return 1;\n  }\n  if (this.getHmmEnd() != null && that.getHmmEnd() != null) {\n    if (this.getHmmEnd() < that.getHmmEnd())     return -1;\n    if (this.getHmmEnd() > that.getHmmEnd())     return 1;\n  }\n  if (this.getScore() != null && that.getScore() != null) {\n    if (this.getScore() < that.getScore())     return -1;\n    if (this.getScore() > that.getScore())     return 1;\n  }\n  if (this.geteValue() != null && that.geteValue() != null) {\n    if (this.geteValue() < that.geteValue())     return -1;\n    if (this.geteValue() > that.geteValue())     return 1;\n  }\n  throw new IllegalStateException(\"Trying to compare a BerkeleyLocation that has no state.  This: \" + this + \"\\n\\nThat: \"+ that);\n}\n", "nl": "Attempts to sort as follows: <p/> If equal (== or .equals) return 0. Sort on start position Sort on end position Sort on envelope start Sort on envelope end Sort on HmmStart Sort on HmmEnd Sort on Score Sort on Evalue"}
{"code": "boolean isReadyForDisplay(){\n  if (mRootToken.waitingToShow && mService.mAppTransition.isTransitionSet()) {\n    return false;\n  }\n  return mHasSurface && mPolicyVisibility && !mDestroying&& ((!mAttachedHidden && mViewVisibility == View.VISIBLE && !mRootToken.hidden) || mWinAnimator.mAnimation != null || ((mAppToken != null) && (mAppToken.mAppAnimator.animation != null)));\n}\n", "nl": "Like isOnScreen(), but we don't return true if the window is part of a transition that has not yet been started."}
{"code": "@Override public Document build(String uri) throws ParsingException, ValidityException, IOException {\n  return build(new InputSource(uri));\n}\n", "nl": "Parse from URI."}
{"code": "private void publishDomain(String domainName,String requestingHostName){\n  DomainResource domain=loadByForeignKey(DomainResource.class,domainName,clock.nowUtc());\n  try {\n    Update update=new Update(toAbsoluteName(findTldFromName(domainName)));\n    update.delete(toAbsoluteName(domainName),Type.ANY);\n    if (domain != null) {\n      deleteSubordinateHostAddressSet(domain,requestingHostName,update);\n      if (domain.shouldPublishToDns()) {\n        addInBailiwickNameServerSet(domain,update);\n        update.add(makeNameServerSet(domain));\n        update.add(makeDelegationSignerSet(domain));\n      }\n    }\n    Message response=transport.send(update);\n    verify(response.getRcode() == Rcode.NOERROR,\"DNS server failed domain update for '%s' rcode: %s\",domainName,Rcode.string(response.getRcode()));\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"publishDomain failed: \" + domainName,e);\n  }\n}\n", "nl": "Publish the domain, while keeping tracking of which host refresh quest triggered this domain refresh. Delete the requesting host in addition to all subordinate hosts."}
{"code": "@DSComment(\"Package priviledge\") @DSBan(DSCat.DEFAULT_MODIFIER) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:57:21.316 -0500\",hash_original_method=\"165B5BC520C58D38E1ED3303B481AD06\",hash_generated_method=\"31A30F6585BFDDD1EB1245A8A7351220\") final boolean isOwnedBy(AbstractQueuedSynchronizer sync){\n  return sync == AbstractQueuedSynchronizer.this;\n}\n", "nl": "Returns true if this condition was created by the given synchronization object."}
{"code": "public void clear(float r,float g,float b,float a,double depth){\n  if (this.geometryBuffer != null) {\n    this.geometryBuffer.bindFramebuffer(false);\n    GL11.glClearColor(r,g,b,a);\n    GL11.glClearDepth(depth);\n    GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT | GL11.GL_COLOR_BUFFER_BIT);\n  }\n}\n", "nl": "Clears the buffer <p><b>Note:</b> Binds the FBO"}
{"code": "private String highlightField(Query query,String fieldName,String text) throws IOException, InvalidTokenOffsetsException {\n  TokenStream tokenStream=new MockAnalyzer(random(),MockTokenizer.SIMPLE,true,MockTokenFilter.ENGLISH_STOPSET).tokenStream(fieldName,text);\n  SimpleHTMLFormatter formatter=new SimpleHTMLFormatter();\n  MyQueryScorer scorer=new MyQueryScorer(query,fieldName,FIELD_NAME);\n  Highlighter highlighter=new Highlighter(formatter,scorer);\n  highlighter.setTextFragmenter(new SimpleFragmenter(Integer.MAX_VALUE));\n  String rv=highlighter.getBestFragments(tokenStream,text,1,\"(FIELD TEXT TRUNCATED)\");\n  return rv.length() == 0 ? text : rv;\n}\n", "nl": "This method intended for use with <tt>testHighlightingWithDefaultField()</tt>"}
{"code": "public String toString(){\n  if (the_symbol() != null)   return super.toString() + the_symbol();\n else   return super.toString() + \"$$MISSING-SYMBOL$$\";\n}\n", "nl": "Convert to a string."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase SRuntimePackage.EXECUTION_EVENT__RAISED:\n    return raised != RAISED_EDEFAULT;\ncase SRuntimePackage.EXECUTION_EVENT__SCHEDULED:\n  return scheduled != SCHEDULED_EDEFAULT;\ncase SRuntimePackage.EXECUTION_EVENT__DIRECTION:\nreturn direction != DIRECTION_EDEFAULT;\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isEmpty(){\n  return remaining() == 0L;\n}\n", "nl": "Is buffer empty"}
{"code": "private List<?> checkValueAndIndex(CompositeData value){\n  checkValueType(value);\n  List<?> index=internalCalculateIndex(value);\n  if (dataMap.containsKey(index)) {\n    throw new KeyAlreadyExistsException(\"Argument value's index, calculated according to this TabularData \" + \"instance's tabularType, already refers to a value in this table.\");\n  }\n  return index;\n}\n", "nl": "Checks if the specified value can be put (ie added) in this <tt>TabularData</tt> instance (ie value is not null, its composite type is equal to row type, and its index is not already used), and returns the index calculated for this value. The index is a List, and not an array, so that an index.equals(otherIndex) call will actually compare contents, not just the objects references as is done for an array object."}
{"code": "public void test_max_uses_ORDER_BY_not_GT(){\n  final BigdataValueFactory f=BigdataValueFactoryImpl.getInstance(getName());\n  final IVariable<IV> org=Var.var(\"org\");\n  final IVariable<IV> auth=Var.var(\"auth\");\n  final IVariable<IV> book=Var.var(\"book\");\n  final IVariable<IV> lprice=Var.var(\"lprice\");\n  final IConstant<String> org1=new Constant<String>(\"org1\");\n  final IConstant<String> org2=new Constant<String>(\"org2\");\n  final IConstant<String> auth1=new Constant<String>(\"auth1\");\n  final TermId tid1=new TermId<BigdataValue>(VTE.LITERAL,1);\n  tid1.setValue(f.createLiteral(\"auth2\"));\n  final IConstant<IV> auth2=new Constant<IV>(tid1);\n  final IConstant<String> auth3=new Constant<String>(\"auth3\");\n  final IConstant<String> book1=new Constant<String>(\"book1\");\n  final IConstant<String> book2=new Constant<String>(\"book2\");\n  final IConstant<String> book3=new Constant<String>(\"book3\");\n  final IConstant<String> book4=new Constant<String>(\"book4\");\n  final IConstant<XSDNumericIV<BigdataLiteral>> price5=new Constant<XSDNumericIV<BigdataLiteral>>(new XSDNumericIV<BigdataLiteral>(5));\n  final IConstant<XSDNumericIV<BigdataLiteral>> price7=new Constant<XSDNumericIV<BigdataLiteral>>(new XSDNumericIV<BigdataLiteral>(7));\n  final IConstant<XSDNumericIV<BigdataLiteral>> price9=new Constant<XSDNumericIV<BigdataLiteral>>(new XSDNumericIV<BigdataLiteral>(9));\n  final IBindingSet data[]=new IBindingSet[]{new ListBindingSet(new IVariable<?>[]{org,auth,book,lprice},new IConstant[]{org1,auth1,book1,price9}),new ListBindingSet(new IVariable<?>[]{org,auth,book,lprice},new IConstant[]{org1,auth1,book2,price5}),new ListBindingSet(new IVariable<?>[]{org,auth,book,lprice},new IConstant[]{org1,auth2,book3,auth2}),new ListBindingSet(new IVariable<?>[]{org,auth,book,lprice},new IConstant[]{org2,auth3,book4,price7})};\n  price9.get().setValue(f.createLiteral(\"9\",XSD.INT));\n  price5.get().setValue(f.createLiteral(\"5\",XSD.INT));\n  price7.get().setValue(f.createLiteral(\"7\",XSD.INT));\n  final MAX op=new MAX(false,lprice);\n  assertFalse(op.isDistinct());\n  assertFalse(op.isWildcard());\n  op.reset();\n  for (  IBindingSet bs : data) {\n    op.get(bs);\n  }\n  assertEquals(price9.get(),op.done());\n}\n", "nl": "MAX is defined in terms of SPARQL <code>ORDER BY</code> rather than <code>GT</code>."}
{"code": "protected void walk(Node rootNode,CssSelector cssSelector,List<Node> result){\n  CssSelector previousCssSelector=cssSelector.getPrevCssSelector();\n  Combinator combinator=previousCssSelector != null ? previousCssSelector.getCombinator() : Combinator.DESCENDANT;\nswitch (combinator) {\ncase DESCENDANT:\n    JoddArrayList<Node> nodes=new JoddArrayList<>();\n  int childCount=rootNode.getChildNodesCount();\nfor (int i=0; i < childCount; i++) {\n  nodes.add(rootNode.getChild(i));\n}\nwalkDescendantsIteratively(nodes,cssSelector,result);\nbreak;\ncase CHILD:\nchildCount=rootNode.getChildNodesCount();\nfor (int i=0; i < childCount; i++) {\nNode node=rootNode.getChild(i);\nselectAndAdd(node,cssSelector,result);\n}\nbreak;\ncase ADJACENT_SIBLING:\nNode node=rootNode.getNextSiblingElement();\nif (node != null) {\nselectAndAdd(node,cssSelector,result);\n}\nbreak;\ncase GENERAL_SIBLING:\nnode=rootNode;\nwhile (true) {\nnode=node.getNextSiblingElement();\nif (node == null) {\nbreak;\n}\nselectAndAdd(node,cssSelector,result);\n}\nbreak;\n}\n}\n", "nl": "Finds nodes in the tree that matches single selector."}
{"code": "public static String md5Hash(byte[] data) throws NoSuchAlgorithmException {\n  return md5Hash(data,data.length);\n}\n", "nl": "Returns MD5 hash of given byte array."}
{"code": "@Override protected void createLabels(){\n  this.addLabel(\"(PDF)\");\n}\n", "nl": "Create labels for the start and end of the path."}
{"code": "public static <K,V,T>EntryProcessor<K,V,T> wrap(GridKernalContext ctx,@Nullable EntryProcessor<K,V,T> proc){\n  if (proc == null || proc instanceof EntryProcessorResourceInjectorProxy)   return proc;\n  GridResourceProcessor rsrcProcessor=ctx.resource();\n  return rsrcProcessor.isAnnotationsPresent(null,proc,GridResourceIoc.AnnotationSet.ENTRY_PROCESSOR) ? new EntryProcessorResourceInjectorProxy<>(proc) : proc;\n}\n", "nl": "Wraps EntryProcessor if needed."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-18 21:46:35.919 -0400\",hash_original_method=\"048650AFF94B01A571A17F813CE8142B\",hash_generated_method=\"570265486E6BAC8556276C3D4D46AB4B\") public boolean dismissPopupMenus(){\n  boolean result=hideOverflowMenu();\n  result|=hideSubMenus();\n  return result;\n}\n", "nl": "Dismiss all popup menus - overflow and submenus."}
{"code": "public void write(AnnotationsWriter writer) throws IOException {\n  writer.constValueIndex(getValue());\n}\n", "nl": "Writes the value."}
{"code": "public String replaceExactlyOnce(String original){\n  Matcher matcher=searchPattern.matcher(original);\n  if (!matcher.find()) {\n    String msg=\"Pattern not found!\\nTemplate:\" + source + \"\\nPattern:\\n\"+ searchPattern;\n    throw new IllegalStateException(msg);\n  }\n  StringBuffer sb=new StringBuffer();\n  matcher.appendReplacement(sb,replacement);\n  if (matcher.find()) {\n    String msg=\"Pattern found more than once!\\nTemplate:\" + source + \"\\nPattern:\\n\"+ searchPattern;\n    throw new IllegalStateException(msg);\n  }\n  matcher.appendTail(sb);\n  return sb.toString();\n}\n", "nl": "Applies the replacement onto this string. Throws exceptions if the searchString ins being found not at all or more than once."}
{"code": "private JPEGImageIO(){\n}\n", "nl": "Prevent instance creation."}
{"code": "@Override final public boolean isSparql10(){\n  return false;\n}\n", "nl": "Always returns <code>false</code> (response is ignored)."}
{"code": "public static boolean hasNoExplicitBound(final AnnotatedTypeMirror wildcard){\n  return ((Type.WildcardType)wildcard.getUnderlyingType()).isUnbound();\n}\n", "nl": "This method identifies wildcard types that are unbound."}
{"code": "public static void registerMetadata(MetadataRegistry registry){\n  if (registry.isRegistered(KEY)) {\n    return;\n  }\n  ElementCreator builder=registry.build(KEY).setContentRequired(false);\n}\n", "nl": "Registers the metadata for this element."}
{"code": "public BusinessObjectData createBusinessObjectDataFromEntity(BusinessObjectDataEntity businessObjectDataEntity){\n  return createBusinessObjectDataFromEntity(businessObjectDataEntity,false);\n}\n", "nl": "Creates the business object data from the persisted entity."}
{"code": "public InvalidityDate(byte[] encoding) throws IOException {\n  super(encoding);\n  date=(Date)ASN1.decode(encoding);\n}\n", "nl": "Constructs the object on the base of its encoded form."}
{"code": "public NameAlreadyBoundException(){\n  super();\n}\n", "nl": "Constructs a new instance of NameAlreadyBoundException. All fields are set to null;"}
{"code": "public static void copyFromTo(final Plan in,Plan out){\n  out.getPlanElements().clear();\n  out.setScore(in.getScore());\n  out.setType(in.getType());\n  for (  PlanElement pe : in.getPlanElements()) {\n    if (pe instanceof Activity) {\n      out.getPlanElements().add(createActivity((Activity)pe));\n    }\n else     if (pe instanceof Leg) {\n      out.getPlanElements().add(createLeg((Leg)pe));\n    }\n else {\n      throw new IllegalArgumentException(\"unrecognized plan element type discovered\");\n    }\n  }\n}\n", "nl": "loads a copy of an existing plan, but keeps the person reference"}
{"code": "public boolean update(double value){\n  boolean changed=false;\n  if (value < min) {\n    min=value;\n    changed=true;\n  }\n  if (value > max) {\n    max=value;\n    changed=true;\n  }\n  return changed;\n}\n", "nl": "Updates the min and the max with a new value."}
{"code": "private List<Entity> extractHashtagsWithIndices(final String text,final boolean checkUrlOverlap){\n  if (text == null || text.length() == 0)   return Collections.emptyList();\n  boolean found=false;\n  for (  final char c : text.toCharArray()) {\n    if (c == '#' || c == FULLWIDTH_NUMBER_SIGN) {\n      found=true;\n      break;\n    }\n  }\n  if (!found)   return Collections.emptyList();\n  final ArrayList<Entity> extracted=new ArrayList<Entity>();\n  final Matcher matcher=Regex.VALID_HASHTAG.matcher(text);\n  while (matcher.find()) {\n    final String after=text.substring(matcher.end());\n    if (!Regex.INVALID_HASHTAG_MATCH_END.matcher(after).find()) {\n      extracted.add(new Entity(matcher,Entity.Type.HASHTAG,Regex.VALID_HASHTAG_GROUP_TAG));\n    }\n  }\n  if (checkUrlOverlap) {\n    final List<Entity> urls=extractURLsWithIndices(text);\n    if (!urls.isEmpty()) {\n      extracted.addAll(urls);\n      removeOverlappingEntities(extracted);\n      final Iterator<Entity> it=extracted.iterator();\n      while (it.hasNext()) {\n        final Entity entity=it.next();\n        if (entity.getType() != Entity.Type.HASHTAG) {\n          it.remove();\n        }\n      }\n    }\n  }\n  return extracted;\n}\n", "nl": "Extract #hashtag references from Tweet text."}
{"code": "public final void init(byte[] params) throws IOException {\n  if (this.initialized)   throw new IOException(\"already initialized\");\n  paramSpi.engineInit(params);\n  this.initialized=true;\n}\n", "nl": "Imports the specified parameters and decodes them according to the primary decoding format for parameters. The primary decoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists."}
{"code": "public boolean isSetHostname(){\n  return this.hostname != null;\n}\n", "nl": "Returns true if field hostname is set (has been assigned a value) and false otherwise"}
{"code": "public void reply(SerialReply r){\n  InputBits.instance().markChanges(r);\n}\n", "nl": "Process a reply to a poll of Sensors of one panel node"}
{"code": "public boolean isSubtype(ObjectType type,ObjectType possibleSupertype) throws ClassNotFoundException {\n  if (DEBUG_QUERIES) {\n    System.out.println(\"isSubtype: check \" + type + \" subtype of \"+ possibleSupertype);\n  }\n  if (type.equals(possibleSupertype)) {\n    if (DEBUG_QUERIES) {\n      System.out.println(\"  ==> yes, types are same\");\n    }\n    return true;\n  }\n  ClassDescriptor typeClassDescriptor=DescriptorFactory.getClassDescriptor(type);\n  ClassDescriptor possibleSuperclassClassDescriptor=DescriptorFactory.getClassDescriptor(possibleSupertype);\n  return isSubtype(typeClassDescriptor,possibleSuperclassClassDescriptor);\n}\n", "nl": "Determine whether or not a given ObjectType is a subtype of another. Throws ClassNotFoundException if the question cannot be answered definitively due to a missing class."}
{"code": "public void changeAbbrWinStreaks(String oldAbbr,String newAbbr){\n  if (longestWinStreak.getTeam().equals(oldAbbr)) {\n    longestWinStreak.changeAbbr(newAbbr);\n  }\n  if (yearStartLongestWinStreak.getTeam().equals(oldAbbr)) {\n    yearStartLongestWinStreak.changeAbbr(newAbbr);\n  }\n}\n", "nl": "Change the team abbr of the lognest win streak if the user changed it"}
{"code": "@POST @Path(\"setting\") @ZeppelinApi public Response newSettings(String message){\n  try {\n    NewInterpreterSettingRequest request=gson.fromJson(message,NewInterpreterSettingRequest.class);\n    if (request == null) {\n      return new JsonResponse<>(Status.BAD_REQUEST).build();\n    }\n    Properties p=new Properties();\n    p.putAll(request.getProperties());\n    InterpreterSetting interpreterSetting=interpreterFactory.createNewSetting(request.getName(),request.getGroup(),request.getDependencies(),request.getOption(),p);\n    logger.info(\"new setting created with {}\",interpreterSetting.getId());\n    return new JsonResponse<>(Status.CREATED,\"\",interpreterSetting).build();\n  }\n catch (  InterpreterException|IOException e) {\n    logger.error(\"Exception in InterpreterRestApi while creating \",e);\n    return new JsonResponse<>(Status.NOT_FOUND,e.getMessage(),ExceptionUtils.getStackTrace(e)).build();\n  }\n}\n", "nl": "Add new interpreter setting"}
{"code": "public int capacity(){\n  return data.length;\n}\n", "nl": "Gets initial capacity of the list."}
{"code": "public void clear(){\n  absoluteReadIndex=0;\n  relativeReadIndex=0;\n  relativeWriteIndex=0;\n  queueSize=0;\n}\n", "nl": "Clears the queue."}
{"code": "@Override public void addComment(String comment){\n}\n", "nl": "Adds a comment to the current element of the DOM Document."}
{"code": "public WhitenedZCA(){\n  this(50);\n}\n", "nl": "Creates a new WhitenedZCA transform that uses up to 50 dimensions for the transformed space. This may not be optimal for any given dataset."}
{"code": "public static boolean startDocumentPrint(int type,int Record_ID,boolean IsDirectPrint){\n  return startDocumentPrint(type,Record_ID,null,-1,IsDirectPrint);\n}\n", "nl": "Start Document Print for Type. Called also directly from ProcessDialog, VInOutGen, VInvoiceGen, VPayPrint"}
{"code": "public Vector<int[]> computeStartAndEndTimePairs(boolean[] sourceValid,boolean[] destValid,int k){\n  int startTime=0;\n  int endTime=0;\n  boolean lookingForStart=true;\n  Vector<int[]> startAndEndTimePairs=new Vector<int[]>();\n  for (int t=0; t < destValid.length; t++) {\n    if (lookingForStart) {\n      if (destValid[t]) {\n        if (t - startTime < k) {\n          continue;\n        }\n else {\n          if (sourceValid[t - 1]) {\n            endTime=t;\n            lookingForStart=false;\n            if (t == destValid.length - 1) {\n              int[] timePair=new int[2];\n              timePair[0]=startTime;\n              timePair[1]=endTime;\n              startAndEndTimePairs.add(timePair);\n            }\n          }\n else {\n            startTime++;\n          }\n        }\n      }\n else {\n        startTime=t + 1;\n      }\n    }\n else {\n      boolean terminateSequence=false;\n      if (destValid[t] && sourceValid[t - 1]) {\n        endTime=t;\n      }\n else {\n        terminateSequence=true;\n      }\n      if (t == destValid.length - 1) {\n        terminateSequence=true;\n      }\n      if (terminateSequence) {\n        int[] timePair=new int[2];\n        timePair[0]=startTime;\n        timePair[1]=endTime;\n        startAndEndTimePairs.add(timePair);\n        lookingForStart=true;\n        if (!destValid[t]) {\n          startTime=t + 1;\n        }\n else {\n          startTime=t - k + 1;\n        }\n      }\n    }\n  }\n  return startAndEndTimePairs;\n}\n", "nl": "This method copied from TransferEntropyCommon (since we may delete this soon) to test simple cases of TransferEntropyCalculatorViaCondMutualInfo.computeStartAndEndTimePairs() (i.e. where l, l_tau and delay are 1.)"}
{"code": "public void addHttpSessionToken(String site,String token){\n  if (!site.contains(\":\")) {\n    site=site + (\":80\");\n  }\n  HttpSessionTokensSet siteTokens=sessionTokens.get(site);\n  if (siteTokens == null) {\n    siteTokens=new HttpSessionTokensSet();\n    sessionTokens.put(site,siteTokens);\n  }\n  log.info(\"Added new session token for site '\" + site + \"': \"+ token);\n  siteTokens.addToken(token);\n  unmarkRemovedDefaultSessionToken(site,token);\n}\n", "nl": "Adds a new session token for a particular site."}
{"code": "private static String splitStringLeftParenthesis(String name){\n  String[] splitname=name.split(\"-\");\n  if (splitname.length > 1 && splitname[1].startsWith(\"(\")) {\n    return splitname[0].trim();\n  }\n  return name.trim();\n}\n", "nl": "Splits a string if there's a hyphen followed by a left parenthesis \"-(\"."}
{"code": "public float length(){\n  float x=this.m[0];\n  float y=this.m[1];\n  float z=this.m[2];\n  float result=(float)Math.sqrt(x * x + y * y + z * z);\n  return result;\n}\n", "nl": "\\brief Returns: length( this )"}
{"code": "public void commit(){\n  info(\"COMMITting Solr index changes to \" + solrUrl + \"..\");\n  doGet(appendParam(solrUrl.toString(),\"commit=true\"));\n}\n", "nl": "Does a simple commit operation"}
{"code": "private boolean casHead(HeadIndex<K,V> cmp,HeadIndex<K,V> val){\n  return UNSAFE.compareAndSwapObject(this,headOffset,cmp,val);\n}\n", "nl": "compareAndSet head node"}
{"code": "public long nextSetBit(long index){\n  assert index >= 0 && index < numBits : \"index=\" + index + \", numBits=\"+ numBits;\n  int i=(int)(index >> 6);\n  long word=bits[i] >> index;\n  if (word != 0) {\n    return index + Long.numberOfTrailingZeros(word);\n  }\n  while (++i < numWords) {\n    word=bits[i];\n    if (word != 0) {\n      return (i << 6) + Long.numberOfTrailingZeros(word);\n    }\n  }\n  return -1;\n}\n", "nl": "Returns the index of the first set bit starting at the index specified. -1 is returned if there are no more set bits."}
{"code": "public static void mediumText(TextView textView){\n  highlightText(textView,R.string.wire__typeface__regular);\n}\n", "nl": "Will make all sections of the text in a TextView which have [[ ]] around them medium font. For example \"Here [[we]] are [[now]].\" would make \"we\" and \"now\" medium."}
{"code": "@Override public void registerPersistentStore(String storeName,Scope scope) throws SyncException {\n  registerStore(storeName,scope);\n}\n", "nl": "Persistent stores are not actually persistent in the mock sync service"}
{"code": "public SelectionOpacityIcon(DrawingEditor editor,AttributeKey<Double> opacityKey,AttributeKey<Color> fillColorKey,@Nullable AttributeKey<Color> strokeColorKey,URL imageLocation,Shape fillShape,Shape strokeShape){\n  super(imageLocation);\n  this.editor=editor;\n  this.opacityKey=opacityKey;\n  this.fillColorKey=fillColorKey;\n  this.strokeColorKey=strokeColorKey;\n  this.fillShape=fillShape;\n  this.strokeShape=strokeShape;\n}\n", "nl": "Creates a new instance."}
{"code": "private ConversionUtil(){\n}\n", "nl": "This class is not meant to be instantiated."}
{"code": "public void draw(Canvas c,Rect bounds){\n  final RectF arcBounds=mTempBounds;\n  arcBounds.set(bounds);\n  arcBounds.inset(mStrokeInset,mStrokeInset);\n  final float startAngle=(mStartTrim + mRotation) * 360;\n  final float endAngle=(mEndTrim + mRotation) * 360;\n  float sweepAngle=endAngle - startAngle;\n  mPaint.setColor(mColors[mColorIndex]);\n  c.drawArc(arcBounds,startAngle,sweepAngle,false,mPaint);\n  drawTriangle(c,startAngle,sweepAngle,bounds);\n  if (mAlpha < 255) {\n    mCirclePaint.setColor(mBackgroundColor);\n    mCirclePaint.setAlpha(255 - mAlpha);\n    c.drawCircle(bounds.exactCenterX(),bounds.exactCenterY(),bounds.width() / 2,mCirclePaint);\n  }\n}\n", "nl": "Draw the progress spinner"}
{"code": "synchronized private void initView(final ILocalBTreeView view){\n  if (view == null) {\n    throw new AssertionError(\"View not found? \" + this);\n  }\n  if (initView) {\n    return;\n  }\n{\n    long npartitions;\n    try {\n      final IMetadataIndex mdi=resourceManager.getFederation().getMetadataIndex(indexMetadata.getName(),commitTime);\n      if (mdi == null) {\n        log.warn(\"No metadata index: running in test harness?\");\n        npartitions=1L;\n      }\n else {\n        npartitions=mdi.rangeCount();\n        if (npartitions == 0) {\n          log.error(\"No partitions? name=\" + indexMetadata.getName());\n        }\n      }\n    }\n catch (    Throwable t) {\n      if (InnerCause.isInnerCause(t,InterruptedException.class)) {\n        throw new RuntimeException(t);\n      }\n      log.error(\"name=\" + indexMetadata.getName(),t);\n      npartitions=-1L;\n    }\n    this.partitionCount=npartitions;\n  }\n{\n    final int accelerateSplitThreshold=resourceManager.accelerateSplitThreshold;\n    if (accelerateSplitThreshold == 0 || partitionCount > accelerateSplitThreshold) {\n      this.adjustedNominalShardSize=resourceManager.nominalShardSize;\n    }\n else {\n      final double d=(double)partitionCount / accelerateSplitThreshold;\n      this.adjustedNominalShardSize=(long)(resourceManager.nominalShardSize * d);\n      if (log.isInfoEnabled())       log.info(\"npartitions=\" + partitionCount + \", discount=\"+ d+ \", threshold=\"+ accelerateSplitThreshold+ \", adjustedNominalShardSize=\"+ this.adjustedNominalShardSize+ \", nominalShardSize=\"+ resourceManager.nominalShardSize);\n    }\n  }\n  this.rangeCount=view.rangeCount();\n  this.percentOfSplit=super.sumSegBytes / (double)adjustedNominalShardSize;\n  this.tailSplit=this.percentOfSplit > resourceManager.percentOfSplitThreshold && super.percentTailSplits > resourceManager.tailSplitThreshold;\n  initView=true;\n}\n", "nl": "Initialize additional data with higher latency (range count, #of index partitions, the adjusted split handler, etc.)."}
{"code": "int functionSub(int position){\n  return (position / (maxArity + 1)) * (maxArity + 1);\n}\n", "nl": "Computation shared by both function(position, genome) methods. Returns function position that corresponds to the given position."}
{"code": "public void signAssertion(Document document,String signAlgorithm,String digestAlgorithm,X509Certificate cert,PrivateKey key) throws CertificateException, FileNotFoundException, NoSuchAlgorithmException, InvalidKeySpecException, MarshalException, XMLSignatureException, IOException {\n  try {\n    if (Thread.currentThread().getContextClassLoader() == null) {\n      Thread.currentThread().setContextClassLoader(getClass().getClassLoader());\n    }\n    setIDAttribute(document);\n    XPath xpath=XPathFactory.newInstance().newXPath();\n    XPathExpression expr=xpath.compile(\"//*[local-name()='Assertion']/@ID\");\n    NodeList nlURIs=(NodeList)expr.evaluate(document,XPathConstants.NODESET);\n    String[] sigIDs=new String[nlURIs.getLength()];\n    for (int i=0; i < nlURIs.getLength(); i++) {\n      sigIDs[i]=nlURIs.item(i).getNodeValue();\n    }\n    Init.init();\n    for (    String id : sigIDs) {\n      signElement(document,id,cert,key,signAlgorithm,digestAlgorithm);\n    }\n  }\n catch (  XPathExpressionException e) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Sign assertions in SAML message"}
{"code": "public String modifyHeaderTipText(){\n  return \"When selecting on nominal attributes, removes header references to \" + \"excluded values.\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "public AddItemToCollectionAction(final String quest,final String item,int quantity){\n  this.questname=checkNotNull(quest);\n  this.item=checkNotNull(item);\n  this.quantity=quantity;\n}\n", "nl": "Creates a new AddItemToCollectionAction"}
{"code": "private String loadIsPossible(final StackType stackType){\n  if (this.noticeURL.isEmpty(stackType)) {\n    return \"stack is empty\";\n  }\n  if (this.workerQueue.remainingCapacity() == 0) {\n    return \"too many workers active: \" + this.workerQueue.size();\n  }\n  final String cautionCause=this.sb.onlineCaution();\n  if (cautionCause != null) {\n    return \"online caution: \" + cautionCause;\n  }\n  return null;\n}\n", "nl": "Checks if crawl queue has elements and new crawl will not exceed thread-limit"}
{"code": "public MBankStatementLoader(Properties ctx,int C_BankStatementLoader_ID,String trxName){\n  super(ctx,C_BankStatementLoader_ID,trxName);\n  init(null);\n}\n", "nl": "Create a Statement Loader Added for compatibility with new PO infrastructure (bug# 968136)"}
{"code": "public DateTime roundHalfEvenCopy(){\n  return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n}\n", "nl": "Rounds to the nearest whole unit of this field on a copy of this DateTime.  If halfway, the ceiling is favored over the floor only if it makes this field's value even."}
{"code": "public final void insert(Address addr1,Address addr2,Address addr3){\n  if (VM.VERIFY_ASSERTIONS)   VM.assertions._assert(!addr1.isZero());\n  if (VM.VERIFY_ASSERTIONS)   VM.assertions._assert(!addr2.isZero());\n  if (VM.VERIFY_ASSERTIONS)   VM.assertions._assert(!addr3.isZero());\n  checkTailInsert(3);\n  uncheckedTailInsert(addr1);\n  uncheckedTailInsert(addr2);\n  uncheckedTailInsert(addr3);\n}\n", "nl": "Insert an address triple into the address queue."}
{"code": "protected NativePointerObject(){\n  nativePointer=0;\n}\n", "nl": "Creates a new NativePointerObject with a <code>null</code> pointer."}
{"code": "static boolean checkLiteral(IXMLReader reader,String literal) throws IOException, XMLParseException {\n  for (int i=0; i < literal.length(); i++) {\n    if (reader.read() != literal.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Returns true if the data starts with <I>literal</I>. Enough chars are read to determine this result."}
{"code": "public NetworkBuilder<N,E> expectedEdgeCount(int expectedEdgeCount){\n  checkArgument(expectedEdgeCount >= 0,\"The expected number of edges can't be negative: %s\",expectedEdgeCount);\n  this.expectedEdgeCount=Optional.of(expectedEdgeCount);\n  return this;\n}\n", "nl": "Specifies the expected number of edges in the graph."}
{"code": "private void zzScanError(int errorCode){\n  String message;\n  try {\n    message=ZZ_ERROR_MSG[errorCode];\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    message=ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];\n  }\n  throw new Error(message);\n}\n", "nl": "Reports an error that occured while scanning. In a wellformed scanner (no or only correct usage of yypushback(int) and a match-all fallback rule) this method will only be called with things that \"Can't Possibly Happen\". If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty scanner etc.). Usual syntax/scanner level error handling should be done in error fallback rules."}
{"code": "@DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:08.621 -0500\",hash_original_method=\"36E257E69C92FC5D45CD0DCB007DB07A\",hash_generated_method=\"765263DBB9F52D22742C0677CC4C7BD4\") public ListIterator<HDR> listIterator(){\n  return hlist.listIterator(0);\n}\n", "nl": "Get an initialized iterator for my imbedded list"}
{"code": "private String computeOperationString(){\n  Type returnType=methodDoc.returnType();\n  String op=returnType.qualifiedTypeName() + \" \" + methodDoc.name()+ \"(\";\n  Parameter[] parameters=methodDoc.parameters();\n  for (int i=0; i < parameters.length; i++) {\n    if (i > 0) {\n      op+=\", \";\n    }\n    op+=parameters[i].type().toString();\n  }\n  op+=\")\" + returnType.dimension();\n  return op;\n}\n", "nl": "Computes the string representation of this method appropriate for the construction of a java.rmi.server.Operation object."}
{"code": "public boolean isMiniMapVisible(){\n  return miniMapVisible;\n}\n", "nl": "Indicates if the mini-map is currently visible"}
{"code": "private LoggingEventFieldResolver(){\n  super();\n  KEYWORD_LIST.add(LOGGER_FIELD);\n  KEYWORD_LIST.add(LEVEL_FIELD);\n  KEYWORD_LIST.add(CLASS_FIELD);\n  KEYWORD_LIST.add(FILE_FIELD);\n  KEYWORD_LIST.add(LINE_FIELD);\n  KEYWORD_LIST.add(METHOD_FIELD);\n  KEYWORD_LIST.add(MSG_FIELD);\n  KEYWORD_LIST.add(MESSAGE_FIELD);\n  KEYWORD_LIST.add(NDC_FIELD);\n  KEYWORD_LIST.add(EXCEPTION_FIELD);\n  KEYWORD_LIST.add(TIMESTAMP_FIELD);\n  KEYWORD_LIST.add(DATE_FIELD);\n  KEYWORD_LIST.add(THREAD_FIELD);\n  KEYWORD_LIST.add(PROP_FIELD);\n  KEYWORD_LIST.add(MARK_FIELD);\n  KEYWORD_LIST.add(NOTE_FIELD);\n}\n", "nl": "Create new instance."}
{"code": "protected boolean fullTopologicalPredicate(Geometry geom){\n  boolean result=prepPoly.getGeometry().covers(geom);\n  return result;\n}\n", "nl": "Computes the full topological <tt>covers</tt> predicate. Used when short-circuit tests are not conclusive."}
{"code": "public StandardPieToolTipGenerator(String labelFormat,Locale locale){\n  this(labelFormat,NumberFormat.getNumberInstance(locale),NumberFormat.getPercentInstance(locale));\n}\n", "nl": "Creates a pie tool tip generator for the specified locale."}
{"code": "public void write(String key,Bitmap bitmap){\n  if (key == null || bitmap == null) {\n    return;\n  }\nsynchronized (mDiskCacheLock) {\n    if (mDiskLruCache != null) {\n      OutputStream out=null;\n      try {\n        DiskLruCache.Snapshot snapshot=mDiskLruCache.get(key);\n        if (snapshot == null) {\n          final DiskLruCache.Editor editor=mDiskLruCache.edit(key);\n          if (editor != null) {\n            out=editor.newOutputStream(DISK_CACHE_INDEX);\n            bitmap.compress(DEFAULT_COMPRESS_FORMAT,DEFAULT_COMPRESS_QUALITY,out);\n            editor.commit();\n            out.close();\n          }\n        }\n      }\n catch (      final IOException e) {\n        Log.e(TAG,\"addBitmapToCache - \" + e);\n      }\ncatch (      Exception e) {\n        Log.e(TAG,\"addBitmapToCache - \" + e);\n      }\n finally {\n        try {\n          if (out != null) {\n            out.close();\n          }\n        }\n catch (        IOException e) {\n        }\n      }\n    }\n  }\n}\n", "nl": "Adds a bitmap to both memory and disk cache"}
{"code": "protected void parseTagContent(Element element,Reader is) throws IOException {\n  if ((HTMLComponent.SUPPORT_CSS) && (htmlC.loadCSS) && (((HTMLElement)element).getTagId() == HTMLElement.TAG_STYLE)) {\n    CSSElement addTo=CSSParser.getInstance().parseCSSSegment(is,null,htmlC,null);\n    htmlC.addToEmebeddedCSS(addTo);\n    return;\n  }\n  super.parseTagContent(element,is);\n}\n", "nl": "Overrides XMLParser.parseTagContent to enable embedded CSS segments (Style tags)"}
{"code": "protected void prepare(){\n  ProcessInfoParameter[] para=getParameter();\n  for (int i=0; i < para.length; i++) {\n    String name=para[i].getParameterName();\n    if (para[i].getParameter() == null)     ;\n else     if (name.equals(\"M_PriceList_ID\"))     p_M_PriceList_ID=para[i].getParameterAsInt();\n else     if (name.equals(\"InvoiceDocumentNo\"))     p_InvoiceDocumentNo=(String)para[i].getParameter();\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n  p_M_InOut_ID=getRecord_ID();\n}\n", "nl": "Prepare - e.g., get Parameters."}
{"code": "public APIConnectionException(String message,Throwable e){\n  super(message,e);\n}\n", "nl": "Create APIConnectionException with message and cause."}
{"code": "public JsonParser createJsonParser(String content) throws IOException, JsonParseException {\n  Reader r=new StringReader(content);\n  IOContext ctxt=_createContext(r,true);\n  if (_inputDecorator != null) {\n    r=_inputDecorator.decorate(ctxt,r);\n  }\n  return _createJsonParser(r,ctxt);\n}\n", "nl": "Method for constructing parser for parsing contens of given String."}
{"code": "public static void closeSession() throws HibernateException {\n  Session session=(Session)threadLocal.get();\n  threadLocal.set(null);\n  if (session != null) {\n    session.close();\n  }\n}\n", "nl": "Closes the single hibernate session instance."}
{"code": "public void registerSingleBiome(BiomeGenBase biome){\n  registeredSingleBiome.add(biome);\n}\n", "nl": "Registers a biome to have a chance to spawn as the only biome on a planet"}
{"code": "public OVector(int c){\n  vector=new Object[Math.max(defaultCapacity,c)];\n}\n", "nl": "Constructs a new vector with the specified capacity."}
{"code": "private void convertToRGB(float l,float a,float bstar){\n  if (l < 0) {\n    l=0;\n  }\n else   if (l > 100) {\n    l=100;\n  }\n  if (a < R[0]) {\n    a=R[0];\n  }\n else   if (a > R[1]) {\n    a=R[1];\n  }\n  if (bstar < R[2]) {\n    bstar=R[2];\n  }\n else   if (bstar > R[3]) {\n    bstar=R[3];\n  }\n  if ((lastL == l) && (lastA == a) && (lastBstar == bstar)) {\n  }\n else {\n    final int indexL=(int)l;\n    final int indexA=(int)(a - R[0]);\n    final int indexB=(int)(bstar - R[2]);\n    final Integer key=(indexL << 16) + (indexA << 8) + indexB;\n    final Integer value=cache.get(key);\n    if (value != null) {\n      final int raw=value;\n      r=((raw >> 16) & 255);\n      g=((raw >> 8) & 255);\n      b=((raw) & 255);\n    }\n else {\n      final double val1=(l + 16d) / 116d;\n      final double[] vals=new double[3];\n      vals[0]=val1 + (a / 500d);\n      vals[1]=val1;\n      vals[2]=val1 - (bstar / 200d);\n      float[] out=new float[3];\n      for (int j=0; j < 3; j++) {\n        if (vals[j] >= C3) {\n          out[j]=(float)(W[j] * vals[j] * vals[j]* vals[j]);\n        }\n else {\n          out[j]=(float)(W[j] * C1 * (vals[j] - C2));\n        }\n        if (out[j] < 0) {\n          out[j]=0;\n        }\n      }\n      out=cs.toRGB(out);\n      r=(int)(out[0] * 255);\n      g=(int)(out[1] * 255);\n      b=(int)(out[2] * 255);\n      if (r < 0) {\n        r=0;\n      }\n      if (g < 0) {\n        g=0;\n      }\n      if (b < 0) {\n        b=0;\n      }\n      if (r > 255) {\n        r=255;\n      }\n      if (g > 255) {\n        g=255;\n      }\n      if (b > 255) {\n        b=255;\n      }\n      final int raw=(r << 16) + (g << 8) + b;\n      cache.put(key,raw);\n    }\n    lastL=l;\n    lastA=a;\n    lastBstar=bstar;\n  }\n}\n", "nl": "convert numbers to rgb values"}
{"code": "@DSSink({DSSinkKind.SYSTEM_SETTINGS}) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:58:41.491 -0500\",hash_original_method=\"F4F7246DD691380E13C09E794F3AA7A8\",hash_generated_method=\"C92D4A1A16E4C726EA5C5C5E2F1389CD\") public static String gsm8BitUnpackedToString(byte[] data,int offset,int length,String characterset){\n  boolean isMbcs=false;\n  Charset charset=null;\n  ByteBuffer mbcsBuffer=null;\n  if (!TextUtils.isEmpty(characterset) && !characterset.equalsIgnoreCase(\"us-ascii\") && Charset.isSupported(characterset)) {\n    isMbcs=true;\n    charset=Charset.forName(characterset);\n    mbcsBuffer=ByteBuffer.allocate(2);\n  }\n  String languageTableToChar=sLanguageTables[0];\n  String shiftTableToChar=sLanguageShiftTables[0];\n  StringBuilder ret=new StringBuilder(length);\n  boolean prevWasEscape=false;\n  for (int i=offset; i < offset + length; i++) {\n    int c=data[i] & 0xff;\n    if (c == 0xff) {\n      break;\n    }\n else     if (c == GSM_EXTENDED_ESCAPE) {\n      if (prevWasEscape) {\n        ret.append(' ');\n        prevWasEscape=false;\n      }\n else {\n        prevWasEscape=true;\n      }\n    }\n else {\n      if (prevWasEscape) {\n        char shiftChar=shiftTableToChar.charAt(c);\n        if (shiftChar == ' ') {\n          ret.append(languageTableToChar.charAt(c));\n        }\n else {\n          ret.append(shiftChar);\n        }\n      }\n else {\n        if (!isMbcs || c < 0x80 || i + 1 >= offset + length) {\n          ret.append(languageTableToChar.charAt(c));\n        }\n else {\n          mbcsBuffer.clear();\n          mbcsBuffer.put(data,i++,2);\n          mbcsBuffer.flip();\n          ret.append(charset.decode(mbcsBuffer).toString());\n        }\n      }\n      prevWasEscape=false;\n    }\n  }\n  return ret.toString();\n}\n", "nl": "Convert a GSM alphabet string that's stored in 8-bit unpacked format (as it often appears in SIM records) into a String Field may be padded with trailing 0xff's. The decode stops at the first 0xff encountered. Additionally, in some country(ex. Korea), there are non-ASCII or MBCS characters. If a character set is given, characters in data are treat as MBCS."}
{"code": "public FeedFragment(){\n  setHasOptionsMenu(true);\n  setRetainInstance(true);\n}\n", "nl": "Initialize a new feed fragment."}
{"code": "@Override public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.add(\"measureNumRules\");\n  return newVector.elements();\n}\n", "nl": "Returns an enumeration of the additional measure names"}
{"code": "public GPathResult parse(final File file) throws IOException, SAXException {\n  final FileInputStream fis=new FileInputStream(file);\n  final InputSource input=new InputSource(fis);\n  input.setSystemId(\"file://\" + file.getAbsolutePath());\n  try {\n    return parse(input);\n  }\n  finally {\n    fis.close();\n  }\n}\n", "nl": "Parses the content of the given file as XML turning it into a GPathResult object"}
{"code": "private static <Item extends Comparable>void partition(Queue<Item> unsorted,Item pivot,Queue<Item> less,Queue<Item> equal,Queue<Item> greater){\n}\n", "nl": "Partitions the given unsorted queue by pivoting on the given item."}
{"code": "public Boolean isTcpSegmentation(){\n  return tcpSegmentation;\n}\n", "nl": "Gets the value of the tcpSegmentation property."}
{"code": "protected SVGOMMetadataElement(){\n}\n", "nl": "Creates a new SVGOMMetadataElement object."}
{"code": "public void scale(int factor){\n  if (m_icon != null) {\n    removeAll();\n    Image pic=m_icon.getImage();\n    int width=m_icon.getIconWidth();\n    int height=m_icon.getIconHeight();\n    int reduction=width / factor;\n    width-=reduction;\n    height-=reduction;\n    pic=pic.getScaledInstance(width,height,Image.SCALE_SMOOTH);\n    m_icon=new ImageIcon(pic);\n    m_visualLabel=new JLabel(m_icon);\n    add(m_visualLabel,BorderLayout.CENTER);\n    Dimension d=m_visualLabel.getPreferredSize();\n    Dimension d2=new Dimension((int)d.getWidth() + 10,(int)d.getHeight() + 10);\n    setMinimumSize(d2);\n    setPreferredSize(d2);\n    setMaximumSize(d2);\n  }\n}\n", "nl": "Reduce this BeanVisual's icon size by the given factor"}
{"code": "public static byte[] decode(byte[] source,int off,int len) throws Base64DecoderException {\n  return decode(source,off,len,DECODABET);\n}\n", "nl": "Decodes Base64 content in byte array format and returns the decoded byte array."}
{"code": "public boolean contains(byte[] object){\n  for (int i=0; i < hashFuncs; i++) {\n    if (!Utils.checkBitLE(data,hash(i,object)))     return false;\n  }\n  return true;\n}\n", "nl": "Returns true if the given object matches the filter either because it was inserted, or because we have a false-positive."}
{"code": "public static void createTable(SQLiteDatabase db,boolean ifNotExists){\n  String constraint=ifNotExists ? \"IF NOT EXISTS \" : \"\";\n  db.execSQL(\"CREATE TABLE \" + constraint + \"\\\"ALLOPERATORS\\\" (\"+ \"\\\"_id\\\" INTEGER PRIMARY KEY ,\"+ \"\\\"NAME\\\" TEXT NOT NULL ,\"+ \"\\\"THREAD\\\" TEXT NOT NULL ,\"+ \"\\\"DESC\\\" TEXT NOT NULL ,\"+ \"\\\"IMG\\\" TEXT NOT NULL ,\"+ \"\\\"URL\\\" TEXT NOT NULL ,\"+ \"\\\"OPERATORS_ID\\\" INTEGER,\"+ \"\\\"OUTER_ID\\\" INTEGER);\");\n}\n", "nl": "Creates the underlying database table."}
{"code": "public void test_setBooleanLjava_lang_ObjectIZ(){\n  boolean[] x={false};\n  boolean thrown=false;\n  try {\n    Array.setBoolean(x,0,true);\n  }\n catch (  Exception e) {\n    fail(\"Exception during get test : \" + e.getMessage());\n  }\n  assertTrue(\"Failed to set correct value\",Array.getBoolean(x,0));\n  try {\n    Array.setBoolean(new Object(),0,false);\n  }\n catch (  IllegalArgumentException e) {\n    thrown=true;\n  }\n  if (!thrown) {\n    fail(\"Passing non-array failed to throw exception\");\n  }\n  thrown=false;\n  try {\n    Array.setBoolean(x,4,false);\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    thrown=true;\n  }\n  if (!thrown) {\n    fail(\"Invalid index failed to throw exception\");\n  }\n  thrown=false;\n  try {\n    Array.setBoolean(null,0,true);\n  }\n catch (  NullPointerException e) {\n    thrown=true;\n  }\n  if (!thrown) {\n    fail(\"Null argument failed to throw NPE\");\n  }\n}\n", "nl": "java.lang.reflect.Array#setBoolean(java.lang.Object, int, boolean)"}
{"code": "public static boolean isConnectedWifi(Context context){\n  NetworkInfo info=Connectivity.getNetworkInfo(context);\n  return (info != null && info.isConnected() && info.getType() == ConnectivityManager.TYPE_WIFI);\n}\n", "nl": "Check if there is any connectivity to a Wifi network"}
{"code": "private void checkValid(Position pos,Move move){\n  assertTrue(move != null);\n  MoveGen.MoveList moveList=new MoveGen().pseudoLegalMoves(pos);\n  MoveGen.removeIllegal(pos,moveList);\n  boolean contains=false;\n  for (int mi=0; mi < moveList.size; mi++)   if (moveList.m[mi].equals(move)) {\n    contains=true;\n    break;\n  }\n  assertTrue(contains);\n}\n", "nl": "Check that move is a legal move in position pos."}
{"code": "protected void appendDetail(StringBuffer buffer,String fieldName,byte value){\n  buffer.append(value);\n}\n", "nl": "<p>Append to the <code>toString</code> a <code>byte</code> value.</p>"}
{"code": "public void onGoogleLoginError(final Exception error){\n  Logger.e(TAG,\"GOOGLE LOGIN ERROR\");\n}\n", "nl": "Method called when there is an error while google login"}
{"code": "public boolean isOpposed(ECMInfo other){\n  return (owner == null) || (other.getOwner() == null) || owner.isEnemyOf(other.getOwner());\n}\n", "nl": "Returns true if the supplied ECMInfo is opposed to this one."}
{"code": "private String neededPermissionForFeature(String feature){\n  String neededPermission=null;\n  if (FEATURE_KEY_PREF_CONTACTS.equals(feature)) {\n    neededPermission=Manifest.permission.READ_CONTACTS;\n  }\n else   if (FEATURE_KEY_PREF_DIALER.equals(feature)) {\n    neededPermission=Manifest.permission.WRITE_CALL_LOG;\n  }\n  return neededPermission;\n}\n", "nl": "Provides the permission associated to a feature"}
{"code": "public boolean booleanPrimitiveValueOfParameterNamed(final String parameterName){\n  final Boolean value=this.fromApiJsonHelper.extractBooleanNamed(parameterName,this.parsedQuery);\n  return (Boolean)ObjectUtils.defaultIfNull(value,Boolean.FALSE);\n}\n", "nl": "always returns true or false"}
{"code": "public static void v(String tag,String msg){\n  if (sLevel > LEVEL_VERBOSE) {\n    return;\n  }\n  Log.v(tag,msg);\n}\n", "nl": "Send a VERBOSE log message."}
{"code": "public static ImageRequestBuilder newBuilderWithSource(Uri uri){\n  return new ImageRequestBuilder().setSource(uri);\n}\n", "nl": "Creates a new request builder instance. The setting will be done according to the source type."}
{"code": "private int decodeGaincData(){\n  int ret;\n  for (int chNum=0; chNum < numChannels; chNum++) {\n    for (int i=0; i < ATRAC3P_SUBBANDS; i++) {\n      ctx.channels[chNum].gainData[i].clear();\n    }\n    if (br.readBool()) {\n      int codedSubbands=br.read(4) + 1;\n      if (br.readBool()) {\n        ctx.channels[chNum].numGainSubbands=br.read(4) + 1;\n      }\n else {\n        ctx.channels[chNum].numGainSubbands=codedSubbands;\n      }\n      ret=decodeGaincNPoints(chNum,codedSubbands);\n      if (ret < 0) {\n        return ret;\n      }\n      ret=decodeGaincLevels(chNum,codedSubbands);\n      if (ret < 0) {\n        return ret;\n      }\n      ret=decodeGaincLocCodes(chNum,codedSubbands);\n      if (ret < 0) {\n        return ret;\n      }\n      if (codedSubbands > 0) {\n        for (int sb=codedSubbands; sb < ctx.channels[chNum].numGainSubbands; sb++) {\n          ctx.channels[chNum].gainData[sb].copy(ctx.channels[chNum].gainData[sb - 1]);\n        }\n      }\n    }\n else {\n      ctx.channels[chNum].numGainSubbands=0;\n    }\n  }\n  return 0;\n}\n", "nl": "Decode gain control data for all channels."}
{"code": "static public void qsort(double[] array){\n  qsort_h(array,0,array.length - 1);\n}\n", "nl": "Non-Recursive QuickSort"}
{"code": "public boolean isEmpty(){\n  return bits == 0;\n}\n", "nl": "Return whether or not the set of non-null parameters is empty."}
{"code": "public MutableLeafData(final int branchingFactor,final ILeafData src){\n  keys=new MutableKeyBuffer(branchingFactor + 1,src.getKeys());\n  vals=new MutableValueBuffer(branchingFactor + 1,src.getValues());\n  versionTimestamps=(src.hasVersionTimestamps() ? new long[branchingFactor + 1] : null);\n  deleteMarkers=(src.hasDeleteMarkers() ? new boolean[branchingFactor + 1] : null);\n  rawRecords=(src.hasRawRecords() ? new boolean[branchingFactor + 1] : null);\n  final int nkeys=keys.size();\n  if (versionTimestamps != null) {\n    for (int i=0; i < nkeys; i++) {\n      versionTimestamps[i]=src.getVersionTimestamp(i);\n    }\n    minimumVersionTimestamp=src.getMinimumVersionTimestamp();\n    maximumVersionTimestamp=src.getMaximumVersionTimestamp();\n  }\n else {\n    minimumVersionTimestamp=Long.MAX_VALUE;\n    maximumVersionTimestamp=Long.MIN_VALUE;\n  }\n  if (deleteMarkers != null) {\n    for (int i=0; i < nkeys; i++) {\n      deleteMarkers[i]=src.getDeleteMarker(i);\n    }\n  }\n  if (rawRecords != null) {\n    for (int i=0; i < nkeys; i++) {\n      rawRecords[i]=src.getRawRecord(i) != IRawStore.NULL;\n    }\n  }\n}\n", "nl": "Copy ctor."}
{"code": "public boolean isI_IsImported(){\n  Object oo=get_Value(COLUMNNAME_I_IsImported);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Imported."}
{"code": "public static int nextPowerOfTwo(int x){\n  if (x == 0)   return 1;\n  x--;\n  x|=x >> 1;\n  x|=x >> 2;\n  x|=x >> 4;\n  x|=x >> 8;\n  return (x | x >> 16) + 1;\n}\n", "nl": "Return the least power of two greater than or equal to the specified value. <p>Note that this function will return 1 when the argument is 0."}
{"code": "public static ObjectAnimator ofFloat(Object target,String propertyName,float... values){\n  ObjectAnimator anim=new ObjectAnimator(target,propertyName);\n  anim.setFloatValues(values);\n  return anim;\n}\n", "nl": "Constructs and returns an ObjectAnimator that animates between float values. A single value implies that that value is the one being animated to. Two values imply a starting and ending values. More than two values imply a starting value, values to animate through along the way, and an ending value (these values will be distributed evenly across the duration of the animation)."}
{"code": "public static int calculateReward(Player player){\n  int moneys=0;\n  int kills=0;\n  for (int i=0; i < RAT_TYPES.size(); i++) {\n    try {\n      final String killed=player.getQuest(QUEST_SLOT,i + 1);\n      if (killed != null) {\n        kills=Integer.decode(killed);\n      }\n    }\n catch (    NumberFormatException nfe) {\n    }\n    moneys=moneys + kills * RAT_REWARDS.get(i);\n  }\n  return (moneys);\n}\n", "nl": "function for calculating reward's moneys for player"}
{"code": "public void copyContent(){\n  StringSelection selection;\n  Clipboard clipboard;\n  selection=getTable().getStringSelection();\n  if (selection == null) {\n    return;\n  }\n  clipboard=Toolkit.getDefaultToolkit().getSystemClipboard();\n  clipboard.setContents(selection,selection);\n}\n", "nl": "copies the content of the selection to the clipboard"}
{"code": "public AngularObject add(String name,Object o,String noteId,String paragraphId,boolean emit){\n  AngularObject ao=createNewAngularObject(name,o,noteId,paragraphId);\nsynchronized (registry) {\n    Map<String,AngularObject> noteLocalRegistry=getRegistryForKey(noteId,paragraphId);\n    noteLocalRegistry.put(name,ao);\n    if (listener != null && emit) {\n      listener.onAdd(interpreterId,ao);\n    }\n  }\n  return ao;\n}\n", "nl": "Add object into registry Paragraph scope when noteId and paragraphId both not null Notebook scope when paragraphId is null Global scope when noteId and paragraphId both null"}
{"code": "public DisqusClient(ApiConfig config,Context context){\n  super(config);\n  mcontent=context;\n  if (instance_am == null) {\n    instance_am=createAuthenticationManager(context);\n  }\n}\n", "nl": "THe content"}
{"code": "public FunctionDeclaration(ImportStack importStack,Context context,String signature,Object object,Method method,List<ArgumentConverter> argumentConverters){\n  this.importStack=importStack;\n  this.context=context;\n  this.signature=signature;\n  this.object=object;\n  this.method=method;\n  this.argumentConverters=argumentConverters;\n}\n", "nl": "Create a new function declaration."}
{"code": "public List<RawProperty> removeExperimentalProperties(String name){\n  List<RawProperty> all=getExperimentalProperties();\n  List<RawProperty> toRemove=new ArrayList<RawProperty>();\n  for (  RawProperty property : all) {\n    if (property.getName().equalsIgnoreCase(name)) {\n      toRemove.add(property);\n    }\n  }\n  all.removeAll(toRemove);\n  return Collections.unmodifiableList(toRemove);\n}\n", "nl": "Removes all experimental properties that have the given name."}
{"code": "public int typicalIndsProduced(){\n  return (tossSecondParent ? 1 : INDS_PRODUCED);\n}\n", "nl": "Returns 2 (unless tossing the second sibling, in which case it returns 1)"}
{"code": "public static String asUrl(File file){\n  return PROTOCOL + file.getAbsolutePath();\n}\n", "nl": "Prefixes `file://` to the file's absolute path."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-08-13 13:14:13.410 -0400\",hash_original_method=\"25736550470809040A3F8C62976339C4\",hash_generated_method=\"B61E8F76A04C239FB09D418D5B87F38F\") public Method element(){\n  return element;\n}\n", "nl": "Returns the method object for the invalid type."}
{"code": "int read(byte[] buffer,int offset,int length) throws IOException {\n  throw new UnsupportedOperationException();\n}\n", "nl": "Reads bytes from the underlying stream."}
{"code": "private String replacePlaceholders(String query,Map<String,String> replacements){\n  String resultQuery=query;\n  for (  Map.Entry<String,String> entry : replacements.entrySet()) {\n    resultQuery=resultQuery.replace(entry.getKey(),entry.getValue());\n  }\n  return resultQuery;\n}\n", "nl": "Replaces the placeholders with concrete values"}
{"code": "public static void annotateSupers(List<AnnotatedDeclaredType> supertypes,TypeElement subtypeElement){\n  SuperTypeApplier.annotateSupers(supertypes,subtypeElement);\n}\n", "nl": "Annotate the list of supertypes using the annotations on the TypeElement representing a class or interface"}
{"code": "public void close() throws java.io.IOException {\n  out.writeBytes(PREFIX);\n  out.writeBytes(boundary);\n  out.writeBytes(PREFIX);\n  out.writeBytes(NEWLINE);\n  out.flush();\n  out.close();\n}\n", "nl": "Closes the stream.  <br /> <br /> <b>NOTE:</b> This method <b>MUST</b> be called to finalize the multipart stream."}
{"code": "private void processMethods(final Object component,final Context context,final ContextDestroyer contextDestroyer){\n  Class<?> componentClass=component.getClass();\n  while (componentClass != null && !componentClass.equals(Object.class)) {\n    final Method[] methods=ClassReflection.getDeclaredMethods(componentClass);\n    if (methods != null && methods.length > 0) {\n      processMethods(component,methods,context,contextDestroyer);\n    }\n    componentClass=componentClass.getSuperclass();\n  }\n}\n", "nl": "Scans class tree of component to process all its methods."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFilesString=null;\n  String[] pointFiles;\n  String outputHeader=null;\n  int row, col;\n  int nrows, ncols;\n  double x, y, z;\n  int i;\n  int progress=0;\n  int numPoints=0;\n  int lineNum=0;\n  int nlines=0;\n  double maxDist=Double.POSITIVE_INFINITY;\n  double minX=Double.POSITIVE_INFINITY;\n  double maxX=Double.NEGATIVE_INFINITY;\n  double minY=Double.POSITIVE_INFINITY;\n  double maxY=Double.NEGATIVE_INFINITY;\n  double north, south, east, west;\n  double resolution=1;\n  String delimiter=\" \";\n  boolean firstLineHeader=false;\n  String str1=null;\n  FileWriter fw=null;\n  BufferedWriter bw=null;\n  PrintWriter out=null;\n  List<KdTree.Entry<Double>> results;\n  double noData=-32768;\n  double northing, easting;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputFilesString=args[0];\n  firstLineHeader=Boolean.parseBoolean(args[1]);\n  outputHeader=args[2];\n  resolution=Double.parseDouble(args[3]);\n  if (!args[4].equalsIgnoreCase(\"not specified\")) {\n    maxDist=Double.parseDouble(args[4]);\n  }\n  if ((inputFilesString.length() <= 0) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    pointFiles=inputFilesString.split(\";\");\n    int numPointFiles=pointFiles.length;\n    if (maxDist < Double.POSITIVE_INFINITY) {\n      maxDist=maxDist * maxDist;\n    }\n    updateProgress(\"Counting the number of points:\",0);\n    numPoints=0;\n    for (i=0; i < numPointFiles; i++) {\n      nlines=countLinesInFile(pointFiles[i]);\n      if (firstLineHeader) {\n        numPoints+=nlines - 1;\n      }\n else {\n        numPoints+=nlines;\n      }\n    }\n    KdTree<Double> pointsTree=new KdTree.SqrEuclid<Double>(2,new Integer(numPoints));\n    nlines=0;\n    for (i=0; i < numPointFiles; i++) {\n      DataInputStream in=null;\n      BufferedReader br=null;\n      try {\n        FileInputStream fstream=new FileInputStream(pointFiles[i]);\n        in=new DataInputStream(fstream);\n        br=new BufferedReader(new InputStreamReader(in));\n        String line;\n        String[] str;\n        lineNum=1;\n        while ((line=br.readLine()) != null) {\n          str=line.split(delimiter);\n          if (str.length <= 1) {\n            delimiter=\"\\t\";\n            str=line.split(delimiter);\n            if (str.length <= 1) {\n              delimiter=\" \";\n              str=line.split(delimiter);\n              if (str.length <= 1) {\n                delimiter=\",\";\n                str=line.split(delimiter);\n              }\n            }\n          }\n          if ((lineNum > 1 || !firstLineHeader) && (str.length >= 3)) {\n            x=Double.parseDouble(str[0]);\n            y=Double.parseDouble(str[1]);\n            z=Double.parseDouble(str[2]);\n            double[] entry={y,x};\n            pointsTree.addPoint(entry,z);\n            if (x < minX) {\n              minX=x;\n            }\n            if (x > maxX) {\n              maxX=x;\n            }\n            if (y < minY) {\n              minY=y;\n            }\n            if (y > maxY) {\n              maxY=y;\n            }\n          }\n          lineNum++;\n          nlines++;\n          progress=(int)(100d * nlines / numPoints);\n          updateProgress(\"Reading point data:\",progress);\n        }\n        in.close();\n        br.close();\n      }\n catch (      java.io.IOException e) {\n        System.err.println(\"Error: \" + e.getMessage());\n      }\n finally {\n        try {\n          if (in != null || br != null) {\n            in.close();\n            br.close();\n          }\n        }\n catch (        java.io.IOException ex) {\n        }\n      }\n    }\n    west=minX - 0.5 * resolution;\n    north=maxY + 0.5 * resolution;\n    nrows=(int)(Math.ceil((north - minY) / resolution));\n    ncols=(int)(Math.ceil((maxX - west) / resolution));\n    south=north - nrows * resolution;\n    east=west + ncols * resolution;\n    fw=new FileWriter(outputHeader,false);\n    bw=new BufferedWriter(fw);\n    out=new PrintWriter(bw,true);\n    str1=\"Min:\\t\" + Double.toString(Integer.MAX_VALUE);\n    out.println(str1);\n    str1=\"Max:\\t\" + Double.toString(Integer.MIN_VALUE);\n    out.println(str1);\n    str1=\"North:\\t\" + Double.toString(north);\n    out.println(str1);\n    str1=\"South:\\t\" + Double.toString(south);\n    out.println(str1);\n    str1=\"East:\\t\" + Double.toString(east);\n    out.println(str1);\n    str1=\"West:\\t\" + Double.toString(west);\n    out.println(str1);\n    str1=\"Cols:\\t\" + Integer.toString(ncols);\n    out.println(str1);\n    str1=\"Rows:\\t\" + Integer.toString(nrows);\n    out.println(str1);\n    str1=\"Data Type:\\t\" + \"float\";\n    out.println(str1);\n    str1=\"Z Units:\\t\" + \"not specified\";\n    out.println(str1);\n    str1=\"XY Units:\\t\" + \"not specified\";\n    out.println(str1);\n    str1=\"Projection:\\t\" + \"not specified\";\n    out.println(str1);\n    str1=\"Data Scale:\\tcontinuous\";\n    out.println(str1);\n    str1=\"Preferred Palette:\\t\" + \"spectrum.pal\";\n    out.println(str1);\n    str1=\"NoData:\\t\" + noData;\n    out.println(str1);\n    if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {\n      str1=\"Byte Order:\\t\" + \"LITTLE_ENDIAN\";\n    }\n else {\n      str1=\"Byte Order:\\t\" + \"BIG_ENDIAN\";\n    }\n    out.println(str1);\n    out.close();\n    WhiteboxRaster image=new WhiteboxRaster(outputHeader,\"rw\");\n    double halfResolution=resolution / 2;\n    for (row=0; row < nrows; row++) {\n      for (col=0; col < ncols; col++) {\n        easting=(col * resolution) + (west + halfResolution);\n        northing=(north - halfResolution) - (row * resolution);\n        double[] entry={northing,easting};\n        results=pointsTree.nearestNeighbor(entry,1,true);\n        if (results.get(0).distance < maxDist) {\n          image.setValue(row,col,results.get(0).value);\n        }\n else {\n          image.setValue(row,col,noData);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (nrows - 1));\n      updateProgress(\"Interpolating point data:\",progress);\n    }\n    image.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    image.addMetadataEntry(\"Created on \" + new Date());\n    image.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public RotateFilter(float angle){\n  this(angle,true);\n}\n", "nl": "Construct a RotateFilter."}
{"code": "@Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase DomPackage.VARIABLE_REFERENCE__VARIABLE_NAME:\n    setVariableName((String)newValue);\n  return;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void writeStaticField(final Class<?> cls,final String fieldName,final Object value) throws IllegalAccessException {\n  FieldUtils.writeStaticField(cls,fieldName,value,false);\n}\n", "nl": "Write a named public static Field. Superclasses will be considered."}
{"code": "static Object newInstance(String className,ClassLoader cl,boolean doFallback) throws ConfigurationError {\n  try {\n    Class providerClass=findProviderClass(className,cl,doFallback);\n    Object instance=providerClass.newInstance();\n    debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \"+ cl);\n    return instance;\n  }\n catch (  ClassNotFoundException x) {\n    throw new ConfigurationError(\"Provider \" + className + \" not found\",x);\n  }\ncatch (  Exception x) {\n    throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \"+ x,x);\n  }\n}\n", "nl": "Create an instance of a class using the specified ClassLoader"}
{"code": "public void calcMajorTick(){\n  majorTick=10;\n  majorTickCount=(int)Math.round(log10(maxTick / minTick)) + 1;\n}\n", "nl": "Calculate the optimum major tick distance."}
{"code": "protected void finalize() throws Throwable {\n  this.systemID=null;\n  this.encapsulatedException=null;\n  super.finalize();\n}\n", "nl": "Cleans up the object when it's destroyed."}
{"code": "public TFSFolder(final ExtendedItem extendedItem){\n  this(extendedItem,null);\n}\n", "nl": "Creates a new TFSFolder using the given AExtendedItem."}
{"code": "public NGramTokenizer(int n,Tokenizer base,boolean allSubN){\n  if (n <= 0)   throw new IllegalArgumentException(\"Number of n-grams must be positive, not \" + n);\n  this.n=n;\n  this.base=base;\n  this.allSubN=allSubN;\n}\n", "nl": "Creates a new n-gramer"}
{"code": "protected boolean accept(XSLTVisitor visitor){\n  return visitor.visitInstruction(this);\n}\n", "nl": "Accept a visitor and call the appropriate method  for this class."}
{"code": "public void query(String query){\n}\n", "nl": "Filters the DbfTableModel given a SQL like string"}
{"code": "public void push(final int a){\n  if (pointer >= stack.length) {\n    final int[] newStack=new int[(int)(stack.length * 1.5)];\n    System.arraycopy(stack,0,newStack,0,stack.length);\n    stack=newStack;\n  }\n  stack[pointer]=a;\n  pointer++;\n}\n", "nl": "Adds an item to the top of the stack, expanding the stack if needed"}
{"code": "private HttpEntity paramsToEntity(RequestParams params,ResponseHandlerInterface responseHandler){\n  HttpEntity entity=null;\n  try {\n    if (params != null) {\n      entity=params.getEntity(responseHandler);\n    }\n  }\n catch (  IOException e) {\n    if (responseHandler != null) {\n      responseHandler.sendFailureMessage(0,null,null,e);\n    }\n else {\n      e.printStackTrace();\n    }\n  }\n  return entity;\n}\n", "nl": "Returns HttpEntity containing data from RequestParams included with request declaration. Allows also passing progress from upload via provided ResponseHandler"}
{"code": "public void shuffle(){\n  Random random=new Random();\n  for (int i=size() - 1; i > 0; i--) {\n    int j=random.nextInt(i);\n    swapCards(i,j);\n  }\n}\n", "nl": "Randomly permute the cards."}
{"code": "public void readCommandLine(String[] args){\n  String key=null;\n  String value=\"\";\n  for (int i=0; i < args.length; i++) {\n    if (args[i].startsWith(\"-\")) {\n      if (key != null) {\n        put(key,value);\n      }\n      key=args[i].substring(1);\n      int ik=key.indexOf('=');\n      if (ik >= 0) {\n        value=key.substring(ik + 1);\n        key=key.substring(0,ik).toLowerCase();\n      }\n else {\n        key=key.toLowerCase();\n        value=NULL;\n      }\n    }\n else {\n      if (value == NULL) {\n        value=args[i];\n      }\n else {\n        value+=(\" \" + args[i]);\n      }\n    }\n  }\n  if (key != null) {\n    put(key,value);\n  }\n}\n", "nl": "Removes any - or -- prepends as it populates properties."}
{"code": "public CubeHash224(){\n}\n", "nl": "Create the engine."}
{"code": "public void swap(int original,int newPosition){\n  Song temp=mSongs.get(original);\n  Song newSong=mSongs.get(newPosition);\n  mSongs.set(original,newSong);\n  mSongs.set(newPosition,temp);\n  int tempVis=mVisible.get(original);\n  mVisible.set(original,mVisible.get(newPosition));\n  mVisible.set(newPosition,tempVis);\n  int tempId=mIds.get(original);\n  mIds.set(original,mIds.get(newPosition));\n  mIds.set(newPosition,tempId);\n  super.notifyDataSetChanged();\n}\n", "nl": "Swaps two elements and their properties"}
{"code": "public SignificantTermsBuilder field(String field){\n  this.field=field;\n  return this;\n}\n", "nl": "Set the field to fetch significant terms from."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public BubbleTransition(int duration,String componentName){\n  this(duration);\n  this.componentName=componentName;\n}\n", "nl": "Creates a Bubble Transition"}
{"code": "public Object clone(){\n  OVector clone=null;\n  try {\n    clone=(OVector)super.clone();\n  }\n catch (  Exception e) {\n    System.err.println(\"Error cloning \" + getClass().getName() + \":\");\n    e.printStackTrace();\n    System.exit(1);\n  }\n  clone.vector=(Object[])vector.clone();\n  return clone;\n}\n", "nl": "Returns a shallow clone of this vector; the vector itself is cloned, but the element objects aren't."}
{"code": "void remove(String filename){\n  if (debug) {\n    System.err.println(\"Removing \" + filename);\n  }\n  new File(filename).delete();\n  if (new File(filename).exists()) {\n    throw new RuntimeException(\"Error deleting \" + filename);\n  }\n}\n", "nl": "Helper, removes a file"}
{"code": "@Override public int eBaseStructuralFeatureID(int derivedFeatureID,Class<?> baseClass){\n  if (baseClass == ReferencingElement_IM.class) {\nswitch (derivedFeatureID) {\ncase ImPackage.PARAMETERIZED_PROPERTY_ACCESS_EXPRESSION_IM__REWIRED_TARGET:\n      return ImPackage.REFERENCING_ELEMENT_IM__REWIRED_TARGET;\ndefault :\n    return -1;\n}\n}\nif (baseClass == ReferencingElementExpression_IM.class) {\nswitch (derivedFeatureID) {\ndefault :\n  return -1;\n}\n}\nreturn super.eBaseStructuralFeatureID(derivedFeatureID,baseClass);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private DefaultJavaType createType(TypeDef typeDef,int dimensions){\n  if (typeDef == null) {\n    return null;\n  }\n  return TypeAssembler.createUnresolved(typeDef,dimensions,classStack.isEmpty() ? source : classStack.getFirst());\n}\n", "nl": "this one is specific for those cases where dimensions can be part of both the type and identifier i.e. private String[] matrix[]; //field public abstract String[] getMatrix[](); //method "}
{"code": "public ConfigureXmlEntityExpansionDialog_NB(XmlEntityExpansion xmlEntityExpansion){\n  this.xmlEntityExpansion=xmlEntityExpansion;\n  initComponents();\n  final IterateModel numberOfEntitiesIterator=xmlEntityExpansion.getNumberOfEntitiesIterator();\n  configureNumberOfEntities.setStartAt(String.valueOf(numberOfEntitiesIterator.getStartAt()));\n  configureNumberOfEntities.setStopAt(String.valueOf(numberOfEntitiesIterator.getStopAt()));\n  configureNumberOfEntities.setIncrement(String.valueOf(numberOfEntitiesIterator.getIncrement()));\n  configureNumberOfEntities.setIterateStrategie(numberOfEntitiesIterator.getIterateStrategie());\n  final IterateModel numberOfTagsIterator=xmlEntityExpansion.getNumberOfEntityElementsIterator();\n  configureNumberOfTags.setStartAt(String.valueOf(numberOfTagsIterator.getStartAt()));\n  configureNumberOfTags.setStopAt(String.valueOf(numberOfTagsIterator.getStopAt()));\n  configureNumberOfTags.setIncrement(String.valueOf(numberOfTagsIterator.getIncrement()));\n  configureNumberOfTags.setIterateStrategie(numberOfTagsIterator.getIterateStrategie());\n}\n", "nl": "Creates new form ConfigureCoerceiveParsingDialog_NB"}
{"code": "static public short unpackShort(final InputStream is) throws IOException {\n  short b=(short)readByte(is);\n  short v;\n  if ((b & 0x80) != 0) {\n    v=(short)((b & 0x7f) << 8);\n    b=readByte(is);\n    v|=(b & 0xff);\n  }\n else {\n    v=b;\n  }\n  return (short)v;\n}\n", "nl": "Unpack a non-negative short value from the input stream."}
{"code": "private void action_loadTree(){\n  KeyNamePair tree=treeField.getSelectedItem().toKeyNamePair();\n  log.info(\"Tree=\" + tree);\n  if (tree.getKey() <= 0) {\n    SimpleListModel tmp=new SimpleListModel();\n    centerList.setItemRenderer(tmp);\n    centerList.setModel(tmp);\n    return;\n  }\n  m_tree=new MTree(Env.getCtx(),tree.getKey(),null);\n  cbAllNodes.setSelected(m_tree.isAllNodes());\n  bAddAll.setEnabled(!m_tree.isAllNodes());\n  bAdd.setEnabled(!m_tree.isAllNodes());\n  bDelete.setEnabled(!m_tree.isAllNodes());\n  bDeleteAll.setEnabled(!m_tree.isAllNodes());\n  String fromClause=m_tree.getSourceTableName(false);\n  String columnNameX=m_tree.getSourceTableName(true);\n  String actionColor=m_tree.getActionColorName();\n  SimpleListModel model=new SimpleListModel();\n  ArrayList<ListItem> items=getTreeItemData();\n  for (  ListItem item : items)   model.addElement(item);\n  log.config(\"#\" + model.getSize());\n  centerList.setItemRenderer(model);\n  centerList.setModel(model);\n  try {\n    centerTree.setModel(null);\n  }\n catch (  Exception e) {\n  }\n  if (centerTree.getTreecols() != null)   centerTree.getTreecols().detach();\n  if (centerTree.getTreefoot() != null)   centerTree.getTreefoot().detach();\n  if (centerTree.getTreechildren() != null)   centerTree.getTreechildren().detach();\n  SimpleTreeModel.initADTree(centerTree,m_tree.getAD_Tree_ID(),m_WindowNo);\n}\n", "nl": "Action: Fill Tree with all nodes"}
{"code": "public void testPeek(){\n  LinkedBlockingQueue q=populatedQueue(SIZE);\n  for (int i=0; i < SIZE; ++i) {\n    assertEquals(i,q.peek());\n    assertEquals(i,q.poll());\n    assertTrue(q.peek() == null || !q.peek().equals(i));\n  }\n  assertNull(q.peek());\n}\n", "nl": "peek returns next element, or null if empty"}
{"code": "public boolean isInitializing(){\n  return getState().isInitializing();\n}\n", "nl": "Returns true for the initializing state."}
{"code": "public PMElement elementAt(int i){\n  return gr.elementAt(i);\n}\n", "nl": "Returns element at specific index."}
{"code": "public void emitMessage(String emitType,JSONObject jsonObject){\n  if (mSocket != null)   mSocket.emit(emitType,jsonObject);\n}\n", "nl": "emit message to socket"}
{"code": "void allocPaddle(){\n  BasicAlignedRect rect=new BasicAlignedRect();\n  rect.setScale(DEFAULT_PADDLE_WIDTH * mPaddleSizeMultiplier,ARENA_HEIGHT * PADDLE_HEIGHT_PERC);\n  rect.setColor(1.0f,1.0f,1.0f);\n  rect.setPosition(ARENA_WIDTH / 2.0f,ARENA_HEIGHT * PADDLE_VERTICAL_PERC);\n  mPaddle=rect;\n}\n", "nl": "Creates the paddle."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "@SuppressWarnings(\"unchecked\") @Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase DatatypePackage.TYPE__NAME:\n    setName((String)newValue);\n  return;\ncase DatatypePackage.TYPE__NAMESPACE:\nsetNamespace((String)newValue);\nreturn;\ncase DatatypePackage.TYPE__VERSION:\nsetVersion((String)newValue);\nreturn;\ncase DatatypePackage.TYPE__REFERENCES:\ngetReferences().clear();\ngetReferences().addAll((Collection<? extends ModelReference>)newValue);\nreturn;\ncase DatatypePackage.TYPE__DESCRIPTION:\nsetDescription((String)newValue);\nreturn;\ncase DatatypePackage.TYPE__DISPLAYNAME:\nsetDisplayname((String)newValue);\nreturn;\ncase DatatypePackage.TYPE__CATEGORY:\nsetCategory((String)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isAttribute(){\n  return false;\n}\n", "nl": "This method is used to determine if the parameter represents  an attribute. This is used to style the name so that elements are styled as elements and attributes are styled as required."}
{"code": "void loadMethodIds() throws IOException {\n  int count=mHeaderItem.methodIdsSize;\n  mMethodIds=new MethodIdItem[count];\n  seek(mHeaderItem.methodIdsOff);\n  for (int i=0; i < count; i++) {\n    mMethodIds[i]=new MethodIdItem();\n    mMethodIds[i].classIdx=readShort() & 0xffff;\n    mMethodIds[i].protoIdx=readShort() & 0xffff;\n    mMethodIds[i].nameIdx=readInt();\n  }\n}\n", "nl": "Loads the method ID list."}
{"code": "public long next(){\n  moveToNextIndex();\n  return _hash._set[_index];\n}\n", "nl": "Advances the iterator to the next element in the underlying collection and returns it."}
{"code": "public static void checkState(boolean expression,@Nullable Object errorMessage){\n  if (!expression) {\n    throw new IllegalStateException(String.valueOf(errorMessage));\n  }\n}\n", "nl": "Ensures the truth of an expression involving the state of the calling instance, but not involving any parameters to the calling method."}
{"code": "public boolean requiresFreshAST(){\n  return fRequiresFreshAST;\n}\n", "nl": "Tells whether a fresh AST, containing all the changes from previous clean ups, will be needed."}
{"code": "public BigdataValueSerializer(final ValueFactory valueFactory){\n  if (valueFactory == null)   throw new IllegalArgumentException();\n  this.valueFactory=valueFactory;\n  this.uc=new UnicodeHelper(new NoCompressor());\n}\n", "nl": "Create an instance that will materialize objects using the caller's factory."}
{"code": "public final void referencesMustNotBeFrozen(){\n  if (referencesFrozen) {\n    throw new CompilerError(\"referencesMustNotBeFrozen \" + this);\n  }\n}\n", "nl": "assertion check"}
{"code": "protected void onPrepareRequest(HttpUriRequest request) throws IOException {\n}\n", "nl": "Called before the request is executed using the underlying HttpClient. <p>Overwrite in subclasses to augment the request.</p>"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public Builder addListenUrl(String url){\n  if (UrlUtil.isUrl(url)) {\n    if (mListenUrls == null) {\n      mListenUrls=new HashSet<String>();\n    }\n    mListenUrls.add(url);\n  }\n  return this;\n}\n", "nl": "add the url for listening"}
{"code": "public String toString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(\"UasDaoLdapUserRecA[\");\n  buffer.append(\"m_id = \").append(m_id);\n  buffer.append(\", m_ldapGuid = \").append(m_ldapGuid);\n  buffer.append(\", m_ldapFullName = \").append(m_ldapFullName);\n  buffer.append(\"]\");\n  return buffer.toString();\n}\n", "nl": "toString methode: creates a String representation of the object"}
{"code": "public static <T>void ifPresent(T primary,Consumer<? super T> consumer){\n  if (primary != null) {\n    consumer.accept(primary);\n  }\n}\n", "nl": "If primary is non-null, invoke the specified consumer with the value, otherwise do nothing."}
{"code": "private int mapNSTokens(String pat,int startSubstring,int posOfNSSep,int posOfScan) throws javax.xml.transform.TransformerException {\n  String prefix=\"\";\n  if ((startSubstring >= 0) && (posOfNSSep >= 0)) {\n    prefix=pat.substring(startSubstring,posOfNSSep);\n  }\n  String uName;\n  if ((null != m_namespaceContext) && !prefix.equals(\"*\") && !prefix.equals(\"xmlns\")) {\n    try {\n      if (prefix.length() > 0)       uName=((PrefixResolver)m_namespaceContext).getNamespaceForPrefix(prefix);\n else {\n        if (false) {\n          addToTokenQueue(\":\");\n          String s=pat.substring(posOfNSSep + 1,posOfScan);\n          if (s.length() > 0)           addToTokenQueue(s);\n          return -1;\n        }\n else {\n          uName=((PrefixResolver)m_namespaceContext).getNamespaceForPrefix(prefix);\n        }\n      }\n    }\n catch (    ClassCastException cce) {\n      uName=m_namespaceContext.getNamespaceForPrefix(prefix);\n    }\n  }\n else {\n    uName=prefix;\n  }\n  if ((null != uName) && (uName.length() > 0)) {\n    addToTokenQueue(uName);\n    addToTokenQueue(\":\");\n    String s=pat.substring(posOfNSSep + 1,posOfScan);\n    if (s.length() > 0)     addToTokenQueue(s);\n  }\n else {\n    m_processor.errorForDOM3(XPATHErrorResources.ER_PREFIX_MUST_RESOLVE,new String[]{prefix});\n  }\n  return -1;\n}\n", "nl": "When a seperator token is found, see if there's a element name or the like to map."}
{"code": "public void testOneNodeSubmitQueryWithLinearizableConsistency() throws Throwable {\n  testSubmitQuery(1,Query.ConsistencyLevel.LINEARIZABLE);\n}\n", "nl": "Tests submitting a query."}
{"code": "public LongMap(){\n  this(32,0.8f);\n}\n", "nl": "Creates a new map with an initial capacity of 32 and a load factor of 0.8. This map will hold 25 items before growing the backing table."}
{"code": "protected void handleMouseReleased(MouseEvent e){\n  Object obj=e.getSource();\n  MapBean map=(MapBean)theMap;\n  Point firstPoint=this.point1;\n  Point secondPoint=this.point2;\n  if (!(obj == map) || !autoZoom || firstPoint == null || secondPoint == null) {\n    return;\n  }\n  Projection projection=map.getProjection();\n  Proj p=(Proj)projection;\nsynchronized (this) {\n    point2=getRatioPoint((MapBean)e.getSource(),firstPoint,e.getPoint());\n    secondPoint=point2;\n    int dx=Math.abs(secondPoint.x - firstPoint.x);\n    int dy=Math.abs(secondPoint.y - firstPoint.y);\n    if ((dx < 5) || (dy < 5)) {\n      if ((dx < 5) && (dy < 5)) {\n        Point2D llp=map.getCoordinates(e);\n        boolean shift=e.isShiftDown();\n        boolean control=e.isControlDown();\n        if (control) {\n          if (shift) {\n            p.setScale(p.getScale() * 2.0f);\n          }\n else {\n            p.setScale(p.getScale() / 2.0f);\n          }\n        }\n        cleanUp();\n        p.setCenter(llp);\n        map.setProjection(p);\n      }\n else {\n        cleanUp();\n        map.repaint();\n      }\n      return;\n    }\n    float newScale=com.bbn.openmap.proj.ProjMath.getScale(firstPoint,secondPoint,projection);\n    int centerx=Math.min(firstPoint.x,secondPoint.x) + dx / 2;\n    int centery=Math.min(firstPoint.y,secondPoint.y) + dy / 2;\n    Point2D center=map.inverse(centerx,centery,null);\n    p.setScale(newScale);\n    p.setCenter(center);\n    cleanUp();\n    map.setProjection(p);\n  }\n}\n", "nl": "Override this method to change what happens when the mouse is released."}
{"code": "public static String toUpperCase(String src){\n  if (src == null) {\n    return null;\n  }\n else {\n    return src.toUpperCase();\n  }\n}\n", "nl": "Safely convert the string to uppercase."}
{"code": "public void visitTypeArgument(){\n}\n", "nl": "Visits an unbounded type argument of the last visited class or inner class type."}
{"code": "public boolean isGroupOwner(){\n  return (groupCapability & GROUP_CAPAB_GROUP_OWNER) != 0;\n}\n", "nl": "Returns true if the device is a group owner"}
{"code": "private void processBackwardBranch(int index,int branchtarget){\n  BasicBlock existingBB, currentBB, newBB;\n  int newBlockNum, i, newBlockEnd;\n  existingBB=basicBlocks[byteToBlockMap[branchtarget]];\n  if (existingBB.getStart() != branchtarget) {\n    newBB=bbf.newBlock(existingBB.getStart());\n    addBasicBlock(newBB);\n    newBlockNum=newBB.getBlockNumber();\n    existingBB.setStart(branchtarget);\n    for (i=branchtarget - 1; byteToBlockMap[i] == BasicBlock.NOTBLOCK; i--) {\n    }\n    newBlockEnd=i;\n    newBB.setEnd(i);\n    for (i=newBB.getStart(); i <= newBlockEnd; i++) {\n      if (byteToBlockMap[i] != BasicBlock.NOTBLOCK) {\n        byteToBlockMap[i]=(short)newBlockNum;\n      }\n    }\n    BasicBlock.transferPredecessors(existingBB,newBB);\n    existingBB.addPredecessor(newBB);\n  }\n else {\n  }\n  currentBB=basicBlocks[byteToBlockMap[index]];\n  existingBB.addPredecessor(currentBB);\n}\n", "nl": "A backwards branch has been found from the byte code at location \"index\" to a target location of \"branchtarget\". Need to make sure that the branchtarget location is the start of a block (and if not, then split the existing block into two) Need to register the block that ends at \"index\" as a predecessor of the block that starts at branchtarget."}
{"code": "public static final String createMessage(String msgKey,Object args[]){\n  return createMsg(XSLTBundle,msgKey,args);\n}\n", "nl": "Creates a message from the specified key and replacement arguments, localized to the given locale."}
{"code": "@Override public void doSave(IProgressMonitor monitor){\n  if (!isDirty()) {\n    return;\n  }\n  try {\n    saveInProgress=true;\n    monitor.beginTask(\"Save changes...\",1);\n    try {\n      monitor.subTask(\"Save '\" + getPartName() + \"' changes...\");\n      SaveJob saveJob=new SaveJob();\n      saveJob.schedule();\n      Display display=Display.getCurrent();\n      while (saveJob.finished == null) {\n        if (!display.readAndDispatch()) {\n          display.sleep();\n        }\n      }\n      display.update();\n      if (!saveJob.finished) {\n        monitor.setCanceled(true);\n        return;\n      }\n    }\n  finally {\n      monitor.done();\n    }\n    firePropertyChange(IEditorPart.PROP_DIRTY);\n  }\n  finally {\n    saveInProgress=false;\n  }\n}\n", "nl": "Saves data in all nested editors"}
{"code": "public Object nextEntity(char ampersand) throws JSONException {\n  StringBuilder sb=new StringBuilder();\n  for (; ; ) {\n    char c=next();\n    if (Character.isLetterOrDigit(c) || c == '#') {\n      sb.append(Character.toLowerCase(c));\n    }\n else     if (c == ';') {\n      break;\n    }\n else {\n      throw syntaxError(\"Missing ';' in XML entity: &\" + sb);\n    }\n  }\n  String string=sb.toString();\n  Object object=entity.get(string);\n  return object != null ? object : ampersand + string + \";\";\n}\n", "nl": "Return the next entity. These entities are translated to Characters: <code>&amp;  &apos;  &gt;  &lt;  &quot;</code>."}
{"code": "public String retryTime(){\n  if (code == 7100)   return retryTime;\n  return null;\n}\n", "nl": "If this does not return <code>null</code>, you need to wait at least until the time returned by this method."}
{"code": "public static void check(String answer,String path) throws IOException {\n  String ans=trimTrailingSlashes(answer);\n  if (path.length() == 0)   return;\n  if (checked.get(path) != null) {\n    System.err.println(\"DUP \" + path);\n    return;\n  }\n  checked.put(path,path);\n  String cpath;\n  try {\n    File f=new File(path);\n    cpath=f.getCanonicalPath();\n    if (f.exists() && f.isFile() && f.canRead()) {\n      InputStream in=new FileInputStream(path);\n      in.close();\n      RandomAccessFile raf=new RandomAccessFile(path,\"r\");\n      raf.close();\n    }\n  }\n catch (  IOException x) {\n    System.err.println(ans + \" <-- \" + path+ \" ==> \"+ x);\n    if (debug)     return;\n else     throw x;\n  }\n  if (cpath.equals(ans)) {\n    System.err.println(ans + \" <== \" + path);\n  }\n else {\n    System.err.println(ans + \" <-- \" + path+ \" ==> \"+ cpath+ \" MISMATCH\");\n    if (!debug) {\n      throw new RuntimeException(\"Mismatch: \" + path + \" ==> \"+ cpath+ \", should be \"+ ans);\n    }\n  }\n}\n", "nl": "Check the given pathname.  Its canonical pathname should be the given answer.  If the path names a file that exists and is readable, then FileInputStream and RandomAccessFile should both be able to open it."}
{"code": "int entryCountMod(){\n  int result=0;\n  Iterator it=this.entryMods.values().iterator();\n  while (it.hasNext()) {\n    TXEntryState es=(TXEntryState)it.next();\n    result+=es.entryCountMod();\n  }\n  return result;\n}\n", "nl": "Returns the total number of modifications made by this transaction to this region's entry count. The result will have a +1 for every create and a -1 for every destroy."}
{"code": "private void processJournal() throws IOException {\n  deleteIfExists(journalFileTmp);\n  for (final Iterator<Entry> i=lruEntries.values().iterator(); i.hasNext(); ) {\n    final Entry entry=i.next();\n    if (entry.currentEditor == null) {\n      for (int t=0; t < valueCount; t++) {\n        size+=entry.lengths[t];\n      }\n    }\n else {\n      entry.currentEditor=null;\n      for (int t=0; t < valueCount; t++) {\n        deleteIfExists(entry.getCleanFile(t));\n        deleteIfExists(entry.getDirtyFile(t));\n      }\n      i.remove();\n    }\n  }\n}\n", "nl": "Computes the initial size and collects garbage as a part of opening the cache. Dirty entries are assumed to be inconsistent and will be deleted."}
{"code": "public Vector minus(Vector v){\n  Vector result=new Vector(size());\n  for (int i=0; i < size(); i++) {\n    result.setValue(i,getValue(i) - v.getValue(i));\n  }\n  return result;\n}\n", "nl": "Returns the result of vector subtraction."}
{"code": "@Override public void emitErrorMessage(String pMessage){\n  if (mMessageCollectionEnabled) {\n    mMessages.add(pMessage);\n  }\n else {\n    super.emitErrorMessage(pMessage);\n  }\n}\n", "nl": "Collects an error message or passes the error message to <code> super.emitErrorMessage(...)</code>. <p/> The actual behaviour depends on whether collecting error messages has been enabled or not."}
{"code": "public static int read(FileDescriptor fd,byte[] bytes,int byteOffset,int byteCount) throws IOException {\n  Arrays.checkOffsetAndCount(bytes.length,byteOffset,byteCount);\n  if (byteCount == 0) {\n    return 0;\n  }\n  try {\n    int readCount=Libcore.os.read(fd,bytes,byteOffset,byteCount);\n    if (readCount == 0) {\n      return -1;\n    }\n    return readCount;\n  }\n catch (  ErrnoException errnoException) {\n    if (errnoException.errno == EAGAIN) {\n      return 0;\n    }\n    throw errnoException.rethrowAsIOException();\n  }\n}\n", "nl": "java.io thinks that a read at EOF is an error and should return -1, contrary to traditional Unix practice where you'd read until you got 0 bytes (and any future read would return -1)."}
{"code": "public WallForce(float x1,float y1,float x2,float y2){\n  this(DEFAULT_GRAV_CONSTANT,x1,y1,x2,y2);\n}\n", "nl": "Create a new WallForce with default gravitational constant."}
{"code": "public Buffer maxDistance(String maxDistance){\n  this.maxDistance=maxDistance;\n  return this;\n}\n", "nl": "Sets the max allowed distance."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:09.153 -0500\",hash_original_method=\"52B4DCA52CE9008BF4F1F47D8B6558D0\",hash_generated_method=\"A1DE28B462D206CC85DA36A53CF4B23D\") public int body(String messageId) throws IOException {\n  return sendCommand(NNTPCommand.BODY,messageId);\n}\n", "nl": "A convenience method to send the NNTP BODY command to the server, receive the initial reply, and return the reply code. <p>"}
{"code": "public V put(K key,V value){\n  m_keys.add(key);\n  m_values.add(value);\n  return null;\n}\n", "nl": "Put Key & Value"}
{"code": "public static Boolean isTopActivity(Context context,String packageName){\n  if (context == null || StringUtils.isEmpty(packageName)) {\n    return null;\n  }\n  ActivityManager activityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);\n  List<RunningTaskInfo> tasksInfo=activityManager.getRunningTasks(1);\n  if (ListUtils.isEmpty(tasksInfo)) {\n    return null;\n  }\n  try {\n    return packageName.equals(tasksInfo.get(0).topActivity.getPackageName());\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return false;\n  }\n}\n", "nl": "whether the app whost package's name is packageName is on the top of the stack <ul> <strong>Attentions:</strong> <li>You should add <strong>android.permission.GET_TASKS</strong> in manifest</li> </ul>"}
{"code": "public boolean isFullyZoomedOut(){\n  if (isFullyZoomedOutX() && isFullyZoomedOutY())   return true;\n else   return false;\n}\n", "nl": "if the chart is fully zoomed out, return true"}
{"code": "@Override public void start(){\n  try {\n    super.start();\n    readSlopeData();\n    readLandUseData();\n    readExcludedAreaData();\n    readUrbanAreaData();\n    readTransportData();\n    readHillShadeData();\n    System.out.println(\"Successfully read in all data!\");\n    for (int i=0; i < grid_width; i++) {\n      for (int j=0; j < grid_height; j++) {\n        Tile tile=(Tile)landscape.get(i,j);\n        if (tile != null && tile.urbanized) {\n          numUrban++;\n          int numUrbanizedNeighbors=getUrbanNeighbors(tile).size();\n          if (numUrbanizedNeighbors > 1 && numUrbanizedNeighbors < 6) {\n            spreadingCenters.add(tile);\n          }\n        }\n else {\n          numNonUrban++;\n        }\n      }\n    }\n    Grower grower=new Grower();\n    schedule.scheduleRepeating(grower);\n  }\n catch (  FileNotFoundException ex) {\n    Logger.getLogger(SleuthWorld.class.getName()).log(Level.SEVERE,null,ex);\n  }\n}\n", "nl": "Starts a new run of the simulation. Reads in the data and schedules the growth rules to fire every turn."}
{"code": "void destroy() throws IOException {\n  if (raf != null) {\n    raf.close();\n  }\n  if (out != null) {\n    out.close();\n  }\n}\n", "nl": "Closes the underlying stream/file without finishing the archive, the result will likely be a corrupt archive. <p>This method only exists to support tests that generate corrupt archives so they can clean up any temporary files.</p>"}
{"code": "public static boolean isValidSpecName(final String aSpecName){\n  String identifier=getIdentifier(aSpecName);\n  return aSpecName.equals(identifier);\n}\n", "nl": "Checks a specification name for its validity WRT the parser identifier definition"}
{"code": "@SuppressFBWarnings(value=\"EI_EXPOSE_REP2\",justification=\"This class is designed to simply wrap an object array.\") public ArrayTuple(final Object[] tuple){\n  this.tuple=tuple;\n}\n", "nl": "Create an <code>ArrayTuple</code> backed by the given array."}
{"code": "@Override protected Action[] createActions(){\n  return new Action[]{getOKAction()};\n}\n", "nl": "Override so only OK action is created and not Cancel"}
{"code": "private int pop(){\n  if (outputStackTop > 0) {\n    return outputStack[--outputStackTop];\n  }\n else {\n    return STACK | -(--owner.inputStackTop);\n  }\n}\n", "nl": "Pops a type from the output frame stack and returns its value."}
{"code": "public void keyReleased(KeyEvent e){\n  if (e.getKeyCode() == KeyEvent.VK_ESCAPE)   setText(m_initialText);\n}\n", "nl": "Key Released if Escape restore old Text."}
{"code": "public boolean containsPrefix(String prefix){\n  return m_Root.contains(prefix);\n}\n", "nl": "checks whether the given prefix is stored in the trie"}
{"code": "public int findReferencePosition(int offset,int nextToken){\n  boolean danglingElse=false;\n  boolean unindent=false;\n  boolean indent=false;\n  boolean matchBrace=false;\n  boolean matchParen=false;\n  boolean matchCase=false;\n  if (offset < fDocument.getLength()) {\n    try {\n      IRegion line=fDocument.getLineInformationOfOffset(offset);\n      int lineOffset=line.getOffset();\n      int prevPos=Math.max(offset - 1,0);\n      boolean isFirstTokenOnLine=fDocument.get(lineOffset,prevPos + 1 - lineOffset).trim().length() == 0;\n      int prevToken=fScanner.previousToken(prevPos,JavaHeuristicScanner.UNBOUND);\n      boolean bracelessBlockStart=fScanner.isBracelessBlockStart(prevPos,JavaHeuristicScanner.UNBOUND);\nswitch (nextToken) {\ncase Symbols.TokenELSE:\n        danglingElse=true;\n      break;\ncase Symbols.TokenCASE:\ncase Symbols.TokenDEFAULT:\n    if (isFirstTokenOnLine)     matchCase=true;\n  break;\ncase Symbols.TokenLBRACE:\nif (bracelessBlockStart && !fPrefs.prefIndentBracesForBlocks) unindent=true;\n else if ((prevToken == Symbols.TokenCOLON || prevToken == Symbols.TokenEQUAL || prevToken == Symbols.TokenRBRACKET) && !fPrefs.prefIndentBracesForArrays) unindent=true;\n else if (!bracelessBlockStart && fPrefs.prefIndentBracesForMethods) indent=true;\nbreak;\ncase Symbols.TokenRBRACE:\nif (isFirstTokenOnLine) matchBrace=true;\nbreak;\ncase Symbols.TokenRPAREN:\nif (isFirstTokenOnLine) matchParen=true;\nbreak;\n}\n}\n catch (BadLocationException e) {\n}\n}\n else {\ndanglingElse=false;\n}\nint ref=findReferencePosition(offset,danglingElse,matchBrace,matchParen,matchCase);\nif (unindent) fIndent--;\nif (indent) fIndent++;\nreturn ref;\n}\n", "nl": "Returns the reference position regarding to indentation for <code>position</code>, or <code>NOT_FOUND</code>. <p>If <code>peekNextChar</code> is <code>true</code>, the next token after <code>offset</code> is read and taken into account when computing the indentation. Currently, if the next token is the first token on the line (i.e. only preceded by whitespace), the following tokens are specially handled: <ul> <li><code>switch</code> labels are indented relative to the switch block</li> <li>opening curly braces are aligned correctly with the introducing code</li> <li>closing curly braces are aligned properly with the introducing code of the matching opening brace</li> <li>closing parenthesis' are aligned with their opening peer</li> <li>the <code>else</code> keyword is aligned with its <code>if</code>, anything else is aligned normally (i.e. with the base of any introducing statements).</li> <li>if there is no token on the same line after <code>offset</code>, the indentation is the same as for an <code>else</code> keyword</li> </ul>"}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase UmplePackage.METHOD_DECLARATOR___METHOD_NAME_1:\n    return METHOD_NAME_1_EDEFAULT == null ? methodName_1 != null : !METHOD_NAME_1_EDEFAULT.equals(methodName_1);\ncase UmplePackage.METHOD_DECLARATOR___PARAMETER_LIST_1:\n  return parameterList_1 != null && !parameterList_1.isEmpty();\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private boolean isRolloverInstallment(Installment installment){\n  Date systemCreatedDate=basicProperty.getProperty().getCreatedDate();\n  return propertyTaxUtil.between(new Date(),installment.getFromDate(),installment.getToDate()) && !propertyTaxUtil.between(systemCreatedDate,installment.getFromDate(),installment.getToDate());\n}\n", "nl": "Returns true if the installment passed is a rollover installment else returns false"}
{"code": "private int deleteData(){\n  StringBuilder updateSQL=new StringBuilder();\n  updateSQL.append(\"DELETE FROM M_ForecastLine WHERE M_Forecast_ID=\").append(p_M_Forecast_ID);\n  return DB.executeUpdateEx(updateSQL.toString(),get_TrxName());\n}\n", "nl": "Delete forecast line"}
{"code": "private static void validate(File file,byte[] actual) throws IOException {\n  String mode=Settings.getFileProtectionMode();\n  File digestFile=getDigestFile(file);\n  if (digestFile.exists()) {\n    byte[] expected=loadDigest(file);\n    if (!MessageDigest.isEqual(actual,expected)) {\n      throw new ValidationException(file,\"digest does not match\");\n    }\n  }\n else {\n    if (mode.equalsIgnoreCase(STRICT_MODE)) {\n      throw new ValidationException(file,\"no digest file\");\n    }\n else {\n      System.err.println(\"no digest file exists to validate \" + file);\n    }\n  }\n}\n", "nl": "Validates the file."}
{"code": "public static boolean equals(int[] list1,int[] list2){\n  if (list1.length != list2.length)   return false;\n  sort(list1);\n  sort(list2);\n  for (int i=0; i < list1.length; i++) {\n    if (list1[i] != list2[i])     return false;\n  }\n  return true;\n}\n", "nl": "equals returns true if the elements in  both lists are equal. False otherwise"}
{"code": "public static HashMap<ICondition,Boolean> testAllConditionsRecursive(final HashSet<ICondition> rules,HashMap<ICondition,Boolean> allConditionsTestedSoFar,final IDelegateBridge aBridge){\n  if (allConditionsTestedSoFar == null) {\n    allConditionsTestedSoFar=new HashMap<>();\n  }\n  for (  final ICondition c : rules) {\n    if (!allConditionsTestedSoFar.containsKey(c)) {\n      testAllConditionsRecursive(new HashSet<>(c.getConditions()),allConditionsTestedSoFar,aBridge);\n      allConditionsTestedSoFar.put(c,c.isSatisfied(allConditionsTestedSoFar,aBridge));\n    }\n  }\n  return allConditionsTestedSoFar;\n}\n", "nl": "Takes the list of ICondition that getAllConditionsRecursive generates, and tests each of them, mapping them one by one to their boolean value."}
{"code": "public List<TriggerKey> selectTriggersInState(Connection conn,String state) throws SQLException {\n  PreparedStatement ps=null;\n  ResultSet rs=null;\n  try {\n    ps=conn.prepareStatement(rtp(SELECT_TRIGGERS_IN_STATE));\n    ps.setString(1,state);\n    rs=ps.executeQuery();\n    LinkedList<TriggerKey> list=new LinkedList<TriggerKey>();\n    while (rs.next()) {\n      list.add(triggerKey(rs.getString(1),rs.getString(2)));\n    }\n    return list;\n  }\n  finally {\n    closeResultSet(rs);\n    closeStatement(ps);\n  }\n}\n", "nl": "<p> Select all of the triggers in a given state. </p>"}
{"code": "public static void main(String[] args) throws IOException {\n  process_command_line(args);\n  info=new JarInfo();\n  if (printVersion) {\n    doPrintVersion();\n  }\n  if (printHelp) {\n    doPrintHelp();\n  }\n}\n", "nl": "This main simply prints the version information to allow users to identify the build version of the Jar."}
{"code": "@Override public boolean contains(int x,int y){\n  Rectangle r=gridElement.getRectangle();\n  if (gridElement.isSelectableOn(new Point(r.getX() + x,r.getY() + y))) {\n    return ElementUtils.checkForOverlap(gridElement,new Point(x,y));\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Must be overwritten because Swing sometimes uses this method instead of contains(Point)"}
{"code": "@SuppressWarnings(\"unchecked\") default T addDependency(String gav) throws Exception {\n  addAsLibrary(ArtifactLookup.get().artifact(gav));\n  return (T)this;\n}\n", "nl": "Add a single Maven dependency into the Archive. The following dependency formats are supported: groupId:artifactId groupId:artifactId:version groupId:artifactId:packaging:version groupId:artifactId:packaging:version:classifier"}
{"code": "@Override public void init(FilterConfig fConfig) throws ServletException {\n  this.filterConfig=fConfig;\n  this.attribute=fConfig.getInitParameter(\"attribute\");\n}\n", "nl": "Place this filter into service."}
{"code": "public int size(){\n  return n;\n}\n", "nl": "Returns the number of strings in the set."}
{"code": "public List(Vector items){\n  this(new DefaultListModel(items));\n}\n", "nl": "Creates a new instance of List"}
{"code": "public static void printf(Locale locale,String format,Object... args){\n  out.printf(locale,format,args);\n  out.flush();\n}\n", "nl": "Print a formatted string to standard output using the specified locale, format string, and arguments, and flush standard output."}
{"code": "private boolean makeServiceNameUnique(ServiceInfoImpl info){\n  final String originalQualifiedName=info.getKey();\n  final long now=System.currentTimeMillis();\n  boolean collision;\n  do {\n    collision=false;\n    for (    DNSEntry dnsEntry : this.getCache().getDNSEntryList(info.getKey())) {\n      if (DNSRecordType.TYPE_SRV.equals(dnsEntry.getRecordType()) && !dnsEntry.isExpired(now)) {\n        final DNSRecord.Service s=(DNSRecord.Service)dnsEntry;\n        if (s.getPort() != info.getPort() || !s.getServer().equals(_localHost.getName())) {\n          if (logger.isLoggable(Level.FINER)) {\n            logger.finer(\"makeServiceNameUnique() JmDNS.makeServiceNameUnique srv collision:\" + dnsEntry + \" s.server=\"+ s.getServer()+ \" \"+ _localHost.getName()+ \" equals:\"+ (s.getServer().equals(_localHost.getName())));\n          }\n          info.setName(NameRegister.Factory.getRegistry().incrementName(_localHost.getInetAddress(),info.getName(),NameRegister.NameType.SERVICE));\n          collision=true;\n          break;\n        }\n      }\n    }\n    final ServiceInfo selfService=_services.get(info.getKey());\n    if (selfService != null && selfService != info) {\n      info.setName(NameRegister.Factory.getRegistry().incrementName(_localHost.getInetAddress(),info.getName(),NameRegister.NameType.SERVICE));\n      collision=true;\n    }\n  }\n while (collision);\n  return !(originalQualifiedName.equals(info.getKey()));\n}\n", "nl": "Generate a possibly unique name for a service using the information we have in the cache."}
{"code": "public static String toString(final BOp bop){\n  final StringBuilder sb=new StringBuilder();\n  toString(bop,sb,0);\n  sb.setLength(sb.length() - 1);\n  return sb.toString();\n}\n", "nl": "Pretty print a bop."}
{"code": "public WeakHashMapPro(){\n  this(DEFAULT_INITIAL_CAPACITY,DEFAULT_LOAD_FACTOR);\n}\n", "nl": "Constructs a new, empty <tt>WeakHashMap</tt> with the default initial capacity (16) and load factor (0.75)."}
{"code": "public SuggestWordQueue(int size,Comparator<SuggestWord> comparator){\n  super(size);\n  this.comparator=comparator;\n}\n", "nl": "Specify the size of the queue and the comparator to use for sorting."}
{"code": "public Object[] values(){\n  Object[] values=new Object[this.size()];\n  Entry[] table=this.table;\n  int i=0;\n  for (int bucket=0; bucket < table.length; bucket++) {\n    for (Entry e=table[bucket]; e != null; e=e.next) {\n      values[i++]=e.value;\n    }\n  }\n  return values;\n}\n", "nl": "Returns all of the objects in the map"}
{"code": "private void subscribe(){\n  String topic=((EditText)connectionDetails.findViewById(R.id.topic)).getText().toString();\n  ((EditText)connectionDetails.findViewById(R.id.topic)).getText().clear();\n  RadioGroup radio=(RadioGroup)connectionDetails.findViewById(R.id.qosSubRadio);\n  int checked=radio.getCheckedRadioButtonId();\n  int qos=ActivityConstants.defaultQos;\nswitch (checked) {\ncase R.id.qos0:\n    qos=0;\n  break;\ncase R.id.qos1:\nqos=1;\nbreak;\ncase R.id.qos2:\nqos=2;\nbreak;\n}\ntry {\nString[] topics=new String[1];\ntopics[0]=topic;\nConnections.getInstance(context).getConnection(clientHandle).getClient().subscribe(topic,qos,null,new ActionListener(context,Action.SUBSCRIBE,clientHandle,topics));\n}\n catch (MqttSecurityException e) {\nLog.e(this.getClass().getCanonicalName(),\"Failed to subscribe to\" + topic + \" the client with the handle \"+ clientHandle,e);\n}\ncatch (MqttException e) {\nLog.e(this.getClass().getCanonicalName(),\"Failed to subscribe to\" + topic + \" the client with the handle \"+ clientHandle,e);\n}\n}\n", "nl": "Subscribe to a topic that the user has specified"}
{"code": "public static int extractLag_Display(String laggedFactor){\n  int colonIndex=laggedFactor.indexOf(\":L\");\n  int lag=Integer.parseInt(laggedFactor.substring(colonIndex + 2,laggedFactor.length()));\n  return lag;\n}\n", "nl": "Extracts the lag from the lagged factor name string. </p> precondition laggedFactor is a legal lagged factor."}
{"code": "public boolean phaseHasTurns(IGame.Phase thisPhase){\nswitch (thisPhase) {\ncase PHASE_SET_ARTYAUTOHITHEXES:\ncase PHASE_DEPLOY_MINEFIELDS:\ncase PHASE_DEPLOYMENT:\ncase PHASE_MOVEMENT:\ncase PHASE_FIRING:\ncase PHASE_PHYSICAL:\ncase PHASE_TARGETING:\ncase PHASE_OFFBOARD:\n    return true;\ndefault :\n  return false;\n}\n}\n", "nl": "Returns true if this phase has turns. If false, the phase is simply waiting for everybody to declare \"done\"."}
{"code": "public static String marshal(Object obj) throws JAXBException {\n  StringWriter writer=new StringWriter();\n  JAXBUtils.getJAXBContext().createMarshaller().marshal(obj,writer);\n  return writer.toString();\n}\n", "nl": "Serialize the given object to XML"}
{"code": "public JSONObject putOpt(String key,Object value) throws JSONException {\n  if (key != null && value != null) {\n    this.put(key,value);\n  }\n  return this;\n}\n", "nl": "Put a key/value pair in the JSONObject, but only if the key and the value are both non-null."}
{"code": "private static Map<String,String> extractMdc(Map<String,String> map,List<String> keys){\n  return keys.stream().filter(null).collect(Collectors.toMap(null,null));\n}\n", "nl": "Get list of fields and populate values into map (if value for key is not empty"}
{"code": "public ExpressionsAdapterFactory(){\n  if (modelPackage == null) {\n    modelPackage=ExpressionsPackage.eINSTANCE;\n  }\n}\n", "nl": "Creates an instance of the adapter factory. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static NurbsCurve createSemiCircle(Origin3D o,float r){\n  Vec4D[] cp=new Vec4D[4];\n  cp[0]=new Vec4D(o.xAxis.scale(r),1);\n  cp[3]=cp[0].getInvertedXYZ();\n  cp[0].addXYZSelf(o.origin);\n  cp[3].addXYZSelf(o.origin);\n  cp[1]=new Vec4D(o.xAxis.add(o.yAxis).scaleSelf(r).addSelf(o.origin),0.5f);\n  cp[2]=new Vec4D(o.xAxis.getInverted().addSelf(o.yAxis).scaleSelf(r).addSelf(o.origin),0.5f);\n  float[] u={0,0,0,0.5f,1,1,1};\n  return new BasicNurbsCurve(cp,u,2);\n}\n", "nl": "Create a semi-circle NurbsCurve around the given Origin with radius r."}
{"code": "public synchronized void removePropertyChangeListener(PropertyChangeListener listener){\n  listenerList.remove(listener);\n}\n", "nl": "Removes PropertyChangeListener from the list of listeners."}
{"code": "@Uninterruptible @Pure public byte parseForArrayElementTypeCode(){\n  if (VM.VerifyAssertions) {\n    VM._assert(val.length > 1,\"An array descriptor has at least two characters\");\n    VM._assert(val[0] == '[',\"An array descriptor must start with '['\");\n  }\n  return val[1];\n}\n", "nl": "Parse \"this\" array descriptor to obtain type code for its element type. this: descriptor - something like \"[Ljava/lang/String;\" or \"[I\""}
{"code": "public ImageRotationCalculatorImpl(OrientationManager orientationManager,int sensorOrientationDegrees,boolean frontFacing){\n  mSensorOrientationDegrees=sensorOrientationDegrees;\n  mFrontFacing=frontFacing;\n  mOrientationManager=orientationManager;\n}\n", "nl": "Create a calculator with the given hardware properties of the camera."}
{"code": "public void stop(){\n  messageLogger.stop();\n}\n", "nl": "Stops the message logger."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private boolean shouldAddImports(){\n  if (isInJavadoc() && !isJavadocProcessingEnabled())   return false;\n  return true;\n}\n", "nl": "Returns <code>true</code> if imports should be added. The return value depends on the context and preferences only and does not take into account the contents of the compilation unit or the kind of proposal. Even if <code>true</code> is returned, there may be cases where no imports are added for the proposal. For example: <ul> <li>when completing within the import section</li> <li>when completing informal javadoc references (e.g. within <code>&lt;code&gt;</code> tags)</li> <li>when completing a type that conflicts with an existing import</li> <li>when completing an implicitly imported type (same package, <code>java.lang</code> types)</li> </ul> <p> The decision whether a qualified type or the simple type name should be inserted must take into account these different scenarios. </p>"}
{"code": "public synchronized void decrement(){\n  tempSet.set(0,dimension);\n  for (int q=0; q < votingRecord.size(); q++) {\n    votingRecord.get(q).xor(tempSet);\n    tempSet.and(votingRecord.get(q));\n  }\n}\n", "nl": "Decrement every dimension. Assumes at least one count in each dimension i.e: no underflow check currently - will wreak havoc with zero counts"}
{"code": "public TimeLagGraphWorkbench(){\n  this(new TimeLagGraph());\n}\n", "nl": "Constructs a new workbench with an empty graph; useful if another graph will be set later."}
{"code": "@Override public void registerPackages(ResourceSet resourceSet){\n  super.registerPackages(resourceSet);\n  if (!isInWorkspace(com.github.lbroudoux.dsl.eip.EipPackage.class)) {\n    resourceSet.getPackageRegistry().put(com.github.lbroudoux.dsl.eip.EipPackage.eINSTANCE.getNsURI(),com.github.lbroudoux.dsl.eip.EipPackage.eINSTANCE);\n  }\n}\n", "nl": "This can be used to update the resource set's package registry with all needed EPackages."}
{"code": "public boolean cmd_save(boolean manualCmd){\n  if (m_curAPanelTab != null)   manualCmd=false;\n  log.config(\"Manual=\" + manualCmd);\n  m_errorDisplayed=false;\n  m_curGC.stopEditor(true);\n  m_curGC.acceptEditorChanges();\n  if (m_curAPanelTab != null) {\n    m_curAPanelTab.saveData();\n    aSave.setEnabled(false);\n  }\n  if (m_curTab.getCommitWarning().length() > 0 && m_curTab.needSave(true,false))   if (!ADialog.ask(m_curWindowNo,this,\"SaveChanges?\",m_curTab.getCommitWarning()))   return false;\n  boolean retValue=m_curTab.dataSave(manualCmd);\n  if (manualCmd && !retValue && !m_errorDisplayed) {\n    showLastError();\n  }\n  if (retValue)   m_curGC.rowChanged(true,m_curTab.getRecord_ID());\n  if (manualCmd) {\n    m_curGC.dynamicDisplay(0);\n    if (!isNested)     m_window.setTitle(getTitle());\n  }\n  if (m_curGC.isDetailGrid() && retValue) {\n    m_curGC.getGCParent().refreshMTab(m_curGC);\n  }\n  return retValue;\n}\n", "nl": "If required ask if you want to save and save it"}
{"code": "public synchronized int size(){\n  return this.stack.size();\n}\n", "nl": "get the size of a stack"}
{"code": "public static long readVarLong(ByteBuffer buff){\n  int shift=0;\n  long l=0;\n  while (true) {\n    byte b=(byte)buff.get();\n    l|=(long)(b & 0x7F) << shift;\n    shift+=7;\n    if (b >= 0) {\n      return l;\n    }\n  }\n}\n", "nl": "Reads a VarLong."}
{"code": "@Override public int prepare(Xid xid) throws XAException {\n  if (isDebugEnabled()) {\n    debugCode(\"prepare(\" + JdbcXid.toString(xid) + \");\");\n  }\n  checkOpen();\n  if (!currentTransaction.equals(xid)) {\n    throw new XAException(XAException.XAER_INVAL);\n  }\n  try (Statement stat=physicalConn.createStatement()){\n    stat.execute(\"PREPARE COMMIT \" + JdbcXid.toString(xid));\n    prepared=true;\n  }\n catch (  SQLException e) {\n    throw convertException(e);\n  }\n  return XA_OK;\n}\n", "nl": "Prepare a transaction."}
{"code": "public static void main(String[] args){\n  System.out.println(PROPERTIES);\n}\n", "nl": "Only for testing"}
{"code": "private static void deleteRecursiveSilent(CarbonFile f){\n  if (f.isDirectory()) {\n    if (f.listFiles() != null) {\n      for (      CarbonFile c : f.listFiles()) {\n        deleteRecursiveSilent(c);\n      }\n    }\n  }\n  if (f.exists() && !f.delete()) {\n    return;\n  }\n}\n", "nl": "this method will delete the folders recursively"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:29:44.177 -0500\",hash_original_method=\"E35FF664DA486BBF1CFE86498473FB9B\",hash_generated_method=\"81AF2D5B35CA402304449ACA5C911EFF\") public static void disableVsync(){\n  nDisableVsync();\n}\n", "nl": "Disables v-sync. For performance testing only."}
{"code": "public boolean similar(Object other){\n  if (!(other instanceof JSONArray)) {\n    return false;\n  }\n  int len=this.length();\n  if (len != ((JSONArray)other).length()) {\n    return false;\n  }\n  for (int i=0; i < len; i+=1) {\n    Object valueThis=this.get(i);\n    Object valueOther=((JSONArray)other).get(i);\n    if (valueThis instanceof JSONObject) {\n      if (!((JSONObject)valueThis).similar(valueOther)) {\n        return false;\n      }\n    }\n else     if (valueThis instanceof JSONArray) {\n      if (!((JSONArray)valueThis).similar(valueOther)) {\n        return false;\n      }\n    }\n else     if (!valueThis.equals(valueOther)) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Determine if two JSONArrays are similar. They must contain similar sequences."}
{"code": "@Override public boolean eIsSet(int featureID){\nswitch (featureID) {\ncase N4JSPackage.IDENTIFIER_REF__STRICT_MODE:\n    return strictMode != STRICT_MODE_EDEFAULT;\ncase N4JSPackage.IDENTIFIER_REF__ID:\n  return id != null;\ncase N4JSPackage.IDENTIFIER_REF__ID_AS_TEXT:\nreturn ID_AS_TEXT_EDEFAULT == null ? idAsText != null : !ID_AS_TEXT_EDEFAULT.equals(idAsText);\n}\nreturn super.eIsSet(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void processBinaryMeta(CacheTypeMetadata meta,TypeDescriptor d) throws IgniteCheckedException {\n  Map<String,String> aliases=meta.getAliases();\n  if (aliases == null)   aliases=Collections.emptyMap();\n  for (  Map.Entry<String,Class<?>> entry : meta.getAscendingFields().entrySet()) {\n    BinaryProperty prop=buildBinaryProperty(entry.getKey(),entry.getValue(),aliases);\n    d.addProperty(prop,false);\n    String idxName=prop.name() + \"_idx\";\n    d.addIndex(idxName,isGeometryClass(prop.type()) ? GEO_SPATIAL : SORTED);\n    d.addFieldToIndex(idxName,prop.name(),0,false);\n  }\n  for (  Map.Entry<String,Class<?>> entry : meta.getDescendingFields().entrySet()) {\n    BinaryProperty prop=buildBinaryProperty(entry.getKey(),entry.getValue(),aliases);\n    d.addProperty(prop,false);\n    String idxName=prop.name() + \"_idx\";\n    d.addIndex(idxName,isGeometryClass(prop.type()) ? GEO_SPATIAL : SORTED);\n    d.addFieldToIndex(idxName,prop.name(),0,true);\n  }\n  for (  String txtIdx : meta.getTextFields()) {\n    BinaryProperty prop=buildBinaryProperty(txtIdx,String.class,aliases);\n    d.addProperty(prop,false);\n    d.addFieldToTextIndex(prop.name());\n  }\n  Map<String,LinkedHashMap<String,IgniteBiTuple<Class<?>,Boolean>>> grps=meta.getGroups();\n  if (grps != null) {\n    for (    Map.Entry<String,LinkedHashMap<String,IgniteBiTuple<Class<?>,Boolean>>> entry : grps.entrySet()) {\n      String idxName=entry.getKey();\n      LinkedHashMap<String,IgniteBiTuple<Class<?>,Boolean>> idxFields=entry.getValue();\n      int order=0;\n      for (      Map.Entry<String,IgniteBiTuple<Class<?>,Boolean>> idxField : idxFields.entrySet()) {\n        BinaryProperty prop=buildBinaryProperty(idxField.getKey(),idxField.getValue().get1(),aliases);\n        d.addProperty(prop,false);\n        Boolean descending=idxField.getValue().get2();\n        d.addFieldToIndex(idxName,prop.name(),order,descending != null && descending);\n        order++;\n      }\n    }\n  }\n  for (  Map.Entry<String,Class<?>> entry : meta.getQueryFields().entrySet()) {\n    BinaryProperty prop=buildBinaryProperty(entry.getKey(),entry.getValue(),aliases);\n    if (!d.props.containsKey(prop.name()))     d.addProperty(prop,false);\n  }\n}\n", "nl": "Processes declarative metadata for binary object."}
{"code": "private static boolean isCorbaUrl(String url){\n  return url.startsWith(\"iiop://\") || url.startsWith(\"iiopname://\") || url.startsWith(\"corbaname:\");\n}\n", "nl": "These are the URL schemes that need to be processed. IOR and corbaloc URLs can be passed directly to ORB.string_to_object()"}
{"code": "public T caseAnonymous_program_1_(Anonymous_program_1_ object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>Anonymous program 1</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public static BinaryExpression newInitializationExpression(String variable,ClassNode type,Expression rhs){\n  VariableExpression lhs=new VariableExpression(variable);\n  if (type != null) {\n    lhs.setType(type);\n  }\n  Token operator=Token.newPlaceholder(Types.ASSIGN);\n  return new BinaryExpression(lhs,operator,rhs);\n}\n", "nl": "Creates variable initialization expression in which the specified expression is written into the specified variable name."}
{"code": "@Override public boolean containsValue(Object value){\n  if (value == null)   return containsNullValue();\n  Entry[] tab=table;\n  for (int i=0; i < tab.length; i++)   for (Entry e=tab[i]; e != null; e=e.next)   if (value.equals(e.value))   return true;\n  return false;\n}\n", "nl": "Returns <tt>true</tt> if this map maps one or more keys to the specified value."}
{"code": "public String toString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(\"DbConnectionConfig[\");\n  buffer.append(\"cntByDriver = \").append(m_cntByDriver);\n  buffer.append(\", cntParam = \").append(m_cntParam);\n  buffer.append(\", url = \").append(m_url);\n  buffer.append(\", user = \").append(m_user);\n  buffer.append(\", pwd = \").append(m_pwd);\n  buffer.append(\"]\");\n  return buffer.toString();\n}\n", "nl": "toString methode: creates a String representation of the object"}
{"code": "DocCollection createCollection(int nSlices,DocRouter router){\n  List<Range> ranges=router.partitionRange(nSlices,router.fullRange());\n  Map<String,Slice> slices=new HashMap<>();\n  for (int i=0; i < ranges.size(); i++) {\n    Range range=ranges.get(i);\n    Slice slice=new Slice(\"shard\" + (i + 1),null,map(\"range\",range));\n    slices.put(slice.getName(),slice);\n  }\n  DocCollection coll=new DocCollection(\"collection1\",slices,null,router);\n  return coll;\n}\n", "nl": "public void testPrintHashCodes() throws Exception { // from negative to positive, the upper bits of the hash ranges should be // shard1: 11 // shard2: 10 // shard3: 00 // shard4: 01 String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"}; for (int i = 0; i<26; i++) { String id  = new String(Character.toChars('a'+i)); int hash = hash(id); System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30) + \" shard=\"+highBitsToShard[hash>>>30]); } }"}
{"code": "public ESRIPointRecord(byte b[],int off) throws IOException {\n  super(b,off);\n  int ptr=off + 8;\n  int shapeType=readLEInt(b,ptr);\n  ptr+=4;\n  if (shapeType != SHAPE_TYPE_POINT) {\n    throw new IOException(\"Invalid point record.  Expected shape \" + \"type \" + SHAPE_TYPE_POINT + \" but found \"+ shapeType);\n  }\n  x=readLEDouble(b,ptr);\n  ptr+=8;\n  y=readLEDouble(b,ptr);\n  ptr+=8;\n}\n", "nl": "Initialize a point record from the given buffer."}
{"code": "public boolean isBeanSupportEnabled(){\n  return beanSupportEnabled;\n}\n", "nl": "Returns true if this instance supports extracting/setting bean properties."}
{"code": "public NominalToNumericModel(ExampleSet exampleSet,int codingType){\n  super(exampleSet);\n  this.codingType=codingType;\n}\n", "nl": "Constructs a new model. Use this ctor to create a model for value encoding."}
{"code": "public static boolean isNullOrEmpty(String... input){\n  if (input == null) {\n    return true;\n  }\n  for (  String s : input) {\n    if (s == null || s.isEmpty()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks if any of the String arguments is null or empty."}
{"code": "public void test_DELETE_accessPath_delete_c_nothingMatched() throws Exception {\n  if (TestMode.quads != getTestMode())   return;\n  doInsertbyURL(\"POST\",packagePath + \"test_delete_by_access_path.trig\");\n  final long mutationResult=doDeleteWithAccessPath(null,null,null,new URIImpl(\"http://xmlns.com/foaf/0.1/XXX\"));\n  assertEquals(0,mutationResult);\n}\n", "nl": "Delete using an access path with the context position bound."}
{"code": "public synchronized boolean makeProxyClass(Class clazz) throws CannotCompileException, NotFoundException {\n  String classname=clazz.getName();\n  if (proxyClasses.get(classname) != null)   return false;\n else {\n    CtClass ctclazz=produceProxyClass(classPool.get(classname),clazz);\n    proxyClasses.put(classname,ctclazz);\n    modifySuperclass(ctclazz);\n    return true;\n  }\n}\n", "nl": "Makes a proxy class.  The produced class is substituted for the original class."}
{"code": "private static BufferedImage cutByShort(String source) throws UtilException {\n  try {\n    BufferedImage src=ImageIO.read(new File(source));\n    int width=src.getWidth();\n    int height=src.getHeight();\n    int size=width > height ? height : width;\n    BufferedImage dest=new BufferedImage(size,size,BufferedImage.TYPE_INT_RGB);\n    Graphics g=dest.getGraphics();\n    g.drawImage(src,0,0,size,size,0,0,size,size,null);\n    return dest;\n  }\n catch (  IOException e) {\n    throw new UtilException(ErrorCodeDef.IMAGE_ZOOM_10020,e);\n  }\n}\n", "nl": "Description: <br>"}
{"code": "static void copy32bit(byte[] src,int isrc,byte[] dest,int idest){\n  dest[idest]=src[isrc];\n  dest[idest + 1]=src[isrc + 1];\n  dest[idest + 2]=src[isrc + 2];\n  dest[idest + 3]=src[isrc + 3];\n}\n", "nl": "Copies a 32bit integer."}
{"code": "public static <E>ImmutableList<E> of(E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9,E e10,E e11){\n  return construct(e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11);\n}\n", "nl": "Returns an immutable list containing the given elements, in order."}
{"code": "@Override public double totalEstimatedQuantityForPreviousREs(final Long woActivityId,Long estimateId,final Long activityId,final WorkOrder workOrder){\n  if (estimateId == null)   estimateId=-1l;\n  Object[] params=null;\n  Double estQuantity=null;\n  params=new Object[]{estimateId,workOrder,workOrder,woActivityId,activityId};\n  estQuantity=(Double)genericService.findByNamedQuery(\"totalEstimatedQuantityInRE\",params);\n  Double estQuantityRE=null;\n  params=new Object[]{estimateId,workOrder,workOrder,activityId};\n  estQuantityRE=(Double)genericService.findByNamedQuery(\"totalEstimatedQuantityForPreviousREs\",params);\n  if (estQuantity != null && estQuantityRE != null)   estQuantity=estQuantity + estQuantityRE;\n  if (estQuantity == null && estQuantityRE != null)   estQuantity=estQuantityRE;\n  if (estQuantity == null)   return 0.0d;\n else   return estQuantity.doubleValue();\n}\n", "nl": "Similar to totalEstimatedQuantityForRE but will consider only previous REs and not all REs"}
{"code": "public Element(String name,String id,XmlTag xml){\n  final Matcher matcher=sIdPattern.matcher(id);\n  if (matcher.find() && matcher.groupCount() > 1) {\n    this.id=matcher.group(2);\n    String androidNS=matcher.group(1);\n    this.isAndroidNS=!(androidNS == null || androidNS.length() == 0);\n  }\n  if (this.id == null) {\n    throw new IllegalArgumentException(\"Invalid format of view id\");\n  }\n  String[] packages=name.split(\"\\\\.\");\n  if (packages.length > 1) {\n    this.nameFull=name;\n    this.name=packages[packages.length - 1];\n  }\n else {\n    this.nameFull=null;\n    this.name=name;\n  }\n  this.xml=xml;\n  XmlAttribute clickable=xml.getAttribute(\"android:clickable\",null);\n  boolean hasClickable=clickable != null && clickable.getValue() != null && clickable.getValue().equals(\"true\");\n  String xmlName=xml.getName();\n  if (xmlName.contains(\"RadioButton\")) {\n  }\n else {\n    if ((xmlName.contains(\"ListView\") || xmlName.contains(\"GridView\")) && hasClickable) {\n      isItemClickable=true;\n    }\n else     if (xmlName.contains(\"Button\") || hasClickable) {\n      isClickable=true;\n    }\n  }\n  isEditText=xmlName.contains(\"EditText\");\n}\n", "nl": "Constructs new element"}
{"code": "public void run(Throwing.Runnable runnable){\n  wrap(runnable).run();\n}\n", "nl": "Attempts to run the given runnable."}
{"code": "@Override public String validateName(String name,boolean increaseNumber){\n  String result=name;\n  if (!isOKImpl(name,true).isEmpty() && !increaseNumber || name.isEmpty()) {\n    return \"\";\n  }\n  int i=1;\n  while (!isOKImpl(result,true).isEmpty()) {\n    result=name + i;\n    i++;\n  }\n  return result;\n}\n", "nl": "Validates name to be suggested in context"}
{"code": "public boolean isValid(){\n  if (mXVals == null || mXVals.size() <= 0 || mDataSets == null || mDataSets.size() < 1 || mDataSets.get(0).getYVals().size() <= 0) {\n    return false;\n  }\n else {\n    return true;\n  }\n}\n", "nl": "Checks if the ChartData object contains valid data"}
{"code": "public static void closeRegistersQuery(String sessionID,Integer bookID) throws BookException, SessionException, ValidationException {\n  Validator.validate_String_NotNull_LengthMayorZero(sessionID,ValidationException.ATTRIBUTE_SESSION);\n  Validator.validate_Integer(bookID,ValidationException.ATTRIBUTE_BOOK);\n  try {\n    CacheBag cacheBag=CacheFactory.getCacheInterface().getCacheEntry(sessionID);\n    if (!cacheBag.containsKey(bookID)) {\n      throw new BookException(BookException.ERROR_BOOK_NOT_OPEN);\n    }\n    THashMap bookInformation=(THashMap)cacheBag.get(bookID);\n    AxSfQueryResults queryResults=(AxSfQueryResults)bookInformation.get(AXSF_QUERY_RESULTS);\n    if (queryResults == null) {\n      throw new BookException(BookException.ERROR_QUERY_NOT_OPEN);\n    }\n else {\n      bookInformation.remove(AXSF_QUERY_RESULTS);\n    }\n  }\n catch (  SessionException sE) {\n    throw sE;\n  }\ncatch (  BookException bE) {\n    throw bE;\n  }\ncatch (  Exception e) {\n    log.error(\"Impossible to close the book [\" + bookID + \"] for the session [\"+ sessionID+ \"]\",e);\n    throw new BookException(BookException.ERROR_CANNOT_CLOSE_BOOK);\n  }\n}\n", "nl": "PUBLIC METHOD"}
{"code": "public NaiveKMeans(DistanceMetric dm,SeedSelection seedSelection){\n  this(dm,seedSelection,new XORWOW());\n}\n", "nl": "Creates a new naive k-Means cluster"}
{"code": "private static int checkFieldTypeSignature(final String signature,int pos){\nswitch (getChar(signature,pos)) {\ncase 'L':\n    return checkClassTypeSignature(signature,pos);\ncase '[':\n  return checkTypeSignature(signature,pos + 1);\ndefault :\nreturn checkTypeVariableSignature(signature,pos);\n}\n}\n", "nl": "Checks a field type signature."}
{"code": "public URLConnectionRequestPropertiesBuilder withCookie(String cookieName,String cookieValue){\n  if (requestProperties.containsKey(\"Cookie\")) {\n    final String cookies=requestProperties.get(\"Cookie\");\n    requestProperties.put(\"Cookie\",cookies + COOKIES_SEPARATOR + buildCookie(cookieName,cookieValue));\n  }\n else {\n    requestProperties.put(\"Cookie\",buildCookie(cookieName,cookieValue));\n  }\n  return this;\n}\n", "nl": "Add provided cookie to 'Cookie' request property."}
{"code": "@Command(aliases=\"join\",description=\"Join the game\") @PlayerCommand public static void join(CommandContext cmd,@Optional Team team){\n  Player player=(Player)cmd.getSender();\n  MatchThread thread=Cardinal.getMatchThread(player);\n  Match match=thread.getCurrentMatch();\n  PlayingPlayerContainer playing=team;\n  if (!match.isFfa()) {\n    if (playing == null) {\n      playing=Team.getEmptiestTeam(Team.getTeams(Cardinal.getMatch(player)));\n    }\n  }\n else {\n    playing=SinglePlayerContainer.of(player);\n  }\n  PlayerContainerData newData=new PlayerContainerData(thread,match,playing);\n  PlayerContainerData oldData=PlayerContainerData.of(player);\n  Containers.handleStateChangeEvent(player,oldData,newData);\n}\n", "nl": "Join the game."}
{"code": "public boolean checkPattern(List<LockPatternView.Cell> pattern){\n  try {\n    RandomAccessFile raf=new RandomAccessFile(sLockPatternFilename,\"r\");\n    final byte[] stored=new byte[(int)raf.length()];\n    int got=raf.read(stored,0,stored.length);\n    raf.close();\n    if (got <= 0) {\n      return true;\n    }\n    return Arrays.equals(stored,LockPatternUtils.patternToHash(pattern));\n  }\n catch (  FileNotFoundException fnfe) {\n    return true;\n  }\ncatch (  IOException ioe) {\n    return true;\n  }\n}\n", "nl": "Check to see if a pattern matches the saved pattern. If no pattern exists, always returns true."}
{"code": "public boolean isLeft(){\n  return m_left;\n}\n", "nl": "Is Left Aouter Join"}
{"code": "public synchronized void connected(BluetoothSocket socket){\n  if (mConnectThread != null) {\n    mConnectThread.cancel();\n    mConnectThread=null;\n  }\n  if (mConnectedThread != null) {\n    mConnectedThread.cancel();\n    mConnectedThread=null;\n  }\n  if (mAcceptThread != null) {\n    mAcceptThread.cancel();\n    mAcceptThread=null;\n  }\n  mConnectedThread=new ConnectedThread(socket);\n  mConnectedThread.start();\n  mBluetoothDevice=socket.getRemoteDevice();\n  setState(State.STATE_CONNECTED);\n}\n", "nl": "Start the ConnectedThread to begin managing a Bluetooth connection."}
{"code": "protected CollectionAdminResponse deleteCollection(String collectionName) throws Exception {\n  SolrClient client=createCloudClient(null);\n  CollectionAdminResponse res;\n  try {\n    ModifiableSolrParams params=new ModifiableSolrParams();\n    params.set(\"action\",CollectionParams.CollectionAction.DELETE.toString());\n    params.set(\"name\",collectionName);\n    QueryRequest request=new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    res=new CollectionAdminResponse();\n    res.setResponse(client.request(request));\n  }\n catch (  Exception e) {\n    log.warn(\"Error while deleting the collection \" + collectionName,e);\n    return new CollectionAdminResponse();\n  }\n finally {\n    client.close();\n  }\n  return res;\n}\n", "nl": "Delete a collection through the Collection API."}
{"code": "public void sendMessage(String configKey,String value){\n  if (mPeerId != null) {\n    DataMap config=new DataMap();\n    config.putString(configKey,value);\n    byte[] rawData=config.toByteArray();\n    Wearable.MessageApi.sendMessage(mGoogleApiClient,mPeerId,PATH_WITH_FEATURE,rawData);\n  }\n}\n", "nl": "Send information using the wearable message API"}
{"code": "public MoveDownAction(){\n  putValue(SMALL_ICON,new ImageIcon(CMain.class.getResource(\"data/arrow_down.png\")));\n}\n", "nl": "Creates a new action handler for the Down button."}
{"code": "@Override public void startRadio(String streamURL){\n  mService.play(streamURL);\n}\n", "nl": "Start Radio Streaming"}
{"code": "public ClusterInfo(final Map<String,DiskUsage> leastAvailableSpaceUsage,final Map<String,DiskUsage> mostAvailableSpaceUsage,final Map<String,Long> shardSizes,Map<ShardRouting,String> routingToDataPath){\n  this.leastAvailableSpaceUsage=leastAvailableSpaceUsage;\n  this.shardSizes=shardSizes;\n  this.mostAvailableSpaceUsage=mostAvailableSpaceUsage;\n  this.routingToDataPath=routingToDataPath;\n}\n", "nl": "Creates a new ClusterInfo instance."}
{"code": "public String normalizeSystemName(String systemName){\n  boolean aMatch=aCodes.reset(systemName).matches();\n  int aCount=aCodes.groupCount();\n  boolean hMatch=hCodes.reset(systemName).matches();\n  int hCount=hCodes.groupCount();\n  boolean iMatch=iCodes.reset(systemName).matches();\n  int iCount=iCodes.groupCount();\n  if (!aMatch || aCount != 2 || (!validSystemNameFormat(systemName,aCodes.group(2).charAt(0)))) {\n    return \"\";\n  }\n  String nName=\"\";\n  if (hMatch && hCount == 4) {\n    nName=hCodes.group(1) + hCodes.group(2) + hCodes.group(3)+ Integer.toString(Integer.parseInt(hCodes.group(4)));\n  }\n  if (nName.equals(\"\")) {\n    if (iMatch && iCount == 5) {\n      nName=iCodes.group(1) + iCodes.group(2) + iCodes.group(3)+ \".\"+ iCodes.group(4)+ \".\"+ iCodes.group(5);\n    }\n else {\n      if (log.isDebugEnabled()) {\n        log.debug(\"valid name doesn't normalize: \" + systemName + \" hMatch: \"+ hMatch+ \" hCount: \"+ hCount);\n      }\n    }\n  }\n  return nName;\n}\n", "nl": "Public static method to normalize a system name <P> This routine is used to ensure that each system name is uniquely linked to one bit, by removing extra zeros inserted by the user. <P> If the supplied system name does not have a valid format, an empty string is returned. Otherwise a normalized name is returned in the same format as the input name."}
{"code": "@Override public void configureZone(final StendhalRPZone zone,final Map<String,String> attributes){\n  buildprincipal(zone);\n}\n", "nl": "Configure a zone."}
{"code": "public boolean equals(Object other){\n  if (!(other instanceof action_part))   return false;\n else   return equals((action_part)other);\n}\n", "nl": "Generic equality comparison."}
{"code": "public ParseException generateParseException(){\n  jj_expentries.clear();\n  boolean[] la1tokens=new boolean[40];\n  if (jj_kind >= 0) {\n    la1tokens[jj_kind]=true;\n    jj_kind=-1;\n  }\n  for (int i=0; i < 23; i++) {\n    if (jj_la1[i] == jj_gen) {\n      for (int j=0; j < 32; j++) {\n        if ((jj_la1_0[i] & (1 << j)) != 0) {\n          la1tokens[j]=true;\n        }\n        if ((jj_la1_1[i] & (1 << j)) != 0) {\n          la1tokens[32 + j]=true;\n        }\n      }\n    }\n  }\n  for (int i=0; i < 40; i++) {\n    if (la1tokens[i]) {\n      jj_expentry=new int[1];\n      jj_expentry[0]=i;\n      jj_expentries.add(jj_expentry);\n    }\n  }\n  jj_endpos=0;\n  jj_rescan_token();\n  jj_add_error_token(0,0);\n  int[][] exptokseq=new int[jj_expentries.size()][];\n  for (int i=0; i < jj_expentries.size(); i++) {\n    exptokseq[i]=jj_expentries.get(i);\n  }\n  return new ParseException(token,exptokseq,tokenImage);\n}\n", "nl": "Generate ParseException."}
{"code": "public void reset(){\n  color=null;\n  background=null;\n}\n", "nl": "Resets the color settings."}
{"code": "private static double determinant(DelaunayVertex[] matrix,int row,boolean[] columns){\n  if (row == matrix.length) {\n    return 1;\n  }\n  double sum=0;\n  int sign=1;\n  for (int col=0; col < columns.length; col++) {\n    if (!columns[col]) {\n      continue;\n    }\n    columns[col]=false;\n    sum+=sign * matrix[row].coordinates[col] * determinant(matrix,row + 1,columns);\n    columns[col]=true;\n    sign=-sign;\n  }\n  return sum;\n}\n", "nl": "Compute the determinant of a submatrix specified by starting row and by \"active\" columns."}
{"code": "public DataTable(){\n  this(new DataSortedTableModel(\"\"));\n}\n", "nl": "initializes with no model"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  if (isNetworkedPlaylistCall(stack,0)) {\n    return makeNetworkedCall(stack);\n  }\n  Playlist p=getPlaylist(stack);\n  if (p != null && p.getID() == 0) {\n    p.clear();\n  }\n else   if (Permissions.hasPermission(Permissions.PERMISSION_PLAYLIST,stack.getUIMgr())) {\n    Wizard.getInstance().removePlaylist(p);\n    sage.plugin.PluginEventManager.postEvent(sage.plugin.PluginEventManager.PLAYLIST_REMOVED,new Object[]{sage.plugin.PluginEventManager.VAR_PLAYLIST,p,sage.plugin.PluginEventManager.VAR_UICONTEXT,(stack.getUIMgr() != null ? stack.getUIMgr().getLocalUIClientName() : null)});\n  }\n  return null;\n}\n", "nl": "Removes a specified Playlist from the databse completely. The files in the Playlist will NOT be removed."}
{"code": "public static void stopStoreSessionListeners(GridKernalContext ctx,Collection<CacheStoreSessionListener> sesLsnrs) throws IgniteCheckedException {\n  if (sesLsnrs == null)   return;\n  for (  CacheStoreSessionListener lsnr : sesLsnrs) {\n    if (lsnr instanceof LifecycleAware)     ((LifecycleAware)lsnr).stop();\n    ctx.resource().cleanupGeneric(lsnr);\n  }\n}\n", "nl": "Stops store session listeners."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public synchronized void engineStore(OutputStream stream,char[] password) throws IOException, NoSuchAlgorithmException, CertificateException {\n  if (password == null) {\n    throw new IllegalArgumentException(\"password can't be null\");\n  }\n  DerOutputStream pfx=new DerOutputStream();\n  DerOutputStream version=new DerOutputStream();\n  version.putInteger(VERSION_3);\n  byte[] pfxVersion=version.toByteArray();\n  pfx.write(pfxVersion);\n  DerOutputStream authSafe=new DerOutputStream();\n  DerOutputStream authSafeContentInfo=new DerOutputStream();\n  if (privateKeyCount > 0 || secretKeyCount > 0) {\n    if (debug != null) {\n      debug.println(\"Storing \" + (privateKeyCount + secretKeyCount) + \" protected key(s) in a PKCS#7 data content-type\");\n    }\n    byte[] safeContentData=createSafeContent();\n    ContentInfo dataContentInfo=new ContentInfo(safeContentData);\n    dataContentInfo.encode(authSafeContentInfo);\n  }\n  if (certificateCount > 0) {\n    if (debug != null) {\n      debug.println(\"Storing \" + certificateCount + \" certificate(s) in a PKCS#7 encryptedData content-type\");\n    }\n    byte[] encrData=createEncryptedData(password);\n    ContentInfo encrContentInfo=new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,new DerValue(encrData));\n    encrContentInfo.encode(authSafeContentInfo);\n  }\n  DerOutputStream cInfo=new DerOutputStream();\n  cInfo.write(DerValue.tag_SequenceOf,authSafeContentInfo);\n  byte[] authenticatedSafe=cInfo.toByteArray();\n  ContentInfo contentInfo=new ContentInfo(authenticatedSafe);\n  contentInfo.encode(authSafe);\n  byte[] authSafeData=authSafe.toByteArray();\n  pfx.write(authSafeData);\n  byte[] macData=calculateMac(password,authenticatedSafe);\n  pfx.write(macData);\n  DerOutputStream pfxout=new DerOutputStream();\n  pfxout.write(DerValue.tag_Sequence,pfx);\n  byte[] pfxData=pfxout.toByteArray();\n  stream.write(pfxData);\n  stream.flush();\n}\n", "nl": "Stores this keystore to the given output stream, and protects its integrity with the given password."}
{"code": "void back(){\n  if (index > 0)   index--;\n}\n", "nl": "Puts back last read character."}
{"code": "private void initializeLiveAttributes(){\n  target=createLiveAnimatedString(null,SVG_TARGET_ATTRIBUTE);\n}\n", "nl": "Initializes the live attribute values of this element."}
{"code": "public void applyToTaskView(View v,int duration,Interpolator interp,boolean allowLayers,boolean allowShadows,ValueAnimator.AnimatorUpdateListener updateCallback){\n  if (duration > 0) {\n    ViewPropertyAnimator anim=v.animate();\n    boolean requiresLayers=false;\n    if (hasTranslationYChangedFrom(v.getTranslationY())) {\n      anim.translationY(translationY);\n    }\n    if (allowShadows && hasTranslationZChangedFrom(v.getTranslationZ())) {\n      anim.translationZ(translationZ);\n    }\n    if (hasScaleChangedFrom(v.getScaleX())) {\n      anim.scaleX(scale).scaleY(scale);\n      requiresLayers=true;\n    }\n    if (hasAlphaChangedFrom(v.getAlpha())) {\n      anim.alpha(alpha);\n      requiresLayers=true;\n    }\n    if (requiresLayers && allowLayers) {\n      anim.withLayer();\n    }\n    if (updateCallback != null) {\n      anim.setUpdateListener(updateCallback);\n    }\n else {\n      anim.setUpdateListener(null);\n    }\n    anim.setStartDelay(startDelay).setDuration(duration).setInterpolator(interp).start();\n  }\n else {\n    if (hasTranslationYChangedFrom(v.getTranslationY())) {\n      v.setTranslationY(translationY);\n    }\n    if (allowShadows && hasTranslationZChangedFrom(v.getTranslationZ())) {\n      v.setTranslationZ(translationZ);\n    }\n    if (hasScaleChangedFrom(v.getScaleX())) {\n      v.setScaleX(scale);\n      v.setScaleY(scale);\n    }\n    if (hasAlphaChangedFrom(v.getAlpha())) {\n      v.setAlpha(alpha);\n    }\n  }\n}\n", "nl": "Applies this transform to a view."}
{"code": "@Override public Iterator iterator(){\n  return new StructBagIterator(fieldValuesIterator());\n}\n", "nl": "Return an iterator over the elements in this collection. Duplicates will show up the number of times it has occurrances."}
{"code": "public Tradestrategy findTradestrategyByUniqueKeys(final ZonedDateTime open,final String strategy,final Integer idContract,final String portfolioName) throws PersistentModelException {\n  return m_tradestrategyHome.findTradestrategyByUniqueKeys(open,strategy,idContract,portfolioName);\n}\n", "nl": "Method findTradestrategyByUniqueKeys."}
{"code": "public void print(String value) throws IOException {\n  print(value,true);\n}\n", "nl": "Print the string as the next value on the line. The value will be escaped or encapsulated as needed."}
{"code": "public void startScroll(int startX,int startY,int dx,int dy,int duration){\n  mScrollerX.mMode=mScrollerY.mMode=SCROLL_MODE;\n  mScrollerX.startScroll(startX,dx,duration);\n  mScrollerY.startScroll(startY,dy,duration);\n}\n", "nl": "Start scrolling by providing a starting point and the distance to travel."}
{"code": "public void testSortsElementsWithDifferentValue() throws Exception {\n  XppDom dom1=XppFactory.buildDom(\"<dom>value1</dom>\");\n  XppDom dom2=XppFactory.buildDom(\"<dom>value2</dom>\");\n  assertEquals(-1,comparator.compare(dom1,dom2));\n  assertEquals(\"/dom::text()\",xpath.get());\n  assertEquals(1,comparator.compare(dom2,dom1));\n  assertEquals(\"/dom::text()\",xpath.get());\n}\n", "nl": "Tests comparison of different values."}
{"code": "public void initGUI(){\n  removeAll();\n  try {\n    URL url=PropUtils.getResourceOrFileOrURL(this,forwardIconURL);\n    forwardIcon=new ImageIcon(url);\n    url=PropUtils.getResourceOrFileOrURL(this,forwardStepIconURL);\n    forwardStepIcon=new ImageIcon(url);\n    url=PropUtils.getResourceOrFileOrURL(this,backwardIconURL);\n    backwardIcon=new ImageIcon(url);\n    url=PropUtils.getResourceOrFileOrURL(this,backwardStepIconURL);\n    backwardStepIcon=new ImageIcon(url);\n    url=PropUtils.getResourceOrFileOrURL(this,pauseIconURL);\n    pauseIcon=new ImageIcon(url);\n  }\n catch (  MalformedURLException murle) {\n    Debug.error(\"TimerToggleButton: initGUI() bad icon.\");\n  }\ncatch (  NullPointerException npe) {\n    Debug.error(\"TimerToggleButton: initGUI() bad icon.\");\n    npe.printStackTrace();\n  }\n  JToolBar jtb=new JToolBar();\n  jtb.setFloatable(false);\n  backwardButton=new JButton(backwardIcon);\n  backwardButton.setToolTipText(\"Run Timer Backwards\");\n  backwardButton.setActionCommand(TimerStatus.TIMER_BACKWARD);\n  backwardButton.addActionListener(this);\n  jtb.add(backwardButton);\n  JButton button=new JButton(backwardStepIcon);\n  button.setToolTipText(\"Step Timer Backward\");\n  button.setActionCommand(TimerStatus.TIMER_STEP_BACKWARD);\n  button.addActionListener(this);\n  jtb.add(button);\n  button=new JButton(forwardStepIcon);\n  button.setToolTipText(\"Step Timer Forward\");\n  button.setActionCommand(TimerStatus.TIMER_STEP_FORWARD);\n  button.addActionListener(this);\n  jtb.add(button);\n  forwardButton=new JButton(forwardIcon);\n  forwardButton.setToolTipText(\"Run Timer Forward\");\n  forwardButton.setActionCommand(TimerStatus.TIMER_FORWARD);\n  forwardButton.addActionListener(this);\n  jtb.add(forwardButton);\n  add(jtb);\n}\n", "nl": "Set the ImageIcons to whatever is set on the URL variables. Sets the running icon to be the pressed icon, and makes the stopped and inactive icons."}
{"code": "private void calculateCalibration(long difference,float currentMeasure,byte currentIndex){\n  if (difference >= MedtronicConstants.TIME_15_MIN_IN_MS && difference < MedtronicConstants.TIME_20_MIN_IN_MS) {\n    if (isSensorMeasureInRange(currentIndex,expectedSensorSortNumberForCalibration)) {\n      isCalibrating=false;\n      calibrationStatus=MedtronicConstants.CALIBRATED;\n      calibrationIsigValue=currentMeasure;\n      SharedPreferences.Editor editor=settings.edit();\n      calibrationFactor=lastGlucometerValue / calibrationIsigValue;\n      editor.remove(\"expectedSensorSortNumberForCalibration0\");\n      editor.remove(\"expectedSensorSortNumberForCalibration1\");\n      editor.putFloat(\"calibrationFactor\",(float)calibrationFactor);\n      editor.putInt(\"calibrationStatus\",calibrationStatus);\n      editor.commit();\n    }\n else {\n      if (calibrationStatus != MedtronicConstants.WITHOUT_ANY_CALIBRATION && currentIndex != expectedSensorSortNumber) {\n        calibrationStatus=MedtronicConstants.LAST_CALIBRATION_FAILED_USING_PREVIOUS;\n        isCalibrating=false;\n      }\n else {\n        calibrationStatus=MedtronicConstants.WITHOUT_ANY_CALIBRATION;\n      }\n      SharedPreferences.Editor editor=settings.edit();\n      editor.remove(\"expectedSensorSortNumberForCalibration0\");\n      editor.remove(\"expectedSensorSortNumberForCalibration1\");\n      editor.commit();\n    }\n  }\n else   if (difference >= MedtronicConstants.TIME_20_MIN_IN_MS) {\n    if (isSensorMeasureInRange(currentIndex,expectedSensorSortNumberForCalibration)) {\n      calibrationStatus=MedtronicConstants.CALIBRATED_IN_15MIN;\n      calibrationIsigValue=currentMeasure;\n      SharedPreferences.Editor editor=settings.edit();\n      calibrationFactor=lastGlucometerValue / calibrationIsigValue;\n      editor.remove(\"expectedSensorSortNumberForCalibration0\");\n      editor.remove(\"expectedSensorSortNumberForCalibration1\");\n      editor.putFloat(\"calibrationFactor\",(float)calibrationFactor);\n      editor.putInt(\"calibrationStatus\",calibrationStatus);\n      editor.commit();\n    }\n else {\n      if (calibrationStatus != MedtronicConstants.WITHOUT_ANY_CALIBRATION)       calibrationStatus=MedtronicConstants.LAST_CALIBRATION_FAILED_USING_PREVIOUS;\n else {\n        calibrationStatus=MedtronicConstants.WITHOUT_ANY_CALIBRATION;\n      }\n      SharedPreferences.Editor editor=settings.edit();\n      editor.remove(\"expectedSensorSortNumberForCalibration0\");\n      editor.remove(\"expectedSensorSortNumberForCalibration1\");\n      editor.commit();\n    }\n    isCalibrating=false;\n  }\n else {\n    if (isCalibrating) {\n      if (difference < MedtronicConstants.TIME_5_MIN_IN_MS) {\n        calibrationStatus=MedtronicConstants.CALIBRATING;\n      }\n else       if (difference >= MedtronicConstants.TIME_5_MIN_IN_MS && difference <= MedtronicConstants.TIME_15_MIN_IN_MS)       calibrationStatus=MedtronicConstants.CALIBRATING2;\n else       calibrationStatus=MedtronicConstants.CALIBRATING;\n    }\n else {\n      if (calibrationStatus != MedtronicConstants.WITHOUT_ANY_CALIBRATION)       calibrationStatus=MedtronicConstants.LAST_CALIBRATION_FAILED_USING_PREVIOUS;\n else {\n        calibrationStatus=MedtronicConstants.WITHOUT_ANY_CALIBRATION;\n      }\n      SharedPreferences.Editor editor=settings.edit();\n      editor.remove(\"expectedSensorSortNumberForCalibration0\");\n      editor.remove(\"expectedSensorSortNumberForCalibration1\");\n      editor.putInt(\"calibrationStatus\",calibrationStatus);\n      editor.commit();\n    }\n  }\n}\n", "nl": "This method checks if a calibration is valid."}
{"code": "@Inline @Entrypoint public static void floatArrayWrite(float[] ref,int index,float value){\n  if (NEEDS_FLOAT_GC_WRITE_BARRIER) {\n    ObjectReference array=ObjectReference.fromObject(ref);\n    Offset offset=Offset.fromIntZeroExtend(index << LOG_BYTES_IN_FLOAT);\n    Selected.Mutator.get().floatWrite(array,array.toAddress().plus(offset),value,offset.toWord(),Word.zero(),ARRAY_ELEMENT);\n  }\n else   if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);\n}\n", "nl": "Barrier for writes of floats into arrays (i.e. fastore)."}
{"code": "public static boolean isXMLDocument(Object o){\n  return o instanceof Document;\n}\n", "nl": "tests if object is a XML Document Object"}
{"code": "public static synchronized void injectPools(ExecutorService globalThreadPool,ScheduledExecutorService scheduledThreadPool){\n  if (globalThreadPool == null || scheduledThreadPool == null)   throw new IllegalArgumentException(\"thread pools must not be null\");\n  clearThreadPools();\n  ActiveMQClient.globalThreadPool=globalThreadPool;\n  ActiveMQClient.globalScheduledThreadPool=scheduledThreadPool;\n  injectedPools=true;\n}\n", "nl": "Warning: This method has to be called before any clients or servers is started on the JVM otherwise previous ServerLocator would be broken after this call."}
{"code": "protected void reportWarning(String msg,long lineNo,long columnNo){\n  if (errListener != null) {\n    errListener.warning(msg,lineNo,columnNo);\n  }\n}\n", "nl": "Reports a warning with associated line- and column number to the registered ParseErrorListener, if any."}
{"code": "public static String loadTextFileFromAssets(Context context,String fileName) throws IOException {\n  InputStream inputStream=context.getAssets().open(fileName);\n  try {\n    OutputStream outputStream=new ByteArrayOutputStream();\n    try {\n      byte[] buffer=new byte[DEFAULT_BUFFER_SIZE];\n      for (int n; (n=inputStream.read(buffer)) >= 0; ) {\n        outputStream.write(buffer,0,n);\n      }\n      return outputStream.toString();\n    }\n  finally {\n      outputStream.close();\n    }\n  }\n  finally {\n    inputStream.close();\n  }\n}\n", "nl": "Returns the text of a file as a String object"}
{"code": "private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n  try {\n    ois.defaultReadObject();\n    remove(m_visualLabel);\n    m_visualLabel=new JLabel(m_icon);\n    loadIcons(m_iconPath,m_animatedIconPath);\n    add(m_visualLabel,BorderLayout.CENTER);\n    Dimension d=m_visualLabel.getPreferredSize();\n    Dimension d2=new Dimension((int)d.getWidth() + 10,(int)d.getHeight() + 10);\n    setMinimumSize(d2);\n    setPreferredSize(d2);\n    setMaximumSize(d2);\n  }\n catch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}\n", "nl": "Overides default read object in order to reload icons. This is necessary because for some strange reason animated gifs stop being animated after being serialized/deserialized."}
{"code": "public void cacheEntryAdded(CacheEntryEvent arg0){\n  super.cacheEntryAdded(arg0);\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(\"Cache entry added [\");\n  buffer.append(arg0.getEntry().getKey());\n  buffer.append(\"]. Added [\");\n  buffer.append(getEntryAddedCount());\n  buffer.append(\"] Removed [\");\n  buffer.append(getEntryRemovedCount());\n  buffer.append(\"]\");\n  log.debug(buffer.toString());\n}\n", "nl": "Public methods"}
{"code": "public CtClass[] mayThrow(){\n  return super.mayThrow();\n}\n", "nl": "Returns the list of exceptions that the expression may throw. This list includes both the exceptions that the try-catch statements including the expression can catch and the exceptions that the throws declaration allows the method to throw."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:31:36.469 -0500\",hash_original_method=\"19A6345BB30DA1B94EF425A139EBF7B6\",hash_generated_method=\"3F38B0E9396A1A008A1A74F14E81449E\") public boolean isColumnCollapsed(int columnIndex){\n  return mCollapsedColumns.get(columnIndex);\n}\n", "nl": "<p>Returns the collapsed state of the specified column.</p>"}
{"code": "@Override public Object dataAccessObjectProcess(ProceedingJoinPoint pjp) throws AuthorityException, ServiceException, Throwable {\n  return pjp.proceed();\n}\n", "nl": "no enable for scan DAO package"}
{"code": "public int nextNode(){\n  if (m_foundLast)   return DTM.NULL;\n  int next;\n  if (null != m_exprObj) {\n    m_lastFetched=next=m_exprObj.nextNode();\n  }\n else   m_lastFetched=next=DTM.NULL;\n  if (DTM.NULL != next) {\n    m_pos++;\n    return next;\n  }\n else {\n    m_foundLast=true;\n    return DTM.NULL;\n  }\n}\n", "nl": "Returns the next node in the set and advances the position of the iterator in the set. After a NodeIterator is created, the first call to nextNode() returns the first node in the set."}
{"code": "private void updateUiForConfigDataMap(final DataMap config){\n  boolean uiUpdated=false;\n  for (  String configKey : config.keySet()) {\n    if (!config.containsKey(configKey)) {\n      continue;\n    }\n    if (updateUiForKey(configKey,config)) {\n      uiUpdated=true;\n    }\n  }\n  if (uiUpdated) {\n    invalidate();\n    sendMessage(\"WEARABLE_SETTINGS_CHANGE\",config.toByteArray());\n  }\n}\n", "nl": "Update the interface on changes on the settings"}
{"code": "public void stop(){\n  if (mLocaleChangedReceiver != null) {\n    mCtx.unregisterReceiver(mLocaleChangedReceiver);\n    mLocaleChangedReceiver=null;\n  }\n  mUpdateExecutor.shutdownNow();\n}\n", "nl": "Stops Locale manager"}
{"code": "@Deprecated public ScriptSortBuilder lang(String lang){\n  this.lang=lang;\n  return this;\n}\n", "nl": "The language of the script."}
{"code": "public void reset(){\n  super.reset();\n  H0=0x67452301;\n  H1=0xefcdab89;\n  H2=0x98badcfe;\n  H3=0x10325476;\n  H4=0x76543210;\n  H5=0xFEDCBA98;\n  H6=0x89ABCDEF;\n  H7=0x01234567;\n  xOff=0;\n  for (int i=0; i != X.length; i++) {\n    X[i]=0;\n  }\n}\n", "nl": "reset the chaining variables to the IV values."}
{"code": "@Override public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj instanceof AbstractChronology) {\n    return compareTo((AbstractChronology)obj) == 0;\n  }\n  return false;\n}\n", "nl": "Checks if this chronology is equal to another chronology. <p> The comparison is based on the entire state of the object."}
{"code": "@Override protected final Object clone(){\n  return this;\n}\n", "nl": "There is only intended to be a single instance of the NULL object, so the clone method returns itself."}
{"code": "private Object readResolve(){\n  dataset=new XYSeriesCollection();\n  dataset.addSeries(new XYSeries(\"Data\",false,true));\n  projector.postOpenInit();\n  addListeners();\n  return this;\n}\n", "nl": "Standard method call made to objects after they are deserialized. See: http://java.sun.com/developer/JDCTechTips/2002/tt0205.html#tip2 http://xstream.codehaus.org/faq.html"}
{"code": "@Override public void updateSelectionTo(Collection<GraphNode> selection){\n  for (  GraphNode node : getEditor().getViewGraph().getNodes()) {\n    NodeWrapper<NodeDisplayProperty> nodeWrapper=nodeTreeView.getNodeWrapper(node);\n    if (null != nodeWrapper) {\n      nodeTreeView.getTreeViewer().update(nodeWrapper,new String[]{COL_SELECTED});\n    }\n  }\n  updateSelectedExtend(selection);\n}\n", "nl": "Set the nodes in the given set as the only ones selected. Which means that the previously selected are first unselected, then nodes in the <code>selection</code> argument are added."}
{"code": "public void testBogusArguments() throws Exception {\n  IllegalArgumentException expected=expectThrows(IllegalArgumentException.class,null);\n  assertTrue(expected.getMessage().contains(\"Unknown parameters\"));\n}\n", "nl": "Test that bogus arguments result in exception"}
{"code": "public static char toDimensionSymbol(int dimensionValue){\nswitch (dimensionValue) {\ncase FALSE:\n    return SYM_FALSE;\ncase TRUE:\n  return SYM_TRUE;\ncase DONTCARE:\nreturn SYM_DONTCARE;\ncase P:\nreturn SYM_P;\ncase L:\nreturn SYM_L;\ncase A:\nreturn SYM_A;\n}\nthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n}\n", "nl": "Converts the dimension value to a dimension symbol, for example, <code>TRUE =&gt; 'T'</code> ."}
{"code": "private K highestKey(){\n  ConcurrentSkipListMap.Node<K,V> n=hiNode();\n  if (n != null) {\n    K last=n.key;\n    if (inBounds(last))     return last;\n  }\n  throw new NoSuchElementException();\n}\n", "nl": "Returns highest absolute key (ignoring directonality)."}
{"code": "public ScatterPlotSetter(final Integer index){\n  this.index=index;\n}\n", "nl": "Construct a setter object."}
{"code": "private boolean saveSelection(){\n  if (!m_readWrite)   return true;\n  log.info(\"\");\n  MAttributeSet as=m_masi.getMAttributeSet();\n  if (as == null)   return true;\n  m_changed=false;\n  String mandatory=\"\";\n  if ((!m_productWindow || !m_productASI) && as.isLot()) {\n    log.fine(\"Lot=\" + fieldLotString.getText());\n    String text=fieldLotString.getText();\n    m_masi.setLot(text);\n    if (as.isLotMandatory() && (text == null || text.length() == 0))     mandatory+=\" - \" + Msg.translate(Env.getCtx(),\"Lot\");\n    m_changed=true;\n  }\n  if ((!m_productWindow || !m_productASI) && as.isSerNo()) {\n    log.fine(\"SerNo=\" + fieldSerNo.getText());\n    String text=fieldSerNo.getText();\n    m_masi.setSerNo(text);\n    if (as.isSerNoMandatory() && (text == null || text.length() == 0))     mandatory+=\" - \" + Msg.translate(Env.getCtx(),\"SerNo\");\n    m_changed=true;\n  }\n  if ((!m_productWindow || !m_productASI) && as.isGuaranteeDate()) {\n    log.fine(\"GuaranteeDate=\" + fieldGuaranteeDate.getValue());\n    Timestamp ts=(Timestamp)fieldGuaranteeDate.getValue();\n    m_masi.setGuaranteeDate(ts);\n    if (as.isGuaranteeDateMandatory() && ts == null)     mandatory+=\" - \" + Msg.translate(Env.getCtx(),\"GuaranteeDate\");\n    m_changed=true;\n  }\n  if (m_changed || m_masi.getM_AttributeSetInstance_ID() == 0) {\n    m_masi.save();\n    m_M_AttributeSetInstance_ID=m_masi.getM_AttributeSetInstance_ID();\n    m_M_AttributeSetInstanceName=m_masi.getDescription();\n  }\n  if (m_M_AttributeSetInstance_ID > 0 && m_readWrite) {\n    MAttribute[] attributes=as.getMAttributes(!m_productASI);\n    for (int i=0; i < attributes.length; i++) {\n      if (MAttribute.ATTRIBUTEVALUETYPE_List.equals(attributes[i].getAttributeValueType())) {\n        CComboBox editor=(CComboBox)m_editors.get(i);\n        MAttributeValue value=(MAttributeValue)editor.getSelectedItem();\n        log.fine(attributes[i].getName() + \"=\" + value);\n        if (attributes[i].isMandatory() && value == null)         mandatory+=\" - \" + attributes[i].getName();\n        attributes[i].setMAttributeInstance(m_M_AttributeSetInstance_ID,value);\n      }\n else       if (MAttribute.ATTRIBUTEVALUETYPE_Number.equals(attributes[i].getAttributeValueType())) {\n        VNumber editor=(VNumber)m_editors.get(i);\n        BigDecimal value=(BigDecimal)editor.getValue();\n        log.fine(attributes[i].getName() + \"=\" + value);\n        if (attributes[i].isMandatory() && value == null)         mandatory+=\" - \" + attributes[i].getName();\n        if (value != null && value.scale() == 0)         value=value.setScale(1,BigDecimal.ROUND_HALF_UP);\n        attributes[i].setMAttributeInstance(m_M_AttributeSetInstance_ID,value);\n      }\n else {\n        VString editor=(VString)m_editors.get(i);\n        String value=editor.getText();\n        log.fine(attributes[i].getName() + \"=\" + value);\n        if (attributes[i].isMandatory() && (value == null || value.length() == 0))         mandatory+=\" - \" + attributes[i].getName();\n        attributes[i].setMAttributeInstance(m_M_AttributeSetInstance_ID,value);\n      }\n    }\n    m_changed=true;\n  }\n  if (m_changed) {\n    m_masi.setDescription();\n    m_masi.save();\n  }\n  m_M_AttributeSetInstance_ID=m_masi.getM_AttributeSetInstance_ID();\n  m_M_AttributeSetInstanceName=m_masi.getDescription();\n  if (mandatory.length() > 0) {\n    ADialog.error(m_WindowNo,this,\"FillMandatory\",mandatory);\n    return false;\n  }\n  return true;\n}\n", "nl": "Save Selection"}
{"code": "public static ArrayList<Instruction> cleanupRuntimeInstructions(ArrayList<Instruction> insts,String[] outputs){\n  for (int i=0; i < insts.size(); i++) {\n    Instruction linst=insts.get(i);\n    if (linst instanceof VariableCPInstruction && ((VariableCPInstruction)linst).isRemoveVariable()) {\n      VariableCPInstruction varinst=(VariableCPInstruction)linst;\n      for (      String var : outputs)       if (varinst.isRemoveVariable(var)) {\n        insts.remove(i);\n        i--;\n        break;\n      }\n    }\n  }\n  return insts;\n}\n", "nl": "Cleanup runtime instructions, removing rmvar instructions for any of the given output variable names."}
{"code": "private void init(){\n  setFocusPainted(false);\n  setFocusable(false);\n  JComboBox box=new JComboBox();\n  Object preventHide=box.getClientProperty(\"doNotCancelPopup\");\n  putClientProperty(\"doNotCancelPopup\",preventHide);\n}\n", "nl": "Initialize the column control button's gui"}
{"code": "@Override public void beginOfStream() throws AdeException, AdeFlowException {\n  if (s_marshaller == null) {\n    JAXBContext jaxbContext;\n    try {\n      jaxbContext=JAXBContext.newInstance(ADEEXT_JAXB_CONTEXT);\n    }\n catch (    JAXBException e) {\n      throw new AdeInternalException(\"failed to create JAXBContext object for package \" + Arrays.toString(ADEEXT_JAXB_CONTEXT),e);\n    }\n    try {\n      s_marshaller=jaxbContext.createMarshaller();\n    }\n catch (    JAXBException e) {\n      throw new AdeInternalException(\"failed to create JAXB Marshaller object\",e);\n    }\n    try {\n      s_marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,m_formatXMLOutput);\n      s_marshaller.setProperty(Marshaller.JAXB_FRAGMENT,Boolean.TRUE);\n      s_marshaller.setProperty(Marshaller.JAXB_NO_NAMESPACE_SCHEMA_LOCATION,XML_INTERVAL_V2_XSD);\n    }\n catch (    PropertyException e) {\n      throw new AdeInternalException(\"failed to set formatted output for JAXB Marshaller object\",e);\n    }\n    SchemaFactory sf=SchemaFactory.newInstance(javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI);\n    File xmlParent=Ade.getAde().getConfigProperties().getXsltDir().getAbsoluteFile();\n    xmlParent=xmlParent.getParentFile();\n    File intervalSchema=new File(xmlParent,XML_INTERVAL_V2_XSD);\n    Schema schema;\n    try {\n      URL analyzedIntervalSchema=intervalSchema.toURI().toURL();\n      schema=sf.newSchema(analyzedIntervalSchema);\n    }\n catch (    SAXException e) {\n      throw new AdeInternalException(\"failed to create XML Schemal for event log analysis results\",e);\n    }\ncatch (    MalformedURLException e) {\n      throw new AdeInternalException(\"failed to create URL from Schema path: \" + intervalSchema.getAbsolutePath(),e);\n    }\n    s_marshaller.setSchema(schema);\n  }\n  m_xmlMetaData=new XMLMetaDataRetriever();\n}\n", "nl": "Begin of Stream"}
{"code": "public ActionErrors validate(ActionMapping mapping,HttpServletRequest request){\n  ActionErrors errors=new ActionErrors();\n  if (!new CustomDate(this.fechaFormato,this.fechaA,this.fechaM,this.fechaD,this.fechaS).validate() || !new CustomDate(this.fechaIniFormato,this.fechaIniA,this.fechaIniM,this.fechaIniD,this.fechaIniS).validate() || !new CustomDate(this.fechaFinFormato,this.fechaFinA,this.fechaFinM,this.fechaFinD,this.fechaFinS).validate()) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_DATE,Messages.getString(DescripcionConstants.DESCRIPCION_BUSQUEDA_AUT_FECHA,request.getLocale())));\n  }\n  if (StringUtils.isNotBlank(numero) && !NumberUtils.isNumber(numero)) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_INVALID,Messages.getString(ArchivoDetails.DESCRIPCION_BUSQUEDA_DATO_NUMERICO,request.getLocale())));\n  }\n  if (listasDescriptoras.length == 0) {\n    errors.add(ActionErrors.GLOBAL_MESSAGE,new ActionError(Constants.ERROR_REQUIRED,Messages.getString(ArchivoDetails.DESCRIPCION_BUSQUEDA_LISTAS_DESCRIPTORAS,request.getLocale())));\n  }\n  return errors;\n}\n", "nl": "Valida el formulario"}
{"code": "@Override public boolean canHandleJitter(){\n  return true;\n}\n", "nl": "Returns true."}
{"code": "public OperationNotSupportException(Throwable arg0){\n  super(arg0);\n}\n", "nl": "Creates a new instance of OperationNotSupportException."}
{"code": "private static void initialize(GemFireCacheImpl cache){\n  try {\n    AttributesFactory factory=new AttributesFactory();\n    factory.setScope(Scope.LOCAL);\n    factory.setEntryTimeToLive(new ExpirationAttributes(ADMIN_REGION_EXPIRY_INTERVAL,ExpirationAction.DESTROY));\n    cache.getLogger().fine(\"ClientHealthMonitoringRegion, setting TTL for entry....\");\n    factory.addCacheListener(prepareCacheListener());\n    factory.setStatisticsEnabled(true);\n    RegionAttributes regionAttrs=factory.create();\n    InternalRegionArguments internalArgs=new InternalRegionArguments();\n    internalArgs.setIsUsedForMetaRegion(true);\n    internalArgs.setIsUsedForPartitionedRegionAdmin(false);\n    currentInstance=cache.createVMRegion(ADMIN_REGION_NAME,regionAttrs,internalArgs);\n  }\n catch (  Exception ex) {\n    cache.getLoggerI18n().error(LocalizedStrings.ClientHealthMonitoringRegion_ERROR_WHILE_CREATING_AN_ADMIN_REGION,ex);\n  }\n}\n", "nl": "This method creates the client health monitoring region."}
{"code": "public String namespace(){\n  return theNamespace;\n}\n", "nl": "Returns the namespace name of this element type."}
{"code": "private List<StoragePool> processStorageThickPoolResponse(StorageSystem system,List<Pool> thickPoolListFromResponse,AccessProfile accessProfile,Set<String> supportedProtocols,List<StoragePool> poolsToMatchWithVpool) throws IOException {\n  _logger.debug(\"Entering {}\",Thread.currentThread().getStackTrace()[1].getMethodName());\n  List<StoragePool> newPools=new ArrayList<StoragePool>();\n  List<StoragePool> updatePools=new ArrayList<StoragePool>();\n  List<StoragePool> allPools=new ArrayList<StoragePool>();\n  if (null != thickPoolListFromResponse && !thickPoolListFromResponse.isEmpty()) {\n    _logger.debug(\"thickPoolListFromResponse.size() :{}\",thickPoolListFromResponse.size());\n    for (    Pool poolFromResponse : thickPoolListFromResponse) {\n      _logger.debug(\"Pool Id:{}\",poolFromResponse.getPoolID());\n      if (!(0 == Integer.valueOf(poolFromResponse.getType()) || -1 == Integer.valueOf(poolFromResponse.getType()) || 1 == Integer.valueOf(poolFromResponse.getType()))) {\n        continue;\n      }\n      boolean isNew=false;\n      boolean isModified=false;\n      String nativeGuid=NativeGUIDGenerator.generateNativeGuid(system,poolFromResponse.getObjectID(),NativeGUIDGenerator.POOL);\n      _logger.debug(\"nativeGuid :{}\",nativeGuid);\n      StoragePool pool=checkPoolExistsInDB(nativeGuid);\n      if (null == pool) {\n        isNew=true;\n        pool=new StoragePool();\n        pool.setNativeGuid(nativeGuid);\n        pool.setStorageDevice(system.getId());\n        pool.setId(URIUtil.createId(StoragePool.class));\n        pool.setNativeId(poolFromResponse.getPoolID());\n        pool.setOperationalStatus(StoragePool.PoolOperationalStatus.READY.toString());\n        pool.setMaximumThickVolumeSize(104857600L);\n        pool.setPoolServiceType(PoolServiceType.block.toString());\n        pool.setRegistrationStatus(DiscoveredDataObject.RegistrationStatus.REGISTERED.toString());\n        StringSet raidLevels=new StringSet();\n        String raidLevel=parseRaidLevel(poolFromResponse.getRaidType());\n        if (StringUtils.isNotEmpty(raidLevel)) {\n          raidLevels.add(raidLevel);\n        }\n        pool.addSupportedRaidLevels(raidLevels);\n        pool.setSupportedResourceTypes(StoragePool.SupportedResourceTypes.THICK_ONLY.toString());\n        _logger.info(\"poolType {} {}\",poolFromResponse.getType(),poolFromResponse.getObjectID());\n      }\n      StringSet protocols=new StringSet(supportedProtocols);\n      if (!isNew && ImplicitPoolMatcher.checkPoolPropertiesChanged(pool.getProtocols(),protocols)) {\n        isModified=true;\n      }\n      pool.setProtocols(protocols);\n      pool.setPoolName(poolFromResponse.getDisplayName());\n      pool.setFreeCapacity(poolFromResponse.getFreeCapacity());\n      StringSet copyTypes=new StringSet();\n      copyTypes.add(StoragePool.CopyTypes.UNSYNC_ASSOC.name());\n      copyTypes.add(StoragePool.CopyTypes.UNSYNC_UNASSOC.name());\n      copyTypes.add(StoragePool.CopyTypes.SYNC.name());\n      copyTypes.add(StoragePool.CopyTypes.ASYNC.name());\n      pool.setSupportedCopyTypes(copyTypes);\n      pool.setTotalCapacity(poolFromResponse.getFreeCapacity() + poolFromResponse.getUsedCapacity());\n      if (StringUtils.isNotBlank(poolFromResponse.getDisplayName())) {\n        pool.setLabel(poolFromResponse.getDisplayName().length() == 1 ? \" \" + poolFromResponse.getDisplayName() : poolFromResponse.getDisplayName());\n      }\n      if (!isNew && !isModified && (ImplicitPoolMatcher.checkPoolPropertiesChanged(pool.getCompatibilityStatus(),CompatibilityStatus.COMPATIBLE.name()) || ImplicitPoolMatcher.checkPoolPropertiesChanged(pool.getDiscoveryStatus(),DiscoveryStatus.VISIBLE.name()))) {\n        isModified=true;\n      }\n      pool.setCompatibilityStatus(CompatibilityStatus.COMPATIBLE.name());\n      pool.setDiscoveryStatus(DiscoveryStatus.VISIBLE.name());\n      if (isNew) {\n        newPools.add(pool);\n        poolsToMatchWithVpool.add(pool);\n      }\n else {\n        updatePools.add(pool);\n        if (isModified) {\n          poolsToMatchWithVpool.add(pool);\n        }\n      }\n    }\n    StoragePoolAssociationHelper.setStoragePoolVarrays(system.getId(),newPools,_dbClient);\n    _logger.debug(\"newPools size:{}\",newPools.size());\n    _logger.debug(\"updatePools size:{}\",updatePools.size());\n    _dbClient.createObject(newPools);\n    _dbClient.persistObject(updatePools);\n    allPools.addAll(newPools);\n    allPools.addAll(updatePools);\n  }\n  _logger.debug(\"Exiting {}\",Thread.currentThread().getStackTrace()[1].getMethodName());\n  return allPools;\n}\n", "nl": "Process the ThickPool response received from server."}
{"code": "public void translate(Properties ctx){\n  if (m_originalString == null)   return;\n  String inText=Msg.parseTranslation(ctx,m_originalString);\n  String[] lines=Pattern.compile(\"$\",Pattern.MULTILINE).split(inText);\n  m_string_paper=new AttributedString[lines.length];\n  for (int i=0; i < lines.length; i++) {\n    String line=Util.removeCRLF(lines[i]);\n    m_string_paper[i]=new AttributedString(line);\n    if (line.length() > 0) {\n      m_string_paper[i].addAttribute(TextAttribute.FONT,m_font);\n      m_string_paper[i].addAttribute(TextAttribute.FOREGROUND,m_paint);\n    }\n  }\n  m_string_view=m_string_paper;\n}\n", "nl": "Translate Context if required If content is translated, the element needs to stay in the bounds of the originally calculated size and need to align the field."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:30:30.328 -0500\",hash_original_method=\"C0D74F5DDFD9A01C19E54F3379BA7652\",hash_generated_method=\"618EE3A321C4FFDE67749913AA58ADE8\") final public boolean isAdded(){\n  return mActivity != null && mAdded;\n}\n", "nl": "Return true if the fragment is currently added to its activity."}
{"code": "public void onReferencesBuild(RefElement refElement){\n}\n", "nl": "Called after the references to the specified element have been collected."}
{"code": "public Matrix4f(){\n  mMat=new float[16];\n  loadIdentity();\n}\n", "nl": "Creates a new identity 4x4 matrix"}
{"code": "public static void responseCodeReceived(Context context,RestoreTransactions request,ResponseCode responseCode){\n  if (sPurchaseObserver != null) {\n    sPurchaseObserver.onRestoreTransactionsResponse(request,responseCode);\n  }\n}\n", "nl": "This is called when we receive a response code from Android Market for a RestoreTransactions request."}
{"code": "public Partition(double ratio[],int size,PartitionBuilder builder){\n  init(ratio,size,builder);\n}\n", "nl": "Creates a new partition of a given size consisting of <tt>ratio.length</tt> sets. The set <i>i</i> will be of size of <i>size x ratio[i]</i>, i.e. the sum of all <i>ratio[i]</i> must be 1. Initially all partitions are selected."}
{"code": "@Override public void run(){\n  amIActive=true;\n  if (args.length < 2) {\n    showFeedback(\"Plugin parameters have not been set properly.\");\n    return;\n  }\n  String inputHeader=args[0];\n  String outputHeader=args[1];\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    int row, col;\n    double z;\n    int progress, oldProgress=-1;\n    double[] data;\n    WhiteboxRaster inputFile=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=inputFile.getNumberRows();\n    int cols=inputFile.getNumberColumns();\n    double noData=inputFile.getNoDataValue();\n    WhiteboxRaster outputFile=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    outputFile.setPreferredPalette(inputFile.getPreferredPalette());\n    for (row=0; row < rows; row++) {\n      data=inputFile.getRowValues(row);\n      for (col=0; col < cols; col++) {\n        z=data[col];\n        if (z != noData) {\n          outputFile.setValue(row,col,Math.log(z));\n        }\n      }\n      progress=(int)(100f * row / (rows - 1));\n      if (progress != oldProgress) {\n        oldProgress=progress;\n        updateProgress((int)progress);\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n      }\n    }\n    outputFile.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    outputFile.addMetadataEntry(\"Created on \" + new Date());\n    inputFile.close();\n    outputFile.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public void java_lang_Class_setSigners(SootMethod method,ReferenceVariable thisVar,ReferenceVariable returnVar,ReferenceVariable params[]){\n  ReferenceVariable tempFld=helper.tempField(\"<java.lang.Class signers>\");\n  helper.assign(tempFld,params[0]);\n}\n", "nl": "Sets the signers of a class. This should be called after defining a class.  Parameters:  c - the Class object  signers - the signers for the class native void setSigners(java.lang.Object[]);"}
{"code": "public UserTunnel(UserContext userContext,GuacamoleTunnel tunnel){\n  super(tunnel);\n  this.userContext=userContext;\n}\n", "nl": "Creates a new UserTunnel which wraps the given tunnel, associating it with the given UserContext. The UserContext MUST be from the AuthenticationProvider that created this tunnel, and MUST be associated with the user for whom this tunnel was created."}
{"code": "protected JTree createTree(){\n  JTree tree=new JTree(model);\n  tree.setName(\"TreePopup.tree\");\n  tree.setFont(getFont());\n  tree.setForeground(getForeground());\n  tree.setBackground(getBackground());\n  tree.setBorder(null);\n  tree.setFocusable(true);\n  tree.addMouseListener(handler);\n  tree.addKeyListener(handler);\n  tree.setCellRenderer(new Renderer());\n  return tree;\n}\n", "nl": "Creates the JList used in the popup to display the items in the combo box model. This method is called when the UI class is created."}
{"code": "@Override public int aggregateData(AbstractScannedResult scannedResult){\n  while (scannedResult.hasNext()) {\n    wrapper.setDictionaryKey(scannedResult.getDictionaryKeyArray());\n    wrapper.setNoDictionaryKeys(scannedResult.getNoDictionaryKeyArray());\n    wrapper.setComplexTypesKeys(scannedResult.getComplexTypeKeyArray());\n    MeasureAggregator[] measureAggregators=aggData.get(wrapper);\n    if (null == measureAggregators) {\n      measureAggregators=getNewAggregator();\n      ByteArrayWrapper byteArrayWrapper=wrapper;\n      wrapper=new ByteArrayWrapper();\n      aggData.put(byteArrayWrapper,measureAggregators);\n    }\n    dataAggregator.aggregateData(scannedResult,measureAggregators);\n  }\n  return 0;\n}\n", "nl": "Below method will be used to aggregate the scanned result"}
{"code": "public void testCrashCorruptsIndexing() throws Exception {\n  path=createTempDir(\"testCrashCorruptsIndexing\");\n  indexAndCrashOnCreateOutputSegments2();\n  searchForFleas(2);\n  indexAfterRestart();\n  searchForFleas(3);\n}\n", "nl": "LUCENE-3627: This test fails."}
{"code": "public ServiceHost startService(Service service){\n  Operation post=Operation.createPost(UriUtils.buildUri(this,service.getClass()));\n  return startService(post,service);\n}\n", "nl": "Start a service using the default start operation."}
{"code": "public String dropEngine(Engine engine){\n  StringBuilder builder=new StringBuilder();\n  for (  String attribute : Setup.getDropEngineMessageFormat()) {\n    builder.append(getEngineAttribute(engine,attribute,!PICKUP));\n  }\n  return builder.toString();\n}\n", "nl": "Returns the drop string for a loco. Useful for frames like the train conductor and yardmaster."}
{"code": "@Override public boolean rowInserted() throws SQLException {\n  try {\n    debugCodeCall(\"rowInserted\");\n    return false;\n  }\n catch (  Exception e) {\n    throw logAndConvert(e);\n  }\n}\n", "nl": "Detects if the row was inserted."}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:22.109 -0500\",hash_original_method=\"3044E621F64D9746C61861BC2D15D7B8\",hash_generated_method=\"55D3BEE5320ADD2D9AB948841488DEF3\") private void sendMessage(byte[] msg,boolean retry) throws IOException {\n  Socket sock=this.sipStack.ioHandler.sendBytes(this.messageProcessor.getIpAddress(),this.peerAddress,this.peerPort,this.peerProtocol,msg,retry,this);\n  if (sock != mySock && sock != null) {\n    try {\n      if (mySock != null)       mySock.close();\n    }\n catch (    IOException ex) {\n    }\n    mySock=sock;\n    this.myClientInputStream=mySock.getInputStream();\n    this.myClientOutputStream=mySock.getOutputStream();\n    Thread thread=new Thread(this);\n    thread.setDaemon(true);\n    thread.setName(\"TCPMessageChannelThread\");\n    thread.start();\n  }\n}\n", "nl": "Send message to whoever is connected to us. Uses the topmost via address to send to."}
{"code": "public int indexOf(final StrMatcher matcher){\n  return indexOf(matcher,0);\n}\n", "nl": "Searches the string builder using the matcher to find the first match. <p> Matchers can be used to perform advanced searching behaviour. For example you could write a matcher to find the character 'a' followed by a number."}
{"code": "public static void checkArgument(boolean expression,Object errorMessage){\n  if (!expression) {\n    throw new IllegalArgumentException(String.valueOf(errorMessage));\n  }\n}\n", "nl": "Ensures the truth of an expression involving one or more parameters to the calling method."}
{"code": "public int score(){\n  return score;\n}\n", "nl": "Return the score for this node."}
{"code": "public void tryToDequeueAllOneToOneChatMessagesAndOneToOneFileTransfers(){\n  mImOperationHandler.post(new OneToOneChatDequeueTask(mCtx,mCore,mMessagingLog,mRcsSettings,mChatService,mFileTransferService,mContactManager,mHistoryLog));\n}\n", "nl": "Try to dequeue all one-to-one chat messages and one-one file transfers"}
{"code": "public DisposableLazy(){\n  super();\n}\n", "nl": "Constructs an empty lazy object with no provider. Stored variable has to be set manually."}
{"code": "public boolean selectSingleNode(D nodeData){\n  if ((selectedNodes.size() == 1) && (selectedNodes.get(0).equals(nodeData))) {\n    return false;\n  }\n  clearSelections();\n  insertAndSelectNode(nodeData,0,true);\n  return true;\n}\n", "nl": "Clears the the current selection and selects a single node."}
{"code": "@Deprecated public MutuallyExclusiveSetLock(boolean fair){\n  this(fair,null);\n}\n", "nl": "Constructs a new <code>MutuallyExclusiveSetLock</code>."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "private void start(){\n  mStarted=true;\n  mEnableSessionInvalidationsTimer.resume();\n  Intent intent=new Intent(mContext,InvalidationClientService.class);\n  mContext.startService(intent);\n}\n", "nl": "Starts the invalidation client without updating the registered invalidation types."}
{"code": "public static SimpleSimulationProperties serializableInstance(){\n  return new SimpleSimulationProperties();\n}\n", "nl": "Generates a simple exemplar of this class to test serialization."}
{"code": "public Annotation(boolean isPersistent){\n  this(null,isPersistent,null,0,null,null);\n}\n", "nl": "Creates a new annotation with the given persistence state."}
{"code": "public void addState(int[] specs,Animation animation){\n  Tuple tuple=new Tuple(specs,animation);\n  animation.setAnimationListener(mAnimationListener);\n  mTuples.add(tuple);\n}\n", "nl": "Associates the given Animation with the provided drawable state specs so that it will be run when the View's drawable state matches the specs."}
{"code": "public void decodeAttributeBody(byte[] attributeValue,char offset,char length){\n  hmacSha1Content=new byte[length];\n  System.arraycopy(attributeValue,offset,hmacSha1Content,0,length);\n}\n", "nl": "Sets this attribute's fields according to the message and attributeValue arrays."}
{"code": "public ShapeWriter(PointTransformation pointTransformer,PointShapeFactory pointFactory){\n  if (pointTransformer != null)   this.pointTransformer=pointTransformer;\n  if (pointFactory != null)   this.pointFactory=pointFactory;\n}\n", "nl": "Creates a new ShapeWriter with a specified point transformation and point shape factory."}
{"code": "private int handleDataMessage(String lastRxMsg){\n  int result=0;\nswitch (service) {\ncase OBD_SVC_NONE:\n    break;\ncase OBD_SVC_CAN_MONITOR:\n  result=canProt.handleTelegram(lastRxMsg.toCharArray());\nbreak;\ndefault :\nresult=super.handleTelegram(lastRxMsg.toCharArray());\n}\nreturn result;\n}\n", "nl": "forward data message for further handling"}
{"code": "public final Intersection[] intersect(Line line){\n  if (line == null) {\n    String message=Logging.getMessage(\"nullValue.LineIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  double a=line.getDirection().getLengthSquared3();\n  double b=2 * line.selfDot();\n  double c=line.getOrigin().getLengthSquared3() - this.radius * this.radius;\n  double discriminant=Sphere.discriminant(a,b,c);\n  if (discriminant < 0)   return null;\n  double discriminantRoot=Math.sqrt(discriminant);\n  if (discriminant == 0) {\n    Vec4 p=line.getPointAt((-b - discriminantRoot) / (2 * a));\n    return new Intersection[]{new Intersection(p,true)};\n  }\n else {\n    Vec4 near=line.getPointAt((-b - discriminantRoot) / (2 * a));\n    Vec4 far=line.getPointAt((-b + discriminantRoot) / (2 * a));\n    return new Intersection[]{new Intersection(near,false),new Intersection(far,false)};\n  }\n}\n", "nl": "Obtains the intersections of this sphere with a line. The returned array may be either null or of zero length if no intersections are discovered. It does not contain null elements and will have a size of 2 at most. Tangential intersections are marked as such. <code>line</code> is considered to have infinite length in both directions."}
{"code": "public void addMessageToConsole(String message,int lineNumber,String sourceID,int msgLevel){\n  if (mWebChromeClient == null) {\n    return;\n  }\n  Message msg=obtainMessage(ADD_MESSAGE_TO_CONSOLE);\n  msg.getData().putString(\"message\",message);\n  msg.getData().putString(\"sourceID\",sourceID);\n  msg.getData().putInt(\"lineNumber\",lineNumber);\n  msg.getData().putInt(\"msgLevel\",msgLevel);\n  sendMessage(msg);\n}\n", "nl": "Called by WebViewCore when we have a message to be added to the JavaScript error console. Sends a message to the Java side with the details."}
{"code": "public org.smpte_ra.schemas.st2067_2_2016.CompositionTimecodeType buildCompositionTimeCode(BigInteger compositionEditRate){\n  org.smpte_ra.schemas.st2067_2_2016.CompositionTimecodeType compositionTimecodeType=new CompositionTimecodeType();\n  compositionTimecodeType.setTimecodeDropFrame(false);\n  compositionTimecodeType.setTimecodeRate(compositionEditRate);\n  compositionTimecodeType.setTimecodeStartAddress(IMFUtils.generateTimecodeStartAddress());\n  return compositionTimecodeType;\n}\n", "nl": "A method to construct a CompositionTimecodeType conforming to the 2016 schema"}
{"code": "public static String saveImageResultsToHtml(String prefix,ImageSearchHits hits,String queryImage,IndexReader reader) throws IOException {\n  long l=System.currentTimeMillis() / 1000;\n  String fileName=\"results-\" + prefix + \"-\"+ l+ \".html\";\n  BufferedWriter bw=new BufferedWriter(new FileWriter(fileName));\n  bw.write(\"<html>\\n\" + \"<head><title>Search Results</title></head>\\n\" + \"<body bgcolor=\\\"#FFFFFF\\\">\\n\");\n  bw.write(\"<h3>query</h3>\\n\");\n  bw.write(\"<a href=\\\"file://\" + queryImage + \"\\\"><img src=\\\"file://\"+ queryImage+ \"\\\"></a><p>\\n\");\n  bw.write(\"<h3>results</h3>\\n\");\n  for (int i=0; i < hits.length(); i++) {\n    bw.write(hits.score(i) + \" - <a href=\\\"file://\" + reader.document(hits.documentID(i)).getValues(DocumentBuilder.FIELD_NAME_IDENTIFIER)[0]+ \"\\\"><img src=\\\"file://\"+ reader.document(hits.documentID(i)).getValues(DocumentBuilder.FIELD_NAME_IDENTIFIER)[0]+ \"\\\"></a><p>\\n\");\n  }\n  bw.write(\"</body>\\n\" + \"</html>\");\n  bw.close();\n  return fileName;\n}\n", "nl": "Puts results into a HTML file."}
{"code": "public IElementType advance() throws java.io.IOException {\n  int zzInput;\n  int zzAction;\n  int zzCurrentPosL;\n  int zzMarkedPosL;\n  int zzEndReadL=zzEndRead;\n  CharSequence zzBufferL=zzBuffer;\n  char[] zzBufferArrayL=zzBufferArray;\n  char[] zzCMapL=ZZ_CMAP;\n  int[] zzTransL=ZZ_TRANS;\n  int[] zzRowMapL=ZZ_ROWMAP;\n  int[] zzAttrL=ZZ_ATTRIBUTE;\n  while (true) {\n    zzMarkedPosL=zzMarkedPos;\n    zzAction=-1;\n    zzCurrentPosL=zzCurrentPos=zzStartRead=zzMarkedPosL;\n    zzState=ZZ_LEXSTATE[zzLexicalState];\n    zzForAction: {\n      while (true) {\n        if (zzCurrentPosL < zzEndReadL)         zzInput=(zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++));\n else         if (zzAtEOF) {\n          zzInput=YYEOF;\n          break zzForAction;\n        }\n else {\n          zzCurrentPos=zzCurrentPosL;\n          zzMarkedPos=zzMarkedPosL;\n          boolean eof=zzRefill();\n          zzCurrentPosL=zzCurrentPos;\n          zzMarkedPosL=zzMarkedPos;\n          zzBufferL=zzBuffer;\n          zzEndReadL=zzEndRead;\n          if (eof) {\n            zzInput=YYEOF;\n            break zzForAction;\n          }\n else {\n            zzInput=(zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++));\n          }\n        }\n        int zzNext=zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];\n        if (zzNext == -1)         break zzForAction;\n        zzState=zzNext;\n        int zzAttributes=zzAttrL[zzState];\n        if ((zzAttributes & 1) == 1) {\n          zzAction=zzState;\n          zzMarkedPosL=zzCurrentPosL;\n          if ((zzAttributes & 8) == 8)           break zzForAction;\n        }\n      }\n    }\n    zzMarkedPos=zzMarkedPosL;\nswitch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\ncase 2:\n{\n        return JavaTokenType.WHITE_SPACE;\n      }\ncase 7:\n    break;\ncase 3:\n{\n    return SPITokenType.IDENTIFIER;\n  }\ncase 8:\nbreak;\ncase 6:\n{\nreturn JavaTokenType.DOT;\n}\ncase 9:\nbreak;\ncase 5:\n{\nreturn SPITokenType.DOLLAR;\n}\ncase 10:\nbreak;\ncase 4:\n{\nreturn JavaTokenType.END_OF_LINE_COMMENT;\n}\ncase 11:\nbreak;\ncase 1:\n{\nreturn JavaTokenType.BAD_CHARACTER;\n}\ncase 12:\nbreak;\ndefault :\nif (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\nzzAtEOF=true;\nzzDoEOF();\nreturn null;\n}\n else {\nzzScanError(ZZ_NO_MATCH);\n}\n}\n}\n}\n", "nl": "Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs."}
{"code": "public RequestBuilder form(Object... args){\n  return with(formParams,args);\n}\n", "nl": "Adds form parameters."}
{"code": "private static MyPresenceManager createInstance(Context context,MXSession session){\n  MyPresenceManager instance=new MyPresenceManager(context,session);\n  instances.put(session,instance);\n  return instance;\n}\n", "nl": "Create an instance without any check."}
{"code": "public Builder(){\n}\n", "nl": "Instantiates a new builder."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile;\n  String outputFile;\n  boolean flag;\n  int row, col, rN, cN, r, c, count;\n  double xCoord, yCoord;\n  int progress;\n  int i, a;\n  boolean patternMatch;\n  double value, z, zN;\n  int[] neighbours=new int[8];\n  int FID=0;\n  int[] rowVals=new int[2];\n  int[] colVals=new int[2];\n  int traceDirection=0;\n  int previousTraceDirection=0;\n  double currentHalfRow=0, currentHalfCol=0;\n  double[] inputValueData=new double[4];\n  long numPoints;\n  int minLineLength=2;\n  int[] dX={1,1,1,0,-1,-1,-1,0};\n  int[] dY={-1,0,1,1,1,0,-1,-1};\n  int[][] elements={{6,7,0,4,3,2},{7,0,1,3,5},{0,1,2,4,5,6},{1,2,3,5,7},{2,3,4,6,7,0},{3,4,5,7,1},{4,5,6,0,1,2},{5,6,7,1,3},{0,1,2,3,4,5,6,7},{0,1,2,3,4,5,6,7}};\n  double[][] vals={{0,0,0,1,1,1},{0,0,0,1,1},{0,0,0,1,1,1},{0,0,0,1,1},{0,0,0,1,1,1},{0,0,0,1,1},{0,0,0,1,1,1},{0,0,0,1,1},{1,1,1,1,1,1,1,1},{0,0,0,0,0,0,0,0}};\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputFile=args[0];\n  outputFile=args[1];\n  minLineLength=Integer.parseInt(args[2]);\n  if (minLineLength < 2) {\n    minLineLength=2;\n  }\n  if ((inputFile == null) || (outputFile == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster input=new WhiteboxRaster(inputFile,\"r\");\n    int rows=input.getNumberRows();\n    int cols=input.getNumberColumns();\n    double rowsD=(double)rows;\n    double colsD=(double)cols;\n    double noData=input.getNoDataValue();\n    double gridResX=input.getCellSizeX();\n    double gridResY=input.getCellSizeY();\n    double east=input.getEast() - gridResX / 2.0;\n    double west=input.getWest() + gridResX / 2.0;\n    double EWRange=east - west;\n    double north=input.getNorth() - gridResY / 2.0;\n    double south=input.getSouth() + gridResY / 2.0;\n    double NSRange=north - south;\n    String tempHeader1=inputFile.replace(\".dep\",\"_temp1.dep\");\n    WhiteboxRaster temp1=new WhiteboxRaster(tempHeader1,\"rw\",inputFile,WhiteboxRaster.DataType.INTEGER,0);\n    temp1.isTemporaryFile=true;\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=input.getValue(row,col);\n        if (z > 0 && z != noData) {\n          for (i=0; i < 8; i++) {\n            z=input.getValue(row + dY[i],col + dX[i]);\n            if (z == 1) {\n              neighbours[i]=1;\n            }\n else {\n              neighbours[i]=0;\n            }\n          }\n          value=1;\n          for (a=8; a < elements.length; a++) {\n            patternMatch=true;\n            for (i=0; i < elements[a].length; i++) {\n              if (neighbours[elements[a][i]] != vals[a][i]) {\n                patternMatch=false;\n                break;\n              }\n            }\n            if (patternMatch) {\n              value=0;\n            }\n          }\n          temp1.setValue(row,col,value);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100.0 * row / (rows - 1));\n      updateProgress(\"Loop 1 of 4:\",progress);\n    }\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=temp1.getValue(row,col);\n        if (z == 1) {\n          for (i=0; i < 8; i++) {\n            z=temp1.getValue(row + dY[i],col + dX[i]);\n            if (z == 1) {\n              neighbours[i]=1;\n            }\n else {\n              neighbours[i]=0;\n            }\n          }\n          value=1;\n          for (a=0; a < 8; a++) {\n            patternMatch=true;\n            for (i=0; i < elements[a].length; i++) {\n              if (neighbours[elements[a][i]] != vals[a][i]) {\n                patternMatch=false;\n                break;\n              }\n            }\n            if (patternMatch) {\n              value=0;\n            }\n          }\n          temp1.setValue(row,col,value);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100.0 * row / (rows - 1));\n      updateProgress(\"Loop 2 of 4:\",progress);\n    }\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=temp1.getValue(row,col);\n        if (z > 0 && z != noData) {\n          count=0;\n          for (i=0; i < 8; i++) {\n            rN=row + dY[i];\n            cN=col + dX[i];\n            zN=temp1.getValue(rN,cN);\n            if (zN > 0 && zN != noData) {\n              count++;\n            }\n          }\n          temp1.setValue(row,col,count);\n        }\n else {\n          temp1.setValue(row,col,0);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100.0 * row / (rows - 1));\n      updateProgress(\"Loop 3 of 4:\",progress);\n    }\n    ShapeFile output=new ShapeFile(outputFile,ShapeType.POLYLINE);\n    DBFField fields[]=new DBFField[2];\n    fields[0]=new DBFField();\n    fields[0].setName(\"FID\");\n    fields[0].setDataType(DBFField.DBFDataType.NUMERIC);\n    fields[0].setFieldLength(10);\n    fields[0].setDecimalCount(0);\n    fields[1]=new DBFField();\n    fields[1].setName(\"VALUE\");\n    fields[1].setDataType(DBFField.DBFDataType.NUMERIC);\n    fields[1].setFieldLength(10);\n    fields[1].setDecimalCount(2);\n    String DBFName=output.getDatabaseFile();\n    DBFWriter writer=new DBFWriter(new File(DBFName));\n    writer.setFields(fields);\n    int[] parts={0};\n    boolean pointAdded=false;\n    for (row=0; row < rows; row++) {\n      for (col=0; col < cols; col++) {\n        z=temp1.getValue(row,col);\n        if (z == 1) {\n          PointsList points=new PointsList();\n          value=1;\n          r=row;\n          c=col;\n          flag=true;\n          previousTraceDirection=-1;\n          traceDirection=0;\n          do {\n            xCoord=west + (c / colsD) * EWRange;\n            yCoord=north - (r / rowsD) * NSRange;\n            pointAdded=false;\n            if (traceDirection != previousTraceDirection) {\n              points.addPoint(xCoord,yCoord);\n              previousTraceDirection=traceDirection;\n              pointAdded=true;\n            }\n            temp1.setValue(r,c,0);\n            traceDirection=-1;\n            value=-1;\n            for (i=0; i < 8; i++) {\n              rN=r + dY[i];\n              cN=c + dX[i];\n              zN=temp1.getValue(rN,cN);\n              if (zN > 0 && zN != noData) {\n                traceDirection=i;\n                value=zN;\n                break;\n              }\n            }\n            if (value == 2) {\n              r+=dY[traceDirection];\n              c+=dX[traceDirection];\n            }\n else             if (value >= 0) {\n              r+=dY[traceDirection];\n              c+=dX[traceDirection];\n              if (!pointAdded) {\n                xCoord=west + (c / colsD) * EWRange;\n                yCoord=north - (r / rowsD) * NSRange;\n                points.addPoint(xCoord,yCoord);\n              }\n              if (value == 1) {\n                temp1.setValue(r,c,0);\n              }\n else {\n                temp1.setValue(r,c,value - 1);\n              }\n              flag=false;\n            }\n else {\n              flag=false;\n            }\n          }\n while (flag);\n          if (points.size() >= minLineLength) {\n            PolyLine poly=new PolyLine(parts,points.getPointsArray());\n            output.addRecord(poly);\n            Object[] rowData=new Object[2];\n            rowData[0]=new Double(FID);\n            rowData[1]=new Double(z);\n            writer.addRecord(rowData);\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100.0 * row / (rows - 1));\n      updateProgress(\"Loop 4 of 4:\",progress);\n    }\n    temp1.close();\n    input.close();\n    output.write();\n    returnData(outputFile);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public boolean isErrors(){\n  return errors;\n}\n", "nl": "method to check if any errors were generated during DITA generation"}
{"code": "public CustomSwitchPreference(Context context,AttributeSet attrs){\n  super(context,attrs);\n}\n", "nl": "Construct a new SwitchPreference with the given style options."}
{"code": "public KerningTable(Kern[] entries){\n  this.entries=entries;\n}\n", "nl": "Creates a KerningTable from an array of Kern entries."}
{"code": "public static byte[] formatMessageForSigning(String message){\n  try {\n    ByteArrayOutputStream bos=new ByteArrayOutputStream();\n    bos.write(BITCOIN_SIGNED_MESSAGE_HEADER_BYTES.length);\n    bos.write(BITCOIN_SIGNED_MESSAGE_HEADER_BYTES);\n    byte[] messageBytes=message.getBytes(Charsets.UTF_8);\n    VarInt size=new VarInt(messageBytes.length);\n    bos.write(size.encode());\n    bos.write(messageBytes);\n    return bos.toByteArray();\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}\n", "nl": "<p>Given a textual message, returns a byte buffer formatted as follows:</p> <tt><p>[24] \"Bitcoin Signed Message:\\n\" [message.length as a varint] message</p></tt>"}
{"code": "public Scenario(MapEnvironment env,Map agentMap,String agentLoc){\n  this.agentMap=agentMap;\n  this.env=env;\n  this.initAgentLoc=agentLoc;\n}\n", "nl": "Creates a scenario."}
{"code": "public IpInterfaceRestRep create(URI hostId,IpInterfaceCreateParam input){\n  return client.post(IpInterfaceRestRep.class,input,PathConstants.IPINTERFACE_BY_HOST_URL,hostId);\n}\n", "nl": "Creates an IP interface for the given host. <p> API Call: <tt>POST /compute/hosts/{hostId}/ip-interfaces</tt>"}
{"code": "public Writer write(Writer writer) throws JSONException {\n  return this.write(writer,0,0);\n}\n", "nl": "Write the contents of the JSONObject as JSON text to a writer. For compactness, no whitespace is added. <p> Warning: This method assumes that the data structure is acyclical."}
{"code": "private boolean createTable(MTable mTable,DatabaseMetaData md){\n  String tableName=mTable.getTableName();\n  log.info(tableName);\n  String catalog=m_dbSource.getCatalog();\n  String schema=m_dbSource.getSchema();\n  String table=tableName.toUpperCase();\n  MColumn[] columns=mTable.getColumns(false);\n  StringBuffer sb=new StringBuffer(\"CREATE TABLE \");\n  sb.append(tableName).append(\" (\");\n  try {\n    boolean first=true;\n    ResultSet sourceColumns=md.getColumns(catalog,schema,table,null);\n    while (sourceColumns.next()) {\n      sb.append(first ? \"\" : \", \");\n      first=false;\n      MColumn column=null;\n      String columnName=sourceColumns.getString(\"COLUMN_NAME\");\n      for (int i=0; i < columns.length; i++) {\n        String cn=columns[i].getColumnName();\n        if (cn.equalsIgnoreCase(columnName)) {\n          columnName=cn;\n          column=columns[i];\n          break;\n        }\n      }\n      sb.append(columnName).append(\" \");\n      int sqlType=sourceColumns.getInt(\"DATA_TYPE\");\n      String typeName=sourceColumns.getString(\"TYPE_NAME\");\n      int size=sourceColumns.getInt(\"COLUMN_SIZE\");\n      int decDigits=sourceColumns.getInt(\"DECIMAL_DIGITS\");\n      if (sourceColumns.wasNull())       decDigits=-1;\n      if (typeName.equals(\"NUMBER\")) {\n        int dt=column.getAD_Reference_ID();\n        if (DisplayType.isID(dt))         sb.append(\"INTEGER\");\n else {\n          int scale=DisplayType.getDefaultPrecision(dt);\n          sb.append(\"DECIMAL(\").append(18 + scale).append(\",\").append(scale).append(\")\");\n        }\n      }\n else       if (typeName.equals(\"DATE\") || typeName.equals(\"BLOB\") || typeName.equals(\"CLOB\"))       sb.append(typeName);\n else       if (typeName.equals(\"CHAR\") || typeName.startsWith(\"VARCHAR\"))       sb.append(typeName).append(\"(\").append(size).append(\")\");\n else       if (typeName.startsWith(\"NCHAR\") || typeName.startsWith(\"NVAR\"))       sb.append(typeName).append(\"(\").append(size / 2).append(\")\");\n else       if (typeName.startsWith(\"TIMESTAMP\"))       sb.append(\"DATE\");\n else       log.severe(\"Do not support data type \" + typeName);\n      String def=sourceColumns.getString(\"COLUMN_DEF\");\n      if (def != null) {\n        def.replaceAll(\"''\",\"\\\\'\");\n        sb.append(\" DEFAULT \").append(def);\n      }\n      if (sourceColumns.getInt(\"NULLABLE\") == DatabaseMetaData.columnNoNulls)       sb.append(\" NOT NULL\");\n else       sb.append(\" NULL\");\n    }\n    sourceColumns.close();\n    ResultSet sourcePK=md.getPrimaryKeys(catalog,schema,table);\n    first=true;\n    boolean hasPK=false;\n    while (sourcePK.next()) {\n      hasPK=true;\n      if (first)       sb.append(\", CONSTRAINT \").append(sourcePK.getString(\"PK_NAME\")).append(\" PRIMARY KEY (\");\n else       sb.append(\",\");\n      first=false;\n      String columnName=sourcePK.getString(\"COLUMN_NAME\");\n      sb.append(checkColumnName(columnName));\n    }\n    if (hasPK)     sb.append(\")\");\n    sourcePK.close();\n    sb.append(\")\");\n  }\n catch (  Exception ex) {\n    log.log(Level.SEVERE,\"createTable\",ex);\n    return false;\n  }\n  if (!executeCommands(new String[]{sb.toString()},m_conn,false,true))   return true;\n  createTableIndexes(mTable,md);\n  return createTableData(mTable);\n}\n", "nl": "Create Table"}
{"code": "public ImAdapterFactory(){\n  if (modelPackage == null) {\n    modelPackage=ImPackage.eINSTANCE;\n  }\n}\n", "nl": "Creates an instance of the adapter factory. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static int indexOf(Coordinate coordinate,Coordinate[] coordinates){\n  for (int i=0; i < coordinates.length; i++) {\n    if (coordinate.equals(coordinates[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "nl": "Returns the index of <code>coordinate</code> in <code>coordinates</code>. The first position is 0; the second, 1; etc."}
{"code": "public void addTestSuite(Class<? extends Test> testClass,Validator[] validators){\n  addTestSuite(testClass,validators,null);\n}\n", "nl": "Add a given test suite."}
{"code": "public void testHttpsConnection_Not_Found_Response() throws Throwable {\n  setUpStoreProperties();\n  SSLContext ctx=getContext();\n  ServerSocket ss=ctx.getServerSocketFactory().createServerSocket(0);\n  TestHostnameVerifier hnv=new TestHostnameVerifier();\n  HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n  URL url=new URL(\"https://localhost:\" + ss.getLocalPort());\n  HttpsURLConnection connection=(HttpsURLConnection)url.openConnection();\n  connection.setSSLSocketFactory(ctx.getSocketFactory());\n  try {\n    doInteraction(connection,ss,NOT_FOUND_CODE);\n    fail(\"Expected exception was not thrown.\");\n  }\n catch (  FileNotFoundException e) {\n    if (DO_LOG) {\n      System.out.println(\"Expected exception was thrown: \" + e.getMessage());\n      e.printStackTrace();\n    }\n  }\n  connection.connect();\n}\n", "nl": "Tests the behaviour of HTTPS connection in case of unavailability of requested resource."}
{"code": "private void synthesise(String utterance){\n  String systemSpeechVar=system.getSettings().systemSpeech;\n  SpeechData outputSpeech;\n  if (ttsCache.containsKey(utterance)) {\n    outputSpeech=ttsCache.get(utterance);\n    outputSpeech.rewind();\n  }\n else {\n    AudioFormat format=new AudioFormat(16000,16,1,true,false);\n    outputSpeech=new SpeechData(format);\n    new Thread(null).start();\n  }\n  currentSynthesis.add(outputSpeech);\n  new Thread(null).start();\n}\n", "nl": "Synthesises the provided utterance (first looking at the cache of existing synthesised speech, and starting the generation if no one is already present)."}
{"code": "public HostCandidate(TransportAddress transportAddress,Component parentComponent){\n  super(transportAddress,parentComponent,CandidateType.HOST_CANDIDATE,CandidateExtendedType.HOST_CANDIDATE,null);\n  this.socket=null;\n  setBase(this);\n}\n", "nl": "Creates a HostCandidate for the specified transport address."}
{"code": "public void applyQueryTimeout(Statement stmt){\n  if (hasQueryTimeout()) {\n    try {\n      stmt.setQueryTimeout(getQueryTimeoutInSeconds());\n    }\n catch (    SQLException e) {\n      throw new JDBCException(\"failed to setQueryTimeout to :\" + getQueryTimeoutInSeconds(),e,e.getSQLState());\n    }\n  }\n}\n", "nl": "Apply the current query timeout, if any, to the current <code>Statement</code>."}
{"code": "public static SRegResponse createFetchResponse(){\n  return new SRegResponse();\n}\n", "nl": "Constructs a SReg Response with an empty parameter list."}
{"code": "public static UPSCoord fromLatLon(Angle latitude,Angle longitude){\n  if (latitude == null || longitude == null) {\n    throw new IllegalArgumentException(\"Latitude Or Longitude Is Null\");\n  }\n  final UPSCoordConverter converter=new UPSCoordConverter();\n  long err=converter.convertGeodeticToUPS(latitude.radians,longitude.radians);\n  if (err != UPSCoordConverter.UPS_NO_ERROR) {\n    throw new IllegalArgumentException(\"UPS Conversion Error\");\n  }\n  return new UPSCoord(latitude,longitude,converter.getHemisphere(),converter.getEasting(),converter.getNorthing());\n}\n", "nl": "Create a set of UPS coordinates from a pair of latitude and longitude for the given <code>Globe</code>."}
{"code": "public boolean isEmpty(){\n  return (m_index == -1);\n}\n", "nl": "Tests if this stack is empty."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:52.028 -0400\",hash_original_method=\"95976D81CB90569BB8CC4A3AB0B84125\",hash_generated_method=\"24F0FD499D929F2BE98900B33186C3D7\") @Override public String toString(){\n  return new String(toByteArray());\n}\n", "nl": "Gets the curent contents of this byte stream as a string."}
{"code": "public Cursor newCursor(String storeName) throws UnknownStoreException {\n  IStore<ByteArray,byte[]> store=getStore(storeName);\n  int cursorId=rpcService.getTransactionId();\n  Cursor cursor=new Cursor(cursorId,store.entries());\n  cursorMap.put(Integer.valueOf(cursorId),cursor);\n  return cursor;\n}\n", "nl": "Allocate a new cursor for the given store name"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader=null;\n  String outputHeader=null;\n  int row, col;\n  double z;\n  int progress=0;\n  int i, a;\n  long counter=0;\n  int loopNum=0;\n  int[] dX={1,1,1,0,-1,-1,-1,0};\n  int[] dY={-1,0,1,1,1,0,-1,-1};\n  int[][] elements={{0,1,4,5,6,7},{0,1,2,5,6,7},{0,1,2,3,6,7},{0,1,2,3,4,7},{0,1,2,3,4,5},{1,2,3,4,5,6},{2,3,4,5,6,7},{0,3,4,5,6,7}};\n  double[] neighbours=new double[8];\n  boolean patternMatch=false;\n  int numIterations=10;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputHeader=args[0];\n  outputHeader=args[1];\n  numIterations=Integer.parseInt(args[2]);\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster image=new WhiteboxRaster(inputHeader,\"r\");\n    int nRows=image.getNumberRows();\n    int nCols=image.getNumberColumns();\n    double noData=image.getNoDataValue();\n    WhiteboxRaster output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    output.setPreferredPalette(\"black_white.pal\");\n    double[] data=null;\n    for (row=0; row < nRows; row++) {\n      data=image.getRowValues(row);\n      for (col=0; col < nCols; col++) {\n        if (data[col] > 0) {\n          output.setValue(row,col,1);\n        }\n else         if (data[col] == noData) {\n          output.setValue(row,col,noData);\n        }\n else {\n          output.setValue(row,col,0);\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (nRows - 1));\n      updateProgress(progress);\n    }\n    image.close();\n    output.flush();\n    for (int k=0; k < numIterations; k++) {\n      loopNum++;\n      updateProgress(\"Loop Number \" + loopNum + \":\",0);\n      counter=0;\n      for (row=0; row < nRows; row++) {\n        for (col=0; col < nCols; col++) {\n          z=output.getValue(row,col);\n          if (z == 1 && z != noData) {\n            for (i=0; i < 8; i++) {\n              neighbours[i]=output.getValue(row + dY[i],col + dX[i]);\n            }\n            for (a=0; a < 8; a++) {\n              patternMatch=true;\n              for (i=0; i < elements[a].length; i++) {\n                if (neighbours[elements[a][i]] != 0) {\n                  patternMatch=false;\n                }\n              }\n              if (patternMatch) {\n                output.setValue(row,col,0);\n                counter++;\n              }\n            }\n          }\n        }\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress=(int)(100f * row / (nRows - 1));\n        updateProgress(progress);\n      }\n      if (counter == 0) {\n        break;\n      }\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    output.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(characterdatareplacedataend.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public ToolMetaBuilder start(final ToolMeta meta){\n  return new ToolMetaBuilder(meta);\n}\n", "nl": "Returns new builder of item meta data, based on given one."}
{"code": "public void loadAttributes(Element e3){\n  if (e3 != null) {\n    List<Element> l=e3.getChildren(\"keyvaluepair\");\n    for (    Element fn : l) {\n      String key=fn.getChild(\"key\").getText();\n      String value=fn.getChild(\"value\").getText();\n      this.putAttribute(key,value);\n    }\n  }\n}\n", "nl": "Loads attribute key/value pairs from a JDOM element."}
{"code": "public static boolean neededFor(int uc){\n  return (uc >= UCS4_MIN) && (uc <= UCS4_MAX);\n}\n", "nl": "Tells whether or not the given UCS-4 character must be represented as a surrogate pair in UTF-16."}
{"code": "public Coordinate centre(){\n  if (isNull())   return null;\n  return new Coordinate((getMinX() + getMaxX()) / 2.0,(getMinY() + getMaxY()) / 2.0);\n}\n", "nl": "Computes the coordinate of the centre of this envelope (as long as it is non-null"}
{"code": "public synchronized void stopPreview(){\n  if (autoFocusManager != null) {\n    autoFocusManager.stop();\n    autoFocusManager=null;\n  }\n  if (camera != null && previewing) {\n    camera.stopPreview();\n    previewCallback.setHandler(null,0);\n    previewing=false;\n  }\n}\n", "nl": "Tells the camera to stop drawing preview frames."}
{"code": "private CIMObjectPath createOrSelectSLOBasedStorageGroup(StorageSystem storage,URI exportMaskURI,Collection<Initiator> initiators,VolumeURIHLU[] volumeURIHLUs,String parentGroupName,Map<StorageGroupPolicyLimitsParam,CIMObjectPath> newlyCreatedChildVolumeGroups,TaskCompleter taskCompleter) throws Exception {\n  List<CIMObjectPath> childVolumeGroupsToBeAddedToParentGroup=new ArrayList<CIMObjectPath>();\n  String groupName=null;\n  CIMObjectPath groupPath=null;\n  ExportMask mask=_dbClient.queryObject(ExportMask.class,exportMaskURI);\n  ListMultimap<StorageGroupPolicyLimitsParam,VolumeURIHLU> policyToVolumeGroup=ArrayListMultimap.create();\n  WBEMClient client=_helper.getConnection(storage).getCimClient();\n  for (  VolumeURIHLU volumeUriHLU : volumeURIHLUs) {\n    policyToVolumeGroup.put(new StorageGroupPolicyLimitsParam(volumeUriHLU,storage,_helper),volumeUriHLU);\n  }\n  _log.info(\"{} Groups generated based on grouping volumes by fast policy\",policyToVolumeGroup.size());\n  for (  Entry<StorageGroupPolicyLimitsParam,Collection<VolumeURIHLU>> policyToVolumeGroupEntry : policyToVolumeGroup.asMap().entrySet()) {\n    List<CIMObjectPath> childVolumeGroupsToBeAdded=new ArrayList<CIMObjectPath>();\n    StorageGroupPolicyLimitsParam storageGroupPolicyLimitsParam=policyToVolumeGroupEntry.getKey();\n    ListMultimap<String,VolumeURIHLU> expectedVolumeHluMap=ControllerUtils.getVolumeNativeGuids(policyToVolumeGroupEntry.getValue(),_dbClient);\n    Map<String,Set<String>> existingGroupPaths;\n    _log.info(\"Running Storage Group Selection Process\");\n    existingGroupPaths=_helper.findAnyStorageGroupsCanBeReUsed(storage,expectedVolumeHluMap,storageGroupPolicyLimitsParam);\n    _log.info(\"Existing Storage Groups Found :\" + Joiner.on(\"\\t\").join(existingGroupPaths.keySet()));\n    if (existingGroupPaths.size() > 0) {\n      if (existingGroupPaths.size() > 0) {\n        childVolumeGroupsToBeAdded.addAll(_helper.constructMaskingGroupPathsFromNames(existingGroupPaths.keySet(),storage));\n      }\n    }\n    Set<String> volumesInExistingStorageGroups=_helper.constructVolumeNativeGuids(existingGroupPaths.values());\n    _log.debug(\"Volumes part of existing reusable Storage Groups {}\",Joiner.on(\"\\t\").join(volumesInExistingStorageGroups));\n    Set<String> diff=Sets.difference(expectedVolumeHluMap.asMap().keySet(),volumesInExistingStorageGroups);\n    _log.debug(\"Remaining Volumes, for which new Storage Group needs to be created\",Joiner.on(\"\\t\").join(diff));\n    if (!diff.isEmpty()) {\n      VolumeURIHLU[] volumeURIHLU=ControllerUtils.constructVolumeUriHLUs(diff,expectedVolumeHluMap);\n      groupName=generateStorageGroupName(storage,mask,initiators,storageGroupPolicyLimitsParam);\n      _log.debug(\"Group Name Created :\",groupName);\n      groupPath=createVolumeGroup(storage,groupName,volumeURIHLU,taskCompleter,true);\n      _log.info(\"{} Volume Group created on Array {}\",storage.getSerialNumber());\n    }\n    if (null != groupPath) {\n      newlyCreatedChildVolumeGroups.put(storageGroupPolicyLimitsParam,groupPath);\n      childVolumeGroupsToBeAdded.add(groupPath);\n    }\n    childVolumeGroupsToBeAddedToParentGroup.addAll(childVolumeGroupsToBeAdded);\n  }\n  parentGroupName=_helper.generateGroupName(_helper.getExistingStorageGroupsFromArray(storage),parentGroupName);\n  CIMObjectPath cascadedGroupPath=createCascadedVolumeGroup(storage,parentGroupName,childVolumeGroupsToBeAddedToParentGroup,taskCompleter);\n  for (  Entry<StorageGroupPolicyLimitsParam,CIMObjectPath> createdChildVolumeGroupEntry : newlyCreatedChildVolumeGroups.entrySet()) {\n    CIMObjectPath childGroupPath=createdChildVolumeGroupEntry.getValue();\n    StorageGroupPolicyLimitsParam storageGroupPolicyLimitsParam=createdChildVolumeGroupEntry.getKey();\n    if (storageGroupPolicyLimitsParam.isHostIOLimitBandwidthSet()) {\n      _helper.updateHostIOLimitBandwidth(client,childGroupPath,storageGroupPolicyLimitsParam.getHostIOLimitBandwidth());\n    }\n    if (storageGroupPolicyLimitsParam.isHostIOLimitIOPsSet()) {\n      _helper.updateHostIOLimitIOPs(client,childGroupPath,storageGroupPolicyLimitsParam.getHostIOLimitIOPs());\n    }\n  }\n  return cascadedGroupPath;\n}\n", "nl": "This is used only for VMAX3."}
{"code": "public static boolean matchesExtension(String filename,String ext){\n  return filename.endsWith(\".\" + ext);\n}\n", "nl": "Returns true if the given filename ends with the given extension. One should provide a <i>pure</i> extension, without '.'."}
{"code": "@Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase BasePackage.DOMAIN_ELEMENT__DOMAIN_ID:\n    setDomainID((String)newValue);\n  return;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isPreserveHourOfDayAcrossDaylightSavings(){\n  return preserveHourOfDayAcrossDaylightSavings;\n}\n", "nl": "If intervals are a day or greater, this property (set to true) will  cause the firing of the trigger to always occur at the same time of day, (the time of day of the startTime) regardless of daylight saving time  transitions.  Default value is false. <p> For example, without the property set, your trigger may have a start  time of 9:00 am on March 1st, and a repeat interval of 2 days.  But  after the daylight saving transition occurs, the trigger may start  firing at 8:00 am every other day. </p> <p> If however, the time of day does not exist on a given day to fire (e.g. 2:00 am in the United States on the days of daylight saving transition), the trigger will go ahead and fire one hour off on  that day, and then resume the normal hour on other days.  If you wish for the trigger to never fire at the \"wrong\" hour, then you should set the property skipDayIfHourDoesNotExist. </p>"}
{"code": "public static final Uri buildFolderUri(long folderId){\n  return ContentUris.withAppendedId(CONTENT_URI_DEFAULT_FOLDER,folderId);\n}\n", "nl": "Builds a URI that points to a specific folder."}
{"code": "public synchronized static void closeAll(){\n  for (  HyperGraph graph : dbs.values()) {\n    if (graph.isOpen())     try {\n      graph.close();\n    }\n catch (    Throwable t) {\n      System.err.println(\"Problem closing HyperGraphDB instance at \" + graph.getLocation() + \", stack trace follows...\");\n      t.printStackTrace(System.err);\n    }\n  }\n  dbs.clear();\n}\n", "nl": "<p> Close all currently open <code>HyperGraph</code> instances. This is generally done by a HyperGraphDB internal shutdown hook registered with the JVM. But if you need more control over the shutdown sequence, this method will gracefully do so.  </p>"}
{"code": "public void add(Permission permission){\n  if (!(permission instanceof DelegationPermission))   throw new IllegalArgumentException(\"invalid permission: \" + permission);\n  if (isReadOnly())   throw new SecurityException(\"attempt to add a Permission to a readonly PermissionCollection\");\nsynchronized (this) {\n    perms.add(0,permission);\n  }\n}\n", "nl": "Adds a permission to the DelegationPermissions. The key for the hash is the name."}
{"code": "public boolean empty(){\n  return isEmpty();\n}\n", "nl": "Returns whether the stack is empty or not."}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "private static boolean findActivity(ArrayList<AppInfo> apps,ComponentName component,UserHandleCompat user){\n  final int N=apps.size();\n  for (int i=0; i < N; i++) {\n    final AppInfo info=apps.get(i);\n    if (info.user.equals(user) && info.componentName.equals(component)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Returns whether <em>apps</em> contains <em>component</em>."}
{"code": "private void checkAccessTime(ClientIdentification.Agent agent,final DigestURL url){\n  if (!url.isLocal()) {\n    String host=url.getHost();\n    final Long lastAccess=accessTime.get(host);\n    long wait=0;\n    if (lastAccess != null)     wait=Math.max(0,agent.minimumDelta + lastAccess.longValue() - System.currentTimeMillis());\n    if (wait > 0) {\n      final long untilTime=System.currentTimeMillis() + wait;\n      cleanupAccessTimeTable(untilTime);\n      if (System.currentTimeMillis() < untilTime) {\n        long frcdslp=untilTime - System.currentTimeMillis();\n        LoaderDispatcher.log.info(\"Forcing sleep of \" + frcdslp + \" ms for host \"+ host);\n        try {\n          Thread.sleep(frcdslp);\n        }\n catch (        final InterruptedException ee) {\n        }\n      }\n    }\n  }\n}\n", "nl": "Check access time: this is a double-check (we checked possibly already in the balancer) to make sure that we don't DoS the target by mistake"}
{"code": "@SuppressForbidden(reason=\"System.out required: command line tool\") public static void main(java.lang.String[] args) throws Exception {\n  if (args.length < 1) {\n    return;\n  }\n  args[0].toUpperCase(Locale.ROOT);\n  backward=args[0].charAt(0) == '-';\n  int qq=(backward) ? 1 : 0;\n  boolean storeorig=false;\n  if (args[0].charAt(qq) == '0') {\n    storeorig=true;\n    qq++;\n  }\n  multi=args[0].charAt(qq) == 'M';\n  if (multi) {\n    qq++;\n  }\n  String charset=System.getProperty(\"egothor.stemmer.charset\",\"UTF-8\");\n  char optimizer[]=new char[args[0].length() - qq];\n  for (int i=0; i < optimizer.length; i++) {\n    optimizer[i]=args[0].charAt(qq + i);\n  }\n  for (int i=1; i < args.length; i++) {\n    Diff diff=new Diff();\n    allocTrie();\n    System.out.println(args[i]);\n    try (LineNumberReader in=new LineNumberReader(Files.newBufferedReader(Paths.get(args[i]),Charset.forName(charset)))){\n      for (String line=in.readLine(); line != null; line=in.readLine()) {\n        try {\n          line=line.toLowerCase(Locale.ROOT);\n          StringTokenizer st=new StringTokenizer(line);\n          String stem=st.nextToken();\n          if (storeorig) {\n            trie.add(stem,\"-a\");\n          }\n          while (st.hasMoreTokens()) {\n            String token=st.nextToken();\n            if (token.equals(stem) == false) {\n              trie.add(token,diff.exec(token,stem));\n            }\n          }\n        }\n catch (        java.util.NoSuchElementException x) {\n        }\n      }\n    }\n     Optimizer o=new Optimizer();\n    Optimizer2 o2=new Optimizer2();\n    Lift l=new Lift(true);\n    Lift e=new Lift(false);\n    Gener g=new Gener();\n    for (int j=0; j < optimizer.length; j++) {\n      String prefix;\nswitch (optimizer[j]) {\ncase 'G':\n        trie=trie.reduce(g);\n      prefix=\"G: \";\n    break;\ncase 'L':\n  trie=trie.reduce(l);\nprefix=\"L: \";\nbreak;\ncase 'E':\ntrie=trie.reduce(e);\nprefix=\"E: \";\nbreak;\ncase '2':\ntrie=trie.reduce(o2);\nprefix=\"2: \";\nbreak;\ncase '1':\ntrie=trie.reduce(o);\nprefix=\"1: \";\nbreak;\ndefault :\ncontinue;\n}\ntrie.printInfo(System.out,prefix + \" \");\n}\ntry (DataOutputStream os=new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(Paths.get(args[i] + \".out\"))))){\nos.writeUTF(args[0]);\ntrie.store(os);\n}\n }\n}\n", "nl": "Entry point to the Compile application. <p> This program takes any number of arguments: the first is the name of the desired stemming algorithm to use (a list is available in the package description) , all of the rest should be the path or paths to a file or files containing a stemmer table to compile."}
{"code": "public ConnectionConfig(jmri.jmrix.NetworkPortAdapter p){\n  super(p);\n}\n", "nl": "Ctor for an object being created during load process; Swing init is deferred."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__BODY:\n    return basicSetBody(null,msgs);\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__LOK:\n  return basicSet_lok(null,msgs);\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__FPARS:\nreturn ((InternalEList<?>)getFpars()).basicRemove(otherEnd,msgs);\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__RETURN_TYPE_REF:\nreturn basicSetReturnTypeRef(null,msgs);\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__TYPE_VARS:\nreturn ((InternalEList<?>)getTypeVars()).basicRemove(otherEnd,msgs);\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__DECLARED_TYPE_REF:\nreturn basicSetDeclaredTypeRef(null,msgs);\ncase N4JSPackage.PROPERTY_METHOD_DECLARATION__BOGUS_TYPE_REF:\nreturn basicSetBogusTypeRef(null,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void characters(StylesheetHandler handler,char ch[],int start,int length) throws org.xml.sax.SAXException {\n  handler.error(XSLTErrorResources.ER_CHARS_NOT_ALLOWED,null,null);\n}\n", "nl": "Receive notification of character data inside an element."}
{"code": "private static boolean isDeprecatedSSLProtocol(){\n  return (\"com.sun.net.ssl.internal.www.protocol\".equals(System.getProperty(\"java.protocol.handler.pkgs\")));\n}\n", "nl": "Return true if the protocol handler property java. protocol.handler.pkgs is set to the Sun's com.sun.net.ssl. internal.www.protocol deprecated one, false otherwise."}
{"code": "public static String formatTimestamp(Timestamp timestamp,String format){\n  if (null != timestamp) {\n    SimpleDateFormat sdf=new SimpleDateFormat(format);\n    return sdf.format(timestamp);\n  }\n else {\n    return \"\";\n  }\n}\n", "nl": "Formats the given timestamp object in the format HH:mm"}
{"code": "public int compareTo(cp_info constant_pool[],cp_info cp,cp_info cp_constant_pool[]){\n  int i;\n  if (tag != cp.tag)   return tag - cp.tag;\n  CONSTANT_Methodref_info cu=(CONSTANT_Methodref_info)cp;\n  i=constant_pool[class_index].compareTo(constant_pool,cp_constant_pool[cu.class_index],cp_constant_pool);\n  if (i != 0)   return i;\n  return constant_pool[name_and_type_index].compareTo(constant_pool,cp_constant_pool[cu.name_and_type_index],cp_constant_pool);\n}\n", "nl": "Compares this entry with another cp_info object (which may reside in a different constant pool)."}
{"code": "protected boolean isRelevantToUser(EReference reference){\n  return TypesPackage.Literals.SYNTAX_RELATED_TELEMENT__AST_ELEMENT != reference && TypesPackage.Literals.TSTRUCT_MEMBER__DEFINED_MEMBER != reference;\n}\n", "nl": "Returns <code>true</code> if the reference should be presented to the user."}
{"code": "public void startPreview(){\n  if (camera != null && !previewing) {\n    camera.startPreview();\n    previewing=true;\n  }\n}\n", "nl": "Asks the camera hardware to begin drawing preview frames to the screen."}
{"code": "public final void flushLayoutCache(){\nsynchronized (mCachedXmlBlockIds) {\n    final int num=mCachedXmlBlockIds.length;\n    for (int i=0; i < num; i++) {\n      mCachedXmlBlockIds[i]=-0;\n      XmlBlock oldBlock=mCachedXmlBlocks[i];\n      if (oldBlock != null) {\n        oldBlock.close();\n      }\n      mCachedXmlBlocks[i]=null;\n    }\n  }\n}\n", "nl": "Call this to remove all cached loaded layout resources from the Resources object.  Only intended for use with performance testing tools."}
{"code": "public TableRowElement(){\n  super(\"tr\",new ListElement());\n}\n", "nl": "Construct an empty row"}
{"code": "public Set<Map.Entry<String,Object>> valueSet(){\n  return mValues.entrySet();\n}\n", "nl": "Returns a set of all of the keys and values"}
{"code": "@SuppressWarnings(\"unchecked\") @protection static <E>Set<E> dynamicallyCastSet(Set<?> set,Class<E> type){\n  return dynamicallyCastCollection(set,type,Set.class);\n}\n", "nl": "Dynamically check that the members of the set are all instances of the given type (or null)."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase SRuntimePackage.COMPOSITE_SLOT__SLOTS:\n    return ((InternalEList<?>)getSlots()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static String padRight(String s,int n){\n  return String.format(\"%1$-\" + n + \"s\",s);\n}\n", "nl": "Pad white space to the right of the string to the given length"}
{"code": "public static boolean isCompressed(String filename){\n  if (filename == null) {\n    return false;\n  }\n  File test=new File(filename);\n  if (test.exists()) {\n    return isCompressed(test);\n  }\n  int len=filename.length();\n  return len > 2 && (filename.substring(len - GZIP_EXTENTION.length()).equalsIgnoreCase(GZIP_EXTENTION) || filename.substring(len - COMPRESS_EXTENTION.length()).equals(COMPRESS_EXTENTION) || filename.substring(len - BZIP2_EXTENTION.length()).equals(BZIP2_EXTENTION));\n}\n", "nl": "Is a file compressed? (the magic number in the first 2 bytes is used to detect the compression."}
{"code": "boolean shouldMerge(){\n  return mergeState.segmentInfo.maxDoc() > 0;\n}\n", "nl": "True if any merging should happen"}
{"code": "public void addDaemonThreadCount(int daemonThreadCount){\n  this.totalDaemonThreadCount+=daemonThreadCount;\n}\n", "nl": "increases the daemon thread count by the given number."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:50.929 -0500\",hash_original_method=\"F21E97E0131CF96F90294027D325F2F1\",hash_generated_method=\"6C0974834F4ED5E3334D2C54E96A4062\") public boolean isUnshared(){\n  return unshared;\n}\n", "nl": "Indicates whether this field is unshared."}
{"code": "public boolean isEqualNode(Node arg){\n  if (arg == this) {\n    return true;\n  }\n  if (arg.getNodeType() != getNodeType()) {\n    return false;\n  }\n  if (getNodeName() == null) {\n    if (arg.getNodeName() != null) {\n      return false;\n    }\n  }\n else   if (!getNodeName().equals(arg.getNodeName())) {\n    return false;\n  }\n  if (getLocalName() == null) {\n    if (arg.getLocalName() != null) {\n      return false;\n    }\n  }\n else   if (!getLocalName().equals(arg.getLocalName())) {\n    return false;\n  }\n  if (getNamespaceURI() == null) {\n    if (arg.getNamespaceURI() != null) {\n      return false;\n    }\n  }\n else   if (!getNamespaceURI().equals(arg.getNamespaceURI())) {\n    return false;\n  }\n  if (getPrefix() == null) {\n    if (arg.getPrefix() != null) {\n      return false;\n    }\n  }\n else   if (!getPrefix().equals(arg.getPrefix())) {\n    return false;\n  }\n  if (getNodeValue() == null) {\n    if (arg.getNodeValue() != null) {\n      return false;\n    }\n  }\n else   if (!getNodeValue().equals(arg.getNodeValue())) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Tests whether two nodes are equal. <br>This method tests for equality of nodes, not sameness (i.e., whether the two nodes are references to the same object) which can be tested with <code>Node.isSameNode</code>. All nodes that are the same will also be equal, though the reverse may not be true. <br>Two nodes are equal if and only if the following conditions are satisfied: The two nodes are of the same type.The following string attributes are equal: <code>nodeName</code>, <code>localName</code>, <code>namespaceURI</code>, <code>prefix</code>, <code>nodeValue</code> , <code>baseURI</code>. This is: they are both <code>null</code>, or they have the same length and are character for character identical. The <code>attributes</code> <code>NamedNodeMaps</code> are equal. This is: they are both <code>null</code>, or they have the same length and for each node that exists in one map there is a node that exists in the other map and is equal, although not necessarily at the same index.The <code>childNodes</code> <code>NodeLists</code> are equal. This is: they are both <code>null</code>, or they have the same length and contain equal nodes at the same index. This is true for <code>Attr</code> nodes as for any other type of node. Note that normalization can affect equality; to avoid this, nodes should be normalized before being compared. <br>For two <code>DocumentType</code> nodes to be equal, the following conditions must also be satisfied: The following string attributes are equal: <code>publicId</code>, <code>systemId</code>, <code>internalSubset</code>.The <code>entities</code> <code>NamedNodeMaps</code> are equal.The <code>notations</code> <code>NamedNodeMaps</code> are equal. <br>On the other hand, the following do not affect equality: the <code>ownerDocument</code> attribute, the <code>specified</code> attribute for <code>Attr</code> nodes, the <code>isWhitespaceInElementContent</code> attribute for <code>Text</code> nodes, as well as any user data or event listeners registered on the nodes."}
{"code": "public static void loadComments(Element commentNode,ICommentHolder parent,Comment.Type type){\n  loadComments(commentNode,parent,0,false,false,type);\n}\n", "nl": "Extract comments recursively."}
{"code": "@Override public void merge(Descriptor other){\n  for (  DescriptorTag tag : descriptorTagFactory.getAllTags()) {\n    Identifier identifier=tag.getIdentifier();\n    if (identifier != null) {\n      MergeStrategy strategy=getMergeStrategy(tag.getTagName());\n      Descriptor left=baseDescriptor;\n      Descriptor right=other;\n      List<Element> itemsL=new ArrayList<Element>(left.getTags(tag));\n      List<Element> itemsR=new ArrayList<Element>(right.getTags(tag));\n      try {\n        for (        Element itemL : itemsL) {\n          DescriptorElement lElement=(DescriptorElement)itemL;\n          DescriptorElement rElement=(DescriptorElement)right.getTagByIdentifier(tag.getTagName(),identifier.getIdentifier(lElement));\n          if (rElement != null) {\n            strategy.inBoth(left,lElement,rElement);\n          }\n else {\n            strategy.inLeft(left,lElement);\n          }\n        }\n        for (        Element itemR : itemsR) {\n          DescriptorElement rElement=(DescriptorElement)itemR;\n          DescriptorElement lElement=(DescriptorElement)left.getTagByIdentifier(tag.getTagName(),identifier.getIdentifier(rElement));\n          if (lElement == null) {\n            strategy.inRight(left,rElement);\n          }\n        }\n      }\n catch (      Exception ex) {\n        throw new CargoException(\"Element Merging Exception\",ex);\n      }\n    }\n else {\n      Descriptor left=baseDescriptor;\n      Descriptor right=other;\n      List<Element> itemsL=left.getTags(tag);\n      List<Element> itemsR=new ArrayList<Element>(right.getTags(tag));\n      if (tag.isMultipleAllowed()) {\n        for (        Element itemR : itemsR) {\n          DescriptorElement rightElement=(DescriptorElement)itemR;\n          left.addElement(tag,rightElement,left.getRootElement());\n        }\n      }\n else {\n        MergeStrategy strategy=getMergeStrategy(tag.getTagName());\n        DescriptorElement leftElement=itemsL.size() == 0 ? null : (DescriptorElement)itemsL.get(0);\n        DescriptorElement rightElement=itemsR.size() == 0 ? null : (DescriptorElement)itemsR.get(0);\n        try {\n          if (leftElement != null && rightElement != null) {\n            strategy.inBoth(left,leftElement,rightElement);\n          }\n else           if (leftElement != null) {\n            strategy.inLeft(left,leftElement);\n          }\n else           if (rightElement != null) {\n            strategy.inRight(left,rightElement);\n          }\n        }\n catch (        Exception ex) {\n          throw new CargoException(\"Element Merging Exception\",ex);\n        }\n      }\n    }\n  }\n}\n", "nl": "Merge this descriptor onto another."}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase UmplePackage.EXTERNAL_DEFINITION___INTERFACE_1:\n    return isInterface_1();\ncase UmplePackage.EXTERNAL_DEFINITION___NAME_1:\n  return getName_1();\ncase UmplePackage.EXTERNAL_DEFINITION___CLASS_CONTENT_1:\nreturn getClassContent_1();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public NotificationChain basicSetScope(Scope newScope,NotificationChain msgs){\n  Scope oldScope=scope;\n  scope=newScope;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,StextPackage.STATE_SPECIFICATION__SCOPE,oldScope,newScope);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static Container encloseIn(Layout l,Component... cmp){\n  Container cnt=new Container(l);\n  for (  Component c : cmp) {\n    cnt.addComponent(c);\n  }\n  return cnt;\n}\n", "nl": "Short-hand for enclosing multiple components in a container typically a box layout"}
{"code": "public static Stopwatch createUnstarted(Ticker ticker){\n  return new Stopwatch(ticker);\n}\n", "nl": "Creates (but does not start) a new stopwatch, using the specified time source."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:36.567 -0500\",hash_original_method=\"55B8B2C74AE8EFAFCF07CA3753E23BB0\",hash_generated_method=\"A30D64FD09E2B0376DF0127CD24EFA6B\") public String debugDump(){\n  String superstring=super.debugDump();\n  stringRepresentation=\"\";\n  sprint(SIPResponse.class.getCanonicalName());\n  sprint(\"{\");\n  if (statusLine != null) {\n    sprint(statusLine.debugDump());\n  }\n  sprint(superstring);\n  sprint(\"}\");\n  return stringRepresentation;\n}\n", "nl": "Print formatting function. Indent and parenthesize for pretty printing. Note -- use the encode method for formatting the message. Hack here to XMLize."}
{"code": "public String toString(){\n  int iMax=length() - 1;\n  if (iMax == -1) {\n    return \"[]\";\n  }\n  StringBuilder b=new StringBuilder((17 + 2) * (iMax + 1));\n  b.append('[');\n  for (int i=0; ; i++) {\n    b.append(longBitsToDouble(longs.get(i)));\n    if (i == iMax) {\n      return b.append(']').toString();\n    }\n    b.append(',').append(' ');\n  }\n}\n", "nl": "Returns the String representation of the current values of array."}
{"code": "private void createProxyAndRegionForClient(){\n  PoolFactory pf=PoolManager.createFactory();\n  pf.addServer(\"localhost\",PORT);\n  pf.setMinConnections(0);\n  pf.setPingInterval(10000);\n  pf.setThreadLocalConnections(true);\n  pf.setReadTimeout(2000);\n  pf.setSocketBufferSize(32768);\n  proxy=(PoolImpl)pf.create(\"junitPool\");\n  AttributesFactory factory=new AttributesFactory();\n  factory.setScope(Scope.DISTRIBUTED_ACK);\n  factory.setPoolName(\"junitPool\");\n  RegionAttributes attrs=factory.createRegionAttributes();\n  cache.createVMRegion(regionName,attrs);\n}\n", "nl": "Initializes proxy object and creates region for client"}
{"code": "public boolean isFieldAlignLeading(){\n  return getFieldAlignmentType().equals(FIELDALIGNMENTTYPE_LeadingLeft);\n}\n", "nl": "Field Align Leading"}
{"code": "public static List<String> changeCase(List<String> list){\n  if (list != null) {\n    List<String> result=new ArrayList<String>();\n    for (    String element : list) {\n      result.add(changeCase(element));\n    }\n    return result;\n  }\n  return null;\n}\n", "nl": "Creates a new list of endpoints modified to upper or lower case based on the endpoint type. Endpoints of type WWN are changed to be upper case. All other types are changed to lower case."}
{"code": "public MessageHandler(GlowNetworkServer connectionManager){\n  this.connectionManager=connectionManager;\n}\n", "nl": "Creates a new network event handler."}
{"code": "public void addRange(BytesRef minPrefixCoded,BytesRef maxPrefixCoded){\n  throw new UnsupportedOperationException();\n}\n", "nl": "Overwrite this method, if you like to receive the already prefix encoded range bounds. You can directly build classical (inclusive) range queries from them."}
{"code": "public void encode(DerOutputStream out) throws IOException {\n  out.write(tag);\n  out.putLength(length);\n  if (length > 0) {\n    byte[] value=new byte[length];\nsynchronized (data) {\n      buffer.reset();\n      if (buffer.read(value) != length) {\n        throw new IOException(\"short DER value read (encode)\");\n      }\n      out.write(value);\n    }\n  }\n}\n", "nl": "Encode an ASN1/DER encoded datum onto a DER output stream."}
{"code": "public Entry proxyAuth(final String auth,final String ip){\n  final Entry entry=proxyAuth(auth);\n  if (entry != null) {\n    entry.updateLastAccess(false);\n    this.ipUsers.put(ip,entry.getUserName());\n  }\n  return entry;\n}\n", "nl": "Use ProxyAuth String to authenticate user and save IP/username for ipAuth."}
{"code": "@SubscribeEvent public static void playerClone(PlayerEvent.Clone event){\n  final IMaxHealth oldMaxHealth=getMaxHealth(event.getOriginal());\n  final IMaxHealth newMaxHealth=getMaxHealth(event.getEntityPlayer());\n  if (newMaxHealth != null && oldMaxHealth != null) {\n    newMaxHealth.setBonusMaxHealth(oldMaxHealth.getBonusMaxHealth());\n  }\n}\n", "nl": "Copy the player's bonus max health when they respawn after dying or returning from the end."}
{"code": "private TokenImpl(int type){\n  fType=type;\n  fData=null;\n}\n", "nl": "Creates a new token according to the given specification which does not have any data attached to it."}
{"code": "public void create(){\n  try {\n    ManagementFactory.getFactory().registerMBeanObject(JMX_NAME,this);\n    start();\n    if (logger.isInfoEnabled())     logger.info(JMX_NAME + \" registrado con \\351xito.\");\n  }\n catch (  Exception e) {\n    logger.error(\"Error al intentar registrar: \" + JMX_NAME + \". Abortado registro.\",e);\n  }\n}\n", "nl": "Crea el MBean."}
{"code": "public int hashCode(){\n  return value.hashCode() ^ locale.hashCode();\n}\n", "nl": "Returns a hashcode for this text attribute."}
{"code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}\n", "nl": "<p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>"}
{"code": "public static void processStatementScheduleMultiple(EPStatementAgentInstanceHandle handle,Object callbackObject,EPServicesContext services){\n  if (InstrumentationHelper.ENABLED) {\n    InstrumentationHelper.get().qTimeCP(handle,services.getSchedulingService().getTime());\n  }\n  handle.getStatementAgentInstanceLock().acquireWriteLock();\n  try {\n    if (!handle.isDestroyed()) {\n      if (handle.isHasVariables()) {\n        services.getVariableService().setLocalVersion();\n      }\n      if (callbackObject instanceof ArrayDeque) {\n        ArrayDeque<ScheduleHandleCallback> callbackList=(ArrayDeque<ScheduleHandleCallback>)callbackObject;\n        for (        ScheduleHandleCallback callback : callbackList) {\n          callback.scheduledTrigger(services.getEngineLevelExtensionServicesContext());\n        }\n      }\n else {\n        ScheduleHandleCallback callback=(ScheduleHandleCallback)callbackObject;\n        callback.scheduledTrigger(services.getEngineLevelExtensionServicesContext());\n      }\n      handle.internalDispatch();\n    }\n  }\n catch (  RuntimeException ex) {\n    services.getExceptionHandlingService().handleException(ex,handle,ExceptionHandlerExceptionType.PROCESS,null);\n  }\n finally {\n    if (handle.isHasTableAccess()) {\n      services.getTableService().getTableExprEvaluatorContext().releaseAcquiredLocks();\n    }\n    handle.getStatementAgentInstanceLock().releaseWriteLock();\n    if (InstrumentationHelper.ENABLED) {\n      InstrumentationHelper.get().aTimeCP();\n    }\n  }\n}\n", "nl": "Processing multiple schedule matches for a statement."}
{"code": "public CategoryListItem(Category category,CategoryListItem parentItem){\n  name=category.getName();\n  fullName=parentItem == null ? name : parentItem.fullName + \" / \" + name;\n  key=category.getKey();\n  List<Category> subCategories=category.getSubCategories();\n  int cntSubCategories=subCategories == null ? 0 : subCategories.size();\n  if (cntSubCategories == 0) {\n    subItems=new CategoryListItem[0];\n  }\n else {\n    subItems=new CategoryListItem[cntSubCategories];\n    for (int i=0; i < cntSubCategories; i++) {\n      subItems[i]=new CategoryListItem(subCategories.get(i),this);\n    }\n    subItems[cntSubCategories - 1]=new CategoryListItem(name,fullName,key,null);\n  }\n}\n", "nl": "Converts a Category object into a CategoryListItem."}
{"code": "public void sortFromTo(int from,int to){\n  countSortFromTo(from,to);\n}\n", "nl": "Sorts the specified range of the receiver into ascending order.  The sorting algorithm is countsort."}
{"code": "private void writeQNameAttribute(java.lang.String namespace,java.lang.String attName,javax.xml.namespace.QName qname,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  java.lang.String attributeNamespace=qname.getNamespaceURI();\n  java.lang.String attributePrefix=xmlWriter.getPrefix(attributeNamespace);\n  if (attributePrefix == null) {\n    attributePrefix=registerPrefix(xmlWriter,attributeNamespace);\n  }\n  java.lang.String attributeValue;\n  if (attributePrefix.trim().length() > 0) {\n    attributeValue=attributePrefix + \":\" + qname.getLocalPart();\n  }\n else {\n    attributeValue=qname.getLocalPart();\n  }\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attributeValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attributeValue);\n  }\n}\n", "nl": "Util method to write an attribute without the ns prefix"}
{"code": "public BetterWeakReference(T r,ReferenceQueue<? super T> q){\n  super(r,q);\n}\n", "nl": "Constructs a new weak reference to the given referent. The newly created reference is registered with the given reference queue."}
{"code": "public String addBinary(String a,String b){\n  int m=a.length();\n  int n=b.length();\n  int carry=0;\n  StringBuilder res=new StringBuilder();\n  int i=0;\n  while (i < m || i < n) {\n    int p=i < m ? a.charAt(m - 1 - i) - '0' : 0;\n    int q=i < n ? b.charAt(n - 1 - i) - '0' : 0;\n    int temp=p + q + carry;\n    carry=temp / 2;\n    res.insert(0,temp % 2);\n    i++;\n  }\n  return carry == 0 ? res.toString() : \"1\" + res.toString();\n}\n", "nl": "Math, String. From right to left, do it digit-by-digit. Get current digits of ab and b, add them up. Also use an integer to store carry from the previous addition. Store the sum to result and update carry for each round. Stop when longest string is reached. Remember to check carry before return, if carry is 1, it should still be inserted to the result."}
{"code": "protected void init(DerValue encoding,int rep_type) throws Asn1Exception, IOException, RealmException {\n  DerValue der, subDer;\n  msgType=(encoding.getTag() & (byte)0x1F);\n  if (msgType != Krb5.KRB_ENC_AS_REP_PART && msgType != Krb5.KRB_ENC_TGS_REP_PART) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  der=encoding.getData().getDerValue();\n  if (der.getTag() != DerValue.tag_Sequence) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  key=EncryptionKey.parse(der.getData(),(byte)0x00,false);\n  lastReq=LastReq.parse(der.getData(),(byte)0x01,false);\n  subDer=der.getData().getDerValue();\n  if ((subDer.getTag() & (byte)0x1F) == (byte)0x02) {\n    nonce=subDer.getData().getBigInteger().intValue();\n  }\n else {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  keyExpiration=KerberosTime.parse(der.getData(),(byte)0x03,true);\n  flags=TicketFlags.parse(der.getData(),(byte)0x04,false);\n  authtime=KerberosTime.parse(der.getData(),(byte)0x05,false);\n  starttime=KerberosTime.parse(der.getData(),(byte)0x06,true);\n  endtime=KerberosTime.parse(der.getData(),(byte)0x07,false);\n  renewTill=KerberosTime.parse(der.getData(),(byte)0x08,true);\n  Realm srealm=Realm.parse(der.getData(),(byte)0x09,false);\n  sname=PrincipalName.parse(der.getData(),(byte)0x0A,false,srealm);\n  if (der.getData().available() > 0) {\n    caddr=HostAddresses.parse(der.getData(),(byte)0x0B,true);\n  }\n}\n", "nl": "Initializes an EncKDCRepPart object."}
{"code": "public boolean hasMoreTokens(){\n  return super.hasMoreTokens();\n}\n", "nl": "Check whether the object has more tokens."}
{"code": "private static Unit insertGotoBefore(Chain unitChain,Unit node,Unit target){\n  Unit newGoto=Jimple.v().newGotoStmt(target);\n  unitChain.insertBefore(newGoto,node);\n  newGoto.redirectJumpsToThisTo(node);\n  return newGoto;\n}\n", "nl": "inserts a Jimple<code>Goto</code> to <code> target, directly before <code>node</code> in the given <code>unitChain</code>.<br> As we use <code>JGoto</code> the chain must contain Jimple-stmts."}
{"code": "public static boolean isPrimitive(String signature){\n  char t=signature.charAt(0);\n  return t == 'Z' || t == 'B' || t == 'C' || t == 'S' || t == 'I' || t == 'J' || t == 'F' || t == 'D';\n}\n", "nl": "<table> <tr><th>Type Signature</th><th>Java Type</th></tr> <tr>Z<td></td><td>boolean</td></tr> <tr>B<td></td><td>byte</td></tr> <tr>C<td></td><td>char</td></tr> <tr>S<td></td><td>short</td></tr> <tr>I<td></td><td>int</td></tr> <tr>J<td></td><td>long</td></tr> <tr>F<td></td><td>float</td></tr> <tr>D<td></td><td>double</td></tr> </table>"}
{"code": "private void inflateViewContainerLayout(){\n  setContentView(R.layout.activity_main);\n  ButterKnife.inject(this);\n  mainFlow=mainView.getFlow();\n}\n", "nl": "Inflate the view container layout and inject our view components"}
{"code": "public MimeTypeParseException(String s){\n  super(s);\n}\n", "nl": "Constructs a MimeTypeParseException with the specified detail message."}
{"code": "private void buildLines(List<SuperMatchBucket> buckets){\n  final Set<CondensedLine> unsortedLines=new HashSet<CondensedLine>();\n  for (  SuperMatchBucket bucket : buckets) {\n    boolean bucketFoundAHome=false;\n    for (    CondensedLine line : unsortedLines) {\n      bucketFoundAHome=line.addSuperMatchesSameTypeWithoutOverlap(bucket);\n      if (bucketFoundAHome) {\n        break;\n      }\n    }\n    if (!bucketFoundAHome) {\n      unsortedLines.add(new CondensedLine(bucket));\n    }\n    numSuperMatchBlobs+=bucket.getSupermatches().size();\n  }\n  lines=new TreeSet<CondensedLine>(unsortedLines);\n}\n", "nl": "Considering each bucket in turn, attempt to add the buckets to a line, minimising the number of lines and attempting to add the"}
{"code": "public Color(Color color){\n  if (color == null) {\n    throw new IllegalArgumentException(Logger.logMessage(Logger.ERROR,\"Color\",\"constructor\",\"missingColor\"));\n  }\n  this.red=color.red;\n  this.green=color.green;\n  this.blue=color.blue;\n  this.alpha=color.alpha;\n}\n", "nl": "Constructs a color with the components of a specified color."}
{"code": "public BiosCommandResult doCreateReplicationPolicy(StorageSystem system,String name,String source_root_path,String target_host,String target_path,IsilonSyncPolicy.Action action,String description,String schedule){\n  try {\n    _log.info(\"IsilonFileStorageDevice doCreateReplicationPolicy {} - start\",source_root_path);\n    IsilonApi isi=getIsilonDevice(system);\n    IsilonSyncPolicy policy=new IsilonSyncPolicy(name,source_root_path,target_path,target_host,action);\n    if (schedule != null && !schedule.isEmpty()) {\n      policy.setSchedule(schedule);\n    }\n    if (description != null && !description.isEmpty()) {\n      policy.setDescription(description);\n    }\n    policy.setEnabled(false);\n    String policyId=isi.createReplicationPolicy(policy);\n    _log.info(\"IsilonFileStorageDevice doCreateReplicationPolicy {} with policyId {} - complete\",name,policyId);\n    return BiosCommandResult.createSuccessfulResult();\n  }\n catch (  IsilonException e) {\n    return BiosCommandResult.createErrorResult(e);\n  }\n}\n", "nl": "Call to Isilon Device to Create Replication Session"}
{"code": "@Override public void deliver(WriteStream os,OutHttp2 outHttp) throws IOException {\n  outHttp.writeGoAway();\n}\n", "nl": "Deliver the message"}
{"code": "private int preFillGrid(Direction direction,int dy,int emptyTop,RecyclerView.Recycler recycler,RecyclerView.State state){\n  int newFirstVisiblePosition=firstChildPositionForRow(mFirstVisibleRow);\n  SparseArray<View> viewCache=new SparseArray<>(getChildCount());\n  int startLeftOffset=getPaddingLeft();\n  int startTopOffset=getPaddingTop() + emptyTop;\n  if (getChildCount() != 0) {\n    startTopOffset=getDecoratedTop(getChildAt(0));\n    if (mFirstVisiblePosition != newFirstVisiblePosition) {\nswitch (direction) {\ncase UP:\n        double previousTopRowHeight=sizeForChildAtPosition(mFirstVisiblePosition - 1).getHeight();\n      startTopOffset-=previousTopRowHeight;\n    break;\ncase DOWN:\n  double topRowHeight=sizeForChildAtPosition(mFirstVisiblePosition).getHeight();\nstartTopOffset+=topRowHeight;\nbreak;\n}\n}\nfor (int i=0; i < getChildCount(); i++) {\nint position=mFirstVisiblePosition + i;\nfinal View child=getChildAt(i);\nviewCache.put(position,child);\n}\nfor (int i=0; i < viewCache.size(); i++) {\nfinal View cachedView=viewCache.valueAt(i);\ndetachView(cachedView);\n}\n}\nmFirstVisiblePosition=newFirstVisiblePosition;\nint leftOffset=startLeftOffset;\nint topOffset=startTopOffset + mPendingScrollPositionOffset;\nint nextPosition=mFirstVisiblePosition;\nwhile (nextPosition >= 0 && nextPosition < state.getItemCount()) {\nboolean isViewCached=true;\nView view=viewCache.get(nextPosition);\nif (view == null) {\nview=recycler.getViewForPosition(nextPosition);\nisViewCached=false;\n}\nif (mIsFirstViewHeader && nextPosition == HEADER_POSITION) {\nmeasureChildWithMargins(view,0,0);\nmHeaderViewSize=new Size(view.getMeasuredWidth(),view.getMeasuredHeight());\n}\nSize viewSize=sizeForChildAtPosition(nextPosition);\nif ((leftOffset + viewSize.getWidth()) > getContentWidth()) {\nleftOffset=startLeftOffset;\nSize previousViewSize=sizeForChildAtPosition(nextPosition - 1);\ntopOffset+=previousViewSize.getHeight();\n}\nboolean isAtEndOfContent;\nswitch (direction) {\ncase DOWN:\nisAtEndOfContent=topOffset >= getContentHeight() + dy;\nbreak;\ndefault :\nisAtEndOfContent=topOffset >= getContentHeight();\nbreak;\n}\nif (isAtEndOfContent) break;\nif (isViewCached) {\nattachView(view);\nviewCache.remove(nextPosition);\n}\n else {\naddView(view);\nmeasureChildWithMargins(view,0,0);\nint right=leftOffset + viewSize.getWidth();\nint bottom=topOffset + viewSize.getHeight();\nlayoutDecorated(view,leftOffset,topOffset,right,bottom);\n}\nleftOffset+=viewSize.getWidth();\nnextPosition++;\n}\nfor (int i=0; i < viewCache.size(); i++) {\nfinal View removingView=viewCache.valueAt(i);\nrecycler.recycleView(removingView);\n}\nint pixelsFilled=0;\nif (getChildCount() > 0) {\npixelsFilled=getChildAt(getChildCount() - 1).getBottom();\n}\nreturn pixelsFilled;\n}\n", "nl": "Find first visible position, scrap all children, and then layout all visible views returning the number of pixels laid out, which could be greater than the entire view (useful for scroll functions)."}
{"code": "@Override public boolean equals(Object o){\n  if (!(o instanceof AttributeWeights)) {\n    return false;\n  }\n else {\n    AttributeWeights other=(AttributeWeights)o;\n    return this.weightMap.equals(other.weightMap);\n  }\n}\n", "nl": "Returns true if both objects have the same weight map."}
{"code": "private static PipelineOp convertNamedSolutionSetScan(PipelineOp left,final NamedSubqueryInclude nsi,final Set<IVariable<?>> doneSet,final AST2BOpContext ctx){\n  @SuppressWarnings(\"rawtypes\") final Map<IConstraint,Set<IVariable<IV>>> needsMaterialization=new LinkedHashMap<IConstraint,Set<IVariable<IV>>>();\n  final IConstraint[] joinConstraints=getJoinConstraints(getJoinConstraints(nsi),needsMaterialization);\n  final String name=nsi.getName();\n  final INamedSolutionSetRef namedSolutionSet=NamedSolutionSetRefUtility.newInstance(ctx.getNamespace(),ctx.getTimestamp(),name,IVariable.EMPTY);\n  left=new NestedLoopJoinOp(leftOrEmpty(left),new NV(BOp.Annotations.BOP_ID,ctx.nextId()),new NV(BOp.Annotations.EVALUATION_CONTEXT,BOpEvaluationContext.CONTROLLER),new NV(PipelineOp.Annotations.SHARED_STATE,true),new NV(NestedLoopJoinOp.Annotations.NAMED_SET_REF,namedSolutionSet),new NV(NestedLoopJoinOp.Annotations.CONSTRAINTS,joinConstraints));\n  left=addMaterializationSteps3(left,doneSet,needsMaterialization,nsi.getQueryHints(),ctx);\n  return left;\n}\n", "nl": "If the cardinality of the exogenous solutions is low, then we can SCAN the named solution set and use an inner loop to test each solution read from the named solution set against each exogenous solution. <p> Note: This code path MUST NOT change the order of the solutions read from the named solution set. We rely on that guarantee to provide fast ordered SLICEs from a pre-computed named solution set."}
{"code": "public Map<String,StoredException> loadAll(){\n  Map<String,StoredException> storedExceptions=new HashMap<>();\n  if (context != null) {\n    String[] fileNames=context.fileList();\n    if (fileNames != null) {\n      for (      String fileName : fileNames) {\n        if (utils.isNotBlank(fileName) && fileName.startsWith(\"FoamStoredException\")) {\n          StoredException storedException=loadStoredExceptionData(fileName);\n          if (storedException != null) {\n            storedExceptions.put(fileName,storedException);\n          }\n        }\n      }\n    }\n  }\n  return storedExceptions;\n}\n", "nl": "Load and return all StoredException data.  These represent crashes that have not yet been reported."}
{"code": "public void uploadConfigDir(Path dir,String configName) throws IOException {\n  zkClient.uploadToZK(dir,CONFIGS_ZKNODE + \"/\" + configName,UPLOAD_FILENAME_EXCLUDE_PATTERN);\n}\n", "nl": "Upload files from a given path to a config in Zookeeper"}
{"code": "public static final boolean isConversationAbort(byte esmClass){\n  return isMessageType(esmClass,SMPPConstant.ESMCLS_CONV_ABORT);\n}\n", "nl": "Message Type."}
{"code": "public static boolean request(final long size,final boolean force){\n  if (size < 1024)   return true;\n  return getStrategy().request(size,force,shortStatus);\n}\n", "nl": "check for a specified amount of bytes"}
{"code": "static MPrintFont create(Font font){\n  MPrintFont pf=new MPrintFont(Env.getCtx(),0,null);\n  StringBuffer name=new StringBuffer(font.getName());\n  if (font.isBold())   name.append(\" bold\");\n  if (font.isItalic())   name.append(\" italic\");\n  name.append(\" \").append(font.getSize());\n  pf.setName(name.toString());\n  pf.setFont(font);\n  pf.saveEx();\n  return pf;\n}\n", "nl": "Create Font in Database and save"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "@SuppressWarnings({\"PMD.LooseCoupling\",\"unchecked\"}) protected void createDefaultState(){\n  Class<?> c=getStateClass();\n  try {\n    Object newState=(T)c.newInstance();\n    this.state=(T)newState;\n  }\n catch (  Exception e) {\n    throw new UncheckedException(e);\n  }\n}\n", "nl": "Creates a default state representation for this actor"}
{"code": "@TransactionAttribute(TransactionAttributeType.REQUIRED) public boolean restart(boolean isRestartAPP){\n  final String messageKey=\"mail_bes_notification_connection_success\";\n  boolean isSuspendedByApp=false;\n  if (!besDAO.isBESAvalible()) {\n    if (isRestartAPP) {\n      sendMailToAppAdmin(\"mail_bes_notification_error_app_admin\");\n    }\n    return false;\n  }\n  List<ServiceInstance> serviceInstances=instanceDAO.getInstancesSuspendedbyApp();\n  for (  ServiceInstance instance : serviceInstances) {\n    String actionLink=getResumeLinkForInstance(instance);\n    if (actionLink == null || actionLink.isEmpty()) {\n      isSuspendedByApp=true;\n      continue;\n    }\n    sendActionMail(true,instance,messageKey,null,actionLink,false);\n    instance.setSuspendedByApp(false);\n  }\n  configService.setAPPSuspend(Boolean.valueOf(isSuspendedByApp).toString());\n  return true;\n}\n", "nl": "If BES is available process failed serviceInstances and reset APP_SUSPEND."}
{"code": "public AdempiereThemeInnova(){\n  setDefault();\n  s_theme=this;\n  s_name=NAME;\n}\n", "nl": "Adempiere default Theme Blue Metal"}
{"code": "protected void determineCoverageGoals(){\n  List<MethodCoverageTestFitness> goals=new MethodCoverageFactory().getCoverageGoals();\n  for (  MethodCoverageTestFitness goal : goals) {\n    methodCoverageMap.put(goal.getClassName() + \".\" + goal.getMethod(),goal);\n    if (Properties.TEST_ARCHIVE)     TestsArchive.instance.addGoalToCover(this,goal);\n  }\n}\n", "nl": "Initialize the set of known coverage goals"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:00:04.128 -0400\",hash_original_method=\"7855450641F7BEAB9B605C4390783013\",hash_generated_method=\"4D3E123755D01FEB460C17473C4BE80F\") protected void engineUpdate(byte input){\n  oneByte[0]=input;\n  SHA1Impl.updateHash(buffer,oneByte,0,0);\n  messageLength++;\n}\n", "nl": "Supplements a byte to current message. <BR> The method overrides \"engineUpdate(byte)\" in class MessageDigestSpi. <BR>"}
{"code": "public Allele(String seq,int start,int end,byte[] nt){\n  super(seq,start,end);\n  if (nt == null) {\n    throw new NullPointerException();\n  }\n  mNt=nt;\n}\n", "nl": "Construct an Allele"}
{"code": "public static ShareIntentNoBuilder from(@NonNull Context context){\n  checkNotNull(context);\n  ShareIntentBuilder builder=new ShareIntentBuilder(context);\n  return new ShareIntentNoBuilder(builder);\n}\n", "nl": "Create the first in a series of type-safe builder wrappers to create a share intent or to launch a share using that intent."}
{"code": "private void testIsoDayOfWeek() throws Exception {\n  assertEquals(1,getIsoDayOfWeek(parse(\"2008-09-29\")));\n  assertEquals(2,getIsoDayOfWeek(parse(\"2008-09-30\")));\n  assertEquals(3,getIsoDayOfWeek(parse(\"2008-10-01\")));\n  assertEquals(4,getIsoDayOfWeek(parse(\"2008-10-02\")));\n  assertEquals(5,getIsoDayOfWeek(parse(\"2008-10-03\")));\n  assertEquals(6,getIsoDayOfWeek(parse(\"2008-10-04\")));\n  assertEquals(7,getIsoDayOfWeek(parse(\"2008-10-05\")));\n}\n", "nl": "Test if day of week is returned as Monday = 1 to Sunday = 7."}
{"code": "public int indexOf(int elem){\n  if (null == m_map)   return -1;\n  for (int i=0; i < m_firstFree; i++) {\n    int node=m_map[i];\n    if (node == elem)     return i;\n  }\n  return -1;\n}\n", "nl": "Searches for the first occurence of the given argument, beginning the search at index, and testing for equality using the equals method."}
{"code": "private void stateChange(int nextState){\n  if (state == nextState)   return;\n  if (newState == nextState) {\n    state=nextState;\n    phaser.arrive();\n    log(\"%d:   state change: %s %s%n\",getId(),toStateName(nextState),phaserToString(phaser));\n    return;\n  }\n  throw new RuntimeException(\"current \" + state + \" next \"+ nextState+ \" new state \"+ newState);\n}\n", "nl": "Change the state if it matches newState."}
{"code": "private boolean same(double d1,double d2,double tolerance){\n  return (Math.abs(d1 - d2) < tolerance);\n}\n", "nl": "Tests two doubles for 'near enough' equality."}
{"code": "public AssignmentWizard(String action,String description,Assignment assignment,int fieldFlags,String helpId,String pageTwoHelpId){\n  super();\n  this.assignment=assignment;\n  assignmentPage=new AssignmentWizardPage(action,description,fieldFlags,helpId);\n  typePage=new TypingWizardPage(action,description,pageTwoHelpId);\n}\n", "nl": "Constructs the wizard that assigns values to constants,  I believe it also constructs the wizard that overrides definitions. (LL) The last argument is meaningful only for the wizard that assigns values to constants."}
{"code": "static WordInfo[] doWordAnalysis(GVTGlyphVector gv,AttributedCharacterIterator aci,int numWords,FontRenderContext frc){\n  int numGlyphs=gv.getNumGlyphs();\n  int[] glyphWords=new int[numGlyphs];\n  int[] wordMap=allocWordMap(null,10);\n  int maxWord=0;\n  int aciIdx=aci.getBeginIndex();\n  for (int i=0; i < numGlyphs; i++) {\n    int cnt=gv.getCharacterCount(i,i);\n    aci.setIndex(aciIdx);\n    Integer integer=(Integer)aci.getAttribute(WORD_LIMIT);\n    int minWord=integer.intValue() - numWords;\n    if (minWord > maxWord) {\n      maxWord=minWord;\n      wordMap=allocWordMap(wordMap,maxWord + 1);\n    }\n    aciIdx++;\n    for (int c=1; c < cnt; c++) {\n      aci.setIndex(aciIdx);\n      integer=(Integer)aci.getAttribute(WORD_LIMIT);\n      int cWord=integer.intValue() - numWords;\n      if (cWord > maxWord) {\n        maxWord=cWord;\n        wordMap=allocWordMap(wordMap,maxWord + 1);\n      }\n      if (cWord < minWord) {\n        wordMap[minWord]=cWord;\n        minWord=cWord;\n      }\n else       if (cWord > minWord) {\n        wordMap[cWord]=minWord;\n      }\n      aciIdx++;\n    }\n    glyphWords[i]=minWord;\n  }\n  int words=0;\n  WordInfo[] cWordMap=new WordInfo[maxWord + 1];\n  for (int i=0; i <= maxWord; i++) {\n    int nw=wordMap[i];\n    if (nw == -1) {\n      cWordMap[i]=new WordInfo(words++);\n    }\n else {\n      int word=nw;\n      nw=wordMap[i];\n      while (nw != -1) {\n        word=nw;\n        nw=wordMap[word];\n      }\n      wordMap[i]=word;\n      cWordMap[i]=cWordMap[word];\n    }\n  }\n  wordMap=null;\n  WordInfo[] wordInfos=new WordInfo[words];\n  for (int i=0; i <= maxWord; i++) {\n    WordInfo wi=cWordMap[i];\n    wordInfos[wi.getIndex()]=cWordMap[i];\n  }\n  aciIdx=aci.getBeginIndex();\n  int aciEnd=aci.getEndIndex();\n  char ch=aci.setIndex(aciIdx);\n  int aciWordStart=aciIdx;\n  GVTFont gvtFont=(GVTFont)aci.getAttribute(GVT_FONT);\n  float lineHeight=1.0f;\n  Float lineHeightFloat=(Float)aci.getAttribute(LINE_HEIGHT);\n  if (lineHeightFloat != null)   lineHeight=lineHeightFloat.floatValue();\n  int runLimit=aci.getRunLimit(szAtts);\n  WordInfo prevWI=null;\n  float[] lastAdvAdj=new float[numGlyphs];\n  float[] advAdj=new float[numGlyphs];\n  boolean[] hideLast=new boolean[numGlyphs];\n  boolean[] hide=new boolean[numGlyphs];\n  boolean[] space=new boolean[numGlyphs];\n  float[] glyphPos=gv.getGlyphPositions(0,numGlyphs + 1,null);\n  for (int i=0; i < numGlyphs; i++) {\n    char pch=ch;\n    ch=aci.setIndex(aciIdx);\n    Integer integer=(Integer)aci.getAttribute(WORD_LIMIT);\n    WordInfo theWI=cWordMap[integer.intValue() - numWords];\n    if (theWI.getFlowLine() == null)     theWI.setFlowLine(aci.getAttribute(FLOW_LINE_BREAK));\n    if (prevWI == null) {\n      prevWI=theWI;\n    }\n else     if (prevWI != theWI) {\n      GVTLineMetrics lm=gvtFont.getLineMetrics(aci,aciWordStart,aciIdx,frc);\n      prevWI.addLineMetrics(gvtFont,lm);\n      prevWI.addLineHeight(lineHeight);\n      aciWordStart=aciIdx;\n      prevWI=theWI;\n    }\n    int chCnt=gv.getCharacterCount(i,i);\n    if (chCnt == 1) {\n      char nch;\n      float kern;\nswitch (ch) {\ncase SOFT_HYPHEN:\n        hideLast[i]=true;\n      nch=aci.next();\n    aci.previous();\n  kern=gvtFont.getHKern(pch,nch);\nadvAdj[i]=-(glyphPos[2 * i + 2] - glyphPos[2 * i] + kern);\nbreak;\ncase ZERO_WIDTH_JOINER:\nhide[i]=true;\nbreak;\ncase ZERO_WIDTH_SPACE:\nhide[i]=true;\nbreak;\ncase SPACE:\nspace[i]=true;\nnch=aci.next();\naci.previous();\nkern=gvtFont.getHKern(pch,nch);\nlastAdvAdj[i]=-(glyphPos[2 * i + 2] - glyphPos[2 * i] + kern);\ndefault :\n}\n}\naciIdx+=chCnt;\nif ((aciIdx > runLimit) && (aciIdx < aciEnd)) {\nGVTLineMetrics lm=gvtFont.getLineMetrics(aci,aciWordStart,runLimit,frc);\nprevWI.addLineMetrics(gvtFont,lm);\nprevWI.addLineHeight(lineHeight);\nprevWI=null;\naciWordStart=aciIdx;\naci.setIndex(aciIdx);\ngvtFont=(GVTFont)aci.getAttribute(GVT_FONT);\nFloat f=(Float)aci.getAttribute(LINE_HEIGHT);\nlineHeight=f.floatValue();\nrunLimit=aci.getRunLimit(szAtts);\n}\n}\nGVTLineMetrics lm=gvtFont.getLineMetrics(aci,aciWordStart,runLimit,frc);\nprevWI.addLineMetrics(gvtFont,lm);\nprevWI.addLineHeight(lineHeight);\nint[] wordGlyphCounts=new int[words];\nfor (int i=0; i < numGlyphs; i++) {\nint word=glyphWords[i];\nint cWord=cWordMap[word].getIndex();\nglyphWords[i]=cWord;\nwordGlyphCounts[cWord]++;\n}\ncWordMap=null;\nint[][] wordGlyphs=new int[words][];\nint[] wordGlyphGroupsCounts=new int[words];\nfor (int i=0; i < numGlyphs; i++) {\nint cWord=glyphWords[i];\nint[] wgs=wordGlyphs[cWord];\nif (wgs == null) {\nwgs=wordGlyphs[cWord]=new int[wordGlyphCounts[cWord]];\nwordGlyphCounts[cWord]=0;\n}\nint cnt=wordGlyphCounts[cWord];\nwgs[cnt]=i;\nif (cnt == 0) {\nwordGlyphGroupsCounts[cWord]++;\n}\n else {\nif (wgs[cnt - 1] != i - 1) wordGlyphGroupsCounts[cWord]++;\n}\nwordGlyphCounts[cWord]++;\n}\nfor (int i=0; i < words; i++) {\nint cnt=wordGlyphGroupsCounts[i];\nGlyphGroupInfo[] wordGlyphGroups=new GlyphGroupInfo[cnt];\nif (cnt == 1) {\nint[] glyphs=wordGlyphs[i];\nint start=glyphs[0];\nint end=glyphs[glyphs.length - 1];\nwordGlyphGroups[0]=new GlyphGroupInfo(gv,start,end,hide,hideLast[end],glyphPos,advAdj,lastAdvAdj,space);\n}\n else {\nint glyphGroup=0;\nint[] glyphs=wordGlyphs[i];\nint prev=glyphs[0];\nint start=prev;\nfor (int j=1; j < glyphs.length; j++) {\nif (prev + 1 != glyphs[j]) {\nint end=glyphs[j - 1];\nwordGlyphGroups[glyphGroup]=new GlyphGroupInfo(gv,start,end,hide,hideLast[end],glyphPos,advAdj,lastAdvAdj,space);\nstart=glyphs[j];\nglyphGroup++;\n}\nprev=glyphs[j];\n}\nint end=glyphs[glyphs.length - 1];\nwordGlyphGroups[glyphGroup]=new GlyphGroupInfo(gv,start,end,hide,hideLast[end],glyphPos,advAdj,lastAdvAdj,space);\n}\nwordInfos[i].setGlyphGroups(wordGlyphGroups);\n}\nreturn wordInfos;\n}\n", "nl": "This returns an array of glyphs numbers for each glyph group in each word: ret[word][glyphGroup][glyphNum]."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:31:04.328 -0500\",hash_original_method=\"D53B73924CE25BA79BE5C682EDA80315\",hash_generated_method=\"76103A06C46A7D3BD84888DC632CF17F\") public static Sampler CLAMP_NEAREST(RenderScript rs){\n  if (rs.mSampler_CLAMP_NEAREST == null) {\n    Builder b=new Builder(rs);\n    b.setMinification(Value.NEAREST);\n    b.setMagnification(Value.NEAREST);\n    b.setWrapS(Value.CLAMP);\n    b.setWrapT(Value.CLAMP);\n    rs.mSampler_CLAMP_NEAREST=b.create();\n  }\n  return rs.mSampler_CLAMP_NEAREST;\n}\n", "nl": "Retrieve a sampler with min and mag set to nearest and wrap modes set to clamp."}
{"code": "public static XMLObjectReader newInstance(InputStream in,String encoding) throws XMLStreamException {\n  XMLObjectReader reader=new XMLObjectReader();\n  reader.setInput(in,encoding);\n  return reader;\n}\n", "nl": "Returns a XML object reader (potentially recycled) having the specified input stream/encoding as input."}
{"code": "public boolean isForeignKeysSupported(){\n  return foreignKeysSupported;\n}\n", "nl": "Determines whether indices are supported."}
{"code": "public Builder(RenderScript rs,Element e){\n  e.checkValid();\n  mRS=rs;\n  mElement=e;\n}\n", "nl": "Create a new builder object."}
{"code": "public void prologueStackHeights(NormalMethod method,BytecodeStream bcodes,int[] stackHeights){\n  if (VM.TraceOnStackReplacement) {\n    VM.sysWriteln(\"computing stack heights of method \" + method.toString());\n  }\n  bytecodes=bcodes;\n  visitedpc=new byte[bytecodes.length()];\n  ignoreGotos=true;\n  int localsize=method.getLocalWords();\n  retaddr=new int[localsize];\n  for (int i=0; i < localsize; i++) {\n    retaddr[i]=-1;\n  }\n  addr=-1;\n  int stacksize=method.getOperandWords();\n  TypeStack simstacks=new TypeStack(stacksize,VoidTypeCode);\n{\n    int startpc=0;\n    scanBlocks(method,bytecodes,false,-1,null,null,startpc,simstacks,stackHeights);\n  }\n  visitedpc=null;\n}\n", "nl": "Compute stack heights of bytecode stream (used for osr prologue)"}
{"code": "public void sendSAXComment(org.xml.sax.ext.LexicalHandler ch,int start,int length) throws org.xml.sax.SAXException {\n  String comment=getString(start,length);\n  ch.comment(comment.toCharArray(),0,length);\n}\n", "nl": "Sends the specified range of characters as sax Comment. <p> Note that, unlike sendSAXcharacters, this has to be done as a single  call to LexicalHandler#comment."}
{"code": "public AbstractIndexTask(final String termText,final int termNdx,final int numTerms,final boolean prefixMatch,final double queryTermWeight,final FullTextIndex<V> searchEngine){\n  if (termText == null)   throw new IllegalArgumentException();\n  if (searchEngine == null)   throw new IllegalArgumentException();\n  this.queryTerm=termText;\n  this.queryTermNdx=termNdx;\n  this.numQueryTerms=numTerms;\n  this.queryTermWeight=queryTermWeight;\n  final IKeyBuilder keyBuilder=searchEngine.getIndex().getIndexMetadata().getKeyBuilder();\n{\n    keyBuilder.reset();\n    keyBuilder.appendText(termText,true,false);\n    final byte[] tmp=keyBuilder.getKey();\n    if (prefixMatch) {\n      fromKey=new byte[tmp.length - 3];\n      System.arraycopy(tmp,0,fromKey,0,fromKey.length);\n    }\n else {\n      fromKey=tmp;\n    }\n  }\n{\n    toKey=SuccessorUtil.successor(fromKey.clone());\n  }\n}\n", "nl": "Setup a task that will perform a range scan for entries matching the search term."}
{"code": "public List<Pair<Level,String>> load() throws IOException {\n  final Logger logger=GPLogger.getLogger(GanttCSVOpen.class);\n  final List<Pair<Level,String>> errors=Lists.newArrayList();\n  for (  RecordGroup group : myRecordGroups) {\n    group.setErrorOutput(errors);\n  }\n  int idxCurrentGroup=0;\n  int idxNextGroup;\n  int skipHeadLines=0;\n  do {\n    idxNextGroup=idxCurrentGroup;\n    CSVFormat format=CSVFormat.DEFAULT.withIgnoreEmptyLines(false).withIgnoreSurroundingSpaces(true);\n    if (myCsvOptions != null) {\n      format=format.withDelimiter(myCsvOptions.sSeparatedChar.charAt(0)).withQuote(myCsvOptions.sSeparatedTextChar.charAt(0));\n    }\n    RecordGroup currentGroup=myRecordGroups.get(idxCurrentGroup);\n    if (currentGroup.getHeader() != null) {\n      format=format.withHeader(currentGroup.getHeader().toArray(new String[0]));\n      idxNextGroup++;\n    }\n    try (Reader reader=myInputSupplier.get()){\n      CSVParser parser=new CSVParser(reader,format);\n      skipHeadLines=doLoad(parser,idxCurrentGroup,skipHeadLines);\n    }\n     idxCurrentGroup=idxNextGroup;\n  }\n while (skipHeadLines > 0);\n  for (  RecordGroup group : myRecordGroups) {\n    group.postProcess();\n  }\n  return errors;\n}\n", "nl": "Create tasks from file."}
{"code": "public void convertToFileIfRequired(){\n  try {\n    if (small != null && small.length > getMaxLengthInplaceLob()) {\n      int len=getBufferSize(Long.MAX_VALUE);\n      int tabId=tableId;\n      if (type == Value.BLOB) {\n        createFromStream(DataUtils.newBytes(len),0,getInputStream(),Long.MAX_VALUE);\n      }\n else {\n        createFromReader(new char[len],0,getReader(),Long.MAX_VALUE);\n      }\n      Value v2=link(tabId);\n      if (SysProperties.CHECK && v2 != this) {\n        DbException.throwInternalError();\n      }\n    }\n  }\n catch (  IOException e) {\n    throw DbException.convertIOException(e,null);\n  }\n}\n", "nl": "Store the lob data to a file if the size of the buffer is larger than the maximum size for an in-place lob."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  MediaFile mf=getMediaFile(stack);\n  return new Long(mf == null ? 0 : mf.getRecordTime());\n}\n", "nl": "Returns the starting time for the content in ths specified MediaFile. This corresponds to when the file's recording started or the timestamp on the file itself. See java.lang.System.currentTimeMillis() for information on the time units."}
{"code": "public JCExpression makeNullCheck(JCExpression arg){\n  Name name=TreeInfo.name(arg);\n  if (name == names._this || name == names._super)   return arg;\n  JCTree.Tag optag=NULLCHK;\n  JCUnary tree=make.at(arg.pos).Unary(optag,arg);\n  tree.operator=syms.nullcheck;\n  tree.type=arg.type;\n  return tree;\n}\n", "nl": "Make an attributed null check tree."}
{"code": "protected boolean handle(){\n  log.debug(\"Waiting for state change\");\n  waitSensorChange(now,sensor);\n  now=sensor.getKnownState();\n  log.debug(\"Found new state: \" + now);\n  setTurnout(now);\n  return true;\n}\n", "nl": "Watch \"sensor\", and when it changes adjust \"turnout\" to match."}
{"code": "@Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase N4JSPackage.FUNCTION_OR_FIELD_ACCESSOR__BODY:\n    setBody((Block)newValue);\n  return;\ncase N4JSPackage.FUNCTION_OR_FIELD_ACCESSOR__LOK:\nset_lok((LocalArgumentsVariable)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public Offer(final RPObject object){\n  super(object);\n  setRPClass(\"offer\");\n  hide();\n  getSlot(OFFER_ITEM_SLOT_NAME).clear();\n  final RPObject itemObject=object.getSlot(OFFER_ITEM_SLOT_NAME).getFirst();\n  final Item entity=new ItemTransformer().transform(itemObject);\n  if (entity == null) {\n    int quantity=1;\n    if (itemObject.has(\"quantity\")) {\n      quantity=itemObject.getInt(\"quantity\");\n    }\n    logger.warn(\"Cannot restore \" + quantity + \" \"+ itemObject.get(\"name\")+ \" to offer \"+ \" because this item was removed from items.xml\");\n    return;\n  }\n  getSlot(OFFER_ITEM_SLOT_NAME).addPreservingId(entity);\n}\n", "nl": "Creates an Offer from a RPObject"}
{"code": "static void stopRefreshTimer(){\n  try {\n    if (refreshTimer != null && mbeanServer != null) {\n      mbeanServer.unregisterMBean(refreshTimerObjectName);\n      refreshTimer.stop();\n    }\n  }\n catch (  JMException e) {\n    logStackTrace(Level.WARN,e);\n  }\ncatch (  JMRuntimeException e) {\n    logStackTrace(Level.WARN,e);\n  }\ncatch (  Exception e) {\n    logStackTrace(Level.DEBUG,e,\"Failed to stop refresh timer for MBeanUtil\");\n  }\n}\n", "nl": "Initializes the timer for sending refresh notifications."}
{"code": "public RenderPass(RajawaliScene scene,Camera camera,int clearColor){\n  mPassType=PassType.RENDER;\n  mScene=scene;\n  mCamera=camera;\n  mClearColor=clearColor;\n  mOldClearColor=0x00000000;\n  mEnabled=true;\n  mClear=true;\n  mNeedsSwap=true;\n}\n", "nl": "Instantiates a new RenderPass object."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:29.511 -0500\",hash_original_method=\"3040682D1BCFEA9BA338FA9FE200A62D\",hash_generated_method=\"CAAB92B2FE1C02DD4BCA219B7AFDAD2B\") public void onRingingBack(SipSession session){\n}\n", "nl": "Called when a RINGING response is received for the INVITE request sent"}
{"code": "public TaskResourceRep hostVcenterUnassign(URI hostId,URI eventId){\n  return hostClusterChange(hostId,NullColumnValueGetter.getNullURI(),NullColumnValueGetter.getNullURI(),true,eventId);\n}\n", "nl": "Unassign host from a vCenter NOTE: In order to maintain backwards compatibility, do not change the signature of this method."}
{"code": "private void openFile(final File file,final int page){\n  try {\n    final boolean fileCanBeOpened=OpenFile.openUpFile(file.getCanonicalPath(),commonValues,searchFrame,currentGUI,decode_pdf,properties,thumbnails);\n    commonValues.setCurrentPage(page);\n    if (fileCanBeOpened) {\n      OpenFile.processPage(commonValues,decode_pdf,currentGUI,thumbnails);\n    }\n  }\n catch (  final Exception e) {\n    System.err.println(\"Exception \" + e + \" processing file\");\n    e.printStackTrace();\n    Values.setProcessing(false);\n  }\n}\n", "nl": "General code to open file at specified page - do not call directly"}
{"code": "public Vertex top(Network network){\n  if (this.contextStack.isEmpty()) {\n    return null;\n  }\n  return network.findById(this.contextStack.get(this.contextStack.size() - 1));\n}\n", "nl": "Return the top of the context stack."}
{"code": "public static GenericValue create(Delegator delegator,ModelEntity modelEntity,Map<String,? extends Object> fields){\n  GenericValue newValue=new GenericValue();\n  newValue.init(delegator,modelEntity,fields);\n  return newValue;\n}\n", "nl": "Creates new GenericValue from existing Map"}
{"code": "public AuthSSLInitializationError(String message){\n  super(message);\n}\n", "nl": "Creates a new AuthSSLInitializationError with the specified message."}
{"code": "public boolean containsEntry(int position,VariableReference var){\n  if (!trace.containsKey(position)) {\n    trace.put(position,new HashMap<Integer,T>());\n    return false;\n  }\n  if (!trace.get(position).containsKey(var.getStPosition()))   return false;\n  return true;\n}\n", "nl": "Get the current entry at the given position"}
{"code": "protected ConditionExpression andConditions(ConditionExpression conds,ConditionExpression cond){\n  if (conds == null)   return cond;\n else {\n    List<ConditionExpression> operands=new ArrayList<>(2);\n    operands.add(conds);\n    operands.add(cond);\n    return new LogicalFunctionCondition(\"and\",operands,cond.getSQLtype(),null,typesTranslator.typeForSQLType(cond.getSQLtype()));\n  }\n}\n", "nl": "Combine AND of conditions (or <code>null</code>) with another one."}
{"code": "public boolean isNullOrEmpty(String section,String key){\n  String value=getKeyValueEL(section,key);\n  return (value == null || value.length() == 0);\n}\n", "nl": "Gets the NullOrEmpty attribute of the IniFile object"}
{"code": "public static SymbolTable makeLocalSymtab(IonSystem system,String... localSymbols){\n  return newLocalSymtab(system,system.getSystemSymbolTable(),Arrays.asList(localSymbols));\n}\n", "nl": "Creates a local symtab with local symbols but no imports."}
{"code": "public boolean isSynchronised() throws IOException {\n  String serverVersion=preCalcMatchClient.getServerVersion();\n  int finalDashIndex=interproscanVersion.lastIndexOf(\"-\");\n  String interproDataVersion=interproscanVersion.substring(finalDashIndex);\n  if (!serverVersion.endsWith(interproDataVersion)) {\n    displayLookupSynchronisationError(interproscanVersion,serverVersion);\n    return false;\n  }\n  return true;\n}\n", "nl": "If the client and the server are based on the same version of interproscan return true, otherwise return false"}
{"code": "public String clusterResultsToString(){\n  return m_clusteringResults.toString();\n}\n", "nl": "return the results of clustering."}
{"code": "public static RxANRequest.PatchRequestBuilder patch(String url){\n  return new RxANRequest.PatchRequestBuilder(url);\n}\n", "nl": "Method to make PATCH request"}
{"code": "@Override public String toString(){\n  return name;\n}\n", "nl": "Returns a string containing a concise, human-readable description of this object. In this case, the enum constant's name is returned."}
{"code": "protected double defaultNoiseVariance(){\n  return 1.0;\n}\n", "nl": "returns the default variance of the noise rate"}
{"code": "public IgniteTxRollbackCheckedException(Throwable cause){\n  super(cause);\n}\n", "nl": "Creates new exception with given nested exception."}
{"code": "public void reAlloc(){\n  final long newAllocationSize=allocationSizeInBytes * 2L;\n  if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n    throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed allocation size\");\n  }\n  final int curSize=(int)newAllocationSize;\n  final ArrowBuf newBuf=allocator.buffer(curSize);\n  newBuf.setZero(0,newBuf.capacity());\n  newBuf.setBytes(0,data,0,data.capacity());\n  data.release();\n  data=newBuf;\n  allocationSizeInBytes=curSize;\n}\n", "nl": "Allocate new buffer with double capacity, and copy data into the new buffer. Replace vector's buffer with new buffer, and release old one"}
{"code": "public boolean undo(INode state){\n  SmallPuzzle tp=(SmallPuzzle)state;\n  tp.s[0]*=2;\n  tp.s[1]*=2;\n  return true;\n}\n", "nl": "Undo a move."}
{"code": "public GradlePluginsRuntimeException(String message,Throwable cause){\n  super(message,cause);\n}\n", "nl": "Creates a new instance."}
{"code": "@Override public DataHeaderViewHolder newViewHolder(ViewGroup viewGroup){\n  View dataHeaderView=LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.offer_header,viewGroup,false);\n  return new DataHeaderViewHolder(dataHeaderView);\n}\n", "nl": "creates a new ViewHolder using the provided xml layout"}
{"code": "public void restart(String gatewayId) throws PageException {\n  executeThread(gatewayId,GatewayThread.RESTART);\n}\n", "nl": "restart the gateway"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "private int readAnnotationValue(int v,final char[] buf,final String name,final AnnotationVisitor av){\n  int i;\n  if (av == null) {\nswitch (b[v] & 0xFF) {\ncase 'e':\n      return v + 5;\ncase '@':\n    return readAnnotationValues(v + 3,buf,true,null);\ncase '[':\n  return readAnnotationValues(v + 1,buf,false,null);\ndefault :\nreturn v + 3;\n}\n}\nswitch (b[v++] & 0xFF) {\ncase 'I':\ncase 'J':\ncase 'F':\ncase 'D':\nav.visit(name,readConst(readUnsignedShort(v),buf));\nv+=2;\nbreak;\ncase 'B':\nav.visit(name,new Byte((byte)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 'Z':\nav.visit(name,readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\nv+=2;\nbreak;\ncase 'S':\nav.visit(name,new Short((short)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 'C':\nav.visit(name,new Character((char)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 's':\nav.visit(name,readUTF8(v,buf));\nv+=2;\nbreak;\ncase 'e':\nav.visitEnum(name,readUTF8(v,buf),readUTF8(v + 2,buf));\nv+=4;\nbreak;\ncase 'c':\nav.visit(name,Type.getType(readUTF8(v,buf)));\nv+=2;\nbreak;\ncase '@':\nv=readAnnotationValues(v + 2,buf,true,av.visitAnnotation(name,readUTF8(v,buf)));\nbreak;\ncase '[':\nint size=readUnsignedShort(v);\nv+=2;\nif (size == 0) {\nreturn readAnnotationValues(v - 2,buf,false,av.visitArray(name));\n}\nswitch (this.b[v++] & 0xFF) {\ncase 'B':\nbyte[] bv=new byte[size];\nfor (i=0; i < size; i++) {\nbv[i]=(byte)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,bv);\n--v;\nbreak;\ncase 'Z':\nboolean[] zv=new boolean[size];\nfor (i=0; i < size; i++) {\nzv[i]=readInt(items[readUnsignedShort(v)]) != 0;\nv+=3;\n}\nav.visit(name,zv);\n--v;\nbreak;\ncase 'S':\nshort[] sv=new short[size];\nfor (i=0; i < size; i++) {\nsv[i]=(short)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,sv);\n--v;\nbreak;\ncase 'C':\nchar[] cv=new char[size];\nfor (i=0; i < size; i++) {\ncv[i]=(char)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,cv);\n--v;\nbreak;\ncase 'I':\nint[] iv=new int[size];\nfor (i=0; i < size; i++) {\niv[i]=readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,iv);\n--v;\nbreak;\ncase 'J':\nlong[] lv=new long[size];\nfor (i=0; i < size; i++) {\nlv[i]=readLong(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,lv);\n--v;\nbreak;\ncase 'F':\nfloat[] fv=new float[size];\nfor (i=0; i < size; i++) {\nfv[i]=Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,fv);\n--v;\nbreak;\ncase 'D':\ndouble[] dv=new double[size];\nfor (i=0; i < size; i++) {\ndv[i]=Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,dv);\n--v;\nbreak;\ndefault :\nv=readAnnotationValues(v - 3,buf,false,av.visitArray(name));\n}\n}\nreturn v;\n}\n", "nl": "Reads a value of an annotation and makes the given visitor visit it."}
{"code": "public boolean isProcessed(){\n  Object oo=get_Value(COLUMNNAME_Processed);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Processed."}
{"code": "public SubscriptionAlreadyExistsException(String message,ApplicationExceptionBean bean){\n  super(message,bean);\n}\n", "nl": "Constructs a new exception with the specified detail message and bean for JAX-WS exception serialization."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public BandPassBuilder stopFrequency2(int stopFrequency){\n  mStopFrequency2=stopFrequency;\n  return this;\n}\n", "nl": "Specifies the beginning frequency of the second stop band"}
{"code": "public NotificationChain basicSetArgs(ExpressionList newArgs,NotificationChain msgs){\n  ExpressionList oldArgs=args;\n  args=newArgs;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,GamlPackage.ACCESS__ARGS,oldArgs,newArgs);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public ObjectNotFoundException(List<LocalizedText> messages){\n  super(messages);\n}\n", "nl": "Constructs a new exception with the specified localized text messages. The cause is not initialized."}
{"code": "public ReadOnlyFileSystemException(){\n}\n", "nl": "Constructs an instance of this class."}
{"code": "public void writeToNBT(final NBTTagCompound nbt){\n  final NBTTagList modulesNbt=new NBTTagList();\n  for (  final Module module : modules) {\n    final NBTTagCompound moduleNbt=new NBTTagCompound();\n    if (module != null) {\n      module.writeToNBT(moduleNbt);\n    }\n    modulesNbt.appendTag(moduleNbt);\n  }\n  nbt.setTag(TAG_MODULES,modulesNbt);\n  lock.ifPresent(null);\n  lock.ifPresent(null);\n}\n", "nl": "Write the state of all modules and pipes to the specified NBT tag."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public static float function2(float x){\n  return x * x * x* x* x - 2 * x * x* x + x;\n}\n", "nl": "Fifth-order polynomial."}
{"code": "public static Number add(Number a,Number b){\n  if (isFloatingPoint(a) || isFloatingPoint(b)) {\n    return a.doubleValue() + b.doubleValue();\n  }\n else {\n    return a.longValue() + b.longValue();\n  }\n}\n", "nl": "Returns the value of adding the two numbers"}
{"code": "public void testUnivariateTEforCoupledVariablesFromFile() throws Exception {\n  ArrayFileReader afr=new ArrayFileReader(\"demos/data/2coupledRandomCols-1.txt\");\n  double[][] data=afr.getDouble2DMatrix();\n  double[] col0=MatrixUtils.selectColumn(data,0);\n  double[] col1=MatrixUtils.selectColumn(data,1);\n  col0=MatrixUtils.normaliseIntoNewArray(col0);\n  col1=MatrixUtils.normaliseIntoNewArray(col1);\n  int kNNs=4;\n  double expectedFromTRENTOOL0to1=0.3058006;\n  double expectedFromTRENTOOL1to0=-0.0029744;\n  System.out.println(\"Kraskov TE comparison 1 to TRENTOOL - univariate coupled data 1\");\n  TransferEntropyCalculatorKraskov teCalc=new TransferEntropyCalculatorKraskov();\n  teCalc.setProperty(ConditionalMutualInfoCalculatorMultiVariateKraskov.PROP_K,Integer.toString(kNNs));\n  teCalc.setProperty(ConditionalMutualInfoCalculatorMultiVariateKraskov.PROP_NORMALISE,\"false\");\n  teCalc.setProperty(ConditionalMutualInfoCalculatorMultiVariateKraskov.PROP_ADD_NOISE,\"0\");\n  teCalc.initialise(1);\n  teCalc.setObservations(col0,col1);\n  double result=teCalc.computeAverageLocalOfObservations();\n  System.out.printf(\"From 2coupledRandomCols 0->1 expecting %.6f, got %.6f\\n\",expectedFromTRENTOOL0to1,result);\n  assertEquals(expectedFromTRENTOOL0to1,result,0.000001);\n  teCalc.initialise(1);\n  teCalc.setObservations(col1,col0);\n  result=teCalc.computeAverageLocalOfObservations();\n  assertEquals(expectedFromTRENTOOL1to0,result,0.000001);\n  System.out.printf(\"From 2coupledRandomCols 1->0 expecting %.6f, got %.6f\\n\",expectedFromTRENTOOL1to0,result);\n  assertEquals(99,teCalc.getNumObservations());\n}\n", "nl": "Test the computed univariate TE against that calculated by Wibral et al.'s TRENTOOL on the same data. To run TRENTOOL (http://www.trentool.de/) for this  data, run its TEvalues.m matlab script on the multivariate source and dest data sets as: TEvalues(source, dest, 1, 1, 1, kraskovK, 0) with these values ensuring source-dest lag 1, history k=1, embedding lag 1, no dynamic correlation exclusion"}
{"code": "public String app_source_path(String app_class){\n  String filename=app_class.replace(\".\",\"/\");\n  filename=filename.replaceFirst(\"[$][0-9]+\",\"\");\n  if (filename.indexOf(\"$\") > 0) {\n    filename=filename.substring(0,filename.indexOf(\"$\"));\n  }\n  return \"../jsrc/\" + filename + \".java.html\";\n}\n", "nl": "Returns the relative path from the android directory to the source html created by java2html"}
{"code": "public Pair<BigDecimal,BigDecimal> findQuantity(final Collection<Warehouse> warehouses,final String productSkuCode){\n  final List<Object> warehouseIdList=new ArrayList<Object>(warehouses.size());\n  for (  Warehouse wh : warehouses) {\n    warehouseIdList.add(wh.getWarehouseId());\n  }\n  final List rez=getGenericDao().findQueryObjectsByNamedQuery(\"SKU.QTY.ON.WAREHOUSES.IN.WAREHOUSEID.BY.SKUCODE\",productSkuCode,warehouseIdList);\n  BigDecimal quantity=BigDecimal.ZERO.setScale(Constants.DEFAULT_SCALE);\n  BigDecimal reserved=BigDecimal.ZERO.setScale(Constants.DEFAULT_SCALE);\n  if (!rez.isEmpty()) {\n    final Object obj[]=(Object[])rez.get(0);\n    if (obj.length > 0 && obj[0] != null) {\n      quantity=((BigDecimal)obj[0]).setScale(Constants.DEFAULT_SCALE);\n    }\n    if (obj.length > 1 && obj[1] != null) {\n      reserved=((BigDecimal)obj[1]).setScale(Constants.DEFAULT_SCALE);\n    }\n  }\n  return new Pair<BigDecimal,BigDecimal>(quantity,reserved);\n}\n", "nl": "Get the sku's Quantity - Reserved quantity pair."}
{"code": "private void checkMatrix(){\n  for (  Node variable : variables) {\n    if (variable == null) {\n      throw new NullPointerException();\n    }\n  }\n  if (sampleSize < 1) {\n    throw new IllegalArgumentException(\"Sample size must be at least 1.\");\n  }\n  for (int i=0; i < matrix.rows(); i++) {\n    for (int j=0; j < matrix.columns(); j++) {\n      if (Double.isNaN(matrix.get(i,j))) {\n        throw new IllegalArgumentException(\"Please remove or impute missing values.\");\n      }\n    }\n  }\n}\n", "nl": "Checks the sample size, variable, and matrix information."}
{"code": "public DummyDataSource(){\n}\n", "nl": "Create new instance."}
{"code": "private int hash(String name){\n  assert name.intern() == name;\n  return name.hashCode() & (hashTableMask);\n}\n", "nl": "The hash function must be based on the name only,  so that searches for {name,type} entries can be found in the same bucket."}
{"code": "@Override public boolean isConsciousProcessingRequired(){\n  return true;\n}\n", "nl": "Wait until conscious is done to avoid database contention/deadlocks."}
{"code": "public boolean useForType(JavaType t){\nswitch (_appliesFor) {\ncase NON_CONCRETE_AND_ARRAYS:\n    while (t.isArrayType()) {\n      t=t.getContentType();\n    }\ncase OBJECT_AND_NON_CONCRETE:\n  return (t.getRawClass() == Object.class) || !t.isConcrete();\ncase NON_FINAL:\nwhile (t.isArrayType()) {\n  t=t.getContentType();\n}\nreturn !t.isFinal();\ndefault :\nreturn (t.getRawClass() == Object.class);\n}\n}\n", "nl": "Method called to check if the default type handler should be used for given type. Note: \"natural types\" (String, Boolean, Integer, Double) will never use typing; that is both due to them being concrete and final, and since actual serializers and deserializers will also ignore any attempts to enforce typing."}
{"code": "public void testFailure(Failure failure) throws Exception {\n  String printedOutput=this.endCapture();\n  String printedOutputNoTrailingWS=printedOutput.replaceFirst(\"\\\\s+$\",\"\");\n  System.out.println(\"Running \" + mostRecentTestName + \": \");\n  System.out.println(\"====================================\");\n  if (printedOutputNoTrailingWS.length() > 0) {\n    System.out.println(printedOutputNoTrailingWS);\n  }\n  System.out.println(JUnitUtilities.failureToString(failure));\n  mostRecentTestPassed=false;\n}\n", "nl": "Sets score to 0 and appends reason for failure and dumps a stack trace. TODO: Clean up this stack trace so it is not hideous.  Other possible things we might want to consider including: http://junit.sourceforge.net/javadoc/org/junit/runner/notification/Failure.html."}
{"code": "public ChunkedInputStream(InputStream in,HttpClient hc,MessageHeader responses) throws IOException {\n  this.in=in;\n  this.responses=responses;\n  this.hc=hc;\n  state=STATE_AWAITING_CHUNK_HEADER;\n}\n", "nl": "Creates a <code>ChunkedInputStream</code> and saves its  arguments, for later use."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFilesString=null;\n  String arcFile=null;\n  String whiteboxHeaderFile=null;\n  int i=0;\n  int row, col, rows, cols;\n  String[] imageFiles;\n  int numImages=0;\n  int progress=0;\n  double xllcenter=0;\n  double yllcenter=0;\n  double xllcorner=0;\n  double yllcorner=0;\n  double cellsize=0;\n  double north=0;\n  double east=0;\n  double west=0;\n  double south=0;\n  double arcNoData=-9999;\n  double whiteboxNoData=-32768d;\n  double z=0;\n  String delimiter=\" \";\n  String str1=null;\n  FileWriter fw=null;\n  BufferedWriter bw=null;\n  PrintWriter out=null;\n  DataInputStream in=null;\n  BufferedReader br=null;\n  try {\n    if (args.length <= 0) {\n      showFeedback(\"Plugin parameters have not been set.\");\n      return;\n    }\n    inputFilesString=args[0];\n    if ((inputFilesString == null)) {\n      showFeedback(\"One or more of the input parameters have not been set properly.\");\n      return;\n    }\n    imageFiles=inputFilesString.split(\";\");\n    numImages=imageFiles.length;\n    for (i=0; i < numImages; i++) {\n      progress=(int)(100f * i / (numImages - 1));\n      updateProgress(\"Loop \" + (i + 1) + \" of \"+ numImages+ \":\",progress);\n      arcFile=imageFiles[i];\n      if (!((new File(arcFile)).exists())) {\n        showFeedback(\"ArcGIS raster file does not exist.\");\n        return;\n      }\n      if (arcFile.lastIndexOf(\".\") >= 0) {\n        String extension=arcFile.substring(arcFile.lastIndexOf(\".\"));\n        whiteboxHeaderFile=arcFile.replace(extension,\".dep\");\n      }\n else {\n        whiteboxHeaderFile=arcFile + \".dep\";\n      }\n      (new File(whiteboxHeaderFile)).delete();\n      (new File(whiteboxHeaderFile.replace(\".dep\",\".tas\"))).delete();\n      FileInputStream fstream=new FileInputStream(arcFile);\n      rows=0;\n      cols=0;\n      in=new DataInputStream(fstream);\n      br=new BufferedReader(new InputStreamReader(in));\n      if (arcFile != null) {\n        String line;\n        String[] str;\n        while ((line=br.readLine()) != null) {\n          str=line.split(delimiter);\n          if (str.length <= 1) {\n            delimiter=\"\\t\";\n            str=line.split(delimiter);\n            if (str.length <= 1) {\n              delimiter=\" \";\n              str=line.split(delimiter);\n              if (str.length <= 1) {\n                delimiter=\",\";\n                str=line.split(delimiter);\n              }\n            }\n          }\n          if (str[0].toLowerCase().contains(\"ncols\")) {\n            cols=Integer.parseInt(str[str.length - 1]);\n          }\n else           if (str[0].toLowerCase().contains(\"nrows\")) {\n            rows=Integer.parseInt(str[str.length - 1]);\n          }\n else           if (str[0].toLowerCase().contains(\"xllcenter\")) {\n            xllcenter=Double.parseDouble(str[str.length - 1]);\n          }\n else           if (str[0].toLowerCase().contains(\"yllcenter\")) {\n            yllcenter=Double.parseDouble(str[str.length - 1]);\n          }\n else           if (str[0].toLowerCase().contains(\"xllcorner\")) {\n            xllcorner=Double.parseDouble(str[str.length - 1]);\n          }\n else           if (str[0].toLowerCase().contains(\"yllcorner\")) {\n            yllcorner=Double.parseDouble(str[str.length - 1]);\n          }\n else           if (str[0].toLowerCase().contains(\"cellsize\")) {\n            cellsize=Double.parseDouble(str[str.length - 1]);\n            if (xllcorner != 0) {\n              east=xllcorner + cols * cellsize;\n              west=xllcorner;\n              south=yllcorner;\n              north=yllcorner + rows * cellsize;\n            }\n else {\n              east=xllcenter - (0.5 * cellsize) + cols * cellsize;\n              west=xllcenter - (0.5 * cellsize);\n              south=yllcenter - (0.5 * cellsize);\n              north=yllcenter - (0.5 * cellsize) + rows * cellsize;\n            }\n          }\n else           if (str[0].toLowerCase().contains(\"nodata\")) {\n            arcNoData=Double.parseDouble(str[str.length - 1]);\n          }\n else {\n            break;\n          }\n        }\n        fw=new FileWriter(whiteboxHeaderFile,false);\n        bw=new BufferedWriter(fw);\n        out=new PrintWriter(bw,true);\n        str1=\"Min:\\t\" + Double.toString(Integer.MAX_VALUE);\n        out.println(str1);\n        str1=\"Max:\\t\" + Double.toString(Integer.MIN_VALUE);\n        out.println(str1);\n        str1=\"North:\\t\" + Double.toString(north);\n        out.println(str1);\n        str1=\"South:\\t\" + Double.toString(south);\n        out.println(str1);\n        str1=\"East:\\t\" + Double.toString(east);\n        out.println(str1);\n        str1=\"West:\\t\" + Double.toString(west);\n        out.println(str1);\n        str1=\"Cols:\\t\" + Integer.toString(cols);\n        out.println(str1);\n        str1=\"Rows:\\t\" + Integer.toString(rows);\n        out.println(str1);\n        str1=\"Data Type:\\t\" + \"float\";\n        out.println(str1);\n        str1=\"Z Units:\\t\" + \"not specified\";\n        out.println(str1);\n        str1=\"XY Units:\\t\" + \"not specified\";\n        out.println(str1);\n        str1=\"Projection:\\t\" + \"not specified\";\n        out.println(str1);\n        str1=\"Data Scale:\\tcontinuous\";\n        out.println(str1);\n        str1=\"Preferred Palette:\\t\" + \"spectrum.pal\";\n        out.println(str1);\n        str1=\"NoData:\\t-32768\";\n        out.println(str1);\n        if (java.nio.ByteOrder.nativeOrder() == java.nio.ByteOrder.LITTLE_ENDIAN) {\n          str1=\"Byte Order:\\t\" + \"LITTLE_ENDIAN\";\n        }\n else {\n          str1=\"Byte Order:\\t\" + \"BIG_ENDIAN\";\n        }\n        out.println(str1);\n        WhiteboxRaster wbr=new WhiteboxRaster(whiteboxHeaderFile,\"rw\");\n        delimiter=\" \";\n        row=0;\n        col=0;\n        while ((line=br.readLine()) != null) {\n          str=line.split(delimiter);\n          if (str.length <= 1) {\n            delimiter=\"\\t\";\n            str=line.split(delimiter);\n            if (str.length <= 1) {\n              delimiter=\" \";\n              str=line.split(delimiter);\n              if (str.length <= 1) {\n                delimiter=\",\";\n                str=line.split(delimiter);\n              }\n            }\n          }\n          if (str[0].toLowerCase().contains(\"ncols\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"nrows\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"xllcenter\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"yllcenter\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"xllcorner\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"yllcorner\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"cellsize\")) {\n          }\n else           if (str[0].toLowerCase().contains(\"nodata\")) {\n          }\n else {\n            for (i=0; i < str.length; i++) {\n              z=Double.parseDouble(str[i]);\n              if (z != arcNoData) {\n                wbr.setValue(row,col,z);\n              }\n else {\n                wbr.setValue(row,col,whiteboxNoData);\n              }\n              col++;\n              if (col == cols) {\n                col=0;\n                row++;\n              }\n            }\n          }\n        }\n        in.close();\n        br.close();\n        wbr.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n        wbr.addMetadataEntry(\"Created on \" + new Date());\n        wbr.close();\n        returnData(whiteboxHeaderFile);\n      }\n    }\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    if (out != null || bw != null) {\n      out.flush();\n      out.close();\n    }\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public IntArray(int capacity){\n  data=new int[capacity];\n}\n", "nl": "Create an int array with specified initial capacity."}
{"code": "@Override public void installBorderSettings(){\n  UIManager.put(\"DockView.singleDockableBorder\",null);\n  UIManager.put(\"DockView.tabbedDockableBorder\",null);\n  UIManager.put(\"DockView.maximizedDockableBorder\",null);\n}\n", "nl": "installs the borders"}
{"code": "private String match(MBankStatementLine bsl){\n  if (m_matchers == null || bsl == null || bsl.getC_Payment_ID() != 0)   return \"--\";\n  log.fine(\"match - \" + bsl);\n  BankStatementMatchInfo info=null;\n  for (int i=0; i < m_matchers.length; i++) {\n    if (m_matchers[i].isMatcherValid()) {\n      info=m_matchers[i].getMatcher().findMatch(bsl);\n      if (info != null && info.isMatched()) {\n        if (info.getC_Payment_ID() > 0)         bsl.setC_Payment_ID(info.getC_Payment_ID());\n        if (info.getC_Invoice_ID() > 0)         bsl.setC_Invoice_ID(info.getC_Invoice_ID());\n        if (info.getC_BPartner_ID() > 0)         bsl.setC_BPartner_ID(info.getC_BPartner_ID());\n        bsl.saveEx();\n        return \"OK\";\n      }\n    }\n  }\n  return \"--\";\n}\n", "nl": "Perform Match"}
{"code": "public Value convert(Value v){\n  try {\n    return v.convertTo(type);\n  }\n catch (  DbException e) {\n    if (e.getErrorCode() == ErrorCode.DATA_CONVERSION_ERROR_1) {\n      String target=(table == null ? \"\" : table.getName() + \": \") + getCreateSQL();\n      throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1,v.getSQL() + \" (\" + target+ \")\");\n    }\n    throw e;\n  }\n}\n", "nl": "Convert a value to this column's type."}
{"code": "private void fillBuf() throws IOException {\n  int result=in.read(buf,0,buf.length);\n  if (result == -1) {\n    throw new EOFException();\n  }\n  pos=0;\n  end=result;\n}\n", "nl": "Reads new input data into the buffer. Call only with pos == end or end == -1, depending on the desired outcome if the function throws."}
{"code": "public static void main(String[] args) throws Exception {\n  if (args.length != 4) {\n    System.out.println();\n    System.out.println(\"Usage: \" + SerialUIDChanger.class.getName() + \" <oldUID> <newUID> <oldFilename> <newFilename>\");\n    System.out.println(\"       <oldFilename> and <newFilename> have to be different\");\n    System.out.println();\n  }\n else {\n    if (args[2].equals(args[3]))     throw new Exception(\"Filenames have to be different!\");\n    changeUID(Long.parseLong(args[0]),Long.parseLong(args[1]),args[2],args[3]);\n  }\n}\n", "nl": "exchanges an old UID for a new one. a file that doesn't end with \".koml\" is considered being binary. takes four arguments: oldUID newUID oldFilename newFilename"}
{"code": "public void sendEmptyDataChunk() throws NetworkException {\n  msrpMgr.sendEmptyChunk();\n}\n", "nl": "Send an empty data chunk"}
{"code": "public boolean commitCorrection(CorrectionInfo correctionInfo){\n  return false;\n}\n", "nl": "Default implementation does nothing and returns false."}
{"code": "public void testSimpleWatchActionMulti() throws Exception {\n  WatchManager<String> em=new WatchManager<String>();\n  StringWatchAction action=new StringWatchAction(3);\n  Watch<String> w=em.watch(new StringWatchPredicate(\"hello\"),3,action);\n  for (int i=0; i < 3; i++) {\n    assertNull(\"Action not taken before match: \" + i,action.getString(i));\n    em.process(\"hello\",i);\n    assertEquals(\"Should have string after match: \" + i,\"hello\",action.getString(i));\n  }\n  assertTrue(\"Should be done\",w.isDone());\n}\n", "nl": "Prove that an action associated with a watch is executed on the task ID for which the watch has just matched."}
{"code": "public boolean hasInitialResponse(){\n  return true;\n}\n", "nl": "This mechanism has an initial response."}
{"code": "protected boolean matches(Node object){\n  if (object instanceof Element) {\n    Element element=(Element)object;\n    return name.equals(element.getName());\n  }\n  return false;\n}\n", "nl": "DOCUMENT ME!"}
{"code": "public boolean showJavaScriptSites(){\n  return mContentSettingsType == ContentSettingsType.CONTENT_SETTINGS_TYPE_JAVASCRIPT;\n}\n", "nl": "Returns whether this category is the JavaScript category."}
{"code": "public boolean isSortingCategories(){\n  return sortingCategories;\n}\n", "nl": "Get whether this model is currently sorting categories."}
{"code": "public PacProxyException(){\n  super();\n}\n", "nl": "Creates a new PacProxyException."}
{"code": "public void allZero(){\n  this.coeff_domlength=0;\n  this.coeff_date=0;\n  this.coeff_wordsintitle=0;\n  this.coeff_wordsintext=0;\n  this.coeff_phrasesintext=0;\n  this.coeff_llocal=0;\n  this.coeff_lother=0;\n  this.coeff_urllength=0;\n  this.coeff_urlcomps=0;\n  this.coeff_hitcount=0;\n  this.coeff_posintext=0;\n  this.coeff_posofphrase=0;\n  this.coeff_posinphrase=0;\n  this.coeff_authority=0;\n  this.coeff_worddistance=0;\n  this.coeff_appurl=0;\n  this.coeff_app_dc_title=0;\n  this.coeff_app_dc_creator=0;\n  this.coeff_app_dc_subject=0;\n  this.coeff_app_dc_description=0;\n  this.coeff_appemph=0;\n  this.coeff_catindexof=0;\n  this.coeff_cathasimage=0;\n  this.coeff_cathasaudio=0;\n  this.coeff_cathasvideo=0;\n  this.coeff_cathasapp=0;\n  this.coeff_termfrequency=0;\n  this.coeff_urlcompintoplist=0;\n  this.coeff_descrcompintoplist=0;\n  this.coeff_prefer=0;\n  this.coeff_language=0;\n  this.coeff_citation=0;\n}\n", "nl": "set all ranking attributes to zero This is usually used when a specific value is set to maximum"}
{"code": "public final boolean isTopLevel(){\n  return outerClass == null || isStatic() || isInterface();\n}\n", "nl": "Tell if the class is \"top-level\", which is either a package member, or a static member of another top-level class."}
{"code": "@Override protected EClass eStaticClass(){\n  return N4JSPackage.Literals.SCRIPT_ELEMENT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public Type1Font(String baseName,PDFObject src,PDFFontDescriptor descriptor) throws IOException {\n  super(baseName,src,descriptor);\n  if (descriptor != null && descriptor.getFontFile() != null) {\n    int start=descriptor.getFontFile().getDictRef(\"Length1\").getIntValue();\n    int len=descriptor.getFontFile().getDictRef(\"Length2\").getIntValue();\n    byte font[]=descriptor.getFontFile().getStream();\n    parseFont(font,start,len);\n  }\n}\n", "nl": "create a new Type1Font based on a font data stream and an encoding."}
{"code": "public static double sortingAUC(ArrayList<Tuple2D> data){\n  double P=sumTruth(data);\n  double N=data.size() - P;\n  double n=data.size();\n  double lastpred=data.get(0).pred - 1.;\n  double lastx=0, lasty=0;\n  double x, y;\n  double tp=0, fp=0;\n  double auc=0;\n  for (  Tuple2D tuple : data) {\n    if (tuple.pred != lastpred) {\n      x=fp / N;\n      y=tp / P;\n      auc=auc + 0.5 * (lasty + y) * (x - lastx);\n      lastx=x;\n      lasty=y;\n      lastpred=tuple.pred;\n    }\n    if (tuple.truth > 0)     tp++;\n else     fp++;\n  }\n  return auc;\n}\n", "nl": "requires input to be sorted by class1, though it doesn't check"}
{"code": "public LinearLocation toLowest(Geometry linearGeom){\n  LineString lineComp=(LineString)linearGeom.getGeometryN(componentIndex);\n  int nseg=lineComp.getNumPoints() - 1;\n  if (segmentIndex < nseg)   return this;\n  return new LinearLocation(componentIndex,nseg,1.0,false);\n}\n", "nl": "Converts a linear location to the lowest equivalent location index. The lowest index has the lowest possible component and segment indices. <p> Specifically: <ul> <li>if the location point is an endpoint, a location value is returned as (nseg-1, 1.0) <li>if the location point is ambiguous (i.e. an endpoint and a startpoint), the lowest endpoint location is returned </ul> If the location index is already the lowest possible value, the original location is returned."}
{"code": "public void extractAudioWaveform(ExtractAudioWaveformProgressListener listener) throws IOException {\n  int frameDuration=0;\n  int sampleCount=0;\n  final String projectPath=mMANativeHelper.getProjectPath();\n  if (mAudioWaveformFilename == null) {\n    String mAudioWaveFileName=null;\n    mAudioWaveFileName=String.format(projectPath + \"/\" + \"audioWaveformFile-\"+ getId()+ \".dat\");\n    if (mMANativeHelper.getAudioCodecType(mAudioType) == MediaProperties.ACODEC_AMRNB) {\n      frameDuration=(MediaProperties.SAMPLES_PER_FRAME_AMRNB * 1000) / MediaProperties.DEFAULT_SAMPLING_FREQUENCY;\n      sampleCount=MediaProperties.SAMPLES_PER_FRAME_AMRNB;\n    }\n else     if (mMANativeHelper.getAudioCodecType(mAudioType) == MediaProperties.ACODEC_AMRWB) {\n      frameDuration=(MediaProperties.SAMPLES_PER_FRAME_AMRWB * 1000) / MediaProperties.DEFAULT_SAMPLING_FREQUENCY;\n      sampleCount=MediaProperties.SAMPLES_PER_FRAME_AMRWB;\n    }\n else     if (mMANativeHelper.getAudioCodecType(mAudioType) == MediaProperties.ACODEC_AAC_LC) {\n      frameDuration=(MediaProperties.SAMPLES_PER_FRAME_AAC * 1000) / MediaProperties.DEFAULT_SAMPLING_FREQUENCY;\n      sampleCount=MediaProperties.SAMPLES_PER_FRAME_AAC;\n    }\n    mMANativeHelper.generateAudioGraph(getId(),mFilename,mAudioWaveFileName,frameDuration,MediaProperties.DEFAULT_CHANNEL_COUNT,sampleCount,listener,true);\n    mAudioWaveformFilename=mAudioWaveFileName;\n  }\n  mWaveformData=new SoftReference<WaveformData>(new WaveformData(mAudioWaveformFilename));\n}\n", "nl": "This API allows to generate a file containing the sample volume levels of the Audio track of this media item. This function may take significant time and is blocking. The file can be retrieved using getAudioWaveformFilename()."}
{"code": "public void actionPerformed(ActionEvent e){\n  log.fine(\"VPayment.actionPerformed - \" + e.getActionCommand());\n  if (e.getActionCommand().equals(ConfirmPanel.A_OK)) {\n    if (checkMandatory()) {\n      saveChanges();\n      dispose();\n    }\n  }\n else   if (e.getActionCommand().equals(ConfirmPanel.A_CANCEL))   dispose();\n else   if (e.getSource() == paymentCombo) {\n    ValueNamePair pp=(ValueNamePair)paymentCombo.getSelectedItem();\n    if (pp != null) {\n      String s=pp.getValue().toLowerCase();\n      if (X_C_Order.PAYMENTRULE_DirectDebit.equalsIgnoreCase(s))       s=X_C_Order.PAYMENTRULE_DirectDeposit.toLowerCase();\n      s+=\"Panel\";\n      centerLayout.show(centerPanel,s);\n      int C_Invoice_ID=Env.getContextAsInt(Env.getCtx(),m_WindowNo,\"C_Invoice_ID\");\n      MInvoice invoice_tmp=new MInvoice(Env.getCtx(),C_Invoice_ID,null);\n      if (!invoice_tmp.isSOTrx()) {\n        bAmountField.setValue(m_Amount.negate());\n      }\n else {\n        bAmountField.setValue(m_Amount);\n      }\n      invoice_tmp=null;\n    }\n  }\n else   if (e.getSource() == sCurrencyCombo) {\n    KeyNamePair pp=(KeyNamePair)sCurrencyCombo.getSelectedItem();\n    BigDecimal amt=MConversionRate.convert(Env.getCtx(),m_Amount,m_C_Currency_ID,pp.getKey(),m_AD_Client_ID,m_AD_Org_ID);\n    sAmountField.setValue(amt);\n  }\n else   if (e.getSource() == bCurrencyCombo) {\n    KeyNamePair pp=(KeyNamePair)bCurrencyCombo.getSelectedItem();\n    BigDecimal amt=MConversionRate.convert(Env.getCtx(),m_Amount,m_C_Currency_ID,pp.getKey(),m_AD_Client_ID,m_AD_Org_ID);\n    bAmountField.setValue(amt);\n  }\n else   if (e.getSource() == kOnline || e.getSource() == sOnline)   processOnline();\n}\n", "nl": "Action Listener"}
{"code": "protected int read(byte[] buffer) throws IOException {\n  return mTiffStream.read(buffer);\n}\n", "nl": "Equivalent to read(buffer, 0, buffer.length)."}
{"code": "public URL find(String classname){\n  if (this.classname.equals(classname)) {\n    String cname=classname.replace('.','/') + \".class\";\n    try {\n      return new URL(\"file:/ByteArrayClassPath/\" + cname);\n    }\n catch (    MalformedURLException e) {\n    }\n  }\n  return null;\n}\n", "nl": "Obtains the URL."}
{"code": "@Override public Object clone() throws CloneNotSupportedException {\n  return super.clone();\n}\n", "nl": "Returns a clone of the entity."}
{"code": "public void selectInList(String listName,int offset){\n  TestUtils.selectInList(listName,offset);\n}\n", "nl": "This method just invokes the test utils method, it is here for convenience"}
{"code": "public MarketService updateUrl(String url){\n  this.updateUrl=url;\n  return this;\n}\n", "nl": "Set the destination url of the default update button."}
{"code": "public void invert(final int ulx,final int uly,final int lrx,final int lry){\n  filter(ulx,uly,lrx,lry,FilterMode.FILTER_INVERT,-1);\n}\n", "nl": "invert filter for a square part of the image"}
{"code": "public void addModel(ModelInstance instance){\n  instances.add(instance);\n}\n", "nl": "Render only"}
{"code": "boolean isHandshakeComplete(){\n  return handshakeComplete;\n}\n", "nl": "Check if handshake is completed."}
{"code": "public StackBlurFilter(){\n  this(3,3);\n}\n", "nl": "<p>Creates a new blur filter with a default radius of 3 and 3 iterations.</p>"}
{"code": "public static CC parseComponentConstraint(String s){\n  CC cc=new CC();\n  if (s.length() == 0)   return cc;\n  String[] parts=toTrimmedTokens(s,',');\n  for (  String part : parts) {\n    try {\n      if (part.length() == 0)       continue;\n      int ix=-1;\n      char c=part.charAt(0);\n      if (c == 'n') {\n        if (part.equals(\"north\")) {\n          cc.setDockSide(0);\n          continue;\n        }\n        if (part.equals(\"newline\")) {\n          cc.setNewline(true);\n          continue;\n        }\n        if (part.startsWith(\"newline \")) {\n          String gapSz=part.substring(7).trim();\n          cc.setNewlineGapSize(parseBoundSize(gapSz,true,true));\n          continue;\n        }\n      }\n      if (c == 'f' && (part.equals(\"flowy\") || part.equals(\"flowx\"))) {\n        cc.setFlowX(part.charAt(4) == 'x' ? Boolean.TRUE : Boolean.FALSE);\n        continue;\n      }\n      if (c == 's') {\n        ix=startsWithLenient(part,\"skip\",4,true);\n        if (ix > -1) {\n          String num=part.substring(ix).trim();\n          cc.setSkip(num.length() != 0 ? Integer.parseInt(num) : 1);\n          continue;\n        }\n        ix=startsWithLenient(part,\"split\",5,true);\n        if (ix > -1) {\n          String split=part.substring(ix).trim();\n          cc.setSplit(split.length() > 0 ? Integer.parseInt(split) : LayoutUtil.INF);\n          continue;\n        }\n        if (part.equals(\"south\")) {\n          cc.setDockSide(2);\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"spany\",\"sy\"},new int[]{5,2},true);\n        if (ix > -1) {\n          cc.setSpanY(parseSpan(part.substring(ix).trim()));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"spanx\",\"sx\"},new int[]{5,2},true);\n        if (ix > -1) {\n          cc.setSpanX(parseSpan(part.substring(ix).trim()));\n          continue;\n        }\n        ix=startsWithLenient(part,\"span\",4,true);\n        if (ix > -1) {\n          String[] spans=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.setSpanX(spans[0].length() > 0 ? Integer.parseInt(spans[0]) : LayoutUtil.INF);\n          cc.setSpanY(spans.length > 1 ? Integer.parseInt(spans[1]) : 1);\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrinkx\",7,true);\n        if (ix > -1) {\n          cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrinky\",7,true);\n        if (ix > -1) {\n          cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"shrink\",6,false);\n        if (ix > -1) {\n          String[] shrinks=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          if (shrinks.length > 1)           cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"shrinkprio\",\"shp\"},new int[]{10,3},true);\n        if (ix > -1) {\n          String sp=part.substring(ix).trim();\n          if (sp.startsWith(\"x\") || sp.startsWith(\"y\")) {\n            (sp.startsWith(\"x\") ? cc.getHorizontal() : cc.getVertical()).setShrinkPriority(Integer.parseInt(sp.substring(2)));\n          }\n else {\n            String[] shrinks=toTrimmedTokens(sp,' ');\n            cc.getHorizontal().setShrinkPriority(Integer.parseInt(shrinks[0]));\n            if (shrinks.length > 1)             cc.getVertical().setShrinkPriority(Integer.parseInt(shrinks[1]));\n          }\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"sizegroupx\",\"sizegroupy\",\"sgx\",\"sgy\"},new int[]{9,9,2,2},true);\n        if (ix > -1) {\n          String sg=part.substring(ix).trim();\n          char lc=part.charAt(ix - 1);\n          if (lc != 'y')           cc.getHorizontal().setSizeGroup(sg);\n          if (lc != 'x')           cc.getVertical().setSizeGroup(sg);\n          continue;\n        }\n      }\n      if (c == 'g') {\n        ix=startsWithLenient(part,\"growx\",5,true);\n        if (ix > -1) {\n          cc.getHorizontal().setGrow(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"growy\",5,true);\n        if (ix > -1) {\n          cc.getVertical().setGrow(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"grow\",4,false);\n        if (ix > -1) {\n          String[] grows=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setGrow(parseFloat(grows[0],ResizeConstraint.WEIGHT_100));\n          cc.getVertical().setGrow(parseFloat(grows.length > 1 ? grows[1] : \"\",ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"growprio\",\"gp\"},new int[]{8,2},true);\n        if (ix > -1) {\n          String gp=part.substring(ix).trim();\n          char c0=gp.length() > 0 ? gp.charAt(0) : ' ';\n          if (c0 == 'x' || c0 == 'y') {\n            (c0 == 'x' ? cc.getHorizontal() : cc.getVertical()).setGrowPriority(Integer.parseInt(gp.substring(2)));\n          }\n else {\n            String[] grows=toTrimmedTokens(gp,' ');\n            cc.getHorizontal().setGrowPriority(Integer.parseInt(grows[0]));\n            if (grows.length > 1)             cc.getVertical().setGrowPriority(Integer.parseInt(grows[1]));\n          }\n          continue;\n        }\n        if (part.startsWith(\"gap\")) {\n          BoundSize[] gaps=parseGaps(part);\n          if (gaps[0] != null)           cc.getVertical().setGapBefore(gaps[0]);\n          if (gaps[1] != null)           cc.getHorizontal().setGapBefore(gaps[1]);\n          if (gaps[2] != null)           cc.getVertical().setGapAfter(gaps[2]);\n          if (gaps[3] != null)           cc.getHorizontal().setGapAfter(gaps[3]);\n          continue;\n        }\n      }\n      if (c == 'a') {\n        ix=startsWithLenient(part,new String[]{\"aligny\",\"ay\"},new int[]{6,2},true);\n        if (ix > -1) {\n          cc.getVertical().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(),false,null));\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"alignx\",\"ax\"},new int[]{6,2},true);\n        if (ix > -1) {\n          cc.getHorizontal().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(),true,null));\n          continue;\n        }\n        ix=startsWithLenient(part,\"align\",2,true);\n        if (ix > -1) {\n          String[] gaps=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.getHorizontal().setAlign(parseUnitValueOrAlign(gaps[0],true,null));\n          if (gaps.length > 1)           cc.getVertical().setAlign(parseUnitValueOrAlign(gaps[1],false,null));\n          continue;\n        }\n      }\n      if ((c == 'x' || c == 'y') && part.length() > 2) {\n        char c2=part.charAt(1);\n        if (c2 == ' ' || (c2 == '2' && part.charAt(2) == ' ')) {\n          if (cc.getPos() == null) {\n            cc.setPos(new UnitValue[4]);\n          }\n else           if (cc.isBoundsInGrid() == false) {\n            throw new IllegalArgumentException(\"Cannot combine 'position' with 'x/y/x2/y2' keywords.\");\n          }\n          int edge=(c == 'x' ? 0 : 1) + (c2 == '2' ? 2 : 0);\n          UnitValue[] pos=cc.getPos();\n          pos[edge]=parseUnitValue(part.substring(2).trim(),null,c == 'x');\n          cc.setPos(pos);\n          cc.setBoundsInGrid(true);\n          continue;\n        }\n      }\n      if (c == 'c') {\n        ix=startsWithLenient(part,\"cell\",4,true);\n        if (ix > -1) {\n          String[] grs=toTrimmedTokens(part.substring(ix).trim(),' ');\n          if (grs.length < 2)           throw new IllegalArgumentException(\"At least two integers must follow \" + part);\n          cc.setCellX(Integer.parseInt(grs[0]));\n          cc.setCellY(Integer.parseInt(grs[1]));\n          if (grs.length > 2)           cc.setSpanX(Integer.parseInt(grs[2]));\n          if (grs.length > 3)           cc.setSpanY(Integer.parseInt(grs[3]));\n          continue;\n        }\n      }\n      if (c == 'p') {\n        ix=startsWithLenient(part,\"pos\",3,true);\n        if (ix > -1) {\n          if (cc.getPos() != null && cc.isBoundsInGrid())           throw new IllegalArgumentException(\"Can not combine 'pos' with 'x/y/x2/y2' keywords.\");\n          String[] pos=toTrimmedTokens(part.substring(ix).trim(),' ');\n          UnitValue[] bounds=new UnitValue[4];\n          for (int j=0; j < pos.length; j++)           bounds[j]=parseUnitValue(pos[j],null,j % 2 == 0);\n          if (bounds[0] == null && bounds[2] == null || bounds[1] == null && bounds[3] == null)           throw new IllegalArgumentException(\"Both x and x2 or y and y2 can not be null!\");\n          cc.setPos(bounds);\n          cc.setBoundsInGrid(false);\n          continue;\n        }\n        ix=startsWithLenient(part,\"pad\",3,true);\n        if (ix > -1) {\n          UnitValue[] p=parseInsets(part.substring(ix).trim(),false);\n          cc.setPadding(new UnitValue[]{p[0],p.length > 1 ? p[1] : null,p.length > 2 ? p[2] : null,p.length > 3 ? p[3] : null});\n          continue;\n        }\n        ix=startsWithLenient(part,\"pushx\",5,true);\n        if (ix > -1) {\n          cc.setPushX(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"pushy\",5,true);\n        if (ix > -1) {\n          cc.setPushY(parseFloat(part.substring(ix).trim(),ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n        ix=startsWithLenient(part,\"push\",4,false);\n        if (ix > -1) {\n          String[] pushs=toTrimmedTokens(part.substring(ix).trim(),' ');\n          cc.setPushX(parseFloat(pushs[0],ResizeConstraint.WEIGHT_100));\n          cc.setPushY(parseFloat(pushs.length > 1 ? pushs[1] : \"\",ResizeConstraint.WEIGHT_100));\n          continue;\n        }\n      }\n      if (c == 't') {\n        ix=startsWithLenient(part,\"tag\",3,true);\n        if (ix > -1) {\n          cc.setTag(part.substring(ix).trim());\n          continue;\n        }\n      }\n      if (c == 'w' || c == 'h') {\n        if (part.equals(\"wrap\")) {\n          cc.setWrap(true);\n          continue;\n        }\n        if (part.startsWith(\"wrap \")) {\n          String gapSz=part.substring(5).trim();\n          cc.setWrapGapSize(parseBoundSize(gapSz,true,true));\n          continue;\n        }\n        boolean isHor=c == 'w';\n        if (isHor && (part.startsWith(\"w \") || part.startsWith(\"width \"))) {\n          String uvStr=part.substring(part.charAt(1) == ' ' ? 2 : 6).trim();\n          cc.getHorizontal().setSize(parseBoundSize(uvStr,false,true));\n          continue;\n        }\n        if (!isHor && (part.startsWith(\"h \") || part.startsWith(\"height \"))) {\n          String uvStr=part.substring(part.charAt(1) == ' ' ? 2 : 7).trim();\n          cc.getVertical().setSize(parseBoundSize(uvStr,false,false));\n          continue;\n        }\n        if (part.startsWith(\"wmin \") || part.startsWith(\"wmax \") || part.startsWith(\"hmin \")|| part.startsWith(\"hmax \")) {\n          String uvStr=part.substring(5).trim();\n          if (uvStr.length() > 0) {\n            UnitValue uv=parseUnitValue(uvStr,null,isHor);\n            boolean isMin=part.charAt(3) == 'n';\n            DimConstraint dc=isHor ? cc.getHorizontal() : cc.getVertical();\n            dc.setSize(new BoundSize(isMin ? uv : dc.getSize().getMin(),dc.getSize().getPreferred(),isMin ? (dc.getSize().getMax()) : uv,uvStr));\n            continue;\n          }\n        }\n        if (part.equals(\"west\")) {\n          cc.setDockSide(1);\n          continue;\n        }\n        if (part.startsWith(\"hidemode \")) {\n          cc.setHideMode(Integer.parseInt(part.substring(9)));\n          continue;\n        }\n      }\n      if (c == 'i' && part.startsWith(\"id \")) {\n        cc.setId(part.substring(3).trim());\n        int dIx=cc.getId().indexOf('.');\n        if (dIx == 0 || dIx == cc.getId().length() - 1)         throw new IllegalArgumentException(\"Dot must not be first or last!\");\n        continue;\n      }\n      if (c == 'e') {\n        if (part.equals(\"east\")) {\n          cc.setDockSide(3);\n          continue;\n        }\n        if (part.equals(\"external\")) {\n          cc.setExternal(true);\n          continue;\n        }\n        ix=startsWithLenient(part,new String[]{\"endgroupx\",\"endgroupy\",\"egx\",\"egy\"},new int[]{-1,-1,-1,-1},true);\n        if (ix > -1) {\n          String sg=part.substring(ix).trim();\n          char lc=part.charAt(ix - 1);\n          DimConstraint dc=(lc == 'x' ? cc.getHorizontal() : cc.getVertical());\n          dc.setEndGroup(sg);\n          continue;\n        }\n      }\n      if (c == 'd') {\n        if (part.equals(\"dock north\")) {\n          cc.setDockSide(0);\n          continue;\n        }\n        if (part.equals(\"dock west\")) {\n          cc.setDockSide(1);\n          continue;\n        }\n        if (part.equals(\"dock south\")) {\n          cc.setDockSide(2);\n          continue;\n        }\n        if (part.equals(\"dock east\")) {\n          cc.setDockSide(3);\n          continue;\n        }\n        if (part.equals(\"dock center\")) {\n          cc.getHorizontal().setGrow(100f);\n          cc.getVertical().setGrow(100f);\n          cc.setPushX(100f);\n          cc.setPushY(100f);\n          continue;\n        }\n      }\n      UnitValue horAlign=parseAlignKeywords(part,true);\n      if (horAlign != null) {\n        cc.getHorizontal().setAlign(horAlign);\n        continue;\n      }\n      UnitValue verAlign=parseAlignKeywords(part,false);\n      if (verAlign != null) {\n        cc.getVertical().setAlign(verAlign);\n        continue;\n      }\n      throw new IllegalArgumentException(\"Unknown keyword.\");\n    }\n catch (    Exception ex) {\n      throw new IllegalArgumentException(\"Illegal Constraint: '\" + part + \"'\\n\"+ ex.getMessage());\n    }\n  }\n  return cc;\n}\n", "nl": "Parses one component constraint and returns the parsed value."}
{"code": "@Override public void removeConnection(Connection connection){\n  super.removeConnection(connection);\n  if (this.getConnections().isEmpty()) {\n    this.setValue(this.getSocketHint().createInitialValue().orElse(null));\n  }\n}\n", "nl": "Reset the socket to its default value when it's no longer connected to anything.  This prevents removed connections from continuing to have an effect on steps because they still hold references to the values they were connected to."}
{"code": "@Override protected void after(){\n  ActiveMQTestBase.deleteDirectory(new File(folderName));\n}\n", "nl": "Override to tear down your specific external resource."}
{"code": "private int runClientSide(String args[],String serviceUrlStr) throws Exception {\n  List<String> opts=buildCommandLine(args);\n  opts.add(\"-serviceUrl\");\n  opts.add(serviceUrlStr);\n  int exitCode=0;\n  String[] optsArray=opts.toArray(new String[0]);\n  ProcessBuilder pb=new ProcessBuilder(optsArray);\n  Process p=ProcessTools.startProcess(\"AuthorizationTest$ClientSide\",pb);\n  try {\n    exitCode=p.waitFor();\n    if (exitCode != 0) {\n      System.out.println(\"Subprocess unexpected exit value of [\" + exitCode + \"]. Expected 0.\\n\");\n    }\n  }\n catch (  InterruptedException e) {\n    System.out.println(\"Parent process interrupted with exception : \\n \" + e + \" :\");\n    p.destroyForcibly();\n    throw new RuntimeException(\"Parent process interrupted with exception : \\n \" + e + \" :\");\n  }\n finally {\n    if (p.isAlive()) {\n      p.destroyForcibly();\n    }\n    return exitCode;\n  }\n}\n", "nl": "Runs AuthorizationTest$ClientSide with the passed options and redirects subprocess standard I/O to the current (parent) process. This provides a trace of what happens in the subprocess while it is runnning (and before it terminates)."}
{"code": "public static boolean pickDirectory(Activity activity,File startPath,int requestCode){\n  PackageManager packageMgr=activity.getPackageManager();\n  for (  String[] intent : PICK_DIRECTORY_INTENTS) {\n    String intentAction=intent[0];\n    String uriPrefix=intent[1];\n    Intent startIntent=new Intent(intentAction).putExtra(\"org.openintents.extra.TITLE\",activity.getString(R.string.save_as)).setData(Uri.parse(uriPrefix + startPath.getPath()));\n    try {\n      if (startIntent.resolveActivity(packageMgr) != null) {\n        activity.startActivityForResult(startIntent,requestCode);\n        return true;\n      }\n    }\n catch (    ActivityNotFoundException e) {\n      showNoFilePickerError(activity,e);\n    }\n  }\n  return false;\n}\n", "nl": "Tries to open a known file browsers to pick a directory."}
{"code": "public Object opt(String key){\n  return key == null ? null : this.map.get(key);\n}\n", "nl": "Get an optional value associated with a key."}
{"code": "public void close(){\n}\n", "nl": "Close the result list and delete the temporary file."}
{"code": "protected SVGOMFlowRegionExcludeElement(){\n}\n", "nl": "Creates a new BatikRegularPolygonElement object."}
{"code": "public String query(SolrQueryRequest req) throws Exception {\n  return query(req.getParams().get(CommonParams.QT),req);\n}\n", "nl": "Processes a \"query\" using a user constructed SolrQueryRequest"}
{"code": "public MethodCallExpr addArgument(Expression arg){\n  getArgs().add(arg);\n  arg.setParentNode(this);\n  return this;\n}\n", "nl": "Adds the given argument to the method call."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:42.369 -0500\",hash_original_method=\"67C1C5FB3D4E718484F296CD0580B923\",hash_generated_method=\"E4FB769FEDC02FEA8A2364FC8AD6FAE5\") public SIPHeader parse() throws ParseException {\n  if (debug)   dbg_enter(\"MinExpiresParser.parse\");\n  MinExpires minExpires=new MinExpires();\n  try {\n    headerName(TokenTypes.MIN_EXPIRES);\n    minExpires.setHeaderName(SIPHeaderNames.MIN_EXPIRES);\n    String number=this.lexer.number();\n    try {\n      minExpires.setExpires(Integer.parseInt(number));\n    }\n catch (    InvalidArgumentException ex) {\n      throw createParseException(ex.getMessage());\n    }\n    this.lexer.SPorHT();\n    this.lexer.match('\\n');\n    return minExpires;\n  }\n  finally {\n    if (debug)     dbg_leave(\"MinExpiresParser.parse\");\n  }\n}\n", "nl": "parse the String message"}
{"code": "public boolean isOrthogonalTo(IntVector v){\n  return dotProduct(v) == 0;\n}\n", "nl": "Checks if this vector is orthogonal to the vector v."}
{"code": "public static char toCharacter(final String value){\n  return value.charAt(0);\n}\n", "nl": "Converts the given XML string to a character value."}
{"code": "final boolean acquireQueued(final Node node,long arg){\n  boolean failed=true;\n  try {\n    boolean interrupted=false;\n    for (; ; ) {\n      final Node p=node.predecessor();\n      if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next=null;\n        failed=false;\n        return interrupted;\n      }\n      if (shouldParkAfterFailedAcquire(p,node) && parkAndCheckInterrupt())       interrupted=true;\n    }\n  }\n  finally {\n    if (failed)     cancelAcquire(node);\n  }\n}\n", "nl": "Acquires in exclusive uninterruptible mode for thread already in queue. Used by condition wait methods as well as acquire."}
{"code": "public Rule(String suffix,int min,String replacement){\n  this.suffix=suffix.toCharArray();\n  this.replacement=replacement.toCharArray();\n  this.min=min;\n}\n", "nl": "Create a rule."}
{"code": "private void validateCoreDataFile(ArchiveFile coreFile,boolean archiveHasExtensions) throws GeneratorException, InterruptedException, IOException {\n  addMessage(Level.INFO,\"Validating the core file: \" + coreFile.getTitle() + \". Depending on the number of records, this can take a while.\");\n  Term id=TERM_FACTORY.findTerm(AppConfig.coreIdTerm(resource.getCoreRowType()));\n  Term basisOfRecord=TERM_FACTORY.findTerm(Constants.DWC_BASIS_OF_RECORD);\n  int basisOfRecordIndex=-1;\n  if (isOccurrenceFile(coreFile)) {\n    if (!coreFile.hasTerm(basisOfRecord)) {\n      addMessage(Level.ERROR,\"Archive validation failed, because required term basisOfRecord was not mapped in the occurrence core\");\n      throw new GeneratorException(\"Can't validate DwC-A for resource \" + resource.getShortname() + \". Required term basisOfRecord was not mapped in the occurrence core\");\n    }\n    addMessage(Level.INFO,\"? Validating the core basisOfRecord is always present is always present and its \" + \"value matches the Darwin Core Type Vocabulary.\");\n    basisOfRecordIndex=coreFile.getField(basisOfRecord).getIndex();\n  }\n  if (coreFile.hasTerm(id) || archiveHasExtensions) {\n    String msg=\"? Validating the core ID field \" + id.simpleName() + \" is always present and unique.\";\n    if (archiveHasExtensions) {\n      msg=msg + \" Note: the core ID field is required to link core records and extension records together. \";\n    }\n    addMessage(Level.INFO,msg);\n  }\n  File sortedCore=sortCoreDataFile(coreFile,ID_COLUMN_INDEX);\n  CSVReader reader=CSVReaderFactory.build(sortedCore,CHARACTER_ENCODING,coreFile.getFieldsTerminatedBy(),coreFile.getFieldsEnclosedBy(),coreFile.getIgnoreHeaderLines());\n  AtomicInteger recordsWithNoId=new AtomicInteger(0);\n  AtomicInteger recordsWithDuplicateId=new AtomicInteger(0);\n  AtomicInteger recordsWithNoBasisOfRecord=new AtomicInteger(0);\n  AtomicInteger recordsWithNonMatchingBasisOfRecord=new AtomicInteger(0);\n  AtomicInteger recordsWithAmbiguousBasisOfRecord=new AtomicInteger(0);\n  ClosableReportingIterator<String[]> iter=null;\n  int line=0;\n  String lastId=null;\n  try {\n    iter=reader.iterator();\n    while (iter.hasNext()) {\n      line++;\n      if (line % 1000 == 0) {\n        checkForInterruption(line);\n        reportIfNeeded();\n      }\n      String[] record=iter.next();\n      if (record == null || record.length == 0) {\n        continue;\n      }\n      if (iter.hasRowError() && iter.getException() != null) {\n        throw new GeneratorException(\"A fatal error was encountered while trying to validate sorted core data file: \" + iter.getErrorMessage(),iter.getException());\n      }\n else {\n        if (coreFile.hasTerm(id) || archiveHasExtensions) {\n          lastId=validateIdentifier(record[ID_COLUMN_INDEX],lastId,recordsWithNoId,recordsWithDuplicateId);\n        }\n        if (isOccurrenceFile(coreFile)) {\n          validateBasisOfRecord(record[basisOfRecordIndex],line,recordsWithNoBasisOfRecord,recordsWithNonMatchingBasisOfRecord,recordsWithAmbiguousBasisOfRecord);\n        }\n      }\n    }\n  }\n catch (  InterruptedException e) {\n    setState(e);\n    throw e;\n  }\ncatch (  Exception e) {\n    log.error(\"Exception caught while validating archive\",e);\n    setState(e);\n    throw new GeneratorException(\"Error while validating archive occurred on line \" + line,e);\n  }\n finally {\n    if (iter != null) {\n      if (!iter.hasRowError() && iter.getErrorMessage() != null) {\n        writePublicationLogMessage(\"Error reading data: \" + iter.getErrorMessage());\n      }\n      iter.close();\n    }\n    FileUtils.deleteQuietly(sortedCore);\n  }\n  if (coreFile.hasTerm(id) || archiveHasExtensions) {\n    summarizeIdentifierValidation(recordsWithNoId,recordsWithDuplicateId,id.simpleName());\n  }\n  if (isOccurrenceFile(coreFile)) {\n    summarizeBasisOfRecordValidation(recordsWithNoBasisOfRecord,recordsWithNonMatchingBasisOfRecord,recordsWithAmbiguousBasisOfRecord);\n  }\n}\n", "nl": "Validate the Archive's core data file has an ID for each row, and that each ID is unique. Perform this check only if the core record ID term (e.g. occurrenceID, taxonID, etc) has actually been mapped. </br> If the core has rowType occurrence, validate the core data file has a basisOfRecord for each row, and that each basisOfRecord matches the DwC Type Vocabulary. </br> If the core has rowType event, validate there are associated occurrences."}
{"code": "private void population(){\n  Network activityLinkNetwork=NetworkTools.filterNetworkByLinkMode(network,Collections.singleton(\"car\"));\n  new NetworkCleaner().run(activityLinkNetwork);\n  log.info(\"adapting plans...\");\n  Counter personCounter=new Counter(\" person # \");\n  for (  Person person : population.getPersons().values()) {\n    personCounter.incCounter();\n    List<? extends Plan> plans=person.getPlans();\n    for (    Plan plan : plans) {\n      List<PlanElement> elements=plan.getPlanElements();\n      for (      PlanElement e : elements) {\n        if (e instanceof Activity) {\n          Activity activity=(Activity)e;\nswitch (activity.getType()) {\ncase \"home\":\n            break;\ncase \"work\":\n          break;\ndefault :\n        activity.setType(OTHER);\n    }\n    activity.setFacilityId(null);\n    activity.setLinkId(NetworkTools.getNearestLink(activityLinkNetwork,activity.getCoord()).getId());\n  }\n}\n}\n}\n}\n", "nl": "modifiy population"}
{"code": "public boolean visit(MultiTextEdit edit){\n  return visitNode(edit);\n}\n", "nl": "Visits a <code>MultiTextEdit</code> instance."}
{"code": "public Iterator<IRemoteTxState0> listTx(){\n  final ConnectOptions opts=new ConnectOptions(mgr.getBaseServiceURL() + \"/tx\");\n  opts.method=\"GET\";\n  JettyResponseListener response=null;\n  try {\n    RemoteRepository.checkResponseCode(response=mgr.doConnect(opts));\n    return multiTxResponse(response).iterator();\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e);\n  }\n finally {\n    if (response != null)     response.abort();\n  }\n}\n", "nl": "<code>LIST-TX</code>: Return the set of active transactions."}
{"code": "public Builder nodeSettings(StaticNodeSettings staticNodeSettings){\n  this.staticNodeSettings=staticNodeSettings;\n  return this;\n}\n", "nl": "Sets static node settings."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:01:03.289 -0500\",hash_original_method=\"41E781585F5EF3A93F8FE051E438DFA6\",hash_generated_method=\"71A4764486C7D6EA74D91BA9F31D39F0\") public static void refresh(){\n  if (needRefresh) {\n    refreshNumber++;\n    updateServiceInfo();\n  }\n}\n", "nl": "Refresh services info"}
{"code": "private void revertFieldsJavaNames(Collection<PojoField> selFields){\n  for (  PojoField field : selFields)   field.resetJavaName();\n}\n", "nl": "Revert fields java name for current POJO to initial value."}
{"code": "public CompactConcurrentHashSet2(){\n}\n", "nl": "Creates a new, empty map with the default initial table size (16)."}
{"code": "public boolean checkType(JCTree declaringElement,Name declaringElementName,JCExpression typeExpression){\n  if (!JSweetConfig.isJDKReplacementMode()) {\n    if (typeExpression instanceof JCArrayTypeTree) {\n      return checkType(declaringElement,declaringElementName,((JCArrayTypeTree)typeExpression).elemtype);\n    }\n    String type=typeExpression.type.tsym.toString();\n    if (!translator.getContext().options.isJDKAllowed() && !translator.getContext().strictMode && type.startsWith(\"java.\")) {\n      if (!(AUTHORIZED_DECLARED_TYPES.contains(type) || NUMBER_TYPES.contains(type) || type.startsWith(\"java.util.function\"))) {\n        translator.report(declaringElement,declaringElementName,JSweetProblem.JDK_TYPE,type);\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "nl": "Checks that the given type is JSweet compatible."}
{"code": "@Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application){\n  return application.sources(Application.class);\n}\n", "nl": "An opinionated WebApplicationInitializer to run a SpringApplication from a traditional WAR deployment. Binds Servlet, Filter and ServletContextInitializer beans from the application context to the servlet container."}
{"code": "public static void checkState(boolean expression){\n  if (!expression) {\n    throw new IllegalStateException();\n  }\n}\n", "nl": "Ensures the truth of an expression involving the state of the calling instance, but not involving any parameters to the calling method."}
{"code": "private void showOptions(){\n  if (client.getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n    getGameOptionsDialog().setEditable(true);\n  }\n else {\n    getGameOptionsDialog().setEditable(false);\n  }\n  getGameOptionsDialog().update(client.getGame().getOptions());\n  getGameOptionsDialog().setVisible(true);\n}\n", "nl": "Called when the user selects the \"View->Game Options\" menu item."}
{"code": "public static void checkAndAppendIntegerlement(AVList params,String paramKey,Element context,String path){\n  if (params == null) {\n    String message=Logging.getMessage(\"nullValue.ParametersIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  if (paramKey == null) {\n    String message=Logging.getMessage(\"nullValue.ParameterKeyIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  if (context == null) {\n    String message=Logging.getMessage(\"nullValue.ElementIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  Integer i=AVListImpl.getIntegerValue(params,paramKey);\n  if (i != null) {\n    appendInteger(context,path,i);\n  }\n}\n", "nl": "Checks a parameter list for a specified key and if present attempts to append new elements represeting the parameter to a specified context."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:52.342 -0400\",hash_original_method=\"610F60ED6DB50185F33A85945665EF11\",hash_generated_method=\"57A04B03533AEBB95DA85C73B06358AD\") @Override public String toString(){\n  return charSequence.toString();\n}\n", "nl": "Return a String representation of the underlying character sequence."}
{"code": "@Override public long position(java.sql.Clob searchstr,long start) throws SQLException {\n  return position(searchstr.getSubString(0,(int)searchstr.length()),(int)start);\n}\n", "nl": "Retrieves the character position at which the specified <code>Clob</code> object <code>searchstr</code> begins within the <code>CLOB</code> value that this <code>Clob</code> object represents. The search for <code>searchstr</code> begins at position <code>start</code>."}
{"code": "protected void checkCapacity(){\n  if (size >= threshold) {\n    final int newCapacity=data.length * 2;\n    if (newCapacity <= MAXIMUM_CAPACITY) {\n      ensureCapacity(newCapacity);\n    }\n  }\n}\n", "nl": "Checks the capacity of the map and enlarges it if necessary. <p> This implementation uses the threshold to check if the map needs enlarging"}
{"code": "public JBBPOut Bits(final JBBPBitNumber numberOfBits,final int value) throws IOException {\n  assertNotEnded();\n  JBBPUtils.assertNotNull(numberOfBits,\"Number of bits must not be null\");\n  if (this.processCommands) {\n    _writeBits(numberOfBits,value);\n  }\n  return this;\n}\n", "nl": "Write bits from a value into the output stream"}
{"code": "public void testCacheImpacts() throws Exception {\n  assertU(adoc(\"id\",\"9\",\"str\",\"c\",\"float\",\"-3.2\",\"int\",\"42\"));\n  assertU(adoc(\"id\",\"7\",\"str\",\"c\",\"float\",\"-3.2\",\"int\",\"-1976\"));\n  assertU(adoc(\"id\",\"2\",\"str\",\"c\",\"float\",\"-3.2\",\"int\",\"666\"));\n  assertU(adoc(\"id\",\"0\",\"str\",\"b\",\"float\",\"64.5\",\"int\",\"-42\"));\n  assertU(adoc(\"id\",\"5\",\"str\",\"b\",\"float\",\"64.5\",\"int\",\"2001\"));\n  assertU(adoc(\"id\",\"8\",\"str\",\"b\",\"float\",\"64.5\",\"int\",\"4055\"));\n  assertU(adoc(\"id\",\"6\",\"str\",\"a\",\"float\",\"64.5\",\"int\",\"7\"));\n  assertU(adoc(\"id\",\"1\",\"str\",\"a\",\"float\",\"64.5\",\"int\",\"7\"));\n  assertU(adoc(\"id\",\"4\",\"str\",\"a\",\"float\",\"11.1\",\"int\",\"6\"));\n  assertU(adoc(\"id\",\"3\",\"str\",\"a\",\"float\",\"11.1\",\"int\",\"3\"));\n  assertU(commit());\n  final Collection<String> allFieldNames=getAllSortFieldNames();\n  final SolrInfoMBean filterCacheStats=h.getCore().getInfoRegistry().get(\"filterCache\");\n  assertNotNull(filterCacheStats);\n  final SolrInfoMBean queryCacheStats=h.getCore().getInfoRegistry().get(\"queryResultCache\");\n  assertNotNull(queryCacheStats);\n  final long preQcIn=(Long)queryCacheStats.getStatistics().get(\"inserts\");\n  final long preFcIn=(Long)filterCacheStats.getStatistics().get(\"inserts\");\n  final long preFcHits=(Long)filterCacheStats.getStatistics().get(\"hits\");\n  SentinelIntSet ids=assertFullWalkNoDups(10,params(\"q\",\"*:*\",\"rows\",\"\" + TestUtil.nextInt(random(),1,11),\"fq\",\"-id:[1 TO 2]\",\"fq\",\"-id:[6 TO 7]\",\"fl\",\"id\",\"sort\",buildRandomSort(allFieldNames)));\n  assertEquals(6,ids.size());\n  final long postQcIn=(Long)queryCacheStats.getStatistics().get(\"inserts\");\n  final long postFcIn=(Long)filterCacheStats.getStatistics().get(\"inserts\");\n  final long postFcHits=(Long)filterCacheStats.getStatistics().get(\"hits\");\n  assertEquals(\"query cache inserts changed\",preQcIn,postQcIn);\n  assertEquals(\"filter cache did not grow correctly\",3,postFcIn - preFcIn);\n  assertTrue(\"filter cache did not have any new cache hits\",0 < postFcHits - preFcHits);\n}\n", "nl": "test that our assumptions about how caches are affected hold true"}
{"code": "@Override public void translate(final ITranslationEnvironment environment,final IInstruction instruction,final List<ReilInstruction> instructions) throws InternalTranslationException {\n  TranslationHelpers.checkTranslationArguments(environment,instruction,instructions,\"SMULW\");\n  translateAll(environment,instruction,\"SMULW\",instructions);\n}\n", "nl": "SMULW<y>{<cond>} <Rd>, <Rm>, <Rs> Operation: if ConditionPassed(cond) then if (y == 0) then operand2 = SignExtend(Rs[15:0]) else // y == 1 operand2 = SignExtend(Rs[31:16]) Rd = (Rm * operand2)[47:16] // Signed multiplication"}
{"code": "public int jumpToIndex(FormIndex index){\n  return mFormEntryController.jumpToIndex(index);\n}\n", "nl": "Jumps to a given FormIndex."}
{"code": "public static boolean startsWith(String s,String start){\n  return s == null || start == null ? false : s.startsWith(start);\n}\n", "nl": "Check is a string starts with another string, ignoring the case."}
{"code": "protected void sequence_ThisTypeRefNominal_TypeRefWithoutModifiers(ISerializationContext context,ThisTypeRefNominal semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: TypeRefWithoutModifiers returns ThisTypeRefNominal Constraint: dynamic?='+'?"}
{"code": "public static String numberToString(Number number) throws JSONException {\n  if (number == null) {\n    throw new JSONException(\"Null pointer\");\n  }\n  testValidity(number);\n  String string=number.toString();\n  if (string.indexOf('.') > 0 && string.indexOf('e') < 0 && string.indexOf('E') < 0) {\n    while (string.endsWith(\"0\")) {\n      string=string.substring(0,string.length() - 1);\n    }\n    if (string.endsWith(\".\")) {\n      string=string.substring(0,string.length() - 1);\n    }\n  }\n  return string;\n}\n", "nl": "Produce a string from a Number."}
{"code": "private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\nsynchronized (refreshLiveNodesLock) {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList=zkClient.getChildren(LIVE_NODES_ZKNODE,watcher,true);\n      newLiveNodes=new HashSet<>(nodeList);\n    }\n catch (    KeeperException.NoNodeException e) {\n      newLiveNodes=emptySet();\n    }\n    lastFetchedLiveNodes.set(newLiveNodes);\n  }\n  Set<String> oldLiveNodes, newLiveNodes;\nsynchronized (getUpdateLock()) {\n    newLiveNodes=lastFetchedLiveNodes.getAndSet(null);\n    if (newLiveNodes == null) {\n      return;\n    }\n    oldLiveNodes=this.liveNodes;\n    this.liveNodes=newLiveNodes;\n    if (clusterState != null) {\n      clusterState.setLiveNodes(newLiveNodes);\n    }\n  }\n  if (oldLiveNodes.size() != newLiveNodes.size()) {\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\",oldLiveNodes.size(),newLiveNodes.size());\n  }\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\",new TreeSet<>(oldLiveNodes),new TreeSet<>(newLiveNodes));\n  }\n}\n", "nl": "Refresh live_nodes."}
{"code": "private void refreshView(){\n  if (!wasInvalidatedBefore) {\n    wasInvalidatedBefore=true;\n    invalidate();\n  }\n}\n", "nl": "Tries to post a invalidate() event if another one was previously posted."}
{"code": "private void applyKitKatTranslucency(){\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    int topPadding=Common.getStatusBarHeight(mContext);\n    if (mDrawerParentLayout != null) {\n      mDrawerParentLayout.setPadding(0,(0 - topPadding),0,0);\n      mDrawerParentLayout.setClipToPadding(false);\n      int navigationBarHeight=Common.getNavigationBarHeight(mContext);\n      mListView.setClipToPadding(false);\n      mListView.setPadding(mListView.getPaddingLeft(),mListView.getPaddingTop(),mListView.getPaddingRight(),mListView.getPaddingBottom() + navigationBarHeight);\n    }\n  }\n}\n", "nl": "Apply KitKat specific translucency."}
{"code": "public PubsubFuture<Void> modifyAckDeadline(final String canonicalSubscriptionName,final int ackDeadlineSeconds,final List<String> ackIds){\n  final String path=canonicalSubscriptionName + \":modifyAckDeadline\";\n  final ModifyAckDeadlineRequest req=ModifyAckDeadlineRequest.builder().ackDeadlineSeconds(ackDeadlineSeconds).ackIds(ackIds).build();\n  return post(\"modify ack deadline\",path,req,Void.class);\n}\n", "nl": "Modify the ack deadline for a list of received messages."}
{"code": "public void testGetPrototype() throws Exception {\n  TestService mockService=control.createMock(TestService.class);\n  assertSame(mockService.getRequestPrototype(fooDescriptor),FooRequest.getDefaultInstance());\n  assertSame(mockService.getResponsePrototype(fooDescriptor),FooResponse.getDefaultInstance());\n  assertSame(mockService.getRequestPrototype(barDescriptor),BarRequest.getDefaultInstance());\n  assertSame(mockService.getResponsePrototype(barDescriptor),BarResponse.getDefaultInstance());\n}\n", "nl": "Tests Service.get{Request,Response}Prototype()."}
{"code": "@Override public boolean isSingleton(){\n  return true;\n}\n", "nl": "Always returns <code>true</code>."}
{"code": "public static boolean isPrimitiveWrapper(Class<?> clazz){\n  Assert.notNull(clazz,\"Class must not be null\");\n  return primitiveWrapperTypeMap.containsKey(clazz);\n}\n", "nl": "Check if the given class represents a primitive wrapper, i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double."}
{"code": "public int size(){\n  return this.parts.size();\n}\n", "nl": "Returns the number of stored diff parts."}
{"code": "public static int octant(Coordinate p0,Coordinate p1){\n  double dx=p1.x - p0.x;\n  double dy=p1.y - p0.y;\n  if (dx == 0.0 && dy == 0.0)   throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n  return octant(dx,dy);\n}\n", "nl": "Returns the octant of a directed line segment from p0 to p1."}
{"code": "@Override public Integer put(Long key,Integer value){\n  return wrapValue(_map.put(unwrapKey(key),unwrapValue(value)));\n}\n", "nl": "Inserts a key/value pair into the map."}
{"code": "@Override public void updateTextCycle(Cycle cycle){\n  textCycle=cycle;\n  textCycleStream.onNext(textCycle);\n}\n", "nl": "Update current text cycle to reflect changes"}
{"code": "public static String decodeJavaMIMEType(String nat){\n  return (isJavaMIMEType(nat)) ? nat.substring(JavaMIME.length(),nat.length()).trim() : null;\n}\n", "nl": "Decodes a <code>String</code> native for use as a Java MIME type."}
{"code": "@Override protected void onAttach(){\n  super.onAttach();\n  setInteractivity(false);\n  mPulseAnimation=AnimationUtils.loadAnimation(SampleKeyguardProviderService.this,R.anim.pulsing_anim);\n  mImageView.startAnimation(mPulseAnimation);\n}\n", "nl": "Called when the view has been attached to a window"}
{"code": "public AttributesDescriptor(String displayName,TextAttributesKey key){\n  myKey=key;\n  myDisplayName=displayName;\n}\n", "nl": "Creates an attribute descriptor with the specified name and text attributes key."}
{"code": "public byte[] encrypt(String clearString) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, InvalidKeySpecException, BadPaddingException, IllegalBlockSizeException {\n  if ((clearString == null) || (clearString.isEmpty())) {\n    return null;\n  }\n  Cipher cipher=getCipher(Cipher.ENCRYPT_MODE);\n  return cipher.doFinal(clearString.getBytes(\"UTF8\"));\n}\n", "nl": "Encryption Method"}
{"code": "protected void prepare(){\n  p_Record_ID=getRecord_ID();\n  if (p_AD_Client_ID == 0)   p_AD_Client_ID=Env.getAD_Client_ID(getCtx());\n  AD_Table_ID=getTable_ID();\n  StringBuffer sb=new StringBuffer(\"AD_Table_ID=\").append(AD_Table_ID);\n  sb.append(\"; Record_ID=\").append(getRecord_ID());\n  ProcessInfoParameter[] para=getParameter();\n  for (int i=0; i < para.length; i++) {\n    String name=para[i].getParameterName();\n    if (para[i].getParameter() == null)     ;\n else     if (name.equals(\"AD_Table_ID\"))     p_AD_Table_ID=para[i].getParameterAsInt();\n else     log.log(Level.SEVERE,\"Unknown Parameter: \" + name);\n  }\n  log.info(sb.toString());\n}\n", "nl": "Get Parameters"}
{"code": "private StringBuilder removeHiddenMarkers(final int c){\n  if (content[c].indexOf(MARKER) == -1) {\n    return content[c];\n  }\n  final StringTokenizer tokens=new StringTokenizer(content[c].toString(),MARKER,true);\n  String temp;\n  StringBuilder processedData=new StringBuilder();\n  while (tokens.hasMoreTokens()) {\n    temp=tokens.nextToken();\n    if (temp.equals(MARKER)) {\n      tokens.nextToken();\n      tokens.nextToken();\n      tokens.nextToken();\n      tokens.nextToken();\n      processedData=processedData.append(tokens.nextToken());\n    }\n else {\n      processedData=processedData.append(temp);\n    }\n  }\n  return processedData;\n}\n", "nl": "strip the hidden numbers of position we encoded into the data (could be coded to be faster by not using Tokenizer)"}
{"code": "public static CoffeeEntry createIcedCoffeeEntry(SkuDetails icedCoffeeDetails){\n  return new CoffeeEntry(icedCoffeeDetails,ICED_COFFEE_CAFFEINE_RATE,ICED_COFFEE_ENERGY_RATE,ICED_COFFEE_CANDYNESS_RATE);\n}\n", "nl": "create iced coffee entry"}
{"code": "public static void main(String[] argv) throws IOException {\n  if (argv.length == 1) {\n    OperatorDocGenerator opDocGen=null;\n    if (argv[0].equals(\"LATEX\"))     opDocGen=new LatexOperatorDocGenerator();\n else     opDocGen=new ProgramHTMLOperatorDocGenerator();\n    ParameterService.init();\n    File file=new File(ParameterService.getRapidMinerHome(),\"tutorial\" + File.separator + \"OperatorsGenerated.tex\");\n    LogService.getGlobal().log(\"Generating class documentation to '\" + file + \"'.\",LogService.STATUS);\n    DocumentationGenerator docGen=new DocumentationGenerator(opDocGen);\n    docGen.getRootDoc();\n    docGen.generateAll(new PrintWriter(new FileWriter(file)));\n  }\n else   if (argv.length == 2) {\n    OperatorDocGenerator opDocGen=null;\n    if (argv[0].equals(\"LATEX\"))     opDocGen=new LatexOperatorDocGenerator();\n else     opDocGen=new ProgramHTMLOperatorDocGenerator();\n    ParameterService.init();\n    File file=new File(argv[1]);\n    LogService.getGlobal().log(\"Generating class documentation to '\" + file + \"'.\",LogService.STATUS);\n    DocumentationGenerator docGen=new DocumentationGenerator(opDocGen);\n    docGen.getRootDoc();\n    docGen.generateAll(new PrintWriter(new FileWriter(file)));\n  }\n else   if (argv.length >= 5) {\n    OperatorDocGenerator opDocGen=null;\n    if (argv[0].equals(\"LATEX\"))     opDocGen=new LatexOperatorDocGenerator();\n else     opDocGen=new ProgramHTMLOperatorDocGenerator();\n    try {\n      OperatorService.registerOperators(argv[1],new FileInputStream(argv[1]),null);\n    }\n catch (    IOException e) {\n      LogService.getGlobal().log(\"Cannot read 'operators.xml'.\",LogService.ERROR);\n    }\n    File file=new File(argv[4]);\n    LogService.getGlobal().log(\"Generating class documentation to '\" + file + \"'.\",LogService.STATUS);\n    PrintWriter out=new PrintWriter(new FileWriter(file));\n    DocumentationGenerator docGen=new DocumentationGenerator(opDocGen);\n    boolean generateSubgroups=false;\n    if (argv.length == 6) {\n      if (argv[5].equals(\"true\"))       generateSubgroups=true;\n    }\n    docGen.getRootDoc(new File(argv[2]),argv[3]);\n    docGen.generateAll(new PrintWriter(new FileWriter(file)),generateSubgroups);\n    out.close();\n  }\n else {\n    LogService.getGlobal().log(\"usage: java com.rapidminer.doc.DocumentationGenerator or\" + Tools.getLineSeparator() + \"       java com.rapidminer.doc.DocumentationGenerator operatordesc srcdir subpackages outputfile [generate subgroups (true/false)]\",LogService.WARNING);\n  }\n}\n", "nl": "If no arguments are given, the LaTeX documentation of the RapidMiner core is generated. Otherwise this documentation generator can be used to generated the documentation of arbitrary RapidMiner operators, e.g. for plugins. In this case the arguments are: <br/> &lt;operators.xml&gt; &lt;sourcedir&gt; &lt;packages&gt; &lt;with_subgroups&gt;"}
{"code": "public NotificationChain basicSetDeclaredTypeRef(TypeRef newDeclaredTypeRef,NotificationChain msgs){\n  TypeRef oldDeclaredTypeRef=declaredTypeRef;\n  declaredTypeRef=newDeclaredTypeRef;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,N4JSPackage.PROPERTY_NAME_VALUE_PAIR__DECLARED_TYPE_REF,oldDeclaredTypeRef,newDeclaredTypeRef);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public DailyTimeIntervalTriggerImpl(String name,Date startTime,Date endTime,TimeOfDay startTimeOfDay,TimeOfDay endTimeOfDay,IntervalUnit intervalUnit,int repeatInterval){\n  this(name,null,startTime,endTime,startTimeOfDay,endTimeOfDay,intervalUnit,repeatInterval);\n}\n", "nl": "<p> Create a <code>DailyTimeIntervalTrigger</code> that will occur at the given time, and repeat at the the given interval until the given end time. </p>"}
{"code": "public Vector3f reflect(Vector3fc normal){\n  float dot=this.dot(normal);\n  x=x - (dot + dot) * normal.x();\n  y=y - (dot + dot) * normal.y();\n  z=z - (dot + dot) * normal.z();\n  return this;\n}\n", "nl": "Reflect this vector about the given <code>normal</code> vector."}
{"code": "public Name(String name) throws IOException {\n  rdn=new DNParser(name).parse();\n}\n", "nl": "Creates new <code>Name</code> instance"}
{"code": "@Override public boolean request(int interruptNumber){\n  int imcSection=getRequestImcSection(interruptNumber);\n  int il=getRequestLevel(interruptNumber);\n  if (isImcDmSet(imcSection)) {\n    dreqflg=Format.clearBit(dreqflg,il);\n    ((TxDmaController)platform.getDmaController()).getChannel(il).startTransferIfConditionsOk();\n    return true;\n  }\n else {\n    if (il > 0) {\n      return request(new TxInterruptRequest(Type.HARDWARE_INTERRUPT,interruptNumber,il));\n    }\n else {\n      return false;\n    }\n  }\n}\n", "nl": "Request a hardware interrupt with the given number"}
{"code": "private int match(final int[] list,final int value){\n  for (int i=0; i < list.length; i++) {\n    if (value == list[i])     return i;\n  }\n  return -1;\n}\n", "nl": "Returns the index of the first element equals to a specific value-"}
{"code": "private List<ItemDTO> mockBaseItemWith2Key1Comment1Blank(){\n  ItemDTO i1=new ItemDTO(\"\",\"\",\"#qqqq\",1);\n  ItemDTO i2=new ItemDTO(\"a\",\"b\",\"\",2);\n  ItemDTO i3=new ItemDTO(\"\",\"\",\"\",3);\n  ItemDTO i4=new ItemDTO(\"b\",\"c\",\"\",4);\n  i4.setLineNum(4);\n  return Arrays.asList(i1,i2,i3,i4);\n}\n", "nl": "#qqqq a=b b=c"}
{"code": "public String checkAcceptanceChangeable(final DigestURL url,final CrawlProfile profile,final int depth){\n  final String urlProtocol=url.getProtocol();\n  final String urlstring=url.toNormalform(true);\n  if (!Switchboard.getSwitchboard().loader.isSupportedProtocol(urlProtocol)) {\n    CrawlStacker.log.severe(\"Unsupported protocol in URL '\" + urlstring + \"'.\");\n    return \"unsupported protocol\";\n  }\n  final String urlRejectReason=urlInAcceptedDomain(url);\n  if (urlRejectReason != null) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"denied_(\" + urlRejectReason + \")\");\n    return \"denied_(\" + urlRejectReason + \")\";\n  }\n  if (Switchboard.urlBlacklist.isListed(BlacklistType.CRAWLER,url)) {\n    CrawlStacker.log.fine(\"URL '\" + urlstring + \"' is in blacklist.\");\n    return \"url in blacklist\";\n  }\n  if ((depth > 0) && !profile.urlMustMatchPattern().matcher(urlstring).matches()) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"URL '\" + urlstring + \"' does not match must-match crawling filter '\"+ profile.urlMustMatchPattern().toString()+ \"'.\");\n    return ERROR_NO_MATCH_MUST_MATCH_FILTER + profile.urlMustMatchPattern().toString();\n  }\n  if ((depth > 0) && profile.urlMustNotMatchPattern().matcher(urlstring).matches()) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"URL '\" + urlstring + \"' matches must-not-match crawling filter '\"+ profile.urlMustNotMatchPattern().toString()+ \"'.\");\n    return ERROR_MATCH_WITH_MUST_NOT_MATCH_FILTER + profile.urlMustNotMatchPattern().toString();\n  }\n  if (url.isIndividual() && !profile.crawlingQ()) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"URL '\" + urlstring + \"' is CGI URL.\");\n    return \"individual url (sessionid etc) not wanted\";\n  }\n  if (url.isPOST() && !profile.crawlingQ()) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"URL '\" + urlstring + \"' is post URL.\");\n    return \"post url not allowed\";\n  }\n  if ((depth > 0) && profile.ipMustMatchPattern() != CrawlProfile.MATCH_ALL_PATTERN && url.getHost() != null && !profile.ipMustMatchPattern().matcher(url.getInetAddress().getHostAddress()).matches()) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"IP \" + url.getInetAddress().getHostAddress() + \" of URL '\"+ urlstring+ \"' does not match must-match crawling filter '\"+ profile.ipMustMatchPattern().toString()+ \"'.\");\n    return \"ip \" + url.getInetAddress().getHostAddress() + \" of url does not match must-match filter\";\n  }\n  if ((depth > 0) && profile.ipMustNotMatchPattern() != CrawlProfile.MATCH_NEVER_PATTERN && url.getHost() != null && profile.ipMustNotMatchPattern().matcher(url.getInetAddress().getHostAddress()).matches()) {\n    if (CrawlStacker.log.isFine())     CrawlStacker.log.fine(\"IP \" + url.getInetAddress().getHostAddress() + \" of URL '\"+ urlstring+ \"' matches must-not-match crawling filter '\"+ profile.ipMustNotMatchPattern().toString()+ \"'.\");\n    return \"ip \" + url.getInetAddress().getHostAddress() + \" of url matches must-not-match filter\";\n  }\n  final String[] countryMatchList=profile.countryMustMatchList();\n  if (depth > 0 && countryMatchList != null && countryMatchList.length > 0) {\n    final Locale locale=url.getLocale();\n    if (locale != null) {\n      final String c0=locale.getCountry();\n      boolean granted=false;\n      matchloop:       for (      final String c : countryMatchList) {\n        if (c0.equals(c)) {\n          granted=true;\n          break matchloop;\n        }\n      }\n      if (!granted) {\n        if (CrawlStacker.log.isFine())         CrawlStacker.log.fine(\"IP \" + url.getInetAddress().getHostAddress() + \" of URL '\"+ urlstring+ \"' does not match must-match crawling filter '\"+ profile.ipMustMatchPattern().toString()+ \"'.\");\n        return \"country \" + c0 + \" of url does not match must-match filter for countries\";\n      }\n    }\n  }\n  return null;\n}\n", "nl": "Test if an url shall be accepted using attributes that are defined by a crawl start but can be changed during a crawl."}
{"code": "public WriterToUTF8Buffered(OutputStream out){\n  m_os=out;\n  m_outputBytes=new byte[BYTES_MAX + 3];\n  m_inputChars=new char[CHARS_MAX + 2];\n  count=0;\n}\n", "nl": "Create an buffered UTF-8 writer."}
{"code": "protected boolean matches(JavaModelStatus status,int mask){\n  int severityMask=mask & 0x7;\n  int categoryMask=mask & ~0x7;\n  int bits=status.getBits();\n  return ((severityMask == 0) || (bits & severityMask) != 0) && ((categoryMask == 0) || (bits & categoryMask) != 0);\n}\n", "nl": "Helper for matches(int)."}
{"code": "public IndexMap(Map<Integer,E> map){\n  this.array=new Object[map.size()];\n  putAll(map);\n}\n", "nl": "Creates a new IntArrayMap that contains the keys-values pairs of the given map."}
{"code": "public void remove(Track track){\n  if (_tracks.contains(track)) {\n    int oldSize=_tracks.size();\n    _tracks.remove(track);\n    this.propertyChangeSupport.firePropertyChange(LISTCHANGE_CHANGED_PROPERTY,Integer.valueOf(oldSize),Integer.valueOf(_tracks.size()));\n  }\n}\n", "nl": "Removes a track from this pool"}
{"code": "public static void main(String[] args) throws Exception {\n  try {\n    int exitCode=ToolRunner.run(new RedisExportJob(),args);\n    System.exit(exitCode);\n  }\n catch (  Exception e) {\n    System.err.println(e.getMessage());\n  }\n}\n", "nl": "The entry point when called from the command line."}
{"code": "public static void showAlert(Context context,CharSequence title,CharSequence msg,CharSequence ok,DialogInterface.OnClickListener lOk){\n  AlertDialog dialog=buildAlert(context,title,msg,ok,null,lOk,null);\n  if (dialog != null) {\n    dialog.show();\n  }\n}\n", "nl": "show an system default alert dialog with given title, msg, ok, cancal, listeners"}
{"code": "public void close(){\n  if (mBluetoothGatt == null) {\n    return;\n  }\n  mBluetoothGatt.close();\n  mBluetoothGatt=null;\n}\n", "nl": "After using a given BLE device, the app must call this method to ensure resources are released properly."}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:59:59.514 -0500\",hash_original_method=\"DBB4EF5840B4656B4D7CD7498EF1A157\",hash_generated_method=\"B5D6BEEE5C50711516C06A63C9884CAB\") private static boolean matchIpAddress(X509Certificate certificate,String thisDomain){\n  if (LOG_ENABLED) {\n    Log.v(TAG,\"DomainNameValidator.matchIpAddress(): this domain: \" + thisDomain);\n  }\n  try {\n    Collection subjectAltNames=certificate.getSubjectAlternativeNames();\n    if (subjectAltNames != null) {\n      Iterator i=subjectAltNames.iterator();\n      while (i.hasNext()) {\n        List altNameEntry=(List)(i.next());\n        if (altNameEntry != null && 2 <= altNameEntry.size()) {\n          Integer altNameType=(Integer)(altNameEntry.get(0));\n          if (altNameType != null) {\n            if (altNameType.intValue() == ALT_IPA_NAME) {\n              String altName=(String)(altNameEntry.get(1));\n              if (altName != null) {\n                if (LOG_ENABLED) {\n                  Log.v(TAG,\"alternative IP: \" + altName);\n                }\n                if (thisDomain.equalsIgnoreCase(altName)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n catch (  CertificateParsingException e) {\n  }\n  return false;\n}\n", "nl": "Checks the site certificate against the IP domain name of the site being visited"}
{"code": "public static void main(String[] args){\n  LeadingSpaces tester=new LeadingSpaces();\n  run(tester,ARGS,TEST,NEGATED_TEST);\n  tester.printSummary();\n}\n", "nl": "The entry point of the test."}
{"code": "protected DMLYarnClient(String dmlScriptStr,DMLConfig conf,String[] args){\n  _dmlScript=dmlScriptStr;\n  _dmlConfig=conf;\n  _args=args;\n}\n", "nl": "Protected since only supposed to be accessed via proxy in same package. This is to ensure robustness in case of missing yarn libraries."}
{"code": "public boolean isIndependent(Node xVar,Node yVar,List<Node> zList){\n  if (zList == null) {\n    throw new NullPointerException();\n  }\n  for (  Node node : zList) {\n    if (node == null) {\n      throw new NullPointerException();\n    }\n  }\n  List<Node> regressors=new ArrayList<>();\n  regressors.add(dataSet.getVariable(yVar.getName()));\n  for (  Node zVar : zList) {\n    regressors.add(dataSet.getVariable(zVar.getName()));\n  }\n  Regression regression=new RegressionDataset(dataSet);\n  RegressionResult result=null;\n  try {\n    result=regression.regress(xVar,regressors);\n  }\n catch (  Exception e) {\n    return false;\n  }\n  double p=result.getP()[1];\n  boolean independent=p > alpha;\n  if (verbose) {\n    if (independent) {\n      TetradLogger.getInstance().log(\"independencies\",SearchLogUtils.independenceFactMsg(xVar,yVar,zList,p));\n    }\n else {\n      TetradLogger.getInstance().log(\"dependencies\",SearchLogUtils.dependenceFactMsg(xVar,yVar,zList,p));\n    }\n  }\n  return independent;\n}\n", "nl": "Determines whether variable x is independent of variable y given a list of conditioning variables z."}
{"code": "@Override public String addStepsVcenterClusterCleanup(Workflow workflow,String waitFor,URI clusterId) throws InternalException {\n  Cluster cluster=_dbClient.queryObject(Cluster.class,clusterId);\n  if (NullColumnValueGetter.isNullURI(cluster.getVcenterDataCenter())) {\n    log.info(\"cluster is not synced to vcenter\");\n    return waitFor;\n  }\n  boolean hasDiscoveredHosts=false;\n  boolean hasProvisionedHosts=false;\n  List<URI> clusterHosts=ComputeSystemHelper.getChildrenUris(_dbClient,clusterId,Host.class,\"cluster\");\n  List<Host> hosts=_dbClient.queryObject(Host.class,clusterHosts);\n  for (  Host host : hosts) {\n    if (NullColumnValueGetter.isNullURI(host.getComputeElement())) {\n      hasDiscoveredHosts=true;\n    }\n else {\n      hasProvisionedHosts=true;\n    }\n  }\n  log.info(\"cluster has provisioned hosts: {}, and discovered hosts: {}\",hasProvisionedHosts,hasDiscoveredHosts);\n  if (hasProvisionedHosts) {\n    waitFor=workflow.createStep(CHECK_CLUSTER_VMS,\"If synced with vCenter, check if there are VMs in the cluster\",waitFor,clusterId,clusterId.toString(),this.getClass(),new Workflow.Method(\"checkClusterVms\",cluster.getId(),cluster.getVcenterDataCenter()),null,null);\n  }\n  if (hasProvisionedHosts && !hasDiscoveredHosts) {\n    waitFor=workflow.createStep(REMOVE_VCENTER_CLUSTER,\"If synced with vCenter, remove the cluster\",waitFor,clusterId,clusterId.toString(),this.getClass(),new Workflow.Method(\"removeVcenterCluster\",cluster.getId(),cluster.getVcenterDataCenter()),null,null);\n  }\n  return waitFor;\n}\n", "nl": "A cluster could have only discovered hosts, only provisioned hosts, or mixed. If cluster has only provisioned hosts, then the hosts will be deleted from vCenter. If cluster has only discovered hosts, then the hosts will not be deleted from vCenter. If cluster is mixed, then the hosts will not be deleted from the vCenter; however, the provisioned hosts will still be decommissioned, and their state in vCenter will be \"disconnected\". If a cluster is provisioned or mixed, then check VMs step will be executed since hosts with running VMs may endup decommissioned."}
{"code": "private static int subAndCheck(final int x,final int y){\n  final long s=(long)x - (long)y;\n  if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n    throw new ArithmeticException(\"overflow: add\");\n  }\n  return (int)s;\n}\n", "nl": "Subtract two integers, checking for overflow."}
{"code": "public boolean isRangeZeroBaselineVisible(){\n  return this.rangeZeroBaselineVisible;\n}\n", "nl": "Returns a flag that controls whether or not a zero baseline is displayed for the range axis."}
{"code": "@Override public boolean shouldDelayChildPressedState(){\n  return false;\n}\n", "nl": "ViewPager inherits ViewGroup's default behavior of delayed clicks on its children, but in order to make the calc buttons more responsive we disable that here."}
{"code": "private void dialogChanged(){\n  errorMsg=validateInputs();\n  updateStatus(errorMsg);\n}\n", "nl": "Ensures that both text fields are set."}
{"code": "public static void main(String[] argv){\n  try {\n    Evaluation.runExperiment((MultiLabelClassifier)new WvARAM(),argv);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    System.err.println(e.getMessage());\n  }\n}\n", "nl": "Main method for testing this class."}
{"code": "public void seekN(int n){\n  pos+=n;\n}\n", "nl": "Skip n chars ahead."}
{"code": "@Override public void updateBlob(String columnLabel,InputStream x,long length) throws SQLException {\n  try {\n    if (isDebugEnabled()) {\n      debugCode(\"updateBlob(\" + quote(columnLabel) + \", x, \"+ length+ \"L);\");\n    }\n    checkClosed();\n    Value v=conn.createBlob(x,-1);\n    update(columnLabel,v);\n  }\n catch (  Exception e) {\n    throw logAndConvert(e);\n  }\n}\n", "nl": "Updates a column in the current or insert row."}
{"code": "public static void previous(final IdocApplet ui){\n  FileVO ele=(FileVO)ui.getFileVO();\n  if (ele.getImageSelectIndex() - 1 < 0) {\n    ele.setImageSelectIndex(ele.getListImage().size() - 1);\n  }\n else {\n    ele.setImageSelectIndex(ele.getImageSelectIndex() - 1);\n  }\n}\n", "nl": "Muestra la imagen anterior en el applet"}
{"code": "public static void registerMetadata(MetadataRegistry registry){\n  if (registry.isRegistered(KEY)) {\n    return;\n  }\n  ElementCreator builder=registry.build(KEY);\n  builder.addAttribute(NAME).setRequired(true);\n  builder.addAttribute(TYPE);\n  builder.addAttribute(UNIT);\n}\n", "nl": "Registers the metadata for this element."}
{"code": "private static int testSwitchingTwoWays(){\n  int failures=0;\n  for (  MetaSynVar msv : MetaSynVar.values()) {\n    int enumResult=enumSwitch(msv);\n    int stringResult=stringSwitch(msv.name());\n    if (enumResult != stringResult) {\n      failures++;\n      System.err.printf(\"One value %s, computed 0x%x with the enum switch \" + \"and 0x%x with the string one.%n\",msv,enumResult,stringResult);\n    }\n  }\n  return failures;\n}\n", "nl": "Verify that a switch on an enum and a switch with the same structure on the string name of an enum compute equivalent values."}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:19.993 -0500\",hash_original_method=\"D1AF4635F236F26EDAA4AC997AD8C09A\",hash_generated_method=\"2288A665FEBE4EF35DE6B0C0BF9BCD7C\") public static String valueOf(long value){\n  String str=new String();\n  str.addTaint(value);\n  return str;\n}\n", "nl": "Converts the specified long to its string representation."}
{"code": "private ExternalSaslClient(String authorizationId,String protocol,String serverName,Map props,CallbackHandler cbh){\n  m_authorizationId=authorizationId;\n  m_protocol=protocol;\n  m_serverName=serverName;\n  m_props=props;\n  m_cbh=cbh;\n  m_state=STATE_INITIAL;\n}\n", "nl": "Creates an ExternalSaslClient object using the parameters supplied. Assumes that the QOP, STRENGTH, and SERVER_AUTH properties are contained in props"}
{"code": "public double scaleValue(double value){\n  if (logarithm) {\n    value=Math.log(value);\n  }\n  double min=getMinValue();\n  double max=getMaxValue();\n  return ((value - min) / (max - min));\n}\n", "nl": "Scales the value to a range 0,1 based on the current settings"}
{"code": "public static double product(int size,double sumOfLogarithms){\n  return Math.pow(Math.exp(sumOfLogarithms / size),size);\n}\n", "nl": "Returns the product, which is <tt>Prod( data[i] )</tt>. In other words: <tt>data[0]*data[1]*...*data[data.size()-1]</tt>. This method uses the equivalent definition: <tt>prod = pow( exp( Sum( Log(x[i]) ) / size(), size())</tt>."}
{"code": "public void enableRotation(final boolean enable){\n  mRotationEnabled=enable;\n  if (!mRotationEnabled) {\n    mListRotation=0;\n  }\n  invalidate();\n}\n", "nl": "Enables and disables individual rotation of the items."}
{"code": "public void start(){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Start the IMS module\");\n  }\n  mCnxManager.start();\n  mExtensionManager.start();\n  mServiceDispatcher.start();\n  mCallManager.start();\n  if (sLogger.isActivated()) {\n    sLogger.info(\"IMS module is started\");\n  }\n}\n", "nl": "Start the IMS module"}
{"code": "public static Text valueOf(char c,int length){\n  if (length < 0)   throw new IndexOutOfBoundsException();\n  if (length <= BLOCK_SIZE) {\n    Text text=Text.newPrimitive(length);\n    for (int i=0; i < length; ) {\n      text._data[i++]=c;\n    }\n    return text;\n  }\n else {\n    final int middle=(length >> 1);\n    return Text.newComposite(Text.valueOf(c,middle),Text.valueOf(c,length - middle));\n  }\n}\n", "nl": "Returns the text that contains a specific length sequence of the character specified."}
{"code": "public ByteList MethodInfo(ByteList bytes,int param_count,int return_type,IntList param_types,IntList param_values,ByteList param_kinds,IntList param_names,int debug_name_index,int flags,int method_info_index){\n  if (show_bytecode) {\n    defns_out.write(\"\\n      MethodInfo \");\n    defns_out.write(\" param_count=\" + param_count);\n    defns_out.write(\" return_type=\" + return_type + \" param_types={ \");\n    for (int i=0, size=param_types == null ? 0 : param_types.size(); i < size; i++) {\n      defns_out.write(param_types.get(i) + \" \");\n    }\n    defns_out.write(\"} debug_name_index=\" + debug_name_index + \" needs_arguments=\"+ ((flags & METHOD_Arguments) != 0 ? \"true\" : \"false\")+ \" need_rest=\"+ ((flags & METHOD_Needrest) != 0 ? \"true\" : \"false\")+ \" needs_activation=\"+ ((flags & METHOD_Activation) != 0 ? \"true\" : \"false\")+ \" has_optional=\"+ ((flags & METHOD_HasOptional) != 0 ? \"true\" : \"false\")+ \" ignore_rest=\"+ ((flags & METHOD_IgnoreRest) != 0 ? \"true\" : \"false\")+ \" native=\"+ ((flags & METHOD_Native) != 0 ? \"true\" : \"false\")+ \" has_param_names =\"+ ((flags & METHOD_HasParamNames) != 0 ? \"true\" : \"false\"));\n    if ((flags & METHOD_HasOptional) != 0) {\n      defns_out.write(\" optional_count=\" + param_values.size());\n      defns_out.write(\" optional_indexes={ \");\n      for (int i=0, size=param_values == null ? 0 : param_values.size(); i < size; i++) {\n        defns_out.write(\" \" + param_values.get(i));\n      }\n      defns_out.write(\" }\");\n      defns_out.write(\" optional_kinds={ \");\n      for (int i=0, size=param_values == null ? 0 : param_values.size(); i < size; i++) {\n        defns_out.write(\" \" + param_kinds.get(i));\n      }\n      defns_out.write(\" }\");\n    }\n    if ((flags & METHOD_HasParamNames) != 0) {\n      defns_out.write(\" param_names={ \");\n      for (int i=0, size=param_names == null ? 0 : param_names.size(); i < size; i++) {\n        defns_out.write(\" \" + param_names.get(i));\n      }\n      defns_out.write(\" }\");\n    }\n    defns_out.write(\" -> \" + method_info_index);\n  }\n  if (debug) {\n    System.out.print(\"\\n      bytes.size() = \" + bytes.size());\n  }\n  Int(bytes,param_count);\n  Int(bytes,return_type);\n  for (int i=0; i < param_count; i++) {\n    Int(bytes,param_types.get(i));\n  }\n  Int(bytes,debug_name_index);\n  Byte(bytes,flags);\n  if ((flags & METHOD_HasOptional) != 0) {\n    Int(bytes,param_values.size());\n    for (int i=0, n=param_values.size(); i < n; i++) {\n      Int(bytes,param_values.get(i));\n      bytes.add(param_kinds.get(i));\n    }\n  }\n  if ((flags & METHOD_HasParamNames) != 0) {\n    for (int i=0; i < param_count; i++) {\n      Int(bytes,param_names.get(i));\n    }\n  }\n  return bytes;\n}\n", "nl": "Make a MethodInfo"}
{"code": "public RSAAgentConfig(RSAAMInstanceInfo instInfo){\n  Validate.notNull(instInfo,\"RSAAMInstanceInfo\");\n  this.get_instMap().put(instInfo.get_siteID(),instInfo);\n}\n", "nl": "Minimum ctor with required attributes only"}
{"code": "public boolean intersects(Vector3D other){\n  return other.getX() >= this.min.getX() && other.getX() < this.max.getX() ? (other.getY() >= this.min.getY() && other.getY() < this.max.getY() ? other.getZ() >= this.min.getZ() && other.getZ() < this.max.getZ() : false) : false;\n}\n", "nl": "Checks if a vector is within this cuboid."}
{"code": "public boolean hasValue(){\n  return getValue() != null;\n}\n", "nl": "Returns whether it has the number of times calendar was cleaned."}
{"code": "protected synchronized void expandBufferSizes(){\n  acceptLargeFragments=true;\n}\n", "nl": "Expand the buffer size of both SSL/TLS network packet and application data."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  Agent q=(Agent)stack.pop();\n  Agent a=(Agent)stack.pop();\n  if (Permissions.hasPermission(Permissions.PERMISSION_RECORDINGSCHEDULE,stack.getUIMgr()))   Carny.getInstance().createPriority(a,q);\n  return null;\n}\n", "nl": "Establishes a priority of one Favorite over another. This will take undo any previous prioritization that it directly conflicts with. Favorites with a higher priority will be recorded over ones with a lower priority if there's a case where both cannot be recorded at once."}
{"code": "private void close(T stream){\n  try {\n    stream.close();\n  }\n catch (  IOException e) {\n    logger.warn(\"Unable to close intercepted stream: {}\",e.getMessage());\n    logger.debug(\"I/O error prevented closure of intercepted stream.\",e);\n  }\nsynchronized (stream) {\n    stream.notify();\n  }\n}\n", "nl": "Closes the given stream, logging any errors that occur during closure. The monitor of the stream is notified via a single call to notify() once the attempt to close has been made."}
{"code": "protected int selectOperator(){\n  lastUpdate++;\n  if ((lastUpdate >= UPDATE_WINDOW) || (probabilities == null)) {\n    lastUpdate=0;\n    probabilities=getOperatorProbabilities();\n  }\n  double rand=PRNG.nextDouble();\n  double sum=0.0;\n  for (int i=0; i < operators.size(); i++) {\n    sum+=probabilities[i];\n    if (sum > rand) {\n      return i;\n    }\n  }\n  throw new IllegalStateException();\n}\n", "nl": "Returns the index of one of the available operators randomly selected using the probabilities."}
{"code": "private void verifyPluginToAdd(final IPlugin<IPluginInterface> plugin){\n  Preconditions.checkNotNull(plugin,\"IE00835: Plugin can't be null\");\n  if ((plugin.getName() == null) || plugin.getName().equals(\"\")) {\n    throw new IllegalArgumentException(\"IE00836: Invalid plugin name\");\n  }\n  if (plugin.getGuid() == 0) {\n    throw new IllegalArgumentException(\"IE00837: Invalid plugin GUID\");\n  }\n  for (  final IPlugin<IPluginInterface> oldPlugin : plugins) {\n    if (oldPlugin == plugin) {\n      throw new IllegalArgumentException(\"IE00838: Can not add plugin more than once\");\n    }\n    if (oldPlugin.getGuid() == plugin.getGuid()) {\n      throw new IllegalArgumentException(\"IE00839: Plugin with GUID \" + plugin.getGuid() + \" already exists\");\n    }\n  }\n}\n", "nl": "Verifies the validity of the plugin object to add to the registry. If the plugin is not as expected, throw an exception."}
{"code": "public void shutdown() throws Exception {\n  (new Thread(this,\"NestedActivate\")).start();\n  if (obj != null)   obj.shutdown();\n}\n", "nl": "Spawns a thread to deactivate the object."}
{"code": "@Override public ExampleSet createExampleSet(){\n  return createExampleSet(Collections.<Attribute,String>emptyMap());\n}\n", "nl": "Returns a new example set with all attributes switched on. All attributes given at creation time will be regular."}
{"code": "public Enumeration<AclEntry> entries(){\n  return acl.entries();\n}\n", "nl": "Returns an enumeration of the entries in this ACL. Each element in the enumeration is of type <CODE>java.security.acl.AclEntry</CODE>."}
{"code": "public void fsync(Result<Boolean> result) throws IOException {\n  SegmentStream nodeStream=_nodeStream;\n  if (nodeStream != null) {\n    nodeStream.fsync(result);\n  }\n else {\n    result.ok(true);\n  }\n}\n", "nl": "sync the output stream with the filesystem when possible."}
{"code": "public static BufferedImage loadCompatibleImage(URL resource) throws IOException {\n  BufferedImage image=ImageIO.read(resource);\n  return toCompatibleImage(image);\n}\n", "nl": "<p>Returns a new compatible image from a URL. The image is loaded from the specified location and then turned, if necessary into a compatible image.</p>"}
{"code": "public synchronized void removeTextListener(TextListener cl){\n  m_textListeners.remove(cl);\n}\n", "nl": "Remove a text listener"}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public static ChatMessage createChatMessage(String msgId,String apiMimeType,String content,ContactId contact,String displayName,long timestamp,long timestampSent){\n  if (MimeType.TEXT_MESSAGE.equals(apiMimeType)) {\n    return new ChatMessage(msgId,contact,content,MimeType.TEXT_MESSAGE,timestamp,timestampSent,displayName);\n  }\n else   if (MimeType.GEOLOC_MESSAGE.equals(apiMimeType)) {\n    return new ChatMessage(msgId,contact,content,MimeType.GEOLOC_MESSAGE,timestamp,timestampSent,displayName);\n  }\n  throw new IllegalArgumentException(\"Unable to create message, Invalid mimetype \" + apiMimeType);\n}\n", "nl": "Create a chat message either text or geolocation."}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase ExpressionsPackage.LOGICAL_OR_EXPRESSION__LEFT_OPERAND:\n    setLeftOperand((Expression)null);\n  return;\ncase ExpressionsPackage.LOGICAL_OR_EXPRESSION__RIGHT_OPERAND:\nsetRightOperand((Expression)null);\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private boolean inBounds(final int x,final int y){\n  return x >= 0 && x < m_bufferedImage.getWidth(null) && y >= 0 && y < m_bufferedImage.getHeight(null);\n}\n", "nl": "java.lang.boolean inBounds(java.lang.int, java.lang.int) Checks if the given x/y coordinate point is inbounds or not"}
{"code": "private void trace(){\n  glUseProgram(computeProgram);\n  if (mouseDown) {\n    currRotationAboutY=rotationAboutY + (mouseX - mouseDownX) * 0.01f;\n  }\n else {\n    currRotationAboutY=rotationAboutY;\n  }\n  cameraPosition.set((float)sin(-currRotationAboutY) * 3.0f,2.0f,(float)cos(-currRotationAboutY) * 3.0f);\n  viewMatrix.setLookAt(cameraPosition,cameraLookAt,cameraUp);\n  if (resetFramebuffer) {\n    projMatrix.setPerspective((float)Math.toRadians(60.0f),(float)width / height,1f,2f);\n    resizeFramebufferTexture();\n    resetFramebuffer=false;\n  }\n  projMatrix.invertPerspectiveView(viewMatrix,invViewProjMatrix);\n  glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER,0,atomicBuffer);\n  intBuffer.put(0,(int)System.nanoTime());\n  glBufferSubData(GL_ATOMIC_COUNTER_BUFFER,0,intBuffer);\n  float blendFactor=frameNumber / (frameNumber + 1.0f);\n  glUniform1f(blendFactorUniform,blendFactor);\n  glUniform1i(bounceCountUniform,bounceCount);\n  glUniform3f(eyeUniform,cameraPosition.x,cameraPosition.y,cameraPosition.z);\n  invViewProjMatrix.transformProject(tmpVector.set(-1,-1,0)).sub(cameraPosition);\n  glUniform3f(ray00Uniform,tmpVector.x,tmpVector.y,tmpVector.z);\n  invViewProjMatrix.transformProject(tmpVector.set(-1,1,0)).sub(cameraPosition);\n  glUniform3f(ray01Uniform,tmpVector.x,tmpVector.y,tmpVector.z);\n  invViewProjMatrix.transformProject(tmpVector.set(1,-1,0)).sub(cameraPosition);\n  glUniform3f(ray10Uniform,tmpVector.x,tmpVector.y,tmpVector.z);\n  invViewProjMatrix.transformProject(tmpVector.set(1,1,0)).sub(cameraPosition);\n  glUniform3f(ray11Uniform,tmpVector.x,tmpVector.y,tmpVector.z);\n  glBindImageTexture(framebufferImageBinding,tex,0,false,0,GL_READ_WRITE,GL_RGBA32F);\n  int worksizeX=mathRoundPoT(width);\n  int worksizeY=mathRoundPoT(height);\n  glDispatchCompute(worksizeX / workGroupSizeX,worksizeY / workGroupSizeY,1);\n  glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);\n  glBindImageTexture(framebufferImageBinding,0,0,false,0,GL_READ_WRITE,GL_RGBA32F);\n  glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER,0,0);\n  glUseProgram(0);\n  frameNumber++;\n}\n", "nl": "Compute one frame by tracing the scene using our compute shader and presenting that image on the screen."}
{"code": "public DirtyFlagMap(final int initialCapacity,final float loadFactor){\n  map=new HashMap<K,V>(initialCapacity,loadFactor);\n}\n", "nl": "<p> Create a DirtyFlagMap that 'wraps' a <code>HashMap</code> that has the given initial capacity and load factor. </p>"}
{"code": "LWComponentPeer<?,?> findPeerAt(final int x,final int y){\n  final Rectangle r=getBounds();\n  final Region sh=getRegion();\n  final boolean found=isVisible() && sh.contains(x - r.x,y - r.y);\n  return found ? this : null;\n}\n", "nl": "Finds a top-most visible component for the given point. The location is specified relative to the peer's parent."}
{"code": "public void onCreate(Bundle savedInstanceState){\n  mSlidingMenu=(SlidingMenu)LayoutInflater.from(mActivity).inflate(R.layout.slidingmenumain,null);\n}\n", "nl": "Sets mSlidingMenu as a newly inflated SlidingMenu. Should be called within the activitiy's onCreate()"}
{"code": "@Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase UmplePackage.ANONYMOUS_CONSTANT_DECLARATION_1__LIST_1:\n    setList_1((Boolean)newValue);\n  return;\ncase UmplePackage.ANONYMOUS_CONSTANT_DECLARATION_1__NAME_1:\nsetName_1((String)newValue);\nreturn;\ncase UmplePackage.ANONYMOUS_CONSTANT_DECLARATION_1__TYPE_1:\nsetType_1((String)newValue);\nreturn;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "final public static float[] earthCircle(float phi1,float lambda0,float c,int n,float[] ret_val){\n  return earthCircle(phi1,lambda0,c,0.0f,MoreMath.TWO_PI,n,ret_val);\n}\n", "nl": "Calculate earth circle in the sphere. <p> Returns n float lat,lon pairs at arc distance c from point at phi1,lambda0. <p>"}
{"code": "public boolean isExplicit(){\n  return kind.isExplicit();\n}\n", "nl": "Returns true if the call is due to an explicit invoke statement."}
{"code": "private void enableProgressBarView(boolean aIsProgressBarDisplayed){\n  if (null != mProgressBarView) {\n    mProgressBarView.setVisibility(aIsProgressBarDisplayed ? View.VISIBLE : View.GONE);\n  }\n}\n", "nl": "Helper method to enable/disable the progress bar view used when a remote server action is on progress."}
{"code": "public void putString(String s){\n  ensureCapacity((s.length() * 2) + 1);\n  System.arraycopy(s.getBytes(),0,this.byteBuffer,this.position,s.length());\n  this.position+=s.length();\n  this.byteBuffer[this.position++]=0;\n}\n", "nl": "Put a string in the buffer."}
{"code": "public int read() throws IOException {\n  return checkInputFile().read();\n}\n", "nl": "Read from the file."}
{"code": "public AndroidAuthenticator(Context context,Account account,String authTokenType,boolean notifyAuthFailure){\n  this(AccountManager.get(context),account,authTokenType,notifyAuthFailure);\n}\n", "nl": "Creates a new authenticator."}
{"code": "public ConsoleDocument(){\n}\n", "nl": "Creates an empty console document."}
{"code": "private void readFrameRemainder(ParsableByteArray source){\n  int bytesToRead=Math.min(source.bytesLeft(),frameSize - frameBytesRead);\n  output.sampleData(source,bytesToRead);\n  frameBytesRead+=bytesToRead;\n  if (frameBytesRead < frameSize) {\n    return;\n  }\n  output.sampleMetadata(timeUs,C.SAMPLE_FLAG_SYNC,frameSize,0,null);\n  timeUs+=frameDurationUs;\n  frameBytesRead=0;\n  state=STATE_FINDING_HEADER;\n}\n", "nl": "Attempts to read the remainder of the frame. <p> If a frame is read in full then true is returned. The frame will have been output, and the position of the source will have been advanced to the byte that immediately follows the end of the frame. <p> If a frame is not read in full then the position of the source will have been advanced to the limit, and the method should be called again with the next source to continue the read."}
{"code": "public Lucene50CompoundReader(Directory directory,SegmentInfo si,IOContext context) throws IOException {\n  this.directory=directory;\n  this.segmentName=si.name;\n  String dataFileName=IndexFileNames.segmentFileName(segmentName,\"\",Lucene50CompoundFormat.DATA_EXTENSION);\n  String entriesFileName=IndexFileNames.segmentFileName(segmentName,\"\",Lucene50CompoundFormat.ENTRIES_EXTENSION);\n  this.entries=readEntries(si.getId(),directory,entriesFileName);\n  boolean success=false;\n  long expectedLength=CodecUtil.indexHeaderLength(Lucene50CompoundFormat.DATA_CODEC,\"\");\n  for (  Map.Entry<String,FileEntry> ent : entries.entrySet()) {\n    expectedLength+=ent.getValue().length;\n  }\n  expectedLength+=CodecUtil.footerLength();\n  handle=directory.openInput(dataFileName,context);\n  try {\n    CodecUtil.checkIndexHeader(handle,Lucene50CompoundFormat.DATA_CODEC,version,version,si.getId(),\"\");\n    CodecUtil.retrieveChecksum(handle);\n    if (handle.length() != expectedLength) {\n      throw new CorruptIndexException(\"length should be \" + expectedLength + \" bytes, but is \"+ handle.length()+ \" instead\",handle);\n    }\n    success=true;\n  }\n  finally {\n    if (!success) {\n      IOUtils.closeWhileHandlingException(handle);\n    }\n  }\n}\n", "nl": "Create a new CompoundFileDirectory."}
{"code": "public void writeExif(Bitmap bmap,OutputStream exifOutStream) throws IOException {\n  if (bmap == null || exifOutStream == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=getExifWriterStream(exifOutStream);\n  bmap.compress(Bitmap.CompressFormat.JPEG,90,s);\n  s.flush();\n}\n", "nl": "Writes the tags from this ExifInterface object into a jpeg compressed bitmap, removing prior exif tags."}
{"code": "@Override public String toString(){\n  return String.format(\"Thread (TID: %d)\",getThreadId());\n}\n", "nl": "Returns a string representation of the thread."}
{"code": "public String toString(){\n  StringBuffer buffer=new StringBuffer();\n  buffer.append(\"FlushFdrPage[\");\n  buffer.append(\"fixedValue = \").append(fixedValue);\n  buffer.append(\", className = \").append(className);\n  buffer.append(\", treeId = \").append(treeId);\n  buffer.append(\", pageName = \").append(pageName);\n  buffer.append(\", fatherId = \").append(fatherId);\n  buffer.append(\", fatherClassName = \").append(fatherClassName);\n  buffer.append(\"]\");\n  return buffer.toString();\n}\n", "nl": "toString methode: creates a String representation of the object"}
{"code": "private void ensureCapacity(int newNumStates){\n  int oldLength=epsilon.length;\n  if (newNumStates < oldLength)   return;\n  int newStatesLength=Math.max(oldLength * 2,newNumStates);\n  boolean[] newFinal=new boolean[newStatesLength];\n  boolean[] newIsPush=new boolean[newStatesLength];\n  Action[] newAction=new Action[newStatesLength];\n  StateSet[][] newTable=new StateSet[newStatesLength][numInput];\n  StateSet[] newEpsilon=new StateSet[newStatesLength];\n  System.arraycopy(isFinal,0,newFinal,0,numStates);\n  System.arraycopy(action,0,newAction,0,numStates);\n  System.arraycopy(epsilon,0,newEpsilon,0,numStates);\n  System.arraycopy(table,0,newTable,0,numStates);\n  isFinal=newFinal;\n  action=newAction;\n  epsilon=newEpsilon;\n  table=newTable;\n}\n", "nl": "Make sure the NFA can contain at least newNumStates states."}
{"code": "protected List<TestDiagnostic> readDiagnostics(TestConfiguration config,CompilationResult compilationResult){\n  List<TestDiagnostic> expectedDiagnostics;\n  if (config.getDiagnosticFiles() == null || config.getDiagnosticFiles().isEmpty()) {\n    expectedDiagnostics=JavaDiagnosticReader.readExpectedDiagnosticsJfo(compilationResult.getJavaFileObjects(),true);\n  }\n else {\n    expectedDiagnostics=JavaDiagnosticReader.readDiagnosticFiles(config.getDiagnosticFiles(),true);\n  }\n  return expectedDiagnostics;\n}\n", "nl": "Added in case a subclass wishes to filter out errors or add new expected errors.  This method is called immediately before results are checked."}
{"code": "public static String readFile(String fileName){\n  try {\n    URL resource=TestUtil.class.getClassLoader().getResource(fileName);\n    if (resource == null) {\n      throw new FileNotFoundException(format(\"Could not find the file on classpath: %s\",fileName));\n    }\n    return Resources.toString(resource,Charsets.UTF_8);\n  }\n catch (  IOException e) {\n    throw new IllegalArgumentException(format(\"Error reading file \\\"%s\\\"\",fileName),e);\n  }\n}\n", "nl": "Read a file on the classpath into a string."}
{"code": "public boolean skipPast(String to) throws JSONException {\n  boolean b;\n  char c;\n  int i;\n  int j;\n  int offset=0;\n  int length=to.length();\n  char[] circle=new char[length];\n  for (i=0; i < length; i+=1) {\n    c=next();\n    if (c == 0) {\n      return false;\n    }\n    circle[i]=c;\n  }\n  for (; ; ) {\n    j=offset;\n    b=true;\n    for (i=0; i < length; i+=1) {\n      if (circle[j] != to.charAt(i)) {\n        b=false;\n        break;\n      }\n      j+=1;\n      if (j >= length) {\n        j-=length;\n      }\n    }\n    if (b) {\n      return true;\n    }\n    c=next();\n    if (c == 0) {\n      return false;\n    }\n    circle[offset]=c;\n    offset+=1;\n    if (offset >= length) {\n      offset-=length;\n    }\n  }\n}\n", "nl": "Skip characters until past the requested string. If it is not found, we are left at the end of the source with a result of false."}
{"code": "public void add(Permission permission){\n  if (!(permission instanceof ExecOptionPermission))   throw new IllegalArgumentException(\"invalid permission: \" + permission);\n  if (isReadOnly())   throw new SecurityException(\"attempt to add a Permission to a readonly PermissionCollection\");\n  ExecOptionPermission p=(ExecOptionPermission)permission;\n  permissions.put(p.getName(),permission);\n  if (!all_allowed) {\n    if (p.getName().equals(\"*\"))     all_allowed=true;\n  }\n}\n", "nl": "Adds a permission to the collection. The key for the hash is permission.name."}
{"code": "public boolean isReusable(){\n  if ((socket != null) && (socket instanceof RMISocketInfo))   return ((RMISocketInfo)socket).isReusable();\n else   return true;\n}\n", "nl": "Determine if this connection can be used for multiple operations. If the socket implements RMISocketInfo, then we can query it about this; otherwise, assume that it does provide a full-duplex persistent connection like java.net.Socket."}
{"code": "public ColumnList addCounter(byte[] family,byte[] qualifier,long incr){\n  counters().add(new Counter(family,qualifier,incr));\n  return this;\n}\n", "nl": "Add an HBase counter column."}
{"code": "private final void _writeSegment(int end) throws IOException, JsonGenerationException {\n  final int[] escCodes=CharTypes.getOutputEscapes();\n  final int escLen=escCodes.length;\n  int ptr=0;\n  output_loop:   while (ptr < end) {\n    int start=ptr;\n    while (true) {\n      char c=_outputBuffer[ptr];\n      if (c < escLen && escCodes[c] != 0) {\n        break;\n      }\n      if (++ptr >= end) {\n        break;\n      }\n    }\n    int flushLen=(ptr - start);\n    if (flushLen > 0) {\n      _writer.write(_outputBuffer,start,flushLen);\n      if (ptr >= end) {\n        break output_loop;\n      }\n    }\n{\n      int escCode=escCodes[_outputBuffer[ptr]];\n      ++ptr;\n      int needLen=(escCode < 0) ? 6 : 2;\n      if (needLen > _outputTail) {\n        _writeSingleEscape(escCode);\n      }\n else {\n        ptr-=needLen;\n        _appendSingleEscape(escCode,_outputBuffer,ptr);\n      }\n    }\n  }\n}\n", "nl": "Method called to output textual context which has been copied to the output buffer prior to call. If any escaping is needed, it will also be handled by the method. <p> Note: when called, textual content to write is within output buffer, right after buffered content (if any). That's why only length of that text is passed, as buffer and offset are implied."}
{"code": "private void fillPicks(){\n  String sql=\"SELECT M_PriceList_Version.M_PriceList_Version_ID,\" + \" M_PriceList_Version.Name || ' (' || c.Iso_Code || ')' AS ValueName \" + \"FROM M_PriceList_Version, M_PriceList pl, C_Currency c \"+ \"WHERE M_PriceList_Version.M_PriceList_ID=pl.M_PriceList_ID\"+ \" AND pl.C_Currency_ID=c.C_Currency_ID\"+ \" AND M_PriceList_Version.IsActive='Y' AND pl.IsActive='Y'\";\n  sql=MRole.getDefault().addAccessSQL(sql,\"M_PriceList_Version\",true,false) + \" ORDER BY M_PriceList_Version.Name\";\n  try {\n    pickPriceList.addItem(new KeyNamePair(0,\"\"));\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      KeyNamePair kn=new KeyNamePair(rs.getInt(1),rs.getString(2));\n      pickPriceList.addItem(kn);\n    }\n    rs.close();\n    pstmt.close();\n    sql=\"SELECT M_Warehouse_ID, Value || ' - ' || Name AS ValueName \" + \"FROM M_Warehouse \" + \"WHERE IsActive='Y'\";\n    sql=MRole.getDefault().addAccessSQL(sql,\"M_Warehouse\",MRole.SQL_NOTQUALIFIED,MRole.SQL_RO) + \" ORDER BY Value\";\n    pickWarehouse.addItem(new KeyNamePair(0,\"\"));\n    pstmt=DB.prepareStatement(sql,null);\n    rs=pstmt.executeQuery();\n    while (rs.next()) {\n      KeyNamePair kn=new KeyNamePair(rs.getInt(\"M_Warehouse_ID\"),rs.getString(\"ValueName\"));\n      pickWarehouse.addItem(kn);\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n}\n", "nl": "Fill Picks with values"}
{"code": "public HttpException(){\n  super();\n}\n", "nl": "Creates a new HttpException with a <tt>null</tt> detail message."}
{"code": "static public boolean hasPhoto(Tweet tweet){\n  return getPhotoEntity(tweet) != null;\n}\n", "nl": "Returns true if there is a media entity with the type of \"photo\""}
{"code": "public ScopeContext(String scopeName,Map<String,Object> scope){\n  this.scopeName=scopeName;\n  this.scope=scope;\n}\n", "nl": "<p class=\"changed_added_2_0\">Construct this structure with the supplied arguments.</p>"}
{"code": "public boolean isOK(){\n  return fSeverity == OK;\n}\n", "nl": "Returns whether the status's severity is <code>OK</code> or not."}
{"code": "void waitBeforeNextPoll(int pollingInterval) throws InterruptedException {\nsynchronized (this) {\n    wait(pollingInterval);\n  }\n  if (!pollOutstanding) {\n    return;\n  }\n  log.debug(\"--- extra wait\");\n  for (int i=0; i < 20; i++) {\nsynchronized (this) {\n      wait(pollingInterval / 4);\n    }\n    log.debug(\"-------------extra wait\");\n    if (!pollOutstanding) {\n      return;\n    }\n  }\n}\n", "nl": "Wait before sending next poll. <P> Waits specified time, and then checks to see if response has been returned. If not, it waits again (twice) by 1/2 the interval, then finally polls anyway."}
{"code": "public boolean equivalent(Label other){\n  if (other == null) {\n    return false;\n  }\n  boolean result=true;\n  result&=value.equals(other.getValue());\n  result&=scope.equals(other.getScope());\n  return result;\n}\n", "nl": "A method to determine the equivalence of any two Labels."}
{"code": "private static Map<String,Integer> optionArgDefs(){\n  Map<String,Integer> optionArgDefs=new HashMap<>();\n  optionArgDefs.put(\"annotationsSplit\",0);\n  optionArgDefs.put(\"sourceTokens\",1);\n  optionArgDefs.put(\"targetTokens\",1);\n  optionArgDefs.put(\"alignment\",1);\n  optionArgDefs.put(\"annotations\",1);\n  return optionArgDefs;\n}\n", "nl": "Command-line option specification."}
{"code": "public static ClassInfo[] findOrCreateClass(Class<?>[] l){\n  final ClassInfo[] a=new ClassInfo[l.length];\n  for (int i=0; i < a.length; ++i) {\n    a[i]=findOrCreateClass(l[i]);\n  }\n  return a;\n}\n", "nl": "Find or create a list of class representations"}
{"code": "private boolean existsXmlConversion(Class<?> clazz){\n  return exists(xml.getConversionMethods(clazz));\n}\n", "nl": "Verifies the presence of the xml conversion method in the input class, if found it's returned."}
{"code": "public static void putObject_test4() throws Exception {\n  println(\"Test: putObject(String bucketName, String objectName, String contentType, long size, InputStream body)\");\n  String fileName=createFile(3 * MB);\n  InputStream is=Files.newInputStream(Paths.get(fileName));\n  client.putObject(bucketName,fileName,is,1024 * 1024,customContenType);\n  is.close();\n  Files.delete(Paths.get(fileName));\n  ObjectStat objectStat=client.statObject(bucketName,fileName);\n  if (!customContenType.equals(objectStat.contentType())) {\n    println(\"FAILED\");\n  }\n  client.removeObject(bucketName,fileName);\n}\n", "nl": "Test: putObject(String bucketName, String objectName, String contentType, long size, InputStream body)."}
{"code": "public WorldWindowGLCanvas(WorldWindow shareWith,java.awt.GraphicsDevice device){\n  super(Configuration.getRequiredGLCapabilities(),new BasicGLCapabilitiesChooser(),device);\n  if (shareWith != null)   this.setSharedContext(shareWith.getContext());\n  try {\n    this.wwd=((WorldWindowGLDrawable)WorldWind.createConfigurationComponent(AVKey.WORLD_WINDOW_CLASS_NAME));\n    this.wwd.initDrawable(this);\n    this.wwd.addPropertyChangeListener(this);\n    if (shareWith != null)     this.wwd.initGpuResourceCache(shareWith.getGpuResourceCache());\n else     this.wwd.initGpuResourceCache(WorldWindowImpl.createGpuResourceCache());\n    this.createView();\n    this.createDefaultInputHandler();\n    WorldWind.addPropertyChangeListener(WorldWind.SHUTDOWN_EVENT,this);\n    this.wwd.endInitialization();\n  }\n catch (  Exception e) {\n    String message=Logging.getMessage(\"Awt.WorldWindowGLSurface.UnabletoCreateWindow\");\n    Logging.logger().severe(message);\n    throw new WWRuntimeException(message,e);\n  }\n}\n", "nl": "Constructs a new <code>WorldWindowGLCanvas</code> on a specified graphics device and shares graphics resources with another <code>WorldWindow</code>."}
{"code": "long triggerTime(long delay){\n  return now() + ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n}\n", "nl": "Returns the trigger time of a delayed action."}
{"code": "public final void flush(){\n  if (offset > 0 && offset >= minLenToWrite()) {\n    ChunkRaw c=new ChunkRaw(offset,getChunkId(),false);\n    c.data=buf;\n    c.writeChunk(outputStream);\n    totalBytesWriten+=c.len + 12;\n    chunksWriten++;\n    offset=0;\n    availLen=maxChunkLen;\n    postReset();\n  }\n}\n", "nl": "Writes a chhunk if there is more than minLenToWrite. This is normally called internally, but can be called explicitly to force flush."}
{"code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof StandardXYSeriesLabelGenerator)) {\n    return false;\n  }\n  StandardXYSeriesLabelGenerator that=(StandardXYSeriesLabelGenerator)obj;\n  if (!this.formatPattern.equals(that.formatPattern)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Tests this object for equality with an arbitrary object."}
{"code": "public SecurityObjectAuthority(SecurityObject securityObject){\n  sObj=securityObject;\n}\n", "nl": "Create a new SecurityObjectAuthority."}
{"code": "private static void usage(){\n  System.out.println(\"TAnk Standalone Agent Startup Usage:\");\n  System.out.println(\"java -cp standaloneagent-startup-pkg-1.0-all.jar com/intuit/tank/agent/StandaloneAgentStartup <options>\");\n  System.out.println(\"-controller=<controller_base_url>:  The url of the controller to get test info from.\");\n  System.out.println(\"-host=<agent ip or host>:  optional. only need if agent cannot determine correct ip. The ip or dns name of this agent.\");\n  System.out.println(\"-capacity=<integer>:  optional. The number of users this agent can simulate. Default 4000.\");\n}\n", "nl": "Display usage error text"}
{"code": "public static void startSettingsApp(Fragment fragment){\n  startSettingsApp((Context)fragment.getActivity());\n}\n", "nl": "Helper API to start the Settings app directly into the details page for the app. This allows the user to quickly change the permissions granted/denied for the app. <p>"}
{"code": "public void runMATSimPSSIterations(int numberOfIterations){\n  File resultsDirectory=new File(resultDirectory);\n  if (resultsDirectory.list().length > 0) {\n    throw new Error(\"The result directory is not empty.\");\n  }\n  if (!new File(outputPSSPath + \"\\\\hubPriceInfo.txt\").exists()) {\n    throw new Error(\"The initial price file is not in \" + outputPSSPath);\n  }\n  GeneralLib.copyFile(outputPSSPath + \"\\\\hubPriceInfo.txt\",resultDirectory + \"initialHubPriceInfo.txt\");\n  for (iterationNumber=0; iterationNumber < numberOfIterations; iterationNumber++) {\n    runMATSimIterations();\n    saveMATSimResults();\n    preparePSSInput();\n    runPSS();\n    savePSSResults();\n    prepareMATSimInput();\n  }\n}\n", "nl": "number of iterations, in which both MATSim and PSS (Power System Simulation) is run. The number of iterations within matsim is specified in the config file."}
{"code": "public void start(){\n  init();\n  m_Start=getCurrentTime();\n  m_Stop=m_Start;\n  m_Running=true;\n}\n", "nl": "saves the current system time (or CPU time) in msec as start time"}
{"code": "public PricedProductRole copy(PriceModel pm){\n  return copy(pm,null,null);\n}\n", "nl": "Creates a copy of the current object."}
{"code": "public void handleEvent(Event evt){\n  Node node=(Node)evt.getTarget();\n  BridgeUpdateHandler h=getBridgeUpdateHandler(node);\n  if (h != null) {\n    try {\n      h.handleDOMNodeRemovedEvent((MutationEvent)evt);\n    }\n catch (    Exception e) {\n      userAgent.displayError(e);\n    }\n  }\n}\n", "nl": "Handles 'DOMNodeRemoved' event type."}
{"code": "@Override public void characters(char[] ch,int start,int length){\n  if (this.currentText != null) {\n    this.currentText.append(String.copyValueOf(ch,start,length));\n  }\n}\n", "nl": "Receives some (or all) of the text in the current element."}
{"code": "public RDFXMLWriter(Writer writer){\n  this.writer=writer;\n  namespaceTable=new LinkedHashMap<String,String>();\n  writingStarted=false;\n  headerWritten=false;\n  lastWrittenSubject=null;\n}\n", "nl": "Creates a new RDFXMLWriter that will write to the supplied Writer."}
{"code": "@Override public boolean isEmpty(){\n  return 0 == size();\n}\n", "nl": "Returns true if the deque has no elements."}
{"code": "private BitMatrix sampleGrid(BitMatrix image,ResultPoint topLeft,ResultPoint bottomLeft,ResultPoint bottomRight,ResultPoint topRight) throws NotFoundException {\n  int dimension;\n  if (compact) {\n    dimension=4 * nbLayers + 11;\n  }\n else {\n    if (nbLayers <= 4) {\n      dimension=4 * nbLayers + 15;\n    }\n else {\n      dimension=4 * nbLayers + 2 * ((nbLayers - 4) / 8 + 1) + 15;\n    }\n  }\n  GridSampler sampler=GridSampler.getInstance();\n  return sampler.sampleGrid(image,dimension,dimension,0.5f,0.5f,dimension - 0.5f,0.5f,dimension - 0.5f,dimension - 0.5f,0.5f,dimension - 0.5f,topLeft.getX(),topLeft.getY(),topRight.getX(),topRight.getY(),bottomRight.getX(),bottomRight.getY(),bottomLeft.getX(),bottomLeft.getY());\n}\n", "nl": "Samples an Aztec matrix from an image"}
{"code": "private void put(final Item i){\n  if (index + typeCount > threshold) {\n    int ll=items.length;\n    int nl=ll * 2 + 1;\n    Item[] newItems=new Item[nl];\n    for (int l=ll - 1; l >= 0; --l) {\n      Item j=items[l];\n      while (j != null) {\n        int index=j.hashCode % newItems.length;\n        Item k=j.next;\n        j.next=newItems[index];\n        newItems[index]=j;\n        j=k;\n      }\n    }\n    items=newItems;\n    threshold=(int)(nl * 0.75);\n  }\n  int index=i.hashCode % items.length;\n  i.next=items[index];\n  items[index]=i;\n}\n", "nl": "Puts the given item in the constant pool's hash table. The hash table <i>must</i> not already contains this item."}
{"code": "public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException {\n  String prefix;\n  String namespace;\n  String methName;\n  String fullName=m_arg0.execute(xctxt).str();\n  int indexOfNSSep=fullName.indexOf(':');\n  if (indexOfNSSep < 0) {\n    prefix=\"\";\n    namespace=Constants.S_XSLNAMESPACEURL;\n    methName=fullName;\n  }\n else {\n    prefix=fullName.substring(0,indexOfNSSep);\n    namespace=xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);\n    if (null == namespace)     return XBoolean.S_FALSE;\n    methName=fullName.substring(indexOfNSSep + 1);\n  }\n  if (namespace.equals(Constants.S_XSLNAMESPACEURL) || namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL)) {\n    try {\n      TransformerImpl transformer=(TransformerImpl)xctxt.getOwnerObject();\n      return transformer.getStylesheet().getAvailableElements().containsKey(new QName(namespace,methName)) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\n    }\n catch (    Exception e) {\n      return XBoolean.S_FALSE;\n    }\n  }\n else {\n    ExtensionsProvider extProvider=(ExtensionsProvider)xctxt.getOwnerObject();\n    return extProvider.elementAvailable(namespace,methName) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\n  }\n}\n", "nl": "Execute the function.  The function must return a valid object."}
{"code": "public boolean allowTrailingEdges(){\n  return patternElement.allowTrailingEdges();\n}\n", "nl": "Return whether or not the most recently matched instruction allows trailing edges."}
{"code": "public static CompoundTag putItemHelper(Item item){\n  return putItemHelper(item,null);\n}\n", "nl": "A Named Binary Tag library for BukkitPE Project"}
{"code": "public final boolean contains(String key){\n  for (int i=0; i < m_firstFree; i++) {\n    if (m_map[i].equals(key))     return true;\n  }\n  return false;\n}\n", "nl": "Tell if the table contains the given string."}
{"code": "public void installUI(JComponent c){\n  super.installUI(c);\n  c.setOpaque(false);\n}\n", "nl": "Install UI"}
{"code": "public Collection<GridQueryTypeDescriptor> types(@Nullable String space){\n  Collection<GridQueryTypeDescriptor> spaceTypes=new ArrayList<>(Math.min(10,types.size()));\n  for (  Map.Entry<TypeId,TypeDescriptor> e : types.entrySet()) {\n    TypeDescriptor desc=e.getValue();\n    if (desc.registered() && F.eq(e.getKey().space,space))     spaceTypes.add(desc);\n  }\n  return spaceTypes;\n}\n", "nl": "Gets types for space."}
{"code": "public final synchronized void queueAnalyzeRequest(SearchRequest sr){\n  killOldEngine(sr.engine);\n  stopSearch();\n  ArrayList<Move> moves=movesToSearch(sr);\n  if (moves.size() == 0)   return;\n  searchRequest=sr;\n  handleQueue();\n}\n", "nl": "Start analyzing a position."}
{"code": "public void fireGenerateEvent(int eventType){\n}\n", "nl": "Fire off startDocument, endDocument events."}
{"code": "public static void enable(){\n}\n", "nl": "Enables the JIT compiler. Does nothing on Android."}
{"code": "public Debug_ createDebug_(){\n  Debug_Impl debug_=new Debug_Impl();\n  return debug_;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override protected boolean shouldContinue(){\n  return receivedJDPpackets < 3;\n}\n", "nl": "After receiving three Jdp packets the test should end."}
{"code": "public void test_getPublicExponent(){\n  assertEquals(\"invalid public exponent\",Util.rsaCrtParam.getPublicExponent(),key.getPublicExponent());\n}\n", "nl": "java.security.interfaces.RSAPrivateCrtKey #getPublicExponent()"}
{"code": "private Throwable prepareFault(HashMap fault) throws IOException {\n  Object detail=fault.get(\"detail\");\n  String message=(String)fault.get(\"message\");\n  if (detail instanceof Throwable) {\n    _replyFault=(Throwable)detail;\n    if (message != null && _detailMessageField != null) {\n      try {\n        _detailMessageField.set(_replyFault,message);\n      }\n catch (      Throwable e) {\n      }\n    }\n    return _replyFault;\n  }\n else {\n    String code=(String)fault.get(\"code\");\n    _replyFault=new HessianServiceException(message,code,detail);\n    return _replyFault;\n  }\n}\n", "nl": "Prepares the fault."}
{"code": "public void free(){\n  logger.fine(\"Free ICE agent\");\n  shutdown=true;\n  if (stunKeepAliveThread != null)   stunKeepAliveThread.interrupt();\n  connCheckServer.stop();\n  IceProcessingState state=getState();\n  if (!IceProcessingState.FAILED.equals(state) && !IceProcessingState.TERMINATED.equals(state)) {\n    terminate(IceProcessingState.TERMINATED);\n  }\n  boolean interrupted=false;\n  logger.fine(\"remove streams\");\n  for (  IceMediaStream stream : getStreams()) {\n    try {\n      removeStream(stream);\n      logger.fine(\"remove stream \" + stream.getName());\n    }\n catch (    Throwable t) {\n      logger.fine(\"remove stream \" + stream.getName() + \" failed: \"+ t);\n      if (t instanceof InterruptedException)       interrupted=true;\n else       if (t instanceof ThreadDeath)       throw (ThreadDeath)t;\n    }\n  }\n  if (interrupted)   Thread.currentThread().interrupt();\n  getStunStack().shutDown();\n  logger.fine(\"ICE agent freed\");\n}\n", "nl": "Prepares this <tt>Agent</tt> for garbage collection by ending all related processes and freeing its <tt>IceMediaStream</tt>s, <tt>Component</tt>s and <tt>Candidate</tt>s. This method will also place the agent in the terminated state in case it wasn't already there."}
{"code": "public boolean containsIgnoredSections(){\n  return containsIgnoredSections;\n}\n", "nl": "Returns true if ignored sections where found the pon file"}
{"code": "public NullOutputLogTarget(){\n  open();\n}\n", "nl": "Creation of a new null log target."}
{"code": "@SuppressWarnings(\"deprecation\") protected void preShow(){\n  if (mRootView == null)   throw new IllegalStateException(\"setContentView was not called with a view to display.\");\n  onShow();\n  if (mBackground == null)   mWindow.setBackgroundDrawable(new BitmapDrawable());\n else   mWindow.setBackgroundDrawable(mBackground);\n  mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);\n  mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);\n  mWindow.setTouchable(true);\n  mWindow.setFocusable(true);\n  mWindow.setOutsideTouchable(true);\n  mWindow.setContentView(mRootView);\n}\n", "nl": "On pre show"}
{"code": "private void updateOffsets(){\n  float minSizeX=imageWidth * minRelativeOffset;\n  float minSizeY=imageHeight * minRelativeOffset;\n  offsetWidth=(imageWidth - canvasWidth - minSizeX) > 0 ? imageWidth - canvasWidth : 0;\n  offsetHeight=(imageHeight - canvasHeight - minSizeY) > 0 ? imageHeight - canvasHeight : 0;\n}\n", "nl": "Offset is the difference between image and canvas including the min relative size. Determines the base path animation length."}
{"code": "public boolean isParentOf(Node node1,Node node2){\n  for (  Edge edge1 : getEdges(node1)) {\n    Edge edge=(edge1);\n    Node sub=Edges.traverseDirected(node1,edge);\n    if (sub == node2) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Determines whether one node is a parent of another."}
{"code": "public Rule findById(Integer id){\n  try {\n    EntityManager entityManager=EntityManagerHelper.getEntityManager();\n    entityManager.getTransaction().begin();\n    Rule instance=entityManager.find(Rule.class,id);\n    entityManager.getTransaction().commit();\n    return instance;\n  }\n catch (  Exception re) {\n    EntityManagerHelper.rollback();\n    throw re;\n  }\n finally {\n    EntityManagerHelper.close();\n  }\n}\n", "nl": "Method findById."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-03-25 14:54:53.600 -0400\",hash_original_method=\"3EB1A4F1628CAC368761882425F0BB03\",hash_generated_method=\"3EB1A4F1628CAC368761882425F0BB03\") boolean isValid(){\n  return (null != mMimeType && !mMimeType.equals(\"\") && null != mData && mData.length > 0);\n}\n", "nl": "Determines whether this instance is valid or not."}
{"code": "public static Builder newBuilder(@Nullable Context context){\n  return new Builder(context);\n}\n", "nl": "Create a new builder."}
{"code": "@AfterClass public static void afterClassBaseTest() throws SQLException {\n  if (testSingleHost) {\n    if (!sharedConnection.isClosed()) {\n      if (!tempViewList.isEmpty()) {\n        Statement stmt=sharedConnection.createStatement();\n        String viewName;\n        while ((viewName=tempViewList.poll()) != null) {\n          try {\n            stmt.execute(\"DROP VIEW IF EXISTS \" + viewName);\n          }\n catch (          SQLException e) {\n          }\n        }\n      }\n      if (!tempTableList.isEmpty()) {\n        Statement stmt=sharedConnection.createStatement();\n        String tableName;\n        while ((tableName=tempTableList.poll()) != null) {\n          try {\n            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n          }\n catch (          SQLException e) {\n          }\n        }\n      }\n      if (!tempProcedureList.isEmpty()) {\n        Statement stmt=sharedConnection.createStatement();\n        String procedureName;\n        while ((procedureName=tempProcedureList.poll()) != null) {\n          try {\n            stmt.execute(\"DROP procedure IF EXISTS \" + procedureName);\n          }\n catch (          SQLException e) {\n          }\n        }\n      }\n      if (!tempFunctionList.isEmpty()) {\n        Statement stmt=sharedConnection.createStatement();\n        String functionName;\n        while ((functionName=tempFunctionList.poll()) != null) {\n          try {\n            stmt.execute(\"DROP FUNCTION IF EXISTS \" + functionName);\n          }\n catch (          SQLException e) {\n          }\n        }\n      }\n    }\n    try {\n      sharedConnection.close();\n    }\n catch (    SQLException e) {\n      e.printStackTrace();\n    }\n  }\n}\n", "nl": "Destroy the test tables."}
{"code": "public boolean isSorted(){\n  return (mSortColumn > -1);\n}\n", "nl": "returns whether the table was sorted"}
{"code": "public CacheProfile(FilterProfile localProfile){\n  this.filterProfile=localProfile;\n}\n", "nl": "used for routing computation"}
{"code": "Type(Response.Status status){\n  this.status=status;\n}\n", "nl": "Defines a new error type associated with the given HTTP status."}
{"code": "public INode copy(){\n  return new SmallPuzzle(s);\n}\n", "nl": "return copy of node."}
{"code": "@Override protected final void addArgument(Object argument){\n  if (this.arguments == null) {\n    throw new IllegalStateException(\"Could not add argument to evaluated element\");\n  }\n  this.arguments.add(argument);\n}\n", "nl": "Adds the argument to the list of arguments that is used to calculate the value of this element."}
{"code": "public DImportKeyPairPvk(JFrame parent){\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  initComponents();\n}\n", "nl": "Creates a new DImportKeyPairPvk dialog."}
{"code": "private IgniteBiTuple<Integer,Integer> fieldPositionAndLength(int footerPos,int footerEnd,int rawPos,int fieldIdLen,int fieldOffsetLen){\n  int fieldOffset=BinaryUtils.fieldOffsetRelative(reader,footerPos + fieldIdLen,fieldOffsetLen);\n  int fieldPos=start + fieldOffset;\n  int fieldLen;\n  if (footerPos + fieldIdLen + fieldOffsetLen == footerEnd)   fieldLen=rawPos - fieldPos;\n else {\n    int nextFieldOffset=BinaryUtils.fieldOffsetRelative(reader,footerPos + fieldIdLen + fieldOffsetLen+ fieldIdLen,fieldOffsetLen);\n    fieldLen=nextFieldOffset - fieldOffset;\n  }\n  return F.t(fieldPos,fieldLen);\n}\n", "nl": "Get field position and length."}
{"code": "public Graph search(Node target){\n  long start=System.currentTimeMillis();\n  this.numIndependenceTests=0;\n  this.allTriples=new HashSet<>();\n  this.ambiguousTriples=new HashSet<>();\n  this.colliderTriples=new HashSet<>();\n  this.noncolliderTriples=new HashSet<>();\n  if (target == null) {\n    throw new IllegalArgumentException(\"Null target name not permitted\");\n  }\n  this.target=target;\n  logger.log(\"info\",\"Target = \" + target);\n  this.maxRemainingAtDepth=new int[20];\n  this.maxVariableAtDepth=new Node[20];\n  Arrays.fill(maxRemainingAtDepth,-1);\n  Arrays.fill(maxVariableAtDepth,null);\n  logger.log(\"info\",\"target = \" + getTarget());\n  Graph graph=new EdgeListGraph();\n  this.a=new HashSet<>();\n  logger.log(\"info\",\"BEGINNING step 1 (prune target).\");\n  graph.addNode(getTarget());\n  constructFan(getTarget(),graph);\n  logger.log(\"graph\",\"After step 1 (prune target)\" + graph);\n  logger.log(\"graph\",\"After step 1 (prune target)\" + graph);\n  logger.log(\"info\",\"BEGINNING step 2 (prune PC).\");\n  for (  Node v : graph.getAdjacentNodes(getTarget())) {\n    constructFan(v,graph);\n    W:     for (    Node w : graph.getAdjacentNodes(v)) {\n      if (a.contains(w)) {\n        continue;\n      }\n      List _a=new LinkedList<>(a);\n      _a.retainAll(graph.getAdjacentNodes(w));\n      if (_a.size() > 1)       continue;\n      List<Node> adjT=graph.getAdjacentNodes(getTarget());\n      DepthChoiceGenerator cg=new DepthChoiceGenerator(adjT.size(),depth);\n      int[] choice;\n      while ((choice=cg.next()) != null) {\n        List<Node> s=GraphUtils.asList(choice,adjT);\n        if (!s.contains(v))         continue;\n        if (independent(getTarget(),w,s)) {\n          graph.removeEdge(v,w);\n          continue W;\n        }\n      }\n    }\n  }\n  logger.log(\"graph\",\"After step 2 (prune PC)\" + graph);\n  logger.log(\"info\",\"BEGINNING step 3 (prune PCPC).\");\n  for (  Node v : graph.getAdjacentNodes(getTarget())) {\n    for (    Node w : graph.getAdjacentNodes(v)) {\n      if (getA().contains(w)) {\n        continue;\n      }\n      constructFan(w,graph);\n    }\n  }\n  logger.log(\"graph\",\"After step 3 (prune PCPC)\" + graph);\n  logger.log(\"info\",\"BEGINNING step 4 (PC Orient).\");\n  SearchGraphUtils.pcOrientbk(knowledge,graph,graph.getNodes());\n  List<Node> _visited=new LinkedList<>(getA());\n  orientUnshieldedTriples(knowledge,graph,getTest(),getDepth(),_visited);\n  MeekRules meekRules=new MeekRules();\n  meekRules.setAggressivelyPreventCycles(this.aggressivelyPreventCycles);\n  meekRules.setKnowledge(knowledge);\n  meekRules.orientImplied(graph);\n  logger.log(\"graph\",\"After step 4 (PC Orient)\" + graph);\n  logger.log(\"info\",\"BEGINNING step 5 (Trim graph to {T} U PC U \" + \"{Parents(Children(T))}).\");\n  MbUtils.trimToMbNodes(graph,getTarget(),false);\n  logger.log(\"graph\",\"After step 5 (Trim graph to {T} U PC U {Parents(Children(T))})\" + graph);\n  logger.log(\"info\",\"BEGINNING step 6 (Remove edges among P and P of C).\");\n  MbUtils.trimEdgesAmongParents(graph,getTarget());\n  MbUtils.trimEdgesAmongParentsOfChildren(graph,getTarget());\n  logger.log(\"graph\",\"After step 6 (Remove edges among P and P of C)\" + graph);\n  finishUp(start,graph);\n  this.logger.log(\"graph\",\"\\nReturning this graph: \" + graph);\n  this.graph=graph;\n  return graph;\n}\n", "nl": "Searches for the MB Pattern for the given target."}
{"code": "public static SliceMetaData readSliceMetadata(File rsFiles,int restructFolderNumber) throws CarbonUtilException {\n  SliceMetaData readObject=null;\n  InputStream stream=null;\n  ObjectInputStream objectInputStream=null;\n  File file=null;\n  try {\n    file=new File(rsFiles + File.separator + getSliceMetaDataFileName(restructFolderNumber));\n    stream=new FileInputStream(rsFiles + File.separator + getSliceMetaDataFileName(restructFolderNumber));\n    objectInputStream=new ObjectInputStream(stream);\n    readObject=(SliceMetaData)objectInputStream.readObject();\n  }\n catch (  ClassNotFoundException e) {\n    throw new CarbonUtilException(\"Problem while reading the slicemeta data file \" + file.getAbsolutePath(),e);\n  }\ncatch (  IOException e) {\n    throw new CarbonUtilException(\"Problem while reading the slicemeta data file \",e);\n  }\n finally {\n    closeStreams(objectInputStream,stream);\n  }\n  return readObject;\n}\n", "nl": "This method will be used to read the slice metadata"}
{"code": "private void writeObject(java.io.ObjectOutputStream stream) throws IOException {\n  stream.defaultWriteObject();\n}\n", "nl": "Writes the AffineTrassform object to the output steam."}
{"code": "public static void warn(String tag,String text){\n  try {\n    Log.w(tag,getFormattedLogLine() + text);\n  }\n catch (  OutOfMemoryError error) {\n    error.printStackTrace();\n  }\ncatch (  Exception exception) {\n    exception.printStackTrace();\n  }\n}\n", "nl": "Log warn extendido"}
{"code": "public boolean parse(){\n  BStack=new BracketStack();\n  BStack.newClass();\n  BStack.registerInCurrentClass(AND);\n  BStack.newClass();\n  BStack.registerInCurrentClass(OR);\n  BStack.newClass();\n  BStack.registerInCurrentClass(PROOF);\n  BStack.newClass();\n  BStack.registerInCurrentClass(LBR);\n  BStack.newClass();\n  BStack.registerInCurrentClass(ASSUME);\n  try {\n    ParseTree=CompilationUnit();\n  }\n catch (  ParseException e) {\n    PErrors.push(new ParseError(msgStackToString(e)));\n  }\ncatch (  TokenMgrError tme) {\n    String msg=tme.getMessage();\n    int bl=jj_input_stream.getBeginLine() + 1;\n    int el=jj_input_stream.getEndLine() + 1;\n    if ((msg.indexOf(\"EOF\") != -1) && (bl != el)) {\n      PErrors.push(new ParseError(\"Lexical {error: EOF reached, \" + \"possibly open comment starting around line \" + (bl - 1)));\n    }\n else     PErrors.push(new ParseError(msg));\n  }\n  if (PErrors.empty())   Assert.check(heirsIndex == 0,EC.SANY_PARSER_CHECK_1);\n else {\n    tla2sany.st.ParseError list[]=PErrors.errors();\n    for (int i=0; i < list.length; i++) {\n      ToolIO.out.println(list[i].reportedError());\n    }\n  }\n  return PErrors.empty();\n}\n", "nl": "This is a stack of the kinds and offsets of the tokens that start a   bulleted list within which the parser is currently grabbing tokens. "}
{"code": "void addOrReplaceDecls(XMLNSDecl newDecl){\n  int n=m_prefixTable.size();\n  for (int i=n - 1; i >= 0; i--) {\n    XMLNSDecl decl=(XMLNSDecl)m_prefixTable.get(i);\n    if (decl.getPrefix().equals(newDecl.getPrefix())) {\n      return;\n    }\n  }\n  m_prefixTable.add(newDecl);\n}\n", "nl": "Add or replace this namespace declaration in list of namespaces in scope for this element."}
{"code": "protected ChangeDescriptor(){\n}\n", "nl": "Creates a new change descriptor."}
{"code": "PortTcp port(){\n  return _port;\n}\n", "nl": "Returns the port which generated the connection."}
{"code": "public static final String portDisplayTextFunction(Interface iface){\n  String string;\n  if (iface.hasSpecifiedName()) {\n    string=String.format(\"%s %s\",iface.getName(),iface.getPort().getDisplayText());\n  }\n else {\n    string=iface.getPort().getDisplayText();\n  }\n  return string;\n}\n", "nl": "Pluggable toString for a Port and MAC address."}
{"code": "public void visitFieldInsn(int opcode,String owner,String name,String desc){\n  if (mv != null) {\n    mv.visitFieldInsn(opcode,owner,name,desc);\n  }\n}\n", "nl": "Visits a field instruction. A field instruction is an instruction that loads or stores the value of a field of an object."}
{"code": "public boolean visit(final int depth,final Value predecessor){\n  if (this.depth.compareAndSet(-1,depth)) {\n    this.predecessor.set(predecessor);\n    return true;\n  }\n  return false;\n}\n", "nl": "Note: This marks the vertex at the current traversal depth."}
{"code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  cardboardAudioEngine=new GvrAudioEngine(this,GvrAudioEngine.RenderingMode.BINAURAL_HIGH_QUALITY);\n  setMain(new SpatialAudioMain(cardboardAudioEngine),\"gvr.xml\");\n}\n", "nl": "Called when the activity is first created."}
{"code": "public DataFilterCriteria.Builder<Select<T>> openBracketOr(){\n  return new DataFilterCriteria.Builder<>(this,DataFilterClause.DataFilterConjunction.OR);\n}\n", "nl": "Starts a new Criteria builder with OR conjunction"}
{"code": "protected void putChar(char ch,boolean scan){\n  sbuf=ArrayUtils.ensureCapacity(sbuf,sp);\n  sbuf[sp++]=ch;\n  if (scan)   scanChar();\n}\n", "nl": "Append a character to sbuf."}
{"code": "private boolean isCacheServerPortEquals(CacheServer other){\n  return (this.getPort() == 0) ? true : this.getPort() == other.getPort();\n}\n", "nl": "Compare configured cacheServer port against the running cacheServer port. If the current cacheServer port is set to 0 a random ephemeral port will be used so there is no need to compare returning <code>true</code>. If a port is specified, return the proper comparison."}
{"code": "Property(YearMonthDay partial,int fieldIndex){\n  super();\n  iYearMonthDay=partial;\n  iFieldIndex=fieldIndex;\n}\n", "nl": "Constructs a property."}
{"code": "public E push(E item){\n  top=new Node<>(item,top);\n  return item;\n}\n", "nl": "Pushes an item onto the top of this stack."}
{"code": "public static byte[] asByteArray(final List<Byte> l){\n  final byte[] a=new byte[l.size()];\n  for (int i=0; i < a.length; i++) {\n    a[i]=l.get(i);\n  }\n  return a;\n}\n", "nl": "Return list of boxed bytes as a primitive array."}
{"code": "public double nextDouble(double lambda){\n  return -Math.log(randomGenerator.raw()) / lambda;\n}\n", "nl": "Returns a random number from the distribution; bypasses the internal state."}
{"code": "public void addObserver(AppMenuObserver observer){\n  mObservers.add(observer);\n}\n", "nl": "Adds the observer to App Menu."}
{"code": "private static void initClamp(){\n  for (int i=0; i < 256; i++) {\n    clamp[CLAMP_BASE + i]=i;\n  }\n  for (int i=0; i < CLAMP_BASE; i++) {\n    clamp[i]=0;\n    clamp[i + CLAMP_BASE + 256]=255;\n  }\n}\n", "nl": "Initialize array to clamp values in range [0..255]"}
{"code": "public void detachDatastore(Datastore datastore){\n  for (  HostScsiDisk disk : listDisks(datastore)) {\n    try {\n      host.getHostStorageSystem().detachScsiLun(disk.getUuid());\n    }\n catch (    RemoteException e) {\n      throw new VMWareException(e);\n    }\n  }\n}\n", "nl": "Detach all of the disks associated with the datastore on this host"}
{"code": "public static _Fields findByName(String name){\n  return byName.get(name);\n}\n", "nl": "Find the _Fields constant that matches name, or null if its not found."}
{"code": "@SuppressWarnings(\"deprecation\") public static Expression create(String expression,StatsCollector[] statsCollectors){\n  int paren=expression.indexOf('(');\n  if (paren <= 0) {\n    throw new SolrException(ErrorCode.BAD_REQUEST,\"The expression [\" + expression + \"] has no arguments and is not supported.\");\n  }\n  String topOperation=expression.substring(0,paren).trim();\n  String operands;\n  try {\n    operands=expression.substring(paren + 1,expression.lastIndexOf(')')).trim();\n  }\n catch (  Exception e) {\n    throw new SolrException(ErrorCode.BAD_REQUEST,\"Missing closing parenthesis in [\" + expression + \"]\",e);\n  }\n  if (AnalyticsParams.ALL_STAT_SET.contains(topOperation)) {\n    if (topOperation.equals(AnalyticsParams.STAT_PERCENTILE)) {\n      operands=expression.substring(expression.indexOf(',') + 1,expression.lastIndexOf(')')).trim();\n      topOperation=topOperation + \"_\" + expression.substring(expression.indexOf('(') + 1,expression.indexOf(',')).trim();\n    }\n    StatsCollector collector=null;\n    for (    StatsCollector c : statsCollectors) {\n      if (c.valueSourceString().equals(operands)) {\n        collector=c;\n        break;\n      }\n    }\n    if (collector == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"ValueSource [\" + operands + \"] in Expression [\"+ expression+ \"] not found.\");\n    }\n    return new BaseExpression(collector,topOperation);\n  }\n  if (topOperation.equals(AnalyticsParams.CONSTANT_NUMBER)) {\n    try {\n      return new ConstantNumberExpression(Double.parseDouble(operands));\n    }\n catch (    NumberFormatException e) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The constant \" + operands + \" cannot be converted into a number.\",e);\n    }\n  }\n else   if (topOperation.equals(AnalyticsParams.CONSTANT_DATE)) {\n    return new ConstantDateExpression(DateMathParser.parseMath(null,operands));\n  }\n else   if (topOperation.equals(AnalyticsParams.CONSTANT_STRING)) {\n    operands=expression.substring(paren + 1,expression.lastIndexOf(')'));\n    return new ConstantStringExpression(operands);\n  }\n  String[] arguments=getArguments(operands);\n  Expression[] expArgs=new Expression[arguments.length];\n  for (int count=0; count < arguments.length; count++) {\n    expArgs[count]=create(arguments[count],statsCollectors);\n  }\n  if (expArgs.length == 1) {\n    if (topOperation.equals(AnalyticsParams.NEGATE)) {\n      return new NegateExpression(expArgs[0]);\n    }\n    if (topOperation.equals(AnalyticsParams.ABSOLUTE_VALUE)) {\n      return new AbsoluteValueExpression(expArgs[0]);\n    }\n else     if (topOperation.equals(AnalyticsParams.REVERSE)) {\n      return new ReverseExpression(expArgs[0]);\n    }\n    throw new SolrException(ErrorCode.BAD_REQUEST,topOperation + \" does not have the correct number of arguments.\");\n  }\n else {\n    if (topOperation.equals(AnalyticsParams.ADD)) {\n      return new AddExpression(expArgs);\n    }\n else     if (topOperation.equals(AnalyticsParams.MULTIPLY)) {\n      return new MultiplyExpression(expArgs);\n    }\n else     if (topOperation.equals(AnalyticsParams.DATE_MATH)) {\n      return new DateMathExpression(expArgs);\n    }\n else     if (topOperation.equals(AnalyticsParams.CONCATENATE)) {\n      return new ConcatenateExpression(expArgs);\n    }\n else     if (expArgs.length == 2 && (topOperation.equals(AnalyticsParams.DIVIDE) || topOperation.equals(AnalyticsParams.POWER) || topOperation.equals(AnalyticsParams.LOG))) {\n      if (topOperation.equals(AnalyticsParams.DIVIDE)) {\n        return new DivideExpression(expArgs[0],expArgs[1]);\n      }\n else       if (topOperation.equals(AnalyticsParams.POWER)) {\n        return new PowerExpression(expArgs[0],expArgs[1]);\n      }\n else       if (topOperation.equals(AnalyticsParams.LOG)) {\n        return new LogExpression(expArgs[0],expArgs[1]);\n      }\n      return null;\n    }\n    throw new SolrException(ErrorCode.BAD_REQUEST,topOperation + \" does not have the correct number of arguments or is unsupported.\");\n  }\n}\n", "nl": "Creates a single expression that contains delegate expressions and/or  a StatsCollector. StatsCollectors are given as input and not created within the method so that expressions can share the same StatsCollectors, minimizing computation."}
{"code": "protected SystemMember createSystemMember(InternalDistributedMember member) throws org.apache.geode.admin.AdminException {\n  return new SystemMemberImpl(this,member);\n}\n", "nl": "Constructs & returns a SystemMember instance using the corresponding InternalDistributedMember object."}
{"code": "void writeData(int streamId,byte[] buffer,int offset,int length,int flags) throws IOException {\n  WriteStream os=_os;\n  if (os == null) {\n    return;\n  }\n  if (offset >= 8) {\n    offset-=8;\n    BitsUtil.writeInt16(buffer,offset,length);\n    buffer[offset + 2]=Http2Constants.FRAME_DATA;\n    buffer[offset + 3]=(byte)flags;\n    BitsUtil.writeInt(buffer,offset + 4,streamId);\n    os.write(buffer,offset,length + 8);\n  }\n else {\n    os.write((byte)(length >> 16));\n    os.write((byte)(length >> 8));\n    os.write((byte)(length));\n    os.write(Http2Constants.FRAME_DATA);\n    os.write(flags);\n    BitsUtil.writeInt(os,streamId);\n    if (length > 0) {\n      os.write(buffer,offset,length);\n    }\n  }\n  if ((flags & Http2Constants.END_STREAM) != 0) {\n    closeWrite(streamId);\n  }\n}\n", "nl": "data (0)"}
{"code": "private final void yybegin(int newState){\n  zzLexicalState=newState;\n}\n", "nl": "Enters a new lexical state"}
{"code": "private ShellUtil(){\n  throw new Error(\"Do not need instantiate!\");\n}\n", "nl": "Don't let anyone instantiate this class."}
{"code": "private String preparePath(String path){\n  if (path.endsWith(\"/\") || path.endsWith(pathSeparator)) {\n    path+=DEFAULT_RAML_FILENAME;\n  }\n  return path;\n}\n", "nl": "Checks the path and adds default file name if what was entered appears to be a directory"}
{"code": "@Override public void configureZone(final StendhalRPZone zone,final Map<String,String> attributes){\n  buildhotdoglady(zone);\n}\n", "nl": "Configure a zone."}
{"code": "public static Scs cs_multiply(Scs A,Scs B){\n  int p, j, nz=0, anz, Cp[], Ci[], Bp[], m, n, bnz, w[], Bi[];\n  float x[], Bx[], Cx[];\n  boolean values;\n  Scs C;\n  if (!Scs_util.CS_CSC(A) || !Scs_util.CS_CSC(B))   return (null);\n  if (A.n != B.m)   return (null);\n  m=A.m;\n  anz=A.p[A.n];\n  n=B.n;\n  Bp=B.p;\n  Bi=B.i;\n  Bx=B.x;\n  bnz=Bp[n];\n  w=new int[m];\n  values=(A.x != null) && (Bx != null);\n  x=values ? new float[m] : null;\n  C=Scs_util.cs_spalloc(m,n,anz + bnz,values,false);\n  Cp=C.p;\n  for (j=0; j < n; j++) {\n    if (nz + m > C.nzmax) {\n      Scs_util.cs_sprealloc(C,2 * (C.nzmax) + m);\n    }\n    Ci=C.i;\n    Cx=C.x;\n    Cp[j]=nz;\n    for (p=Bp[j]; p < Bp[j + 1]; p++) {\n      nz=Scs_scatter.cs_scatter(A,Bi[p],(Bx != null) ? Bx[p] : 1,w,x,j + 1,C,nz);\n    }\n    if (values)     for (p=Cp[j]; p < nz; p++)     Cx[p]=x[Ci[p]];\n  }\n  Cp[n]=nz;\n  Scs_util.cs_sprealloc(C,0);\n  return C;\n}\n", "nl": "Sparse matrix multiplication, C = A*B"}
{"code": "@Override public void topologyChanged(List<LDUpdate> updateList){\n  Iterator<Device> diter=deviceMap.values().iterator();\n  if (updateList != null) {\n    if (logger.isTraceEnabled()) {\n      for (      LDUpdate update : updateList) {\n        logger.trace(\"Topo update: {}\",update);\n      }\n    }\n  }\n  while (diter.hasNext()) {\n    Device d=diter.next();\n    if (d.updateAttachmentPoint()) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Attachment point changed for device: {}\",d);\n      }\n      sendDeviceMovedNotification(d);\n    }\n  }\n  debugEventService.flushEvents();\n}\n", "nl": "Topology listener method."}
{"code": "private TreePath findShallowestPath(TreePath[] paths){\n  int shallowest=-1;\n  TreePath shallowestPath=null;\n  for (int counter=paths.length - 1; counter >= 0; counter--) {\n    if (paths[counter] != null) {\n      if (shallowest != -1) {\n        if (paths[counter].getPathCount() < shallowest) {\n          shallowest=paths[counter].getPathCount();\n          shallowestPath=paths[counter];\n          if (shallowest == 1) {\n            return shallowestPath;\n          }\n        }\n      }\n else {\n        shallowestPath=paths[counter];\n        shallowest=paths[counter].getPathCount();\n      }\n    }\n  }\n  return shallowestPath;\n}\n", "nl": "Returns the TreePath with the smallest path count in <code>paths</code>. Will return null if there is no non-null TreePath is <code>paths</code>."}
{"code": "public AppUser addNewUser(String username,String pwd,String priv,String email,boolean confirmed){\n  if (this.retrieveUserInfoFromMetaDB(username) != null)   return null;\n  AppUser newUser=new AppUser();\n  newUser.setName(username.trim().toLowerCase());\n  newUser.setPassword(pwd);\n  newUser.setUserprivilege(AppUser.PRIV_USER_STANDARD);\n  newUser.setEmail(email);\n  newUser.setVerified(confirmed);\n  try {\n    int privInt=Integer.parseInt(priv);\n    if (privInt == AppUser.PRIV_USER_POWER || privInt == AppUser.PRIV_USER_RESTRICTED)     newUser.setUserprivilege(privInt);\n  }\n catch (  Exception ex) {\n  }\n  newUser.setMd5Hash(newUser.calMd5(newUser.getPassword()));\n  metaDb.upsertAppUser(newUser);\n  this.addUser(newUser);\n  return newUser;\n}\n", "nl": "Add a new user. Return AppUser object if succeed. Otherwise null."}
{"code": "protected FinallyBlockImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private Compiler(){\n}\n", "nl": "Prevent this class from being instantiated."}
{"code": "public boolean initLogin(){\n  m_cc=CConnection.get(Adempiere.getCodeBaseHost());\n  hostField.setValue(m_cc);\n  if (Ini.isPropertyBool(Ini.P_VALIDATE_CONNECTION_ON_STARTUP)) {\n    validateConnection();\n  }\n  userTextField.setText(Ini.getProperty(Ini.P_UID));\n  if (Ini.isPropertyBool(Ini.P_STORE_PWD))   passwordField.setText(Ini.getProperty(Ini.P_PWD));\n else   passwordField.setText(\"\");\n  languageCombo.setSelectedItem(Ini.getProperty(Ini.P_LANGUAGE));\n  if (Ini.isPropertyBool(Ini.P_A_LOGIN)) {\n    connectionOK();\n    defaultsOK();\n    if (m_connectionOK)     m_okPressed=true;\n    return m_connectionOK;\n  }\n  return false;\n}\n", "nl": "Set Initial & Ini Parameters Optional Automatic login"}
{"code": "public final double doOperation() throws OperatorFailedException {\n  List<NodeRef> candidates=new ArrayList<NodeRef>();\n  for (int i=0; i < tree.getNodeCount(); i++) {\n    NodeRef node=tree.getNode(i);\n    if (tree.getNodeTrait(node,indicatorTrait) == 1.0)     candidates.add(node);\n  }\n  if (candidates.size() == 0)   throw new OperatorFailedException(\"No suitable bits!\");\n  NodeRef node=candidates.get(MathUtils.nextInt(candidates.size()));\n  NodeRef newNode=node;\n  for (int i=0; i < k; i++) {\n    int randomNode=MathUtils.nextInt(3);\n    if (randomNode < 2) {\n      if (!tree.isExternal(newNode)) {\n        newNode=tree.getChild(newNode,randomNode);\n      }\n    }\n else     if (!tree.isRoot(newNode)) {\n      newNode=tree.getParent(newNode);\n    }\n  }\n  if (node == newNode)   throw new OperatorFailedException(\"Moving to same node!\");\n  double nodeTrait, newTrait;\n  double nodeRate, newRate;\n  nodeTrait=tree.getNodeTrait(node,indicatorTrait);\n  newTrait=tree.getNodeTrait(newNode,indicatorTrait);\n  tree.setNodeTrait(node,indicatorTrait,newTrait);\n  tree.setNodeTrait(newNode,indicatorTrait,nodeTrait);\n  if (swapTrait2) {\n    if (trait2 != null) {\n      nodeTrait=tree.getNodeTrait(node,trait2);\n      newTrait=tree.getNodeTrait(newNode,trait2);\n      tree.setNodeTrait(node,trait2,newTrait);\n      tree.setNodeTrait(newNode,trait2,nodeTrait);\n    }\n else {\n      nodeRate=tree.getNodeRate(node);\n      newRate=tree.getNodeRate(newNode);\n      tree.setNodeRate(node,newRate);\n      tree.setNodeRate(newNode,nodeRate);\n    }\n  }\n  return 0.0;\n}\n", "nl": "Pick a parent-child node pair involving a single rate change and swap the rate change location and corresponding rate parameters."}
{"code": "public void serializationPerformanceRoutine(ShoppingCartStateSerializer serializer,int sampleSize,int skuCount,int giftCount,int couponCount) throws Exception {\n  final List<ShoppingCart> carts=new ArrayList<ShoppingCart>(sampleSize);\n  final List<byte[]> cartsB=new ArrayList<byte[]>(sampleSize);\n  for (int i=0; i < sampleSize; i++) {\n    carts.add(createRandomCart(skuCount,giftCount,couponCount,i));\n  }\n  byte[] bytes=null;\n  final long startSerializing=System.currentTimeMillis();\n  for (  final ShoppingCart cart : carts) {\n    bytes=serializer.saveState(cart);\n    cartsB.add(bytes);\n  }\n  final long finishSerializing=System.currentTimeMillis();\n  System.out.println(\"Serializing \" + sampleSize + \" carts took ~\"+ (finishSerializing - startSerializing)+ \"ms \"+ \"(size of cart is ~\"+ new BigDecimal(((double)bytes.length) / 1024).setScale(1,RoundingMode.HALF_UP).toPlainString()+ \"Kb)\");\n  ShoppingCart cart=null;\n  final long startDeserializing=System.currentTimeMillis();\n  for (  byte[] b : cartsB) {\n    cart=serializer.restoreState(b);\n  }\n  final long finishDeserializing=System.currentTimeMillis();\n  System.out.println(\"Deserializing \" + sampleSize + \" carts took ~\"+ (finishDeserializing - startDeserializing)+ \"ms\");\n  assertNotNull(cart.getGuid());\n  long totalMs=(finishSerializing - startSerializing + finishDeserializing - startDeserializing);\n  System.out.println(\"Total to and back for \" + sampleSize + \" carts took ~\"+ totalMs+ \"ms (~\"+ new BigDecimal(totalMs).divide(new BigDecimal(sampleSize),2,RoundingMode.HALF_UP).toPlainString()+ \"ms per cart)\");\n}\n", "nl": "This routine create sampleSize number of shopping carts with 25 SKU, 3 gifts serialises all of them then deserialises all of them to measure time it takes for both."}
{"code": "public void writeSample(MediaSample sample){\n  mRtpDummySender.incomingStarted();\n  VideoOrientation orientation=((VideoSample)sample).getVideoOrientation();\n  if (orientation != null) {\n    this.videoOrientation=orientation;\n  }\n  int[] decodedFrame=NativeH264Decoder.DecodeAndConvert(sample.getData(),videoOrientation.getOrientation().getValue(),decodedFrameDimensions);\n  if (NativeH264Decoder.getLastDecodeStatus() == 0) {\n    if ((mSurface != null) && (decodedFrame.length > 0)) {\n      if ((rgbFrame.getWidth() != decodedFrameDimensions[0]) || (rgbFrame.getHeight() != decodedFrameDimensions[1])) {\n        rgbFrame=Bitmap.createBitmap(decodedFrameDimensions[0],decodedFrameDimensions[1],Bitmap.Config.RGB_565);\n        mEventListener.onPlayerResized(decodedFrameDimensions[0],decodedFrameDimensions[1]);\n      }\n      rgbFrame.setPixels(decodedFrame,0,decodedFrameDimensions[0],0,0,decodedFrameDimensions[0],decodedFrameDimensions[1]);\n      mSurface.setImage(rgbFrame);\n    }\n  }\n}\n", "nl": "Write a media sample"}
{"code": "public void save() throws IOException {\n  try {\n    final FileOutputStream fos=new FileOutputStream(new File(configfile.getFile()));\n    final Document doc=new DocumentImpl();\n    final Element collections=doc.createElement(Subcollection.TAG_COLLECTIONS);\n    final Iterator iterator=collectionMap.values().iterator();\n    while (iterator.hasNext()) {\n      final Subcollection subCol=(Subcollection)iterator.next();\n      final Element collection=doc.createElement(Subcollection.TAG_COLLECTION);\n      collections.appendChild(collection);\n      final Element name=doc.createElement(Subcollection.TAG_NAME);\n      name.setNodeValue(subCol.getName());\n      collection.appendChild(name);\n      final Element whiteList=doc.createElement(Subcollection.TAG_WHITELIST);\n      whiteList.setNodeValue(subCol.getWhiteListString());\n      collection.appendChild(whiteList);\n      final Element blackList=doc.createElement(Subcollection.TAG_BLACKLIST);\n      blackList.setNodeValue(subCol.getBlackListString());\n      collection.appendChild(blackList);\n    }\n    DomUtil.saveDom(fos,collections);\n    fos.flush();\n    fos.close();\n  }\n catch (  FileNotFoundException e) {\n    throw new IOException(e.toString());\n  }\n}\n", "nl": "Save collections into file"}
{"code": "public ModifierSlot(final String enumName,final String typeName){\n  super(enumName);\n  this.typeName=typeName;\n}\n", "nl": "Construct new ModifierSlot."}
{"code": "public int nnz(){\n  return st.size();\n}\n", "nl": "Returns the number of nonzero entries in this vector."}
{"code": "public InternalStatisticsDisabledException(String msg,Throwable cause){\n  super(msg,cause);\n}\n", "nl": "Constructs an instance of <code>StatisticsDisabledException</code> with the specified detail message and cause."}
{"code": "public void tickSyncScheduler(){\n  this.syncScheduler.tick();\n}\n", "nl": "Ticks the synchronous scheduler."}
{"code": "@Override public boolean equals(Object o){\n  if (o == this)   return true;\n  if (!(o instanceof Set))   return false;\n  Collection c=(Collection)o;\n  if (c.size() != size())   return false;\n  try {\n    return containsAll(c);\n  }\n catch (  ClassCastException unused) {\n    return false;\n  }\ncatch (  NullPointerException unused) {\n    return false;\n  }\n}\n", "nl": "Compares the specified object with this set for equality.  Returns <tt>true</tt> if the given object is also a set, the two sets have the same size, and every member of the given set is contained in this set.  This ensures that the <tt>equals</tt> method works properly across different implementations of the <tt>Set</tt> interface.<p> This implementation first checks if the specified object is this set; if so it returns <tt>true</tt>.  Then, it checks if the specified object is a set whose size is identical to the size of this set; if not, it returns false.  If so, it returns <tt>containsAll((Collection) o)</tt>."}
{"code": "public ProviderNotFoundException(String name,Throwable cause){\n  super(MessageFormat.format(\"no provider for {0}\",name),cause);\n}\n", "nl": "Constructs an exception indicating the specified provider was not found."}
{"code": "public static boolean fileCopy(String src,String dest){\n  SuperUserCommand superUserCommand=new SuperUserCommand(new String[]{\"rm -f '\" + dest + \"'\",\"cat '\" + src + \"' >> '\"+ dest+ \"'\",\"chmod 0777 '\" + dest + \"'\",\"echo 'done'\"});\n  superUserCommand.setHideStandardOutput(true);\n  superUserCommand.execute();\n  return superUserCommand.commandWasSuccessful();\n}\n", "nl": "Copy a file with root permissions"}
{"code": "@Override public WeightVector train(SLProblem problem,SLParameters params) throws Exception {\n  WeightVector init=new WeightVector(10000);\n  return train(problem,params,init);\n}\n", "nl": "To train with the default choice(zero vector) of initial weight vector.  Often this suffices."}
{"code": "private void messageDeliveredAction(Bundle data){\n  IMqttToken token=removeMqttToken(data);\n  if (token != null) {\n    if (callback != null) {\n      Status status=(Status)data.getSerializable(MqttServiceConstants.CALLBACK_STATUS);\n      if (status == Status.OK && token instanceof IMqttDeliveryToken) {\n        callback.deliveryComplete((IMqttDeliveryToken)token);\n      }\n    }\n  }\n}\n", "nl": "Process notification of a published message having been delivered"}
{"code": "private static void initFont(String fontName){\n  GraphicsEnvironment ge=GraphicsEnvironment.getLocalGraphicsEnvironment();\n  boolean needsLoading=true;\n  for (  String font : ge.getAvailableFontFamilyNames()) {\n    if (fontName.equals(font)) {\n      needsLoading=false;\n      break;\n    }\n  }\n  if (needsLoading) {\n    String resource=\"data/gui/\" + fontName + \".ttf\";\n    try {\n      ge.registerFont(Font.createFont(Font.TRUETYPE_FONT,DataLoader.getResourceAsStream(resource)));\n    }\n catch (    IOException|FontFormatException e) {\n      logger.error(\"Error loading custom font '\" + resource + '\"',e);\n    }\n  }\n}\n", "nl": "Load a custom font."}
{"code": "public void printMissingDeps(List<Map<String,Set<String>>> result){\n  assert result.size() == 2;\n  @SuppressWarnings(\"unused\") Map<String,Set<String>> deps=result.get(0);\n  Map<String,Set<String>> missing=result.get(1);\n  for (  String fqcn : missing.keySet()) {\n    mLog.info(\"%s\",fqcn);\n  }\n}\n", "nl": "Prints only a summary of the missing dependencies to the current logger."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public int size(){\n  return size;\n}\n", "nl": "Returns the number of bytes in the backing array that are valid."}
{"code": "public static boolean usingLocalGraphics(Context context){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n  String sunshineArtPack=context.getString(R.string.pref_art_pack_sunshine);\n  return prefs.getString(context.getString(R.string.pref_art_pack_key),sunshineArtPack).equals(sunshineArtPack);\n}\n", "nl": "Helper method to return whether or not Sunshine is using local graphics."}
{"code": "private void findAllModifiedClasses(String name,PathImpl sourceDir,PathImpl classDir,String sourcePath,ArrayList<String> sources) throws IOException, ClassNotFoundException {\n  String[] list;\n  try {\n    list=sourceDir.list();\n  }\n catch (  IOException e) {\n    return;\n  }\n  for (int i=0; list != null && i < list.length; i++) {\n    if (list[i].startsWith(\".\"))     continue;\n    if (_excludedDirectories.contains(list[i]))     continue;\n    PathImpl subSource=sourceDir.lookup(list[i]);\n    if (subSource.isDirectory()) {\n      findAllModifiedClasses(name + list[i] + \"/\",subSource,classDir.lookup(list[i]),sourcePath,sources);\n    }\n else     if (list[i].endsWith(_sourceExt)) {\n      int tail=list[i].length() - _sourceExt.length();\n      String prefix=list[i].substring(0,tail);\n      PathImpl subClass=classDir.lookup(prefix + \".class\");\n      if (subClass.getLastModified() < subSource.getLastModified()) {\n        sources.add(name + list[i]);\n      }\n    }\n  }\n  if (!_requireSource)   return;\n  try {\n    list=classDir.list();\n  }\n catch (  IOException e) {\n    return;\n  }\n  for (int i=0; list != null && i < list.length; i++) {\n    if (list[i].startsWith(\".\"))     continue;\n    if (_excludedDirectories.contains(list[i]))     continue;\n    PathImpl subClass=classDir.lookup(list[i]);\n    if (list[i].endsWith(\".class\")) {\n      String prefix=list[i].substring(0,list[i].length() - 6);\n      PathImpl subSource=sourceDir.lookup(prefix + _sourceExt);\n      if (!subSource.exists()) {\n        String tail=subSource.getTail();\n        boolean doRemove=true;\n        if (tail.indexOf('$') > 0) {\n          String subTail=tail.substring(0,tail.indexOf('$')) + _sourceExt;\n          PathImpl subJava=subSource.getParent().lookup(subTail);\n          if (subJava.exists())           doRemove=false;\n        }\n        if (doRemove) {\n          log.finer(L.l(\"removing obsolete class '{0}'.\",subClass.getPath()));\n          subClass.remove();\n        }\n      }\n    }\n  }\n}\n", "nl": "Returns the classes which need compilation."}
{"code": "public static MethodTraceCoverageTestFitness createMethodTestFitness(String className,String method){\n  return new MethodTraceCoverageTestFitness(className,method.substring(method.lastIndexOf(\".\") + 1));\n}\n", "nl": "Create a fitness function for branch coverage aimed at covering the root branch of the given method in the given class. Covering a root branch means entering the method."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:59:50.439 -0500\",hash_original_method=\"EB3E524D388CAA0001E918D3BE2E0050\",hash_generated_method=\"F8904635ACB2C47E51F6597E693D3268\") public static void start(){\n  if (!enabled) {\n    return;\n  }\n  if (samplingProfiler != null) {\n    Log.e(TAG,\"SamplingProfilerIntegration already started at \" + new Date(startMillis));\n    return;\n  }\n  ThreadGroup group=Thread.currentThread().getThreadGroup();\n  SamplingProfiler.ThreadSet threadSet=SamplingProfiler.newThreadGroupTheadSet(group);\n  samplingProfiler=new SamplingProfiler(samplingProfilerDepth,threadSet);\n  samplingProfiler.start(samplingProfilerMilliseconds);\n  startMillis=System.currentTimeMillis();\n}\n", "nl": "Starts the profiler if profiling is enabled."}
{"code": "@Inject public NewMyFileAction(SampleActionsResources resources,DialogFactory dialogFactory,CoreLocalizationConstant coreLocalizationConstant,EventBus eventBus,AppContext appContext,NotificationManager notificationManager){\n  super(\"Create my file\",\"Create a new file\",resources.icon(),dialogFactory,coreLocalizationConstant,eventBus,appContext,notificationManager);\n}\n", "nl": "Creates new action."}
{"code": "static String pathToCookiePath(String path){\n  if (path == null) {\n    return \"/\";\n  }\n  int lastSlash=path.lastIndexOf('/');\n  return path.substring(0,lastSlash + 1);\n}\n", "nl": "Returns a cookie-safe path by truncating everything after the last \"/\". When request path like \"/foo/bar.html\" yields a cookie, that cookie's default path is \"/foo/\"."}
{"code": "public void error(SourceLocator srcLctr,String msg,Exception e) throws TransformerException {\n  error(srcLctr,msg,null,e);\n}\n", "nl": "Tell the user of an error, and probably throw an exception."}
{"code": "public void destroy(){\n  EventBus.getDefault().post(new ControllerDestroyedEvent(this));\n  EventBus.getDefault().unregister(this);\n}\n", "nl": "Call this from onDestroy() of an activity or fragment, or from an equivalent point in time, to tear down the entire controller. A fresh controller should be created if you want to use the camera again in the future."}
{"code": "public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (!(obj instanceof Path))   return false;\n  Path target=(Path)obj;\n  if ((separators & HASH_MASK) != (target.separators & HASH_MASK))   return false;\n  String[] targetSegments=target.segments;\n  int i=segments.length;\n  if (i != targetSegments.length)   return false;\n  while (--i >= 0)   if (!segments[i].equals(targetSegments[i]))   return false;\n  return device == target.device || (device != null && device.equals(target.device));\n}\n", "nl": "Returns whether this path equals the given object. <p> Equality for paths is defined to be: same sequence of segments, same absolute/relative status, and same device. Trailing separators are disregarded. Paths are not generally considered equal to objects other than paths. </p>"}
{"code": "public ActiveMQRAMessageListener(final MessageListener listener,final ActiveMQRAMessageConsumer consumer){\n  if (ActiveMQRAMessageListener.trace) {\n    ActiveMQRALogger.LOGGER.trace(\"constructor(\" + listener + \", \"+ consumer+ \")\");\n  }\n  this.listener=listener;\n  this.consumer=consumer;\n}\n", "nl": "Create a new wrapper"}
{"code": "@Override protected void sendDispositionHeader(final OutputStream out) throws IOException {\n  LOG.trace(\"enter sendDispositionHeader(OutputStream out)\");\n  super.sendDispositionHeader(out);\n  final String filename=source.getFileName();\n  if (filename != null) {\n    out.write(FILE_NAME_BYTES);\n    out.write(QUOTE_BYTES);\n    out.write(EncodingUtil.getAsciiBytes(filename));\n    out.write(QUOTE_BYTES);\n  }\n}\n", "nl": "Write the disposition header to the output stream"}
{"code": "void traceError(Throwable e){\n  if (trace) {\n    e.printStackTrace();\n  }\n}\n", "nl": "Write the stack trace if trace is enabled."}
{"code": "public void statistics(Statistic stats){\n  log(Level.STATISTICS,stats.getKey() + \": \" + stats.formatValue());\n}\n", "nl": "Log a statistics object."}
{"code": "public LineView(Element elem){\n  super(elem);\n}\n", "nl": "Creates a LineView object."}
{"code": "public void enableVM(String hostname) throws IllegalStateException {\n  logger.info(\"Enabling VM \" + hostname);\n  assignableVMs.enableVM(hostname);\n}\n", "nl": "Enable the VM with the specified host name. Hosts start in an enabled state, so you only need to call this method if you have previously explicitly disabled the host."}
{"code": "private List<StoragePool> returnMatchedVNXPoolsForGivenAutoTieringPolicy(List<StoragePool> pools,String auto_tier_policy_name){\n  if (AutoTieringPolicy.VnxFastPolicy.DEFAULT_NO_MOVEMENT.toString().equalsIgnoreCase(auto_tier_policy_name)) {\n    _logger.info(\"Auto Tiering {} Matcher Ended  {} :\",auto_tier_policy_name,Joiner.on(\"\\t\").join(getNativeGuidFromPools(pools)));\n    return pools;\n  }\n  if (AutoTieringPolicy.VnxFastPolicy.DEFAULT_AUTOTIER.toString().equalsIgnoreCase(auto_tier_policy_name) || AutoTieringPolicy.VnxFastPolicy.DEFAULT_START_HIGH_THEN_AUTOTIER.toString().equalsIgnoreCase(auto_tier_policy_name)) {\n    return getMatchingPoolsForVNXAutoTier(pools,auto_tier_policy_name);\n  }\n  return runRankingAlgorithmToGetMatchedPoolsForHighAndLowTiers(auto_tier_policy_name,pools);\n}\n", "nl": "Ranking Algorithm to find matched Pools NO_DATA_MOVEMENT : return all the Pools AUTO_TIER : Find Pools which contains more than one tier, if not found return all the Pools HIGHEST_TIER: Find Pools which contains max tierPercentage looping through each Derive Type starting from SSD,FC,SAS,NL_SAS,SATA. If a pool is being found with max tier Percentage for a given drive type, return the matched Pool back.If more than one pool is having the same max tier percentage, then pass matching pools to find max tier Percentage for the next Drive Type, and continues till we get a single matched Pool or the processing of all drive Types is done. LOWEST_TIER: The same logic works , by passing drive Types in reverse order."}
{"code": "final public boolean isInLayout(){\n  return mInLayout;\n}\n", "nl": "Return true if the layout is included as part of an activity view hierarchy via the &lt;fragment&gt; tag.  This will always be true when fragments are created through the &lt;fragment&gt; tag, <em>except</em> in the case where an old fragment is restored from a previous state and it does not appear in the layout of the current state."}
{"code": "public void traverse(int pos,int top) throws org.xml.sax.SAXException {\n  while (DTM.NULL != pos) {\n    startNode(pos);\n    int nextNode=m_dtm.getFirstChild(pos);\n    while (DTM.NULL == nextNode) {\n      endNode(pos);\n      if ((DTM.NULL != top) && top == pos)       break;\n      nextNode=m_dtm.getNextSibling(pos);\n      if (DTM.NULL == nextNode) {\n        pos=m_dtm.getParent(pos);\n        if ((DTM.NULL == pos) || ((DTM.NULL != top) && (top == pos))) {\n          nextNode=DTM.NULL;\n          break;\n        }\n      }\n    }\n    pos=nextNode;\n  }\n}\n", "nl": "Perform a non-recursive pre-order/post-order traversal, operating as a Visitor. startNode (preorder) and endNode (postorder) are invoked for each node as we traverse over them, with the result that the node is written out to m_contentHandler."}
{"code": "public LatLng toLatLng(){\n  double OSGB_F0=0.9996012717;\n  double N0=-100000.0;\n  double E0=400000.0;\n  double phi0=Math.toRadians(49.0);\n  double lambda0=Math.toRadians(-2.0);\n  double a=RefEll.AIRY_1830.getMaj();\n  double b=RefEll.AIRY_1830.getMin();\n  double eSquared=RefEll.AIRY_1830.getEcc();\n  double phi=0.0;\n  double lambda=0.0;\n  double E=this.easting;\n  double N=this.northing;\n  double n=(a - b) / (a + b);\n  double M=0.0;\n  double phiPrime=((N - N0) / (a * OSGB_F0)) + phi0;\n  do {\n    M=(b * OSGB_F0) * (((1 + n + ((5.0 / 4.0) * n * n)+ ((5.0 / 4.0) * n * n* n)) * (phiPrime - phi0)) - (((3 * n) + (3 * n * n) + ((21.0 / 8.0) * n * n* n)) * Math.sin(phiPrime - phi0) * Math.cos(phiPrime + phi0)) + ((((15.0 / 8.0) * n * n) + ((15.0 / 8.0) * n * n* n)) * Math.sin(2.0 * (phiPrime - phi0)) * Math.cos(2.0 * (phiPrime + phi0))) - (((35.0 / 24.0) * n * n* n) * Math.sin(3.0 * (phiPrime - phi0)) * Math.cos(3.0 * (phiPrime + phi0))));\n    phiPrime+=(N - N0 - M) / (a * OSGB_F0);\n  }\n while ((N - N0 - M) >= 0.001);\n  double v=a * OSGB_F0 * Math.pow(1.0 - eSquared * Util.sinSquared(phiPrime),-0.5);\n  double rho=a * OSGB_F0 * (1.0 - eSquared)* Math.pow(1.0 - eSquared * Util.sinSquared(phiPrime),-1.5);\n  double etaSquared=(v / rho) - 1.0;\n  double VII=Math.tan(phiPrime) / (2 * rho * v);\n  double VIII=(Math.tan(phiPrime) / (24.0 * rho * Math.pow(v,3.0))) * (5.0 + (3.0 * Util.tanSquared(phiPrime)) + etaSquared - (9.0 * Util.tanSquared(phiPrime) * etaSquared));\n  double IX=(Math.tan(phiPrime) / (720.0 * rho * Math.pow(v,5.0))) * (61.0 + (90.0 * Util.tanSquared(phiPrime)) + (45.0 * Util.tanSquared(phiPrime) * Util.tanSquared(phiPrime)));\n  double X=Util.sec(phiPrime) / v;\n  double XI=(Util.sec(phiPrime) / (6.0 * v * v* v)) * ((v / rho) + (2 * Util.tanSquared(phiPrime)));\n  double XII=(Util.sec(phiPrime) / (120.0 * Math.pow(v,5.0))) * (5.0 + (28.0 * Util.tanSquared(phiPrime)) + (24.0 * Util.tanSquared(phiPrime) * Util.tanSquared(phiPrime)));\n  double XIIA=(Util.sec(phiPrime) / (5040.0 * Math.pow(v,7.0))) * (61.0 + (662.0 * Util.tanSquared(phiPrime)) + (1320.0 * Util.tanSquared(phiPrime) * Util.tanSquared(phiPrime))+ (720.0 * Util.tanSquared(phiPrime) * Util.tanSquared(phiPrime)* Util.tanSquared(phiPrime)));\n  phi=phiPrime - (VII * Math.pow(E - E0,2.0)) + (VIII * Math.pow(E - E0,4.0)) - (IX * Math.pow(E - E0,6.0));\n  lambda=lambda0 + (X * (E - E0)) - (XI * Math.pow(E - E0,3.0)) + (XII * Math.pow(E - E0,5.0)) - (XIIA * Math.pow(E - E0,7.0));\n  return new LatLng(Math.toDegrees(phi),Math.toDegrees(lambda));\n}\n", "nl": "Convert this OSGB grid reference to a latitude/longitude pair using the OSGB36 datum. Note that, the LatLng object may need to be converted to the WGS84 datum depending on the application."}
{"code": "public static String toSVG(Object... objects){\n  List<Object> flattened=new ArrayList<>();\n  for (  Object o : objects) {\n    if (o instanceof Polygon[]) {\n      flattened.addAll(Arrays.asList((Polygon[])o));\n    }\n else {\n      flattened.add(o);\n    }\n  }\n  double minLat=Double.POSITIVE_INFINITY;\n  double maxLat=Double.NEGATIVE_INFINITY;\n  double minLon=Double.POSITIVE_INFINITY;\n  double maxLon=Double.NEGATIVE_INFINITY;\n  for (  Object o : flattened) {\n    final Rectangle r;\n    if (o instanceof Polygon) {\n      r=Rectangle.fromPolygon(new Polygon[]{(Polygon)o});\n      minLat=Math.min(minLat,r.minLat);\n      maxLat=Math.max(maxLat,r.maxLat);\n      minLon=Math.min(minLon,r.minLon);\n      maxLon=Math.max(maxLon,r.maxLon);\n    }\n  }\n  if (Double.isFinite(minLat) == false || Double.isFinite(maxLat) == false || Double.isFinite(minLon) == false || Double.isFinite(maxLon) == false) {\n    throw new IllegalArgumentException(\"you must pass at least one polygon\");\n  }\n  double xpadding=(maxLon - minLon) / 64;\n  double ypadding=(maxLat - minLat) / 64;\n  double pointX=xpadding * 0.1;\n  double pointY=ypadding * 0.1;\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"640\\\" width=\\\"480\\\" viewBox=\\\"\");\n  sb.append(minLon - xpadding).append(\" \").append(90 - maxLat - ypadding).append(\" \").append(maxLon - minLon + (2 * xpadding)).append(\" \").append(maxLat - minLat + (2 * ypadding));\n  sb.append(\"\\\">\\n\");\n  for (  Object o : flattened) {\n    if (o instanceof double[]) {\n      double point[]=(double[])o;\n      sb.append(\"<!-- point: \");\n      sb.append(point[0] + \",\" + point[1]);\n      sb.append(\" -->\\n\");\n    }\n else {\n      sb.append(\"<!-- \" + o.getClass().getSimpleName() + \": \\n\");\n      sb.append(o.toString());\n      sb.append(\"\\n-->\\n\");\n    }\n    final Polygon gon;\n    final String style;\n    final String opacity;\n    if (o instanceof Rectangle) {\n      gon=boxPolygon((Rectangle)o);\n      style=\"fill:lightskyblue;stroke:black;stroke-width:0.2%;stroke-dasharray:0.5%,1%;\";\n      opacity=\"0.3\";\n    }\n else     if (o instanceof double[]) {\n      double point[]=(double[])o;\n      gon=boxPolygon(new Rectangle(Math.max(-90,point[0] - pointY),Math.min(90,point[0] + pointY),Math.max(-180,point[1] - pointX),Math.min(180,point[1] + pointX)));\n      style=\"fill:red;stroke:red;stroke-width:0.1%;\";\n      opacity=\"0.7\";\n    }\n else {\n      gon=(Polygon)o;\n      style=\"fill:lawngreen;stroke:black;stroke-width:0.3%;\";\n      opacity=\"0.5\";\n    }\n    double polyLats[]=gon.getPolyLats();\n    double polyLons[]=gon.getPolyLons();\n    sb.append(\"<polygon fill-opacity=\\\"\" + opacity + \"\\\" points=\\\"\");\n    for (int i=0; i < polyLats.length; i++) {\n      if (i > 0) {\n        sb.append(\" \");\n      }\n      sb.append(polyLons[i]).append(\",\").append(90 - polyLats[i]);\n    }\n    sb.append(\"\\\" style=\\\"\" + style + \"\\\"/>\\n\");\n    for (    Polygon hole : gon.getHoles()) {\n      double holeLats[]=hole.getPolyLats();\n      double holeLons[]=hole.getPolyLons();\n      sb.append(\"<polygon points=\\\"\");\n      for (int i=0; i < holeLats.length; i++) {\n        if (i > 0) {\n          sb.append(\" \");\n        }\n        sb.append(holeLons[i]).append(\",\").append(90 - holeLats[i]);\n      }\n      sb.append(\"\\\" style=\\\"fill:lightgray\\\"/>\\n\");\n    }\n  }\n  sb.append(\"</svg>\\n\");\n  return sb.toString();\n}\n", "nl": "Returns svg of polygon for debugging.  <p> You can pass any number of objects: Polygon: polygon with optional holes Polygon[]: arrays of polygons for convenience Rectangle: for a box double[2]: as latitude,longitude for a point <p> At least one object must be a polygon. The viewBox is formed around all polygons found in the arguments."}
{"code": "@SuppressWarnings(\"deprecation\") public void rewardMoney(Player player,int amount){\n  if (plugin.setUpEconomy(true)) {\n    try {\n      plugin.getEconomy().depositPlayer(player,amount);\n    }\n catch (    NoSuchMethodError e) {\n      plugin.getEconomy().depositPlayer(player.getName(),amount);\n    }\n    if (amount > 1)     player.sendMessage(plugin.getChatHeader() + ChatColor.translateAlternateColorCodes('&',plugin.getPluginLang().getString(\"money-reward-received\",\"You received: AMOUNT !\").replace(\"AMOUNT\",amount + \" \" + plugin.getEconomy().currencyNamePlural())));\n else     player.sendMessage(plugin.getChatHeader() + ChatColor.translateAlternateColorCodes('&',plugin.getPluginLang().getString(\"money-reward-received\",\"You received: AMOUNT !\").replace(\"AMOUNT\",amount + \" \" + plugin.getEconomy().currencyNameSingular())));\n  }\n}\n", "nl": "Give money reward to a player (specified in configuration file)."}
{"code": "public boolean isSmallestMinY(final PlanetModel planetModel){\n  if (minY == null)   return false;\n  return minY - planetModel.getMinimumYValue() < Vector.MINIMUM_RESOLUTION;\n}\n", "nl": "Return true if minY is as small as the planet model allows."}
{"code": "List<String> linesToStatements(List<String> lines){\n  List<String> statements=new ArrayList<>();\n  Delimiter nonStandardDelimiter=null;\n  CqlStatementBuilder cqlStatementBuilder=new CqlStatementBuilder();\n  for (int lineNumber=1; lineNumber <= lines.size(); lineNumber++) {\n    String line=lines.get(lineNumber - 1);\n    if (cqlStatementBuilder.isEmpty()) {\n      if (!StringUtils.hasText(line)) {\n        continue;\n      }\n      Delimiter newDelimiter=cqlStatementBuilder.extractNewDelimiterFromLine(line);\n      if (newDelimiter != null) {\n        nonStandardDelimiter=newDelimiter;\n        continue;\n      }\n      cqlStatementBuilder.setLineNumber(lineNumber);\n      if (nonStandardDelimiter != null) {\n        cqlStatementBuilder.setDelimiter(nonStandardDelimiter);\n      }\n    }\n    cqlStatementBuilder.addLine(line);\n    if (cqlStatementBuilder.isTerminated()) {\n      String cqlStatement=cqlStatementBuilder.getCqlStatement();\n      statements.add(cqlStatement);\n      LOG.debug(\"Found statement: \" + cqlStatement);\n      cqlStatementBuilder=new CqlStatementBuilder();\n    }\n else     if (cqlStatementBuilder.canDiscard()) {\n      cqlStatementBuilder=new CqlStatementBuilder();\n    }\n  }\n  if (!cqlStatementBuilder.isEmpty()) {\n    statements.add(cqlStatementBuilder.getCqlStatement());\n  }\n  return statements;\n}\n", "nl": "Turns these lines in a series of statements."}
{"code": "public NSDate(String textRepresentation) throws ParseException {\n  date=parseDateString(textRepresentation);\n}\n", "nl": "Parses a date from its textual representation. That representation has the following pattern: <code>yyyy-MM-dd'T'HH:mm:ss'Z'</code>"}
{"code": "public boolean textIsPresent(String courseWareErrorText,String text){\n  if (courseWareErrorText.equals(text)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}\n", "nl": "Verify that whether the text is present or not"}
{"code": "public IssueMatcher equals(URI expectedValue){\n  return addPropertyMatcher(URIPropertyMatcher.Mode.Equals,expectedValue);\n}\n", "nl": "Returns a URI property matcher that matches a URI property against the given URI."}
{"code": "boolean fitsIntoLong(boolean isPositive,boolean ignoreNegativeZero){\n  while (count > 0 && digits[count - 1] == '0') {\n    --count;\n  }\n  if (count == 0) {\n    return isPositive || ignoreNegativeZero;\n  }\n  if (decimalAt < count || decimalAt > MAX_COUNT) {\n    return false;\n  }\n  if (decimalAt < MAX_COUNT)   return true;\n  for (int i=0; i < count; ++i) {\n    char dig=digits[i], max=LONG_MIN_REP[i];\n    if (dig > max)     return false;\n    if (dig < max)     return true;\n  }\n  if (count < decimalAt)   return true;\n  return !isPositive;\n}\n", "nl": "Return true if the number represented by this object can fit into a long."}
{"code": "public LineIterator(final Reader reader) throws IllegalArgumentException {\n  if (reader == null) {\n    throw new IllegalArgumentException(\"Reader must not be null\");\n  }\n  if (reader instanceof BufferedReader) {\n    bufferedReader=(BufferedReader)reader;\n  }\n else {\n    bufferedReader=new BufferedReader(reader);\n  }\n}\n", "nl": "Constructs an iterator of the lines for a <code>Reader</code>."}
{"code": "private Patterns(){\n}\n", "nl": "Do not create this static utility class."}
{"code": "public static double pdf(double x,double location,double shape){\n  final double v=(x - location) / shape;\n  return 1. / (Math.PI * shape * (1 + v * v));\n}\n", "nl": "PDF function, static version."}
{"code": "@Deprecated public String templateName(){\n  return template == null ? null : template.getScript();\n}\n", "nl": "The name of the stored template"}
{"code": "public final int allocateNodeNumber(){\n  return numberOfNodes++;\n}\n", "nl": "Get the next node number"}
{"code": "public ActivityMap(ActivityMap parent){\n  m_map=new HashMap();\n  m_parent=parent;\n}\n", "nl": "Creates a new ActivityMap instance with the specified parent map."}
{"code": "void doVolunteerForPrimary(){\n  if (!beginVolunteering()) {\n    return;\n  }\n  boolean dlsDestroyed=false;\n  try {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Begin volunteerForPrimary for {}\",BucketAdvisor.this);\n    }\n    DistributedMemberLock thePrimaryLock=null;\n    while (continueVolunteering()) {\n      BucketAdvisor parentBA=parentAdvisor;\n      BucketAdvisor.this.activePrimaryMoveLock.lock();\n      try {\n        boolean acquiredLock=false;\n        getAdvisee().getCancelCriterion().checkCancelInProgress(null);\n        if (parentBA != null) {\n          if (parentBA.isPrimary() && !isPrimary()) {\n            acquiredLock=acquiredPrimaryLock();\n          }\n else {\n            return;\n          }\n        }\n else {\n          if (startingBucketAdvisor == null) {\n            assignStartingBucketAdvisor();\n          }\n          if (startingBucketAdvisor != null) {\n            Assert.assertHoldsLock(this,false);\nsynchronized (startingBucketAdvisor) {\n              if (startingBucketAdvisor.isPrimary() && !isPrimary()) {\n                acquiredLock=acquiredPrimaryLock();\n              }\n else {\n                return;\n              }\n            }\n          }\n else {\n            if (thePrimaryLock == null) {\n              thePrimaryLock=getPrimaryLock(true);\n              if (thePrimaryLock == null) {\n                return;\n              }\n            }\n            Assert.assertTrue(!thePrimaryLock.holdsLock());\n            if (isAggressive()) {\n              acquiredLock=thePrimaryLock.tryLock(Long.MAX_VALUE,TimeUnit.MILLISECONDS);\n            }\n else {\n              acquiredLock=thePrimaryLock.tryLock();\n            }\n            if (acquiredLock) {\n              acquiredLock=acquiredPrimaryLock();\n            }\n          }\n        }\n        if (acquiredLock) {\n          acquirePrimaryRecursivelyForColocated();\n          acquirePrimaryForRestOfTheBucket();\n          return;\n        }\n      }\n  finally {\n        BucketAdvisor.this.activePrimaryMoveLock.unlock();\n      }\n      if (!continueVolunteering()) {\n        return;\n      }\n      waitIfNoPrimaryMemberFound();\n    }\n  }\n catch (  LockServiceDestroyedException e) {\n    dlsDestroyed=true;\n    handleException(e,true);\n  }\ncatch (  RegionDestroyedException e) {\n    handleException(e,false);\n  }\ncatch (  CancelException e) {\n    handleException(e,false);\n  }\ncatch (  InterruptedException e) {\n    Thread.currentThread().interrupt();\n    handleException(e,false);\n  }\n finally {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Exit volunteerForPrimary for {}; dlsDestroyed={}\",BucketAdvisor.this,dlsDestroyed);\n    }\n    endVolunteering();\n  }\n}\n", "nl": "Invoked by the thread that performs the actual volunteering work."}
{"code": "public static byte[] decodeHex(String hexString){\n  int length=hexString.length();\n  if ((length & 0x01) != 0) {\n    throw new IllegalArgumentException(\"Odd number of characters.\");\n  }\n  boolean badHex=false;\n  byte[] out=new byte[length >> 1];\n  for (int i=0, j=0; j < length; i++) {\n    int c1=hexString.charAt(j++);\n    if (c1 > 'f') {\n      badHex=true;\n      break;\n    }\n    final byte d1=DIGITS[c1];\n    if (d1 == -1) {\n      badHex=true;\n      break;\n    }\n    int c2=hexString.charAt(j++);\n    if (c2 > 'f') {\n      badHex=true;\n      break;\n    }\n    final byte d2=DIGITS[c2];\n    if (d2 == -1) {\n      badHex=true;\n      break;\n    }\n    out[i]=(byte)(d1 << 4 | d2);\n  }\n  if (badHex) {\n    throw new IllegalArgumentException(\"Invalid hexadecimal digit: \" + hexString);\n  }\n  return out;\n}\n", "nl": "Quickly converts a hexadecimal string to a byte array."}
{"code": "public boolean isSortingProperties(){\n  return sortingProperties;\n}\n", "nl": "Get whether this model is currently sorting properties."}
{"code": "private void startQuest(){\n  setTimings();\n  getPhases().add(new InactivePhase(timings));\n  getPhases().add(new InvasionPhase(timings));\n  getPhases().add(new AwaitingPhase(timings));\n  setNewNotificationTime(getDefaultPhaseClass().getMinTimeOut(),getDefaultPhaseClass().getMaxTimeOut());\n}\n", "nl": "first start"}
{"code": "public String toleranceTipText(){\n  return \"tolerance parameter used for checking stopping criterion b.up < b.low + 2 tol\";\n}\n", "nl": "Returns the tip text for this property"}
{"code": "protected List<MemoryPoolMXBean> loadRawDatas(Map<Object,Object> userData){\n  return ManagementFactory.getMemoryPoolMXBeans();\n}\n", "nl": "Call ManagementFactory.getMemoryPoolMXBeans() to load the raw data of this table."}
{"code": "public static Schema load(final JSONObject schemaJson,final SchemaClient httpClient){\n  SchemaLoader loader=builder().schemaJson(schemaJson).httpClient(httpClient).build();\n  return loader.load().build();\n}\n", "nl": "Creates Schema instance from its JSON representation."}
{"code": "public static CommandResult execCommand(String command,boolean isRoot,boolean isNeedResultMsg){\n  return execCommand(new String[]{command},isRoot,isNeedResultMsg);\n}\n", "nl": "execute shell command"}
{"code": "public OMColor(int a,int r,int g,int b){\n  super(r,g,b);\n  argb=(a << 24) | ((r & 0xFF) << 16) | ((g & 0xFF) << 8)| ((b & 0xFF) << 0);\n}\n", "nl": "Create a color with the specified alpha, red, green, and blue components. The four arguments must each be in the range 0-255. //"}
{"code": "public boolean merge(final Frame<? extends V> frame,final boolean[] access){\n  boolean changes=false;\n  for (int i=0; i < locals; ++i) {\n    if (!access[i] && !values[i].equals(frame.values[i])) {\n      values[i]=frame.values[i];\n      changes=true;\n    }\n  }\n  return changes;\n}\n", "nl": "Merges this frame with the given frame (case of a RET instruction)."}
{"code": "public static void assign(int[] n1,int n2[]){\n  int idx=n1.length - 1;\n  int i;\n  for (i=n2.length - 1; i >= 0; i--) {\n    n1[idx--]=n2[i];\n  }\n  while (idx > 0) {\n    n1[idx--]=0;\n  }\n}\n", "nl": "Assign n1 to be the same value as n2. n1's length must be >= n2's length"}
{"code": "@SuppressWarnings(\"unchecked\") public static <K,V>Map<K,V> mapOf(Object... keyValPair){\n  if (keyValPair.length % 2 != 0)   throw new IllegalArgumentException(\"Keys and values must be in pairs\");\n  Map<K,V> map=new HashMap<K,V>(keyValPair.length / 2);\n  for (int i=0; i < keyValPair.length; i+=2) {\n    map.put((K)keyValPair[i],(V)keyValPair[i + 1]);\n  }\n  return map;\n}\n", "nl": "Constructs a map of the key-value pairs, passed as parameters"}
{"code": "@Deprecated @Override public boolean commit() throws InstantiationError {\n  if (mEditor != null) {\n    return mEditor.commit();\n  }\n  throw new InstantiationError(\"\\n ======================================== \\nError : \" + \"Do not call \" + tag + \"'s `commit()`.\"+ \"\\n This method is not supported directly.\"+ \" \\n ======================================== \\n\");\n}\n", "nl": "<h1><u>Do not use this method</u></h1> <br>"}
{"code": "private static double createSubscore(double value,double bestValue,double variance,double bias,boolean ignoreSign){\n  return Math.min(MathUtil.normalPDFNormalized((ignoreSign ? value - bestValue : Math.max((value - bestValue),0)) / bestValue,variance,0) * bias,bias);\n}\n", "nl": "Create a normalized subscore around a current and expected value, using the normalized Normal CDF. <p/> This function is derived from the statistical probability of achieving the optimal value. Values that are less than the best value will return the best subscore, or the bias (unless ignoreSign = true)."}
{"code": "public void append(StringBuffer buffer,String fieldName,boolean[] array,Boolean fullDetail){\n  appendFieldStart(buffer,fieldName);\n  if (array == null) {\n    appendNullText(buffer,fieldName);\n  }\n else   if (isFullDetail(fullDetail)) {\n    appendDetail(buffer,fieldName,array);\n  }\n else {\n    appendSummary(buffer,fieldName,array);\n  }\n  appendFieldEnd(buffer,fieldName);\n}\n", "nl": "<p>Append to the <code>toString</code> a <code>boolean</code> array.</p>"}
{"code": "@CanIgnoreReturnValue @Override public boolean put(@Nullable K key,@Nullable V value){\n  addNode(key,value,null);\n  return true;\n}\n", "nl": "Stores a key-value pair in the multimap."}
{"code": "public void ReInit(SimpleCharStream stream,int lexState){\n  ReInit(stream);\n  SwitchTo(lexState);\n}\n", "nl": "Reinitialise parser."}
{"code": "public static RPairList create(int size){\n  return create(size,null);\n}\n", "nl": "Creates a new pair list of given size > 0. Note: pair list of size 0 is NULL."}
{"code": "public WebgraphConfiguration(final File configurationFile,boolean lazy) throws IOException {\n  super(configurationFile);\n  this.lazy=lazy;\n  if (this.isEmpty())   return;\n  Iterator<Entry> it=this.entryIterator();\n  for (SchemaConfiguration.Entry etr=it.next(); it.hasNext(); etr=it.next()) {\n    try {\n      WebgraphSchema f=WebgraphSchema.valueOf(etr.key());\n      f.setSolrFieldName(etr.getValue());\n    }\n catch (    final IllegalArgumentException e) {\n      ConcurrentLog.fine(\"SolrWebgraphWriter\",\"solr schema file \" + configurationFile.getAbsolutePath() + \" defines unknown attribute '\"+ etr.toString()+ \"'\");\n      it.remove();\n    }\n  }\n  for (  SchemaDeclaration field : WebgraphSchema.values()) {\n    if (this.get(field.name()) == null) {\n      ConcurrentLog.warn(\"SolrWebgraphWriter\",\" solr schema file \" + configurationFile.getAbsolutePath() + \" is missing declaration for '\"+ field.name()+ \"'\");\n    }\n  }\n}\n", "nl": "initialize the schema with a given configuration file the configuration file simply contains a list of lines with keywords or keyword = value lines (while value is a custom Solr field name"}
{"code": "public void testPingPongShortSegments(){\n  PseudoTcpTestPingPong test=new PseudoTcpTestPingPong();\n  test.setLocalMtu(1500);\n  test.setRemoteMtu(1500);\n  test.setOptAckDelay(5000);\n  test.setBytesPerSend(50);\n  test.doTestPingPong(100,5);\n}\n", "nl": "Test sending a ping as pair of short (non-full) segments. Should take ~1s, due to Delayed ACK interaction with Nagling."}
{"code": "protected void messageLoop(){\n  try {\n    byte[] buffer=new byte[40000];\n    while (isConnected()) {\n      int numRead=socket.getInputStream().read(buffer);\n      if (numRead > 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"TimesealSocketMessageProducer \" + \"Read \" + numRead + \" bytes.\");\n        }\n        String text=isTimesealOn ? handleTimeseal(new String(buffer,0,numRead)) : new String(buffer,0,numRead);\n        if (StringUtils.isNotBlank(text)) {\n          inboundMessageBuffer.append(IcsUtils.cleanupMessage(text));\n          listener.messageArrived(inboundMessageBuffer);\n        }\n      }\n else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"TimesealSocketMessageProducer  \" + \"Read 0 bytes disconnecting.\");\n        }\n        close();\n        break;\n      }\n    }\n    LOG.debug(\"TimesealSocketMessageProducer \" + \"Not connected disconnecting.\");\n  }\n catch (  Throwable t) {\n    if (t instanceof IOException) {\n      LOG.debug(\"TimesealSocketMessageProducer \" + \"Connector \" + \"IOException occured in messageLoop (These are common when disconnecting and ignorable)\",t);\n    }\n else {\n      listener.onError(\"TimesealSocketMessageProducer \" + \"Connector Error in DaemonRun Thwoable\",t);\n    }\n    close();\n  }\n finally {\n    LOG.debug(\"TimesealSocketMessageProducer  Leaving readInput\");\n  }\n}\n", "nl": "The messageLoop. Reads the inputChannel and then invokes publishInput with the text read. Should really never be invoked."}
{"code": "public void useDropdownVisibleText(String locator,String option){\n  Select select=new Select(findElement(locator));\n  select.selectByVisibleText(option);\n}\n", "nl": "useDropdownVisibleText -"}
{"code": "public HdfsFileIO(URI uri,TungstenProperties props){\n  this.uri=uri;\n  hdfsConfig=new Configuration();\n  for (  String key : props.keyNames()) {\n    String value=props.get(key);\n    hdfsConfig.set(key,value);\n  }\n  try {\n    this.hdfs=FileSystem.get(uri,hdfsConfig);\n  }\n catch (  IOException e) {\n    throw new FileIOException(\"Unable to access HDFS: uri=\" + uri + \" message=\"+ e.getMessage(),e);\n  }\n}\n", "nl": "Creates a new instance with connection to HDFS."}
{"code": "public Constant(long value){\n  this(Long.class,value);\n}\n", "nl": "Constructs a new node for defining a constant integer value."}
{"code": "public static ConversionMethod toConversionMethod(XmlConversion xmlConversion){\n  if (isEmpty(xmlConversion.name)) {\n    xmlConversion.name=\"undefinedName\";\n    throw new XmlConversionNameException(\"it's mandatory define a name\");\n  }\n  String name=xmlConversion.name;\n  String conversionType=xmlConversion.type;\n  boolean avoidSet=xmlConversion.avoidSet;\n  Type type=conversionType == null ? JMapConversion.Type.STATIC : conversionType.equalsIgnoreCase(\"STATIC\") ? Type.STATIC : conversionType.equalsIgnoreCase(\"DYNAMIC\") ? Type.DYNAMIC : null;\n  if (type == null)   throw new XmlConversionTypeException(\"wrong type defined, only STATIC and DYNAMIC options are permitted\");\n  String[] from=xmlConversion.from == null ? new String[]{ALL} : trim(xmlConversion.from.split(\",\"));\n  String[] to=xmlConversion.to == null ? new String[]{ALL} : trim(xmlConversion.to.split(\",\"));\n  String content=xmlConversion.content.trim();\n  if (!content.contains(source) && content.contains(destination))   throw new XmlConversionParameterException(\"the use of the destination isn't permitted without the use of the source\");\n  ParameterNumber number=content.contains(source) ? content.contains(destination) ? TWO : ONE : ZERO;\n  return new ConversionMethod(name,from,to,type,number,content,avoidSet);\n}\n", "nl": "This method transforms a XmlConversion given in input, into a ConversionMethod."}
{"code": "public final int pop(){\n  m_firstFree--;\n  int n=m_map[m_firstFree];\n  m_map[m_firstFree]=DTM.NULL;\n  return n;\n}\n", "nl": "Pop a node from the tail of the vector and return the result."}
{"code": "public static void main(String[] args) throws AdeException {\n  final AdeExtRequestType requestType=AdeExtRequestType.CONTROL_DB;\n  System.err.println(\"Running Ade: \" + requestType);\n  final AdeExtMessageHandler messageHandler=new AdeExtMessageHandler();\n  final ControlDB controlDB=new ControlDB();\n  try {\n    controlDB.run(args);\n  }\n catch (  AdeUsageException e) {\n    messageHandler.handleUserException(e);\n  }\ncatch (  AdeInternalException e) {\n    messageHandler.handleAdeInternalException(e);\n  }\ncatch (  AdeException e) {\n    messageHandler.handleAdeException(e);\n  }\ncatch (  Throwable e) {\n    messageHandler.handleUnexpectedException(e);\n  }\n finally {\n    controlDB.quietCleanup();\n  }\n}\n", "nl": "The entry point of ControlDB"}
{"code": "private int[] locate(int number){\n  return new int[]{number >> SHIFT,number & MOD};\n}\n", "nl": "Locate the bit position of given number."}
{"code": "public Container add(String label){\n  return add(new Label(label));\n}\n", "nl": "Simpler version of addComponent that allows chaining the calls for shorter syntax"}
{"code": "public final void yyclose() throws java.io.IOException {\n  zzAtEOF=true;\n  zzEndRead=zzStartRead;\n  if (zzReader != null)   zzReader.close();\n}\n", "nl": "Closes the input stream."}
{"code": "public static void clear(){\n  PM.clear();\n  ConfigBean config=getConfig();\n  if (config == null || !Env.APP_SETTINGS.get(Settings.INITIAL_PER_MIN_CALC_EXCL_TIME).equals(config.getInitialPerMinCalcExclTime())) {\n    try {\n      Files.deleteIfExists(PATH_CONFIG_BEAN);\n    }\n catch (    final IOException ie) {\n      Env.LOGGER.error(\"Failed to delete replay processor cache config: \" + PATH_CONFIG_BEAN,ie);\n    }\n    config=new ConfigBean();\n    config.setInitialPerMinCalcExclTime(Env.APP_SETTINGS.get(Settings.INITIAL_PER_MIN_CALC_EXCL_TIME));\n    setConfig(config);\n  }\n}\n", "nl": "Clears the replay processor cache."}
{"code": "public void runRaptorScheduled(TIntIntMap initialStops,int departureTime){\n  long startClockTime=System.currentTimeMillis();\n  max_time=departureTime + req.maxTripDurationMinutes * 60;\n  round=0;\n  patternsTouchedThisRound.clear();\n  stopsTouchedThisSearch.clear();\n  stopsTouchedThisRound.clear();\n  TIntIntIterator iterator=initialStops.iterator();\n  while (iterator.hasNext()) {\n    iterator.advance();\n    int stopIndex=iterator.key();\n    int time=iterator.value() + departureTime;\n    RaptorState state=scheduleState.get(0);\n    if (time < state.bestTimes[stopIndex]) {\n      state.bestTimes[stopIndex]=time;\n      state.transferStop[stopIndex]=-1;\n      markPatternsForStop(stopIndex);\n    }\n  }\n  advanceToNextRound();\n  while (doOneRound(scheduleState.get(round - 1),scheduleState.get(round),false,null) && round < req.maxRides) {\n    advanceToNextRound();\n  }\n  scheduledRounds=Math.max(round + 1,scheduledRounds);\n  while (round < scheduleState.size() - 1) {\n    scheduleState.get(round + 1).min(scheduleState.get(round));\n    round++;\n  }\n  scheduledSearchTime+=System.currentTimeMillis() - startClockTime;\n}\n", "nl": "Run a raptor search on all scheduled routes, ignoring any frequency-based routes. The output of this process will be stored in the scheduleState field."}
{"code": "public static boolean isSameLength(byte[] array1,byte[] array2){\n  if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {\n    return false;\n  }\n  return true;\n}\n", "nl": "<p>Checks whether two arrays are the same length, treating <code>null</code> arrays as length <code>0</code>.</p>"}
{"code": "public ArrayBackedByteBuffer(final byte[] buf,final int ofs,final int pos,final int siz){\n  this.buf=buf;\n  this.ofs=ofs;\n  this.pos=pos;\n  this.siz=siz;\n}\n", "nl": "Create a new ByteBuffer from an existing array"}
{"code": "private void startInvalidGrid(String name){\n  try {\n    startGrid(name);\n    assert false : \"Exception should have been thrown.\";\n  }\n catch (  Exception e) {\n    info(\"Caught expected exception: \" + e);\n  }\n}\n", "nl": "Starts grid that will fail to start due to invalid configuration."}
{"code": "static float interpolate(final float x,final float xmin,final float xmax,final float ymin,final float ymax){\n  return ((x - xmin) * (ymax - ymin) / (xmax - xmin)) + ymin;\n}\n", "nl": "Preform interpolation on the given values."}
{"code": "void pointToCellRounded(int x,int y,int[] result){\n  pointToCellExact(x + (mCellWidth / 2),y + (mCellHeight / 2),result);\n}\n", "nl": "Given a point, return the cell that most closely encloses that point"}
{"code": "public static String findPath(Class<?> context) throws IllegalStateException {\n  if (context == null) {\n    context=DynamicJarPathFinder.class;\n  }\n  String rawName=context.getName();\n  String classFileName;\n{\n    int idx=rawName.lastIndexOf('.');\n    classFileName=(idx == -1 ? rawName : rawName.substring(idx + 1)) + \".class\";\n  }\n  String uri=context.getResource(classFileName).toString();\n  if (uri.startsWith(\"file:\")) {\n    LOG.warn(\"This class has been loaded from a directory and not from a jar file: {}\",uri);\n    String fileName=null;\n    try {\n      fileName=URLDecoder.decode(uri.substring(\"file:\".length(),uri.length()),Charset.defaultCharset().name());\n      return new File(fileName).getAbsolutePath();\n    }\n catch (    UnsupportedEncodingException e) {\n      throw new InternalError(\"default charset doesn't exist. Your VM is borked.\");\n    }\n  }\n  if (!uri.startsWith(\"jar:file:\")) {\n    int idx=uri.indexOf(':');\n    String protocol=idx == -1 ? \"(unknown)\" : uri.substring(0,idx);\n    throw new IllegalStateException(\"This class has been loaded remotely via the \" + protocol + \" protocol. Only loading from a jar on the local file system is supported.\");\n  }\n  int idx=uri.indexOf('!');\n  if (idx == -1) {\n    throw new IllegalStateException(\"You appear to have loaded this class from a local jar file, but I can't make sense of the URL!\");\n  }\n  try {\n    String fileName=URLDecoder.decode(uri.substring(\"jar:file:\".length(),idx),Charset.defaultCharset().name());\n    return new File(fileName).getAbsolutePath();\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new InternalError(\"default charset doesn't exist. Your VM is borked.\");\n  }\n}\n", "nl": "Similar to JarPathFinder, but not make sure the path must valid jar."}
{"code": "public ISourceViewer publicGetSourceViewer(){\n  return this.getSourceViewer();\n}\n", "nl": "Simon put OpenDeclarationHandler as a subclass of TLAEditor because that handler needed to use AbstractTextEditor's getSourceViewer method, inherited by TLAEditor, but that's a private method.  To avoid having to put ShowUsesHandler and all other classes that might want to use getSourceViewer() in TLAEditor, LL defined  the following method that provides it to the public at large."}
{"code": "protected double computeRandomProjection(int rpIndex,int classIndex,Instance instance){\n  double sum=0.0;\n  for (int i=0; i < instance.numValues(); i++) {\n    int index=instance.index(i);\n    if (index != classIndex) {\n      double value=instance.valueSparse(i);\n      if (!Utils.isMissingValue(value)) {\n        sum+=m_rmatrix[rpIndex][index] * value;\n      }\n    }\n  }\n  return sum;\n}\n", "nl": "computes one random projection for a given instance (skip missing values)"}
{"code": "protected static void addStreamsOptions(ContextMenu m,int numStreams,boolean join){\n  String count=\"\";\n  String s=\"\";\n  if (numStreams > 1) {\n    s=\"s\";\n    count=String.valueOf(numStreams) + \" \";\n  }\n  String streamSubmenu=\"Twitch Stream\" + s;\n  String miscSubmenu=\"Miscellaneous\";\n  m.setSubMenuIcon(streamSubmenu,ICON_SPACING);\n  m.addSubItem(\"stream\",\"Normal\",streamSubmenu);\n  m.addSubItem(\"streamPopout\",\"Popout\",streamSubmenu);\n  m.addSeparator(streamSubmenu);\n  m.addSubItem(\"streamsMultitwitchtv\",\"Multitwitch.tv\",streamSubmenu);\n  m.addSubItem(\"streamsSpeedruntv\",\"Speedrun.tv\",streamSubmenu);\n  m.addSubItem(\"streamsKadgar\",\"Kadgar.net\",streamSubmenu);\n  addLivestreamerOptions(m);\n  if (join) {\n    m.addSeparator();\n    m.addItem(\"join\",\"Join \" + count + \"channel\"+ s);\n    m.addSeparator();\n    m.addSubItem(\"hostchannel\",\"Host Channel\",miscSubmenu);\n    m.addSeparator(miscSubmenu);\n    m.addSubItem(\"copy\",\"Copy Stream Name\",miscSubmenu);\n    m.addSeparator(miscSubmenu);\n    m.addSubItem(\"follow\",\"Follow Channel\",miscSubmenu);\n    m.addSubItem(\"unfollow\",\"Unfollow Channel\",miscSubmenu);\n  }\n}\n", "nl": "Adds menu items to the given ContextMenu that provide ways to do stream related stuff."}
{"code": "private MessagingUseBehavior(String publicMessage,String privateMessage){\n  this.publicMessage=publicMessage;\n  this.privateMessage=privateMessage;\n  if ((publicMessage == null) && (privateMessage == null)) {\n    LOGGER.warn(\"MessagingUseBehavior with no messages\");\n  }\n}\n", "nl": "Create a new MessagingUseBehavior with specified public and private messages. Either of those can be <code>null</code>, but a warning is logged if neither is specified."}
{"code": "@Override public void addMouseListener(MouseListener l){\n}\n", "nl": "No one may add mouse listeners, not even Swing!"}
{"code": "public LocatorDUnitTest(){\n  super();\n}\n", "nl": "Creates a new <code>LocatorDUnitTest</code>"}
{"code": "public Bundler putParcelableArray(String key,Parcelable[] value){\n  bundle.putParcelableArray(key,value);\n  return this;\n}\n", "nl": "Inserts an array of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "public boolean isMtuMismatch(){\n  return mtuMismatch;\n}\n", "nl": "Gets the value of the mtuMismatch property."}
{"code": "public RawByteCache(File cacheDir,long maxCacheBytes,long maxObjectBytes,int maxOpenFiles){\n  this.cacheDir=cacheDir;\n  this.maxCacheBytes=maxCacheBytes;\n  this.maxObjectBytes=maxObjectBytes;\n  this.maxOpenFiles=maxOpenFiles;\n}\n", "nl": "Instantiates a new cache."}
{"code": "protected final void CAST_Encipher(int L0,int R0,int result[]){\n  int Lp=L0;\n  int Rp=R0;\n  int Li=L0, Ri=R0;\n  for (int i=1; i <= _rounds; i++) {\n    Lp=Li;\n    Rp=Ri;\n    Li=Rp;\nswitch (i) {\ncase 1:\ncase 4:\ncase 7:\ncase 10:\ncase 13:\ncase 16:\n      Ri=Lp ^ F1(Rp,_Km[i],_Kr[i]);\n    break;\ncase 2:\ncase 5:\ncase 8:\ncase 11:\ncase 14:\n  Ri=Lp ^ F2(Rp,_Km[i],_Kr[i]);\nbreak;\ncase 3:\ncase 6:\ncase 9:\ncase 12:\ncase 15:\nRi=Lp ^ F3(Rp,_Km[i],_Kr[i]);\nbreak;\n}\n}\nresult[0]=Ri;\nresult[1]=Li;\nreturn;\n}\n", "nl": "Does the 16 rounds to encrypt the block."}
{"code": "public final float determinant(){\n  float det;\n  det=m00 * (m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32 - m13 * m22 * m31 - m11 * m23 * m32 - m12 * m21 * m33);\n  det-=m01 * (m10 * m22 * m33 + m12 * m23 * m30 + m13 * m20 * m32 - m13 * m22 * m30 - m10 * m23 * m32 - m12 * m20 * m33);\n  det+=m02 * (m10 * m21 * m33 + m11 * m23 * m30 + m13 * m20 * m31 - m13 * m21 * m30 - m10 * m23 * m31 - m11 * m20 * m33);\n  det-=m03 * (m10 * m21 * m32 + m11 * m22 * m30 + m12 * m20 * m31 - m12 * m21 * m30 - m10 * m22 * m31 - m11 * m20 * m32);\n  return (det);\n}\n", "nl": "Computes the determinate of this matrix."}
{"code": "public int addBarPlot(String name,Color color,double[][] XY){\n  return ((Plot2DCanvas)plotCanvas).addBarPlot(name,color,XY);\n}\n", "nl": "Adds a bar plot (each data point is shown as a dot marker connected to the horizontal axis by a vertical line) to the current plot panel."}
{"code": "public static double L_RankLoss(int y[],int r[]){\n  int L=y.length;\n  ArrayList<Integer> tI=new ArrayList<Integer>();\n  ArrayList<Integer> fI=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      tI.add(j);\n    }\n else {\n      fI.add(j);\n    }\n  }\n  if (!tI.isEmpty() && !fI.isEmpty()) {\n    int c=0;\n    for (    int k : tI) {\n      for (      int l : fI) {\n        if (position(k,r) < position(l,r)) {\n          c++;\n        }\n      }\n    }\n    return (double)c / (double)(tI.size() * fI.size());\n  }\n else {\n    return 0.0;\n  }\n}\n", "nl": "Rank Loss - the average fraction of labels which are not correctly ordered. Thanks to Noureddine Yacine NAIR BENREKIA for providing bug fix for this."}
{"code": "public Headers responseHeaders(){\n  return mResponseHeaders;\n}\n", "nl": "Get response headers."}
{"code": "@Override protected void applyEditorTo(WeaveConfiguration runnerConfiguration) throws ConfigurationException {\n  runnerConfiguration.setWeaveOutput(this.configurationPanel.getOutput().getText());\n  runnerConfiguration.setWeaveFile(this.configurationPanel.getWeaveFile().getText());\n  runnerConfiguration.setMuleHome(this.configurationPanel.getWeaveHome().getText());\n  final Module selectedModule=this.configurationPanel.getModuleCombo().getSelectedModule();\n  if (selectedModule != null) {\n    runnerConfiguration.setModule(selectedModule);\n  }\n  runnerConfiguration.setWeaveInputs(this.configurationPanel.getWeaveInputs().getItems());\n}\n", "nl": "This is invoked when the user fills the form and pushes apply/ok"}
{"code": "@Override protected void internalAdd(final TemplatePersistenceData data){\n  if (!data.isCustom()) {\n    final String id=getNewIdFromId(data.getId());\n    final TemplatePersistenceData d2=new TemplatePersistenceData(data.getTemplate(),true,id);\n    super.internalAdd(d2);\n  }\n}\n", "nl": "Adds a template to the internal store. The added templates must have a unique id."}
{"code": "@Override public void run2(){\n  try {\n    boolean warningLogged=false;\n    while (this.allBucketsRecoveredFromDisk.getCount() > 0) {\n      int sleepMillis=SLEEP_PERIOD;\n      if (!warningLogged) {\n        sleepMillis=SLEEP_PERIOD / 2;\n      }\n      Thread.sleep(sleepMillis);\n      if (this.membershipChanged) {\n        this.membershipChanged=false;\n        for (        RegionStatus region : regions) {\n          region.logWaitingForMembers();\n        }\n        warningLogged=true;\n      }\n    }\n  }\n catch (  InterruptedException e) {\n    logger.error(e.getMessage(),e);\n  }\n finally {\n    removeListeners();\n    for (    RegionStatus region : regions) {\n      if (!region.loggedDoneMessage) {\n        region.logDoneMessage();\n      }\n    }\n  }\n}\n", "nl": "Writes a consolidated log entry every SLEEP_PERIOD that summarizes which buckets are still waiting on persistent members for the region."}
{"code": "public Vector4d negate(){\n  x=-x;\n  y=-y;\n  z=-z;\n  w=-w;\n  return this;\n}\n", "nl": "Negate this vector."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "private void initializeLiveAttributes(){\n  externalResourcesRequired=createLiveAnimatedBoolean(null,SVG_EXTERNAL_RESOURCES_REQUIRED_ATTRIBUTE,false);\n}\n", "nl": "Initializes the live attribute values of this element."}
{"code": "private String replaceReservedChars(boolean isTableResponseType,String str){\n  if (str == null) {\n    return EMPTY_COLUMN_VALUE;\n  }\n  return (!isTableResponseType) ? str : str.replace(TAB,WHITESPACE).replace(NEWLINE,WHITESPACE);\n}\n", "nl": "For %table response replace Tab and Newline characters from the content."}
{"code": "public double metersToPixels(){\n  double screenCenterLat=screenTopLeft.latitude - screenSize.latitude / 2;\n  double metersToLon=1 / (Util.LON_TO_METERS_AT_EQUATOR * Math.cos(screenCenterLat / 180 * Math.PI));\n  return screenSize.longitude / windowWidth * metersToLon;\n}\n", "nl": "Returns the ratio of meters to pixels at the center of the screen"}
{"code": "public static boolean isAssignable(Type lhsType,Type rhsType){\n  Assert.notNull(lhsType,\"Left-hand side type must not be null\");\n  Assert.notNull(rhsType,\"Right-hand side type must not be null\");\n  if (lhsType.equals(rhsType) || lhsType.equals(Object.class)) {\n    return true;\n  }\n  if (lhsType instanceof Class<?>) {\n    Class<?> lhsClass=(Class<?>)lhsType;\n    if (rhsType instanceof Class<?>) {\n      return ClassUtils.isAssignable(lhsClass,(Class<?>)rhsType);\n    }\n    if (rhsType instanceof ParameterizedType) {\n      Type rhsRaw=((ParameterizedType)rhsType).getRawType();\n      if (rhsRaw instanceof Class<?>) {\n        return ClassUtils.isAssignable(lhsClass,(Class<?>)rhsRaw);\n      }\n    }\n else     if (lhsClass.isArray() && rhsType instanceof GenericArrayType) {\n      Type rhsComponent=((GenericArrayType)rhsType).getGenericComponentType();\n      return isAssignable(lhsClass.getComponentType(),rhsComponent);\n    }\n  }\n  if (lhsType instanceof ParameterizedType) {\n    if (rhsType instanceof Class<?>) {\n      Type lhsRaw=((ParameterizedType)lhsType).getRawType();\n      if (lhsRaw instanceof Class<?>) {\n        return ClassUtils.isAssignable((Class<?>)lhsRaw,(Class<?>)rhsType);\n      }\n    }\n else     if (rhsType instanceof ParameterizedType) {\n      return isAssignable((ParameterizedType)lhsType,(ParameterizedType)rhsType);\n    }\n  }\n  if (lhsType instanceof GenericArrayType) {\n    Type lhsComponent=((GenericArrayType)lhsType).getGenericComponentType();\n    if (rhsType instanceof Class<?>) {\n      Class<?> rhsClass=(Class<?>)rhsType;\n      if (rhsClass.isArray()) {\n        return isAssignable(lhsComponent,rhsClass.getComponentType());\n      }\n    }\n else     if (rhsType instanceof GenericArrayType) {\n      Type rhsComponent=((GenericArrayType)rhsType).getGenericComponentType();\n      return isAssignable(lhsComponent,rhsComponent);\n    }\n  }\n  if (lhsType instanceof WildcardType) {\n    return isAssignable((WildcardType)lhsType,rhsType);\n  }\n  return false;\n}\n", "nl": "Check if the right-hand side type may be assigned to the left-hand side type following the Java generics rules."}
{"code": "private Algorithm instantiateAlgorithm(AlgorithmProvider provider,String name,Properties properties,Problem problem){\n  try {\n    return provider.getAlgorithm(name,properties,problem);\n  }\n catch (  ServiceConfigurationError e) {\n    System.err.println(e.getMessage());\n  }\n  return null;\n}\n", "nl": "Attempts to instantiate the given algorithm using the given provider."}
{"code": "public void adapt(){\n  double[] zmin=new double[numberOfObjectives];\n  double[] zmax=new double[numberOfObjectives];\n  Arrays.fill(zmin,Double.POSITIVE_INFINITY);\n  Arrays.fill(zmax,Double.NEGATIVE_INFINITY);\n  for (  Solution solution : this) {\n    for (int i=0; i < numberOfObjectives; i++) {\n      zmin[i]=Math.min(zmin[i],solution.getObjective(i));\n      zmax[i]=Math.max(zmax[i],solution.getObjective(i));\n    }\n  }\n  weights.clear();\n  for (  double[] weight : originalWeights) {\n    double[] newWeight=weight.clone();\n    for (int i=0; i < numberOfObjectives; i++) {\n      newWeight[i]*=Math.max(0.01,zmax[i] - zmin[i]);\n    }\n    weights.add(Vector.normalize(newWeight));\n  }\n  minAngles=new double[weights.size()];\n  for (int i=0; i < weights.size(); i++) {\n    minAngles[i]=smallestAngleBetweenWeights(i);\n  }\n}\n", "nl": "Normalize the reference vectors."}
{"code": "public static String stringFilterStrict(String searchText){\n  return searchText.replaceAll(\"[^ a-zA-Z0-9\\\\u4e00-\\\\u9fa5]\",\"\");\n}\n", "nl": "Remove useless and unsafe characters. Only Chinese, numbers, English characters and space are allowed."}
{"code": "public void loadByteData(int[] data,int[] dims){\n  this.dims=dims;\n  byte[] byteData=new byte[data.length];\n  for (int i=0; i < data.length; i++) {\n    byteData[i]=(byte)data[i];\n  }\n  this.data=ByteBuffer.wrap(byteData);\n}\n", "nl": "Need to have method signature for int or octave can't match it"}
{"code": "protected boolean arePrimeAnnosEqual(final AnnotatedTypeMirror type1,final AnnotatedTypeMirror type2){\n  if (currentTop != null) {\n    return AnnotationUtils.areSame(type1.getAnnotationInHierarchy(currentTop),type2.getAnnotationInHierarchy(currentTop));\n  }\n  return AnnotationUtils.areSame(type1.getAnnotations(),type2.getAnnotations());\n}\n", "nl": "Return true if type1 and type2 have the same set of annotations."}
{"code": "protected void writeImageDesc() throws IOException {\n  out.write(0x2c);\n  writeShort(0);\n  writeShort(0);\n  writeShort(width);\n  writeShort(height);\n  if (firstFrame) {\n    out.write(0);\n  }\n else {\n    out.write(0x80 | 0 | 0| 0| palSize);\n  }\n}\n", "nl": "Writes Image Descriptor"}
{"code": "public StreamResult(String systemId){\n  this.systemId=systemId;\n}\n", "nl": "Construct a StreamResult from a URL."}
{"code": "private void updatePhysicalInterval(Register p,BasicInterval i){\n  CompoundInterval physInterval=regAllocState.getInterval(p);\n  if (physInterval == null) {\n    regAllocState.setInterval(p,new CompoundInterval(i,p));\n  }\n else {\n    CompoundInterval ci=new CompoundInterval(i,p);\n    if (VM.VerifyAssertions)     VM._assert(!ci.intersects(physInterval));\n    physInterval.addAll(ci);\n  }\n}\n", "nl": "Updates the interval representing the allocations of a physical register p to include a new interval i."}
{"code": "@Override public String toString(){\n  StringBuffer result=new StringBuffer();\n  for (int i=0; i < data.length; i++) {\n    result.append((i == 0 ? \"\" : \",\") + data[i]);\n  }\n  return result.toString();\n}\n", "nl": "Returns a string representation of the data row."}
{"code": "public BoolLiteralItemProvider(AdapterFactory adapterFactory){\n  super(adapterFactory);\n}\n", "nl": "This constructs an instance from a factory and a notifier. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private static void initGameFolder(){\n  String defaultFolder=System.getProperty(\"user.home\") + STENDHAL_FOLDER;\n  String unixLikes=\"AIX|Digital Unix|FreeBSD|HP UX|Irix|Linux|Mac OS X|Solaris\";\n  String system=System.getProperty(\"os.name\");\n  if (system.matches(unixLikes)) {\n    File f=new File(defaultFolder + \"user.dat\");\n    if (!f.exists()) {\n      gameFolder=System.getProperty(\"user.home\") + separator + \".config\"+ separator+ STENDHAL_FOLDER;\n      return;\n    }\n  }\n  gameFolder=defaultFolder;\n}\n", "nl": "Initialize the client game directory. <p> NOTE: IF YOU CHANGE THIS, CHANGE ALSO CORRESPONDING CODE IN Bootstrap.java"}
{"code": "public void addCMap(short platformID,short platformSpecificID,CMap cMap){\n  CmapSubtable key=new CmapSubtable(platformID,platformSpecificID);\n  subtables.put(key,cMap);\n}\n", "nl": "Add a CMap"}
{"code": "public static void incrementalWeightedUpdate(DoubleArrayList data,DoubleArrayList weights,int from,int to,double[] inOut){\n  int dataSize=data.size();\n  checkRangeFromTo(from,to,dataSize);\n  if (dataSize != weights.size())   throw new IllegalArgumentException(\"from=\" + from + \", to=\"+ to+ \", data.size()=\"+ dataSize+ \", weights.size()=\"+ weights.size());\n  double sum=inOut[0];\n  double sumOfSquares=inOut[1];\n  double[] elements=data.elements();\n  double[] w=weights.elements();\n  for (int i=from - 1; ++i <= to; ) {\n    double element=elements[i];\n    double weight=w[i];\n    double prod=element * weight;\n    sum+=prod;\n    sumOfSquares+=element * prod;\n  }\n  inOut[0]=sum;\n  inOut[1]=sumOfSquares;\n}\n", "nl": "Incrementally maintains and updates sum and sum of squares of a <i>weighted</i> data sequence. Assume we have already recorded some data sequence elements  and know their sum and sum of squares. Assume further, we are to record some more elements  and to derive updated values of sum and sum of squares. <p> This method computes those updated values without needing to know the already recorded elements. This is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory. <p> <br>Definition of sum: <tt>sum = Sum ( data[i] * weights[i] )</tt>. <br>Definition of sumOfSquares: <tt>sumOfSquares = Sum ( data[i] * data[i] * weights[i])</tt>."}
{"code": "public static UpdateSettingsRequest updateSettingsRequest(String... indices){\n  return new UpdateSettingsRequest(indices);\n}\n", "nl": "A request to update indices settings."}
{"code": "public SQLTransientException(String reason,Throwable cause){\n  super(reason,cause);\n}\n", "nl": "Creates an SQLTransientException object. The Reason string is set to the given and the cause Throwable object is set to the given cause Throwable object."}
{"code": "public static boolean isCompareOperator(BinaryOperator bOp){\n  return (bOp.fn instanceof LessThan || bOp.fn instanceof LessThanEquals || bOp.fn instanceof GreaterThan|| bOp.fn instanceof GreaterThanEquals|| bOp.fn instanceof Equals|| bOp.fn instanceof NotEquals);\n}\n", "nl": "This will return if uaggOp is of type RowIndexMin"}
{"code": "@Override protected EClass eStaticClass(){\n  return DatatypePackage.Literals.ENUM_LITERAL_PROPERTY_ATTRIBUTE;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public void contextCreated(ELContextEvent ece){\n  FacesContext context=FacesContext.getCurrentInstance();\n  if (context == null) {\n    return;\n  }\n  ELContext source=(ELContext)ece.getSource();\n  source.putContext(FacesContext.class,context);\n  ExpressionFactory exFactory=ELUtils.getDefaultExpressionFactory(context);\n  if (null != exFactory) {\n    source.putContext(ExpressionFactory.class,exFactory);\n  }\n  ELContextListener[] listeners=context.getApplication().getELContextListeners();\n  if (listeners == null) {\n    return;\n  }\n  for (int i=0; i < listeners.length; ++i) {\n    ELContextListener elcl=listeners[i];\n    elcl.contextCreated(new ELContextEvent(source));\n  }\n}\n", "nl": "Invoked when a new <code>ELContext</code> has been created."}
{"code": "public static void launchActivity(Activity context,Class<? extends Activity> activity,boolean closeCurrentActivity,Map<String,String> params){\n  Intent intent=new Intent(context,activity);\n  if (params != null) {\n    Bundle bundle=new Bundle();\n    for (    Entry<String,String> param : params.entrySet()) {\n      bundle.putString(param.getKey(),param.getValue());\n    }\n    intent.putExtras(bundle);\n  }\n  context.startActivity(intent);\n  if (closeCurrentActivity) {\n    context.finish();\n  }\n}\n", "nl": "Launch an Activity."}
{"code": "static XPath rewriteChildToExpression(ElemTemplateElement varElem) throws TransformerException {\n  ElemTemplateElement t=varElem.getFirstChildElem();\n  if (null != t && null == t.getNextSiblingElem()) {\n    int etype=t.getXSLToken();\n    if (Constants.ELEMNAME_VALUEOF == etype) {\n      ElemValueOf valueof=(ElemValueOf)t;\n      if (valueof.getDisableOutputEscaping() == false && valueof.getDOMBackPointer() == null) {\n        varElem.m_firstChild=null;\n        return new XPath(new XRTreeFragSelectWrapper(valueof.getSelect().getExpression()));\n      }\n    }\n else     if (Constants.ELEMNAME_TEXTLITERALRESULT == etype) {\n      ElemTextLiteral lit=(ElemTextLiteral)t;\n      if (lit.getDisableOutputEscaping() == false && lit.getDOMBackPointer() == null) {\n        String str=lit.getNodeValue();\n        XString xstr=new XString(str);\n        varElem.m_firstChild=null;\n        return new XPath(new XRTreeFragSelectWrapper(xstr));\n      }\n    }\n  }\n  return null;\n}\n", "nl": "If the children of a variable is a single xsl:value-of or text literal,  it is cheaper to evaluate this as an expression, so try and adapt the  child an an expression."}
{"code": "public final void testParsesFuzz(){\n  StringBuilder testCases=new StringBuilder();\n  String randomJs=\"\";\n  boolean failed=false;\n  for (int testCaseCount=0; testCaseCount < MAX_NUMBER_OF_TESTS; testCaseCount++) {\n    try {\n      randomJs=fudgeroonify();\n      js(fromString(randomJs));\n    }\n catch (    ParseException e) {\n    }\ncatch (    Throwable e) {\n      failed=true;\n      testCases.append(generateTestCase(randomJs,testCaseCount,e.getMessage()));\n    }\n  }\n  System.err.print(testCases.toString());\n  if (failed) {\n    fail();\n  }\n}\n", "nl": "Test parser against a snippet of fuzzed javascript Fail if the parser throws anything other than a ParseException. Formats and prints the failing case to stderr for pasting in to JUnit tests"}
{"code": "public SVMExamples(int size,double b){\n  this.train_size=size;\n  this.b=b;\n  atts=new double[train_size][];\n  index=new int[train_size][];\n  ys=new double[train_size];\n  alphas=new double[train_size];\n  ids=new String[size];\n}\n", "nl": "Creates an empty example set of the given size."}
{"code": "public static KeyInfo generateKey(String tokenId) throws Exception {\n  LOG.trace(\"Generating key for token '{}'\",tokenId);\n  KeyInfo keyInfo=execute(new GenerateKey(tokenId));\n  LOG.trace(\"Received response with keyId '{}' and public key '{}'\",keyInfo.getId(),keyInfo.getPublicKey());\n  return keyInfo;\n}\n", "nl": "Generate a new key for the token with the given ID."}
{"code": "private void badIndex(int index) throws ArrayIndexOutOfBoundsException {\n  String msg=\"Attempt to modify attribute at illegal index: \" + index;\n  throw new ArrayIndexOutOfBoundsException(msg);\n}\n", "nl": "Report a bad array index in a manipulator."}
{"code": "@Override public void load(Element element,Object o){\n  log.error(\"Unexpected call of load(Element, Object)\");\n}\n", "nl": "Update static data from XML file"}
{"code": "public V put(String text,V value){\n  return put(text.toCharArray(),value);\n}\n", "nl": "Add the given mapping."}
{"code": "public static boolean isLandscape(Context context){\n  return context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;\n}\n", "nl": "is landscape"}
{"code": "public boolean queueSurfaceDataReplacing(Component c,Runnable r){\n  return false;\n}\n", "nl": "This method is invoked from the toolkit thread when the surface data of the component needs to be replaced. The method run() of the Runnable argument performs surface data replacing, run() should be invoked on the EDT of this component's AppContext. Returns true if the Runnable has been enqueued to be invoked on the EDT. (Fix 6255371.)"}
{"code": "private static String parseContent(XmlPullParser parser) throws XmlPullParserException, IOException {\n  int parserDepth=parser.getDepth();\n  return parseContentDepth(parser,parserDepth);\n}\n", "nl": "Returns the content of a tag as string regardless of any tags included."}
{"code": "public final void deleteTables(SQL[] tables) throws AdeException {\n  if (tables == null) {\n    return;\n  }\n  for (  SQL table : tables) {\n    TableGeneralUtils.deleteTable(table.toString());\n  }\n}\n", "nl": "Deletes a table"}
{"code": "public long length(){\n  return getBestPath().length();\n}\n", "nl": "Returns the length of the best path."}
{"code": "public static void waitForCondition(String condition){\n  BValue cond=getCond(condition);\nsynchronized (cond) {\n    if (!cond.v) {\n      try {\n        cond.wait();\n      }\n catch (      InterruptedException e) {\n      }\n    }\n  }\n}\n", "nl": "If the named condition does not exist, then it is created and initialized to false. If the condition exists or has just been created and its value is false, then the thread blocks until another thread sets the condition. If the condition exists and is already set to true, then this call returns immediately without blocking."}
{"code": "@Override public float estimateFutureCost(Rule rule,DPState state,Sentence sentence){\n  return 0.0f;\n}\n", "nl": "We don't compute a future cost."}
{"code": "public static <T>T[] subarray(T[] buffer,int offset,int length){\n  Class<T> componentType=(Class<T>)buffer.getClass().getComponentType();\n  return subarray(buffer,offset,length,componentType);\n}\n", "nl": "Returns subarray."}
{"code": "@Override public boolean job(){\n  if (currentQuery == null && querystack != null && querystack.size() > 0) {\n    currentQuery=querystack.iterator().next();\n    querystack.remove(currentQuery);\n    initPeerList();\n  }\n  if (currentQuery != null && !currentQuery.isEmpty()) {\n    if (currentTargets != null && !currentTargets.isEmpty()) {\n      while (currentTargets.size() > 0) {\n        String peerhash=currentTargets.iterator().next();\n        currentTargets.remove(peerhash);\n        Seed seed=Switchboard.getSwitchboard().peers.getConnected(peerhash);\n        if (seed != null) {\n          processSingleTarget(seed);\n          return true;\n        }\n      }\n    }\n    currentQuery=null;\n  }\n  checkBookmarkDB();\n  ConcurrentLog.fine(AutoSearch.class.getName(),\"nothing to do\");\n  return this.querystack.size() > 0;\n}\n", "nl": "Process query queue, select one query and peer to ask next"}
{"code": "public Iterator<AnalysisPass> passIterator(){\n  return passList.iterator();\n}\n", "nl": "Get an Iterator over the AnalysisPasses."}
{"code": "private static InetAddress[] lookupHostByName(String host) throws UnknownHostException {\n  BlockGuard.getThreadPolicy().onNetwork();\n  Object cachedResult=addressCache.get(host);\n  if (cachedResult != null) {\n    if (cachedResult instanceof InetAddress[]) {\n      return (InetAddress[])cachedResult;\n    }\n else {\n      throw new UnknownHostException((String)cachedResult);\n    }\n  }\n  try {\n    StructAddrinfo hints=new StructAddrinfo();\n    hints.ai_flags=AI_ADDRCONFIG;\n    hints.ai_family=AF_UNSPEC;\n    hints.ai_socktype=SOCK_STREAM;\n    InetAddress[] addresses=Libcore.os.getaddrinfo(host,hints);\n    for (    InetAddress address : addresses) {\n      address.hostName=host;\n    }\n    addressCache.put(host,addresses);\n    return addresses;\n  }\n catch (  GaiException gaiException) {\n    if (gaiException.getCause() instanceof ErrnoException) {\n      if (((ErrnoException)gaiException.getCause()).errno == EACCES) {\n        throw new SecurityException(\"Permission denied (missing INTERNET permission?)\",gaiException);\n      }\n    }\n    String detailMessage=\"Unable to resolve host \\\"\" + host + \"\\\": \"+ Libcore.os.gai_strerror(gaiException.error);\n    addressCache.putUnknownHost(host,detailMessage);\n    throw gaiException.rethrowAsUnknownHostException(detailMessage);\n  }\n}\n", "nl": "Resolves a hostname to its IP addresses using a cache."}
{"code": "public static void sort(AbstractList array){\n  Object temp;\n  int j, n=array.size();\n  for (j=n / 2; j > 0; j--) {\n    adjust(array,j,n);\n  }\n  for (j=n - 1; j > 0; j--) {\n    temp=array.get(0);\n    array.set(0,array.get(j));\n    array.set(j,temp);\n    adjust(array,1,j);\n  }\n}\n", "nl": "Sorts a vector of comparable objects into increasing order."}
{"code": "private void initLabelsAndModels(ArrayList<GeneratorInterface> generators,ClassLabel[] labels,Model[] models,Pattern reassign){\n  int existingclusters=0;\n  if (reassign != null) {\n    for (int i=0; i < labels.length; i++) {\n      final GeneratorInterface curclus=generators.get(i);\n      if (!reassign.matcher(curclus.getName()).find()) {\n        labels[i]=new SimpleClassLabel(curclus.getName());\n        models[i]=curclus.makeModel();\n        ++existingclusters;\n      }\n    }\n    if (existingclusters == 0) {\n      LOG.warning(\"All clusters matched the 'reassign' pattern. Ignoring.\");\n    }\n    if (existingclusters == 1) {\n      for (int i=0; i < labels.length; i++) {\n        if (labels[i] != null) {\n          Arrays.fill(labels,labels[i]);\n          Arrays.fill(models,models[i]);\n          break;\n        }\n      }\n    }\n    if (existingclusters == labels.length) {\n      LOG.warning(\"No clusters matched the 'reassign' pattern.\");\n    }\n  }\n  if (existingclusters == 0) {\n    for (int i=0; i < labels.length; i++) {\n      final GeneratorInterface curclus=generators.get(i);\n      labels[i]=new SimpleClassLabel(curclus.getName());\n      models[i]=curclus.makeModel();\n    }\n  }\n}\n", "nl": "Initialize cluster labels and models. Clusters that are set to \"reassign\" will have their labels set to null, or if there is only one possible reassignment, to this target label."}
{"code": "public Directory<T> addFolder(Directory<T> subDirectory){\n  return folder.put(subDirectory.getName(),subDirectory);\n}\n", "nl": "Adds a sub directory"}
{"code": "@Override protected EClass eStaticClass(){\n  return TypesPackage.Literals.TGETTER;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "protected void init_actions(){\n  action_obj=new CUP$actions();\n}\n", "nl": "action encapsulation object initializer"}
{"code": "public boolean newMessage(List<Object> cmds){\n  if (!isBlocked && failoverHandler != null) {\n    if (unprocessedCount() != 0) {\n      processPendingMessages();\n    }\n    failoverHandler.accept(cmds);\n    return true;\n  }\n else {\nsynchronized (this) {\n      notProcessedTransactions.add(cmds);\n    }\n    return false;\n  }\n}\n", "nl": "Must always be called by single thread only."}
{"code": "public CNodeChooserTable(final ZyGraph graph,final CGraphSearchField searchField){\n  m_graph=Preconditions.checkNotNull(graph,\"IE01773: Graph argument can't be null.\");\n  m_searchField=Preconditions.checkNotNull(searchField,\"IE01774: Search field argument can not be null\");\n  m_model=new CNodeChooserModel(graph);\n  setModel(m_model);\n  final TableRowSorter<CNodeChooserModel> tableSorter=new TableRowSorter<CNodeChooserModel>(m_model);\n  setRowSorter(tableSorter);\n  tableSorter.setComparator(CNodeChooserModel.COLUMN_IN,new IntComparator());\n  tableSorter.setComparator(CNodeChooserModel.COLUMN_OUT,new IntComparator());\n  tableSorter.setComparator(CNodeChooserModel.COLUMN_ADDRESS,new LexicalComparator());\n  tableSorter.setComparator(CNodeChooserModel.COLUMN_COLOR,new IntComparator());\n  final CNodeChooserRenderer renderer=new CNodeChooserRenderer(this,m_graph,m_searchField.getGraphSearcher());\n  setRowSelectionAllowed(true);\n  setColumnSelectionAllowed(false);\n  setCellSelectionEnabled(false);\n  setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n  getTableHeader().setReorderingAllowed(false);\n  getColumnModel().getColumn(0).setCellRenderer(renderer);\n  getColumnModel().getColumn(1).setCellRenderer(renderer);\n  getColumnModel().getColumn(2).setCellRenderer(renderer);\n  getColumnModel().getColumn(3).setCellRenderer(renderer);\n  getColumnModel().getColumn(0).setPreferredWidth(35);\n  getColumnModel().getColumn(1).setPreferredWidth(35);\n  getColumnModel().getColumn(3).setPreferredWidth(50);\n  getColumnModel().getColumn(0).setMaxWidth(50);\n  getColumnModel().getColumn(1).setMaxWidth(50);\n  getColumnModel().getColumn(3).setMaxWidth(50);\n  m_searchField.addListener(m_searchFieldListener);\n  m_mouselistener=new CNodeChooserMouseListener(this,graph);\n  addMouseListener(m_mouselistener);\n  m_graph.addListener((INaviGraphListener)m_viewListener);\n  m_graph.addListener((IZyGraphSelectionListener)m_viewListener);\n  initializeViewListeners(m_graph.getRawView());\n}\n", "nl": "Creates a new node chooser table."}
{"code": "protected JsonDeserializer<Object> _findRootDeserializer(DeserializationConfig cfg,JavaType valueType) throws JsonMappingException {\n  if (valueType == null) {\n    throw new JsonMappingException(\"No value type configured for ObjectReader\");\n  }\n  JsonDeserializer<Object> deser=_rootDeserializers.get(valueType);\n  if (deser != null) {\n    return deser;\n  }\n  deser=_provider.findTypedValueDeserializer(cfg,valueType,null);\n  if (deser == null) {\n    throw new JsonMappingException(\"Can not find a deserializer for type \" + valueType);\n  }\n  _rootDeserializers.put(valueType,deser);\n  return deser;\n}\n", "nl": "Method called to locate deserializer for the passed root-level value."}
{"code": "public void write(BufferedImage bimg,OutputStream os) throws IOException {\n  ImageWriter writer=null;\n  ImageOutputStream ios=null;\n  try {\n    writer=lookupImageWriterForFormat(imageFormat);\n    ios=ImageIO.createImageOutputStream(os);\n    writer.setOutput(ios);\n    ImageWriteParam iwparam=getImageWriteParameters(writer);\n    writer.write(null,new IIOImage(bimg,null,null),iwparam);\n  }\n  finally {\n    if (ios != null) {\n      try {\n        ios.flush();\n      }\n catch (      IOException e) {\n      }\n      try {\n        ios.close();\n      }\n catch (      IOException e) {\n      }\n    }\n    if (writer != null) {\n      writer.dispose();\n    }\n  }\n}\n", "nl": "Writes the image out to the target file, creating the file if necessary, or overwriting if it already exists."}
{"code": "static void createNetwork2(final MutableScenario scenario){\n  Network network=(Network)scenario.getNetwork();\n  network.setCapacityPeriod(Time.parseTime(\"01:00:00\"));\n  Node node0=NetworkUtils.createAndAddNode(network,Id.create(\"0\",Node.class),new Coord((double)0,(double)10));\n  Node node1=NetworkUtils.createAndAddNode(network,Id.create(\"1\",Node.class),new Coord((double)0,(double)100));\n  Node node2=NetworkUtils.createAndAddNode(network,Id.create(\"2\",Node.class),new Coord((double)100,(double)100));\n  Node node3=NetworkUtils.createAndAddNode(network,Id.create(\"3\",Node.class),new Coord((double)150,(double)150));\n  Node node4=NetworkUtils.createAndAddNode(network,Id.create(\"4\",Node.class),new Coord((double)200,(double)100));\n  Node node5=NetworkUtils.createAndAddNode(network,Id.create(\"5\",Node.class),new Coord((double)300,(double)100));\n  final double y5=-100;\n  Node node6=NetworkUtils.createAndAddNode(network,Id.create(\"6\",Node.class),new Coord((double)300,y5));\n  final double y4=-100;\n  Node node7=NetworkUtils.createAndAddNode(network,Id.create(\"7\",Node.class),new Coord((double)200,y4));\n  final double y3=-150;\n  Node node8=NetworkUtils.createAndAddNode(network,Id.create(\"8\",Node.class),new Coord((double)150,y3));\n  final double y2=-100;\n  Node node9=NetworkUtils.createAndAddNode(network,Id.create(\"9\",Node.class),new Coord((double)100,y2));\n  final double y1=-100;\n  Node node10=NetworkUtils.createAndAddNode(network,Id.create(\"10\",Node.class),new Coord((double)0,y1));\n  final double y=-10;\n  Node node11=NetworkUtils.createAndAddNode(network,Id.create(\"11\",Node.class),new Coord((double)0,y));\n  final Node fromNode=node0;\n  final Node toNode=node1;\n  NetworkUtils.createAndAddLink(network,Id.create(\"1\",Link.class),fromNode,toNode,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode1=node1;\n  final Node toNode1=node2;\n  NetworkUtils.createAndAddLink(network,Id.create(\"2\",Link.class),fromNode1,toNode1,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode2=node2;\n  final Node toNode2=node3;\n  NetworkUtils.createAndAddLink(network,Id.create(\"3\",Link.class),fromNode2,toNode2,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode3=node3;\n  final Node toNode3=node4;\n  NetworkUtils.createAndAddLink(network,Id.create(\"4\",Link.class),fromNode3,toNode3,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode4=node2;\n  final Node toNode4=node4;\n  NetworkUtils.createAndAddLink(network,Id.create(\"5\",Link.class),fromNode4,toNode4,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode5=node4;\n  final Node toNode5=node5;\n  NetworkUtils.createAndAddLink(network,Id.create(\"6\",Link.class),fromNode5,toNode5,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode6=node5;\n  final Node toNode6=node6;\n  NetworkUtils.createAndAddLink(network,Id.create(\"7\",Link.class),fromNode6,toNode6,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode7=node6;\n  final Node toNode7=node7;\n  NetworkUtils.createAndAddLink(network,Id.create(\"8\",Link.class),fromNode7,toNode7,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode8=node7;\n  final Node toNode8=node8;\n  NetworkUtils.createAndAddLink(network,Id.create(\"9\",Link.class),fromNode8,toNode8,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode9=node8;\n  final Node toNode9=node9;\n  NetworkUtils.createAndAddLink(network,Id.create(\"10\",Link.class),fromNode9,toNode9,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode10=node7;\n  final Node toNode10=node9;\n  NetworkUtils.createAndAddLink(network,Id.create(\"11\",Link.class),fromNode10,toNode10,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode11=node9;\n  final Node toNode11=node10;\n  NetworkUtils.createAndAddLink(network,Id.create(\"12\",Link.class),fromNode11,toNode11,(double)100,(double)5,(double)100,(double)1);\n  final Node fromNode12=node10;\n  final Node toNode12=node11;\n  NetworkUtils.createAndAddLink(network,Id.create(\"13\",Link.class),fromNode12,toNode12,(double)100,(double)5,(double)100,(double)1);\n}\n", "nl": "Creates a simple network with route alternatives in 2 places."}
{"code": "@Override public void onStart(){\n  if (!didStartApp) {\n    didStartApp=true;\n    InstallOptions pendingInstall=this.codePushPackageManager.getPendingInstall();\n    if (pendingInstall == null) {\n      handleUnconfirmedInstall(false);\n    }\n    handleAppStart();\n    if (pendingInstall != null && (InstallMode.ON_NEXT_RESUME.equals(pendingInstall.installMode) || InstallMode.ON_NEXT_RESTART.equals(pendingInstall.installMode))) {\n      this.markUpdate();\n      this.codePushPackageManager.clearPendingInstall();\n    }\n  }\n else {\n    InstallOptions pendingInstall=this.codePushPackageManager.getPendingInstall();\n    long durationInBackground=(new Date().getTime() - lastPausedTimeMs) / 1000;\n    if (pendingInstall != null && InstallMode.ON_NEXT_RESUME.equals(pendingInstall.installMode) && durationInBackground >= pendingInstall.minimumBackgroundDuration) {\n      handleAppStart();\n      this.markUpdate();\n      this.codePushPackageManager.clearPendingInstall();\n    }\n  }\n}\n", "nl": "Called when the activity is becoming visible to the user."}
{"code": "public static List<HostAddress> resolveXMPPServerDomain(String domain){\n  return resolveDomain(domain,'s');\n}\n", "nl": "Returns a list of HostAddresses under which the specified XMPP server can be reached at for server-to-server communication. A DNS lookup for a SRV record in the form \"_xmpp-server._tcp.example.com\" is attempted, according to section 14.4 of RFC 3920. If that lookup fails, a lookup in the older form of \"_jabber._tcp.example.com\" is attempted since servers that implement an older version of the protocol may be listed using that notation. If that lookup fails as well, it's assumed that the XMPP server lives at the host resolved by a DNS lookup at the specified domain on the default port of 5269.<p> As an example, a lookup for \"example.com\" may return \"im.example.com:5269\"."}
{"code": "public void xtestTransactionRollbackOnSessionClose() throws Exception {\n  Destination destination=createDestination(getClass().getName());\n  Connection connection=createConnection();\n  connection.setClientID(idGen.generateId());\n  connection.start();\n  Session consumerSession=connection.createSession(true,Session.CLIENT_ACKNOWLEDGE);\n  MessageConsumer consumer=null;\n  if (topic) {\n    consumer=consumerSession.createDurableSubscriber((Topic)destination,\"TESTRED\");\n  }\n else {\n    consumer=consumerSession.createConsumer(destination);\n  }\n  Session producerSession=connection.createSession(true,Session.AUTO_ACKNOWLEDGE);\n  MessageProducer producer=producerSession.createProducer(destination);\n  producer.setDeliveryMode(deliveryMode);\n  TextMessage sentMsg=producerSession.createTextMessage();\n  sentMsg.setText(\"msg1\");\n  producer.send(sentMsg);\n  producerSession.commit();\n  Message recMsg=consumer.receive(RECEIVE_TIMEOUT);\n  assertFalse(recMsg.getJMSRedelivered());\n  consumerSession.close();\n  consumerSession=connection.createSession(true,Session.CLIENT_ACKNOWLEDGE);\n  consumer=consumerSession.createConsumer(destination);\n  recMsg=consumer.receive(RECEIVE_TIMEOUT);\n  consumerSession.commit();\n  assertTrue(recMsg.equals(sentMsg));\n  connection.close();\n}\n", "nl": "Check a session is rollbacked on a Session close();"}
{"code": "public SnmpNull(String dummy){\n  this();\n}\n", "nl": "Constructs a new <CODE>SnmpNull</CODE>. <BR>For mibgen private use only."}
{"code": "public SQLTransientException(String reason,String sqlState){\n  super(reason,sqlState,0);\n}\n", "nl": "Creates an SQLTransientException object. The Reason string is set to the given reason string, the SQLState string is set to the given SQLState string and the Error Code is set to 0."}
{"code": "public static void main(String[] args){\n  try {\n    PluginManager.loadPlugins();\n    if (args.length == 0) {\n      try {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n      }\n catch (      Exception e) {\n      }\n      new OpenStegoUI().setVisible(true);\n    }\n else {\n      OpenStegoCmd.execute(args);\n    }\n  }\n catch (  OpenStegoException osEx) {\n    if (osEx.getErrorCode() == OpenStegoException.UNHANDLED_EXCEPTION) {\n      osEx.printStackTrace();\n    }\n else {\n      System.err.println(osEx.getMessage());\n    }\n  }\ncatch (  Exception ex) {\n    ex.printStackTrace();\n  }\n}\n", "nl": "Main method for calling openstego from command line."}
{"code": "public AmqpReceiver createDurableReceiver(String address,String subscriptionName) throws Exception {\n  return createDurableReceiver(address,subscriptionName,null,false);\n}\n", "nl": "Create a receiver instance using the given address that creates a durable subscription."}
{"code": "public static RuntimeException codeBug(String msg) throws RuntimeException {\n  msg=\"FAILED ASSERTION: \" + msg;\n  RuntimeException ex=new IllegalStateException(msg);\n  ex.printStackTrace(System.err);\n  throw ex;\n}\n", "nl": "Throws RuntimeException to indicate failed assertion. The function never returns and its return type is RuntimeException only to be able to write <tt>throw Kit.codeBug()</tt> if plain <tt>Kit.codeBug()</tt> triggers unreachable code error."}
{"code": "@Override protected void register(DeployerFactory deployerFactory){\n  deployerFactory.registerDeployer(\"tomcat4x\",DeployerType.INSTALLED,TomcatCopyingInstalledLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat4x\",DeployerType.REMOTE,Tomcat4xRemoteDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat5x\",DeployerType.INSTALLED,TomcatCopyingInstalledLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat5x\",DeployerType.REMOTE,Tomcat5xRemoteDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat5x\",DeployerType.EMBEDDED,TomcatEmbeddedLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat6x\",DeployerType.INSTALLED,TomcatCopyingInstalledLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat6x\",DeployerType.REMOTE,Tomcat6xRemoteDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat6x\",DeployerType.EMBEDDED,TomcatEmbeddedLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat7x\",DeployerType.INSTALLED,TomcatCopyingInstalledLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat7x\",DeployerType.REMOTE,Tomcat7xRemoteDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat7x\",DeployerType.EMBEDDED,TomcatEmbeddedLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat8x\",DeployerType.INSTALLED,TomcatCopyingInstalledLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat8x\",DeployerType.REMOTE,Tomcat8xRemoteDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat8x\",DeployerType.EMBEDDED,TomcatEmbeddedLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat9x\",DeployerType.INSTALLED,TomcatCopyingInstalledLocalDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat9x\",DeployerType.REMOTE,Tomcat9xRemoteDeployer.class);\n  deployerFactory.registerDeployer(\"tomcat9x\",DeployerType.EMBEDDED,TomcatEmbeddedLocalDeployer.class);\n}\n", "nl": "Register deployer."}
{"code": "protected void putInQueue(Object val) throws InterruptedException {\n  if (val instanceof HAEventWrapper && ((HAEventWrapper)val).getClientUpdateMessage() == null) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"HARegionQueue.putGIIDataInRegion(): key={} was removed at sender side, so not putting it into the ha queue.\",((HAEventWrapper)val).getKeyToConflate());\n    }\n  }\n else {\n    this.put(val);\n  }\n}\n", "nl": "Puts the GII'd entry into the ha region, if it was GII'd along with its ClientUpdateMessageImpl instance."}
{"code": "protected EventException createEventException(short code,String key,Object[] args){\n  try {\n    AbstractDocument doc=(AbstractDocument)node.getOwnerDocument();\n    return new EventException(code,doc.formatMessage(key,args));\n  }\n catch (  Exception e) {\n    return new EventException(code,key);\n  }\n}\n", "nl": "Creates an EventException. Overrides this method if you need to create your own RangeException subclass."}
{"code": "private void fetchKey(){\n  if (this.flowLevel == 0) {\n    if (!this.allowSimpleKey) {\n      throw new ScannerException(null,null,\"mapping keys are not allowed here\",reader.getMark());\n    }\n    if (addIndent(this.reader.getColumn())) {\n      Mark mark=reader.getMark();\n      this.tokens.add(new BlockMappingStartToken(mark,mark));\n    }\n  }\n  this.allowSimpleKey=this.flowLevel == 0;\n  removePossibleSimpleKey();\n  Mark startMark=reader.getMark();\n  reader.forward();\n  Mark endMark=reader.getMark();\n  Token token=new KeyToken(startMark,endMark);\n  this.tokens.add(token);\n}\n", "nl": "Fetch a key in a block-style mapping."}
{"code": "@Deprecated protected ActionListener createKeyboardEndListener(){\n  return new KeyboardEndHandler();\n}\n", "nl": "As of Java 2 platform v1.3 this method is no longer used. Subclassers previously using this method should instead create an Action wrapping the ActionListener, and register that Action by overriding <code>installKeyboardActions</code> and placing the Action in the SplitPane's ActionMap. Please refer to the key bindings specification for further details. <p> Creates a ActionListener for the JSplitPane UI that listens for specific key presses."}
{"code": "public FisheyeTreeFilter(String group){\n  this(group,1);\n}\n", "nl": "Create a new FisheyeTreeFilter that processes the given group."}
{"code": "public BufferedSageFile(SageFileSource sageFileSource,int readBufferSize,int writeBufferSize){\n  this.sageFileSource=sageFileSource;\n  realFilePosition=sageFileSource.position();\n  readonly=sageFileSource.isReadOnly();\n  readBuffer=new byte[readBufferSize];\n  readWrap=null;\n  if (readonly) {\n    writeBuffer=empty;\n  }\n else {\n    if (writeBufferSize == 0)     writeBufferSize=8192;\n    int remainder=writeBufferSize % 8192;\n    if (remainder != 0)     writeBufferSize=writeBufferSize + 8192 - remainder;\n    writeOptimizerLimit=writeBufferSize / 2;\n    writeBuffer=new byte[writeBufferSize];\n    writeWrap=null;\n  }\n}\n", "nl": "Create a buffered <code>SageFileSource</code> with custom read and write buffer sizes. <p/> Do not attempt to use the underlying <code>SageFileSource</code> after writing without first calling <code>flush()</code> since otherwise the state of writing will be unknown."}
{"code": "public static boolean isVplexDistributedVolume(UnManagedVolume unManagedVolume){\n  if (isVplexVolume(unManagedVolume)) {\n    String locality=PropertySetterUtil.extractValueFromStringSet(SupportedVolumeInformation.VPLEX_LOCALITY.toString(),unManagedVolume.getVolumeInformation());\n    if (VPlexApiConstants.DISTRIBUTED_VIRTUAL_VOLUME.equalsIgnoreCase(locality)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Returns true if the given UnManagedVolume is a VPLEX distributed volume."}
{"code": "public static void registerMetadata(MetadataRegistry registry){\n  if (registry.isRegistered(KEY)) {\n    return;\n  }\n  registry.build(KEY);\n}\n", "nl": "Registers the metadata for this element."}
{"code": "private boolean filterStaticColumns(OneRowChange orc) throws ReplicatorException {\n  boolean transformed=false;\n  if (orc.getAction() != ActionType.UPDATE)   return transformed;\n  if (tungstenSchema != null && orc.getSchemaName().compareToIgnoreCase(tungstenSchema) == 0) {\n    if (logger.isDebugEnabled())     logger.debug(\"Ignoring \" + tungstenSchema + \" schema\");\n    return transformed;\n  }\n  ArrayList<ColumnSpec> keys=orc.getKeySpec();\n  ArrayList<ColumnSpec> columns=orc.getColumnSpec();\n  ArrayList<ArrayList<ColumnVal>> keyValues=orc.getKeyValues();\n  ArrayList<ArrayList<ColumnVal>> columnValues=orc.getColumnValues();\n  ArrayList<ColumnSpec> columnsToRemove=new ArrayList<ColumnSpec>();\n  if (columns.size() != keys.size() && logger.isDebugEnabled()) {\n    logger.debug(\"Column and key counts are different. Checking only columns matching present keys.\");\n  }\n  for (int k=0; k < keys.size(); k++) {\n    ColumnSpec keySpec=keys.get(k);\n    boolean valueExists=false;\n    int valIndex;\n    ColumnSpec colSpec=null;\n    for (valIndex=0; valIndex < columns.size(); valIndex++) {\n      colSpec=columns.get(valIndex);\n      if (colSpec.getIndex() == keySpec.getIndex()) {\n        valueExists=true;\n        break;\n      }\n    }\n    if (!valueExists)     continue;\n    boolean columnStatic=true;\n    for (int row=0; row < keyValues.size(); row++) {\n      ColumnVal keyValue=keyValues.get(row).get(k);\n      ColumnVal colValue=columnValues.get(row).get(valIndex);\n      if (!(keySpec.getType() == colSpec.getType() && keySpec.getIndex() == colSpec.getIndex() && ((keyValue.getValue() == null && colValue.getValue() == null) || (keyValue.getValue() != null && keyValue.getValue().equals(colValue.getValue()))))) {\n        columnStatic=false;\n      }\n else {\n        logger.debug(\"Col \" + colSpec.getIndex() + \" @ Row \"+ row+ \" is static: \"+ keyValue.getValue()+ \" = \"+ colValue.getValue());\n      }\n    }\n    if (columnStatic)     columnsToRemove.add(colSpec);\n  }\n  if (columnsToRemove.size() == columns.size()) {\n    if (logger.isDebugEnabled())     logger.debug(\"All \" + columnsToRemove.size() + \" of \"+ columns.size()+ \" columns where static - leaving them as is to have a valid transaction\");\n    return transformed;\n  }\n  for (Iterator<ColumnSpec> iterator=columnsToRemove.iterator(); iterator.hasNext(); ) {\n    ColumnSpec columnToRemoveSpec=iterator.next();\n    int idx=columns.indexOf(columnToRemoveSpec);\n    for (Iterator<ArrayList<ColumnVal>> iterator2=columnValues.iterator(); iterator2.hasNext(); ) {\n      ArrayList<ColumnVal> values=iterator2.next();\n      values.remove(idx);\n    }\n    columns.remove(idx);\n    logger.debug(\"Col \" + columnToRemoveSpec.getIndex() + \" removed\");\n    transformed=true;\n  }\n  return transformed;\n}\n", "nl": "Find out which columns' values didn't change by comparing them to the key values. Remove columns, that didn't change, from the UPDATE.<br/> NOTE: we depend on keys containing the same items as columns for this to work, which is generally true for MySQL binary log, if it is not filtered before (eg. with a PrimaryKeyFilter.java)."}
{"code": "public static List<Type> types(List<? extends JCTree> trees){\n  ListBuffer<Type> ts=new ListBuffer<Type>();\n  for (List<? extends JCTree> l=trees; l.nonEmpty(); l=l.tail)   ts.append(l.head.type);\n  return ts.toList();\n}\n", "nl": "Return the types of a list of trees."}
{"code": "public void service(Mail mail){\n  counter++;\n  log(counter + \"\");\n  mail.setState(Mail.GHOST);\n}\n", "nl": "Count processed mails, marking each mail as completed after counting."}
{"code": "public static boolean isPostJDK7(String bytecodeVersion){\n  return JDK7.equals(bytecodeVersion) || JDK8.equals(bytecodeVersion);\n}\n", "nl": "Checks if the specified bytecode version string represents a JDK 1.7+ compatible bytecode version."}
{"code": "@Override protected void registerOperator(Process process){\n  super.registerOperator(process);\n  for (  ExecutionUnit subprocess : subprocesses) {\n    for (    Operator child : subprocess.getOperators()) {\n      child.registerOperator(process);\n    }\n  }\n}\n", "nl": "Register this operator chain and all of its children in the given process. This might change the name of the operator."}
{"code": "public ListQueuesResult listQueues(String queueNamePrefix) throws AmazonServiceException, AmazonClientException {\n  return amazonSqsToBeExtended.listQueues(queueNamePrefix);\n}\n", "nl": "<p> Returns a list of your queues. The maximum number of queues that can be returned is 1000. If you specify a value for the optional <code>QueueNamePrefix</code> parameter, only queues with a name beginning with the specified value are returned. </p>"}
{"code": "public void exitLock(long id){\n  lock(id).unlock();\n}\n", "nl": "Exits a lock."}
{"code": "public WriteMultipleRegistersResponse(int reference,int wordCount){\n  super();\n  setFunctionCode(Modbus.WRITE_MULTIPLE_REGISTERS);\n  setDataLength(4);\n  this.reference=reference;\n  this.wordCount=wordCount;\n}\n", "nl": "Constructs a new <tt>WriteMultipleRegistersResponse</tt> instance."}
{"code": "public IJavaElement createLambdaTypeElement(LambdaExpression expression,ICompilationUnit unit,HashSet existingElements,HashMap knownScopes){\n  return createElement(expression.scope,expression.sourceStart(),unit,existingElements,knownScopes).getParent();\n}\n", "nl": "Returns a handle denoting the lambda type identified by its scope."}
{"code": "@Override public boolean onLongClick(View v){\n  TextInfo parsed=(TextInfo)v.getTag();\n  String text=parsed.getClipboardPrefix() + parsed.getString();\n  Util.copyToClipboard(v.getContext(),R.string.atlas_text_cell_factory_clipboard_description,text);\n  Toast.makeText(v.getContext(),R.string.atlas_text_cell_factory_copied_to_clipboard,Toast.LENGTH_SHORT).show();\n  return true;\n}\n", "nl": "Long click copies message text and sender name to clipboard"}
{"code": "public synchronized static boolean isOpen(String location){\n  location=normalize(location);\n  HyperGraph graph=dbs.get(location);\n  return graph != null && graph.isOpen();\n}\n", "nl": "<p> Return <code>true</code> if the database at the given location is already open and <code>false</code> otherwise. </p>"}
{"code": "public NodeFilter createXPathFilter(String xpathFilterExpression){\n  return createXPath(xpathFilterExpression);\n}\n", "nl": "<p> <code>createXPathFilter</code> parses a NodeFilter from the given XPath filter expression. XPath filter expressions occur within XPath expressions such as <code>self::node()[ filterExpression ]</code> </p>"}
{"code": "long generateRegionId(){\n  long result;\n  do {\n    result=this.regionIdCtr.getAndIncrement();\n  }\n while (result <= MAX_RESERVED_DRID && result >= MIN_RESERVED_DRID);\n  return result;\n}\n", "nl": "Called when creating a new disk region (not a recovered one)."}
{"code": "public void incFunctionExecutionHasResultRunning(){\n  this._stats.incInt(_functionExecutionsHasResultRunningId,1);\n  aggregateStats.incFunctionExecutionHasResultRunning();\n}\n", "nl": "Increments the \"FunctionExecutionsCall\" stat."}
{"code": "public int size(){\n  return map.size();\n}\n", "nl": "Returns the number of attributes in this Map."}
{"code": "@Override public void onBookClicked(View view,String userId,String userName,String userImage,String cardId,String tagName,String contactNumber,String price,String title){\n  loadChat(userId,userName,userImage,tagName,contactNumber,price,title);\n}\n", "nl": "Method callback when the chat action is clicked"}
{"code": "public void generateBooleanEqual(BlockScope currentScope,boolean valueRequired){\n  boolean isEqualOperator=((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL;\n  Constant cst=this.left.optimizedBooleanConstant();\n  if (cst != Constant.NotAConstant) {\n    Constant rightCst=this.right.optimizedBooleanConstant();\n    if (rightCst != Constant.NotAConstant) {\n      this.left.generateCode(currentScope,false);\n      this.right.generateCode(currentScope,false);\n    }\n else     if (cst.booleanValue() == isEqualOperator) {\n      this.left.generateCode(currentScope,false);\n      this.right.generateCode(currentScope,valueRequired);\n    }\n else {\n      if (valueRequired) {\n        BranchLabel falseLabel=new BranchLabel();\n        this.left.generateCode(currentScope,false);\n        this.right.generateOptimizedBoolean(currentScope,null,falseLabel,valueRequired);\n      }\n else {\n        this.left.generateCode(currentScope,false);\n        this.right.generateCode(currentScope,false);\n      }\n    }\n    return;\n  }\n  cst=this.right.optimizedBooleanConstant();\n  if (cst != Constant.NotAConstant) {\n    if (cst.booleanValue() == isEqualOperator) {\n      this.left.generateCode(currentScope,valueRequired);\n      this.right.generateCode(currentScope,false);\n    }\n else {\n      if (valueRequired) {\n        BranchLabel falseLabel=new BranchLabel();\n        this.left.generateOptimizedBoolean(currentScope,null,falseLabel,valueRequired);\n        this.right.generateCode(currentScope,false);\n      }\n else {\n        this.left.generateCode(currentScope,false);\n        this.right.generateCode(currentScope,false);\n      }\n      return;\n    }\n    this.left.generateCode(currentScope,valueRequired);\n    this.right.generateCode(currentScope,valueRequired);\n  }\n}\n", "nl": "Boolean generation for == with boolean operands <p/> Note this code does not optimize conditional constants !!!!"}
{"code": "private void readObject(ObjectInputStream s) throws InvalidObjectException {\n  throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n}\n", "nl": "Defend against malicious streams."}
{"code": "@Override public void put(String name,long value){\n  emulatedFields.put(name,value);\n}\n", "nl": "Find and set the long value of a given field named <code>name</code> in the receiver."}
{"code": "public NdefMessage(NdefRecord record,NdefRecord... records){\n  if (record == null)   throw new NullPointerException(\"record cannot be null\");\n  for (  NdefRecord r : records) {\n    if (r == null) {\n      throw new NullPointerException(\"record cannot be null\");\n    }\n  }\n  mRecords=new NdefRecord[1 + records.length];\n  mRecords[0]=record;\n  System.arraycopy(records,0,mRecords,1,records.length);\n}\n", "nl": "Construct an NDEF Message from one or more NDEF Records."}
{"code": "@Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase DomPackage.LINE_TAG__DOCLET:\n    setDoclet((Doclet)newValue);\n  return;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public IntHashMap(Map t){\n  this(Math.max(2 * t.size(),11),0.75f);\n  putAll(t);\n}\n", "nl": "Constructs a new map with the same mappings as the given map.  The map is created with a capacity of twice the number of mappings in the given map or 11 (whichever is greater), and a default load factor, which is 0.75."}
{"code": "public View build(Context ctx){\n  mContainer=new LinearLayout(ctx);\n  if (mInnerShadow) {\n    if (!mInRTL) {\n      mContainer.setBackgroundResource(R.drawable.material_drawer_shadow_left);\n    }\n else {\n      mContainer.setBackgroundResource(R.drawable.material_drawer_shadow_right);\n    }\n  }\n  mRecyclerView=new RecyclerView(ctx);\n  mContainer.addView(mRecyclerView,ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);\n  mRecyclerView.setItemAnimator(new DefaultItemAnimator());\n  mRecyclerView.setFadingEdgeLength(0);\n  mRecyclerView.setClipToPadding(false);\n  mRecyclerView.setLayoutManager(new LinearLayoutManager(ctx));\n  mDrawerAdapter=new DrawerAdapter();\n  mRecyclerView.setAdapter(mDrawerAdapter);\n  if (mDrawer != null && mDrawer.mDrawerBuilder != null && (mDrawer.mDrawerBuilder.mFullscreen || mDrawer.mDrawerBuilder.mTranslucentStatusBar)) {\n    mRecyclerView.setPadding(mRecyclerView.getPaddingLeft(),UIUtils.getStatusBarHeight(ctx),mRecyclerView.getPaddingRight(),mRecyclerView.getPaddingBottom());\n  }\n  if (mDrawer != null && mDrawer.mDrawerBuilder != null && (mDrawer.mDrawerBuilder.mFullscreen || mDrawer.mDrawerBuilder.mTranslucentNavigationBar)) {\n    mRecyclerView.setPadding(mRecyclerView.getPaddingLeft(),mRecyclerView.getPaddingTop(),mRecyclerView.getPaddingRight(),UIUtils.getNavigationBarHeight(ctx));\n  }\n  createItems();\n  return mContainer;\n}\n", "nl": "build the MiniDrawer"}
{"code": "private void showFeedback(String message){\n  if (myHost != null) {\n    myHost.showFeedback(message);\n  }\n else {\n    System.out.println(message);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public void endVisit(MemberValuePair node){\n}\n", "nl": "End of visit the given type-specific AST node. <p> The default implementation does nothing. Subclasses may reimplement. </p>"}
{"code": "public <T>CLBuffer<T> createBuffer(CLMem.Usage usage,Pointer<T> data){\n  return createBuffer(usage,data,true);\n}\n", "nl": "#documentCallsFunction(\"clCreateBuffer\") Create an OpenCL buffer with the provided initial values, in copy mode (see <a href=\"http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateBuffer.html\">CL_MEM_COPY_HOST_PTR</a>)."}
{"code": "public void notifyClientsOffline(){\n  for (  MqttConnection connection : connections.values()) {\n    connection.offline();\n  }\n}\n", "nl": "Notify clients we're offline"}
{"code": "protected PropertyChangeListener createPropertyChangeListener(){\n  return getHandler();\n}\n", "nl": "Creates a listener that is responsible that updates the UI based on how the tree changes."}
{"code": "private Map<IVariable<?>,Map<URI,StatementPatternNode>> verifyGraphPattern(final AbstractTripleStore database,final GroupNodeBase<IGroupMemberNode> group){\n  Map<IVariable<?>,Map<URI,StatementPatternNode>> tmp=null;\n  final int arity=group.arity();\n  for (int i=0; i < arity; i++) {\n    final BOp child=group.get(i);\n    if (child instanceof GroupNodeBase<?>) {\n      throw new FulltextSearchException(\"Nested groups are not allowed.\");\n    }\n    if (child instanceof StatementPatternNode) {\n      final StatementPatternNode sp=(StatementPatternNode)child;\n      final TermNode p=sp.p();\n      if (!p.isConstant())       throw new FulltextSearchException(\"Expecting search predicate: \" + sp);\n      final URI uri=(URI)((ConstantNode)p).getValue();\n      if (!uri.stringValue().startsWith(FTS.NAMESPACE))       throw new FulltextSearchException(\"Expecting search predicate: \" + sp);\n      if (!ASTFulltextSearchOptimizer.searchUris.contains(uri))       throw new FulltextSearchException(\"Unknown search predicate: \" + uri);\n      final TermNode s=sp.s();\n      if (!s.isVariable())       throw new FulltextSearchException(\"Subject of search predicate is constant: \" + sp);\n      final IVariable<?> searchVar=((VarNode)s).getValueExpression();\n      if (tmp == null) {\n        tmp=new LinkedHashMap<IVariable<?>,Map<URI,StatementPatternNode>>();\n      }\n      Map<URI,StatementPatternNode> statementPatterns=tmp.get(searchVar);\n      if (statementPatterns == null) {\n        tmp.put(searchVar,statementPatterns=new LinkedHashMap<URI,StatementPatternNode>());\n      }\n      statementPatterns.put(uri,sp);\n    }\n  }\n  return tmp;\n}\n", "nl": "Validate the search request. This looks for external search magic predicates and returns them all. It is an error if anything else is found in the group. All such search patterns are reported back by this method, but the service can only be invoked for one a single search variable at a time. The caller will detect both the absence of any search and the presence of more than one search and throw an exception."}
{"code": "private void configurePlatformApiGwtClients(){\n  bind(UserServiceClient.class).to(UserServiceClientImpl.class).in(Singleton.class);\n  bind(UserProfileServiceClient.class).to(UserProfileServiceClientImpl.class).in(Singleton.class);\n  bind(GitServiceClient.class).to(GitServiceClientImpl.class).in(Singleton.class);\n  bind(AccountServiceClient.class).to(AccountServiceClientImpl.class).in(Singleton.class);\n  bind(FactoryServiceClient.class).to(FactoryServiceClientImpl.class).in(Singleton.class);\n  bind(WorkspaceServiceClient.class).to(WorkspaceServiceClientImpl.class).in(Singleton.class);\n  bind(VfsServiceClient.class).to(VfsServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectServiceClient.class).to(ProjectServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectImportersServiceClient.class).to(ProjectImportersServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectTypeServiceClient.class).to(ProjectTypeServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectTemplateServiceClient.class).to(ProjectTemplateServiceClientImpl.class).in(Singleton.class);\n  bind(BuilderServiceClient.class).to(BuilderServiceClientImpl.class).in(Singleton.class);\n  bind(RunnerServiceClient.class).to(RunnerServiceClientImpl.class).in(Singleton.class);\n  bind(ProjectTypeRegistry.class).to(ProjectTypeRegistryImpl.class).in(Singleton.class);\n  bind(ProjectTemplateRegistry.class).to(ProjectTemplateRegistryImpl.class).in(Singleton.class);\n}\n", "nl": "Configure GWT-clients for Codenvy Platform API services"}
{"code": "private static void updateNetwork(WifiManager wifiManager,WifiConfiguration config){\n  Integer foundNetworkID=findNetworkInExistingConfig(wifiManager,config.SSID);\n  if (foundNetworkID != null) {\n    Log.i(TAG,\"Removing old configuration for network \" + config.SSID);\n    wifiManager.removeNetwork(foundNetworkID);\n    wifiManager.saveConfiguration();\n  }\n  int networkId=wifiManager.addNetwork(config);\n  if (networkId >= 0) {\n    if (wifiManager.enableNetwork(networkId,true)) {\n      Log.i(TAG,\"Associating to network \" + config.SSID);\n      wifiManager.saveConfiguration();\n    }\n else {\n      Log.w(TAG,\"Failed to enable network \" + config.SSID);\n    }\n  }\n else {\n    Log.w(TAG,\"Unable to add network \" + config.SSID);\n  }\n}\n", "nl": "Update the network: either create a new network or modify an existing network"}
{"code": "public CModulesTableRenderer(final JTable table){\n  m_table=Preconditions.checkNotNull(table,\"IE02290: table argument can not be null\");\n}\n", "nl": "Creates a new renderer object."}
{"code": "protected Set adjustForQueuing(Set recipients){\n  Set result=null;\n  return result;\n}\n", "nl": "Adjust the specified set of recipients by removing any of them that are currently having their data queued."}
{"code": "public static Range iterateRangeBounds(CategoryDataset dataset){\n  return iterateRangeBounds(dataset,true);\n}\n", "nl": "Iterates over the data item of the category dataset to find the range bounds."}
{"code": "protected void checkDOMVersion(Hashtable h){\n  if (null == h)   h=new Hashtable();\n  final String DOM_LEVEL2_CLASS=\"org.w3c.dom.Document\";\n  final String DOM_LEVEL2_METHOD=\"createElementNS\";\n  final String DOM_LEVEL2WD_CLASS=\"org.w3c.dom.Node\";\n  final String DOM_LEVEL2WD_METHOD=\"supported\";\n  final String DOM_LEVEL2FD_CLASS=\"org.w3c.dom.Node\";\n  final String DOM_LEVEL2FD_METHOD=\"isSupported\";\n  final Class twoStringArgs[]={java.lang.String.class,java.lang.String.class};\n  try {\n    Class clazz=ObjectFactory.findProviderClass(DOM_LEVEL2_CLASS,ObjectFactory.findClassLoader(),true);\n    Method method=clazz.getMethod(DOM_LEVEL2_METHOD,twoStringArgs);\n    h.put(VERSION + \"DOM\",\"2.0\");\n    try {\n      clazz=ObjectFactory.findProviderClass(DOM_LEVEL2WD_CLASS,ObjectFactory.findClassLoader(),true);\n      method=clazz.getMethod(DOM_LEVEL2WD_METHOD,twoStringArgs);\n      h.put(ERROR + VERSION + \"DOM.draftlevel\",\"2.0wd\");\n      h.put(ERROR,ERROR_FOUND);\n    }\n catch (    Exception e2) {\n      try {\n        clazz=ObjectFactory.findProviderClass(DOM_LEVEL2FD_CLASS,ObjectFactory.findClassLoader(),true);\n        method=clazz.getMethod(DOM_LEVEL2FD_METHOD,twoStringArgs);\n        h.put(VERSION + \"DOM.draftlevel\",\"2.0fd\");\n      }\n catch (      Exception e3) {\n        h.put(ERROR + VERSION + \"DOM.draftlevel\",\"2.0unknown\");\n        h.put(ERROR,ERROR_FOUND);\n      }\n    }\n  }\n catch (  Exception e) {\n    h.put(ERROR + VERSION + \"DOM\",\"ERROR attempting to load DOM level 2 class: \" + e.toString());\n    h.put(ERROR,ERROR_FOUND);\n  }\n}\n", "nl": "Report version info from DOM interfaces.  Currently distinguishes between pre-DOM level 2, the DOM  level 2 working draft, the DOM level 2 final draft,  and not found."}
{"code": "public TLongHash(){\n  _hashingStrategy=this;\n}\n", "nl": "Creates a new <code>TLongHash</code> instance with the default capacity and load factor."}
{"code": "public ErrorCountTranspilationHandler(TranspilationHandler delegate){\n  this.delegate=delegate;\n}\n", "nl": "Decorates the given transpilation handler."}
{"code": "private synchronized void addChildNode(DefaultMutableTreeNode parent,DefaultMutableTreeNode child,int index){\n  DefaultTreeModel model=(DefaultTreeModel)getModel();\n  model.insertNodeInto(child,parent,index);\n}\n", "nl": "This method adds the child to the specified parent node at specific index."}
{"code": "public static List<LoadMetadataDetails> filterOutNewlyAddedSegments(List<LoadMetadataDetails> segments,List<LoadMetadataDetails> loadsToMerge,LoadMetadataDetails lastSeg){\n  List<LoadMetadataDetails> list=new ArrayList<>(segments);\n  List<LoadMetadataDetails> trimmedList=new ArrayList<>(CarbonCommonConstants.DEFAULT_COLLECTION_SIZE);\n  CarbonDataMergerUtil.sortSegments(list);\n  trimmedList=list.subList(0,list.indexOf(lastSeg) + 1);\n  return trimmedList;\n}\n", "nl": "Removing the already merged segments from list."}
{"code": "public void count(Collection<T> collection){\n  for (  T element : collection) {\n    count(element);\n  }\n}\n", "nl": "Increment the counts for all elements contained in the collection. When elements are contained multiple times, they are counted multiple times as well."}
{"code": "@Override public boolean equals(Object o){\n  if (this == o)   return true;\n  if (o == null || !(o instanceof RyaType))   return false;\n  RyaType ryaType=(RyaType)o;\n  if (data != null ? !data.equals(ryaType.data) : ryaType.data != null)   return false;\n  if (dataType != null ? !dataType.equals(ryaType.dataType) : ryaType.dataType != null)   return false;\n  return true;\n}\n", "nl": "Determine equality based on string representations of data and datatype."}
{"code": "public void testTimedInvokeAny1() throws Throwable {\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    try {\n      e.invokeAny(null,MEDIUM_DELAY_MS,MILLISECONDS);\n      shouldThrow();\n    }\n catch (    NullPointerException success) {\n    }\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "nl": "timed invokeAny(null) throws NullPointerException"}
{"code": "public BinomialMinPQ(Key[] a){\n  comp=new MyComparator();\n  for (  Key k : a)   insert(k);\n}\n", "nl": "Initializes a priority queue with given keys Worst case is O(n*log(n))"}
{"code": "public void addField(FieldInfo finfo) throws DuplicateMemberException {\n  testExistingField(finfo.getName(),finfo.getDescriptor());\n  fields.add(finfo);\n}\n", "nl": "Appends a field to the class."}
{"code": "@Override public String toString(){\n  StringBuffer result=new StringBuffer();\n  for (int i=0; i < data.length; i++) {\n    result.append((i == 0 ? \"\" : \",\") + data[i]);\n  }\n  return result.toString();\n}\n", "nl": "Returns a string representation of the data row."}
{"code": "public String globalInfo(){\n  return \"Applies the given filter before calling the given distance function.\";\n}\n", "nl": "Returns a string describing this object."}
{"code": "public void testFieldTypeTablesMatch() throws Exception {\n  FieldDescriptor.Type[] values1=FieldDescriptor.Type.values();\n  WireFormat.FieldType[] values2=WireFormat.FieldType.values();\n  assertEquals(values1.length,values2.length);\n  for (int i=0; i < values1.length; i++) {\n    assertEquals(values1[i].toString(),values2[i].toString());\n  }\n}\n", "nl": "Test that the FieldDescriptor.Type enum is the same as the WireFormat.FieldType enum."}
{"code": "public static String toRegex(String glob,char separator){\n  return new GlobToRegexParser(glob,separator).parseToRegex();\n}\n", "nl": "Converts the given glob pattern into a regular expression."}
{"code": "private void drawFrequencies(Graphics2D graphics){\n  Stroke currentStroke=graphics.getStroke();\n  long minFrequency=getMinDisplayFrequency();\n  long maxFrequency=getMaxDisplayFrequency();\n  int label=mLabelSizeMonitor.getLabelIncrement(graphics);\n  int major=mLabelSizeMonitor.getMajorTickIncrement(graphics);\n  int minor=mLabelSizeMonitor.getMinorTickIncrement(graphics);\n  if (minor == 0) {\n    minor=1;\n  }\n  long frequency=minFrequency - (minFrequency % minor);\n  while (frequency < maxFrequency) {\n    if (frequency % label == 0) {\n      drawFrequencyLineAndLabel(graphics,frequency);\n    }\n else     if (frequency % major == 0) {\n      drawTickLine(graphics,frequency,true);\n    }\n else {\n      drawTickLine(graphics,frequency,false);\n    }\n    frequency+=minor;\n  }\n}\n", "nl": "Draws the frequency lines and labels every 10kHz"}
{"code": "final public void yyclose() throws java.io.IOException {\n  yy_atEOF=true;\n  yy_endRead=yy_startRead;\n  if (yy_reader != null)   yy_reader.close();\n}\n", "nl": "Closes the input stream."}
{"code": "public static void execute(ExecutablePool pool,int txId){\n  RollbackOpImpl op=new RollbackOpImpl(txId);\n  pool.execute(op);\n}\n", "nl": "Does a rollback on the server for given transaction"}
{"code": "public static void fft(ComplexArray ca,boolean inverse){\n  final double[] real=ca.real;\n  final double[] complex=ca.complex;\n  int n, mmax, m, j, istep, i;\n  double wtemp, wr, wpr, wpi, wi, theta;\n  double tempr, tempi;\n  final double radians;\n  if (inverse) {\n    radians=2.0 * Math.PI;\n  }\n else {\n    radians=-2.0 * Math.PI;\n  }\n  n=ca.length << 1;\n  j=1;\n  for (i=1; i < n; i+=2) {\n    if (j > i) {\n      final int halfI=i >> 1;\n      final int halfJ=j >> 1;\n      swap(real,halfJ,halfI);\n      swap(complex,halfJ,halfI);\n    }\n    m=ca.length;\n    while (m >= 2 && j > m) {\n      j-=m;\n      m>>=1;\n    }\n    j+=m;\n  }\n  mmax=2;\n  while (n > mmax) {\n    istep=mmax << 1;\n    theta=(radians / mmax);\n    wtemp=Math.sin(0.5 * theta);\n    wpr=-2.0 * wtemp * wtemp;\n    wpi=Math.sin(theta);\n    wr=1.0;\n    wi=0.0;\n    for (m=1; m < mmax; m+=2) {\n      for (i=m; i <= n; i+=istep) {\n        j=i + mmax;\n        final int halfI=i >> 1;\n        final int halfJ=j >> 1;\n        tempr=wr * real[halfJ] - wi * complex[halfJ];\n        tempi=wr * complex[halfJ] + wi * real[halfJ];\n        real[halfJ]=real[halfI] - tempr;\n        complex[halfJ]=complex[halfI] - tempi;\n        real[halfI]+=tempr;\n        complex[halfI]+=tempi;\n      }\n      wtemp=wr;\n      wr+=wr * wpr - wi * wpi;\n      wi+=wi * wpr + wtemp * wpi;\n    }\n    mmax=istep;\n  }\n}\n", "nl": "Computes the fast fourier transform"}
{"code": "public BitVector dominators(BasicBlock block,IR ir){\n  BitVector dominators=new BitVector(ir.getMaxBasicBlockNumber() + 1);\n  dominators.set(block.getNumber());\n  while ((block=getIdom(block,ir)) != null) {\n    dominators.set(block.getNumber());\n  }\n  return dominators;\n}\n", "nl": "This method returns the set of blocks that dominates the passed block, i.e., it answers the question \"Who dominates me?\""}
{"code": "@Override public void repaint(long tm,int x,int y,int width,int height){\n}\n", "nl": "Overridden for performance reasons. See the <a href=\"#override\">Implementation Note</a>  for more information."}
{"code": "public void disconnectPort(MrcPortController p){\n  istream=null;\n  ostream=null;\n  if (controller != p) {\n    log.warn(\"disconnectPort: disconnect called from non-connected MrcPortController\");\n  }\n  controller=null;\n}\n", "nl": "Break connection to existing MrcPortController object. Once broken, attempts to send via \"message\" member will fail."}
{"code": "public GenericEntry createOrganizationUnit(String customerId,String orgUnitName,String parentOrgUnitPath,String description,boolean blockInheritance) throws AppsForYourDomainException, MalformedURLException, IOException, ServiceException {\n  GenericEntry entry=new GenericEntry();\n  entry.addProperty(\"parentOrgUnitPath\",parentOrgUnitPath);\n  entry.addProperty(\"description\",description);\n  entry.addProperty(\"name\",orgUnitName);\n  entry.addProperty(\"blockInheritance\",String.valueOf(blockInheritance));\n  entry=service.insert(new URL(\"https://apps-apis.google.com/a/feeds/orgunit/2.0/\" + customerId),entry);\n  return entry;\n}\n", "nl": "Create a new organization unit under the given parent."}
{"code": "private boolean isSomethingToSave(){\n  if (allowEmpty) {\n    return true;\n  }\n  String currentInput=format(input.getText());\n  return currentInput != null && !currentInput.isEmpty();\n}\n", "nl": "Check if there is currently something to save, based on the allowEmpty property and the current input (possibly after formatting)."}
{"code": "public void processingInstruction(String target,String data) throws SAXException {\n  charactersFlush();\n  int dataIndex=m_data.size();\n  m_previous=addNode(DTM.PROCESSING_INSTRUCTION_NODE,DTM.PROCESSING_INSTRUCTION_NODE,m_parents.peek(),m_previous,-dataIndex,false);\n  m_data.addElement(m_valuesOrPrefixes.stringToIndex(target));\n  m_values.addElement(data);\n  m_data.addElement(m_valueIndex++);\n}\n", "nl": "Override the processingInstruction() interface in SAX2DTM2. <p> %OPT% This one is different from SAX2DTM.processingInstruction() in that we do not use extended types for PI nodes. The name of the PI is saved in the DTMStringPool. Receive notification of a processing instruction."}
{"code": "public static boolean equals(Object[] array1,Object[] array2){\n  if (array1 == array2) {\n    return true;\n  }\n  if (array1 == null || array2 == null || array1.length != array2.length) {\n    return false;\n  }\n  for (int i=0; i < array1.length; i++) {\n    Object e1=array1[i], e2=array2[i];\n    if (!(e1 == null ? e2 == null : e1.equals(e2))) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Compares the two arrays."}
{"code": "public SVG build() throws SVGParseException {\n  if (data == null) {\n    throw new IllegalStateException(\"SVG input not specified. Call one of the readFrom...() methods first.\");\n  }\n  try {\n    final SVGParser.SVGHandler handler=new SVGParser.SVGHandler();\n    handler.setColorSwap(searchColor,replaceColor,overideOpacity);\n    handler.setWhiteMode(whiteMode);\n    if (strokeColorFilter != null) {\n      handler.strokePaint.setColorFilter(strokeColorFilter);\n    }\n    if (fillColorFilter != null) {\n      handler.fillPaint.setColorFilter(fillColorFilter);\n    }\n    if (!data.markSupported())     data=new BufferedInputStream(data);\n    try {\n      data.mark(4);\n      byte[] magic=new byte[2];\n      int r=data.read(magic,0,2);\n      int magicInt=(magic[0] + ((magic[1]) << 8)) & 0xffff;\n      data.reset();\n      if (r == 2 && magicInt == GZIPInputStream.GZIP_MAGIC) {\n        GZIPInputStream gin=new GZIPInputStream(data);\n        data=gin;\n      }\n    }\n catch (    IOException ioe) {\n      throw new SVGParseException(ioe);\n    }\n    final SVG svg=SVGParser.parse(new InputSource(data),handler);\n    return svg;\n  }\n  finally {\n    if (closeInputStream) {\n      try {\n        data.close();\n      }\n catch (      IOException e) {\n        Log.e(SVGParser.TAG,\"Error closing SVG input stream.\",e);\n      }\n    }\n  }\n}\n", "nl": "Loads, reads, parses the SVG (or SVGZ)."}
{"code": "public synchronized OMGraphicList prepare(){\n  OMGraphicList list=getList();\n  if (list == null) {\n    list=new OMGraphicList();\n  }\n else {\n    list.clear();\n  }\n  Debug.message(\"basic\",getName() + \"|DayNightLayer.prepare(): doing it\");\n  OMGraphic ras=createImage(getProjection());\n  if (timer != null)   timer.restart();\n  list.add(ras);\n  return list;\n}\n", "nl": "Prepares the graphics for the layer. This is where the getRectangle() method call is made on the location. <p> Occasionally it is necessary to abort a prepare call. When this happens, the map will set the cancel bit in the LayerThread, (the thread that is running the prepare). If this Layer needs to do any cleanups during the abort, it should do so, but return out of the prepare asap."}
{"code": "private String toIndentedString(Object o){\n  if (o == null) {\n    return \"null\";\n  }\n  return o.toString().replace(\"\\n\",\"\\n    \");\n}\n", "nl": "Convert the given object to string with each line indented by 4 spaces (except the first line)."}
{"code": "public void insert(INode n){\n  stack.push(n);\n}\n", "nl": "Insert pushes the element onto the stack."}
{"code": "protected boolean drawTopBorder(Component c,Graphics g,int x,int y,int width,int height){\n  Rectangle titleBarRect=new Rectangle(x,y,width,BORDER_SIZE);\n  if (!g.getClipBounds().intersects(titleBarRect)) {\n    return false;\n  }\n  int maxX=width - 1;\n  int maxY=BORDER_SIZE - 1;\n  g.setColor(frameColor);\n  g.drawLine(x,y + 2,maxX - 2,y + 2);\n  g.drawLine(x,y + 3,maxX - 2,y + 3);\n  g.drawLine(x,y + 4,maxX - 2,y + 4);\n  g.setColor(frameHighlight);\n  g.drawLine(x,y,maxX,y);\n  g.drawLine(x,y + 1,maxX,y + 1);\n  g.drawLine(x,y + 2,x,y + 4);\n  g.drawLine(x + 1,y + 2,x + 1,y + 4);\n  g.setColor(frameShadow);\n  g.drawLine(x + 4,y + 4,maxX - 4,y + 4);\n  g.drawLine(maxX,y + 1,maxX,maxY);\n  g.drawLine(maxX - 1,y + 2,maxX - 1,maxY);\n  return true;\n}\n", "nl": "Draws the FrameBorder's top border."}
{"code": "public String fullTypeName(){\n  StringBuilder strb=new StringBuilder();\n  boolean _moduleNameSet=this.moduleNameSet();\n  if (_moduleNameSet) {\n    String _moduleName=this.getModuleName();\n    strb.append(_moduleName);\n  }\n  boolean _typeNameSet=this.typeNameSet();\n  if (_typeNameSet) {\n    strb.append(\".\");\n    String _typeName=this.getTypeName();\n    strb.append(_typeName);\n  }\n  return strb.toString();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private E xfer(E e,boolean haveData,int how,long nanos){\n  if (haveData && (e == null))   throw new NullPointerException();\n  Node s=null;\n  retry:   for (; ; ) {\n    for (Node h=head, p=h; p != null; ) {\n      boolean isData=p.isData;\n      Object item=p.item;\n      if (item != p && (item != null) == isData) {\n        if (isData == haveData)         break;\n        if (p.casItem(item,e)) {\n          for (Node q=p; q != h; ) {\n            Node n=q.next;\n            if (head == h && casHead(h,n == null ? q : n)) {\n              h.forgetNext();\n              break;\n            }\n            if ((h=head) == null || (q=h.next) == null || !q.isMatched())             break;\n          }\n          LockSupport.unpark(p.waiter);\n          return LinkedTransferQueue.<E>cast(item);\n        }\n      }\n      Node n=p.next;\n      p=(p != n) ? n : (h=head);\n    }\n    if (how != NOW) {\n      if (s == null)       s=new Node(e,haveData);\n      Node pred=tryAppend(s,haveData);\n      if (pred == null)       continue retry;\n      if (how != ASYNC)       return awaitMatch(s,pred,e,(how == TIMED),nanos);\n    }\n    return e;\n  }\n}\n", "nl": "Implements all queuing methods. See above for explanation."}
{"code": "public ButtonColors(Color top,Color leftOuter,Color leftInner,Color edge,Color edgeShade,Color shadow,Color interior){\n  this.top=top;\n  this.leftOuter=leftOuter;\n  this.leftInner=leftInner;\n  this.edge=edge;\n  this.edgeShade=edgeShade;\n  this.shadow=shadow;\n  this.interior=interior;\n}\n", "nl": "Creates a new ButtonColors object."}
{"code": "public static PropertyValuesHolder ofObject(String propertyName,TypeEvaluator evaluator,Object... values){\n  PropertyValuesHolder pvh=new PropertyValuesHolder(propertyName);\n  pvh.setObjectValues(values);\n  pvh.setEvaluator(evaluator);\n  return pvh;\n}\n", "nl": "Constructs and returns a PropertyValuesHolder with a given property name and set of Object values. This variant also takes a TypeEvaluator because the system cannot automatically interpolate between objects of unknown type."}
{"code": "public void paintDesktopPaneBackground(SynthContext context,Graphics g,int x,int y,int w,int h){\n  paintBackground(context,g,x,y,w,h,null);\n}\n", "nl": "Paints the background of a desktop pane."}
{"code": "public void addInfo(String msg){\n  addInfo(msg,null);\n}\n", "nl": "Adds an <code>INFO</code> entry filled with the given message to this status. If the current severity is <code>OK</code> it will be changed to <code>INFO </code>. It will remain unchanged otherwise."}
{"code": "public int hashCode(){\n  return toString().hashCode();\n}\n", "nl": "Returns a hashcode for this DerValue."}
{"code": "@Override protected EClass eStaticClass(){\n  return SexecPackage.Literals.SEQUENCE;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static List<String> readLines(Reader input) throws IOException {\n  BufferedReader reader=toBufferedReader(input);\n  List<String> list=new ArrayList<String>();\n  String line=reader.readLine();\n  while (line != null) {\n    list.add(line);\n    line=reader.readLine();\n  }\n  return list;\n}\n", "nl": "Get the contents of a <code>Reader</code> as a list of Strings, one entry per line. <p> This method buffers the input internally, so there is no need to use a <code>BufferedReader</code>."}
{"code": "private void validate(){\n  if (checkers != null) {\n    for (    RamlChecker checker : checkers) {\n      Pair<Set<Issue>,Set<Issue>> check=checker.check(published,implemented);\n      warnings.addAll(check.getFirst());\n      errors.addAll(check.getSecond());\n    }\n  }\n}\n", "nl": "Main orchestration method that will compare two Raml models together and identify discrepancies between the implementation and contract"}
{"code": "@Override @TargetApi(21) public void onReceivedClientCertRequest(WebView view,ClientCertRequest request){\n  PluginManager pluginManager=this.parentEngine.pluginManager;\n  if (pluginManager != null && pluginManager.onReceivedClientCertRequest(null,new CordovaClientCertRequest(request))) {\n    parentEngine.client.clearLoadTimeoutTimer();\n    return;\n  }\n  super.onReceivedClientCertRequest(view,request);\n}\n", "nl": "On received client cert request. The method forwards the request to any running plugins before using the default implementation."}
{"code": "public OracleExtractException(String message,Throwable cause){\n  super(message,cause);\n}\n", "nl": "Creates a new <code>OracleExtractException</code> object"}
{"code": "public double positivePredictedValue(int classindex){\n  int tp=truePositives(classindex);\n  return (double)tp / ((double)(tp + falsePositives(classindex)));\n}\n", "nl": "Provides the <i>positive predicted value</i> for the specified class."}
{"code": "public void removeCardOffer(Offer offer){\n  ((AcceptedOfferBinder)getDataBinder(TYPE_CARDS)).remove(offer);\n}\n", "nl": "Set the offer to be removed from the AcceptedOfferBinder"}
{"code": "public static Coord inverseMercator(double latitude,double longitude){\n  double x=(longitude / SIZE) * 180;\n  double y=(latitude / SIZE) * 180;\n  y=180.0 / Math.PI * (2 * MathUtil.atan(MathUtil.exp(y * Math.PI / 180)) - Math.PI / 2);\n  return new Coord(y,x,false);\n}\n", "nl": "Create a unprojected Coord(Latitude, Longitude) from the projected Coord"}
{"code": "private List<Pair<String,String>> extractPortsList(final MachineEntity machine){\n  List<Pair<String,String>> ports=new ArrayList<>();\n  if (machine == null || machine.getRuntime() == null) {\n    return ports;\n  }\n  Map<String,? extends Server> servers=machine.getRuntime().getServers();\n  for (  Map.Entry<String,? extends Server> entry : servers.entrySet()) {\n    String port=entry.getKey();\n    if (port.endsWith(\"/tcp\")) {\n      String portWithoutTcp=port.substring(0,port.length() - 4);\n      String description=portWithoutTcp + \" (\" + entry.getValue().getRef()+ \")\";\n      Pair<String,String> pair=new Pair<>(description,portWithoutTcp);\n      ports.add(pair);\n    }\n  }\n  return ports;\n}\n", "nl": "Extracts list of ports available for connecting to the remote debugger."}
{"code": "public void keyReleased(KeyEvent e){\n}\n", "nl": "Key Listener."}
{"code": "private void initialize(){\n  this.setIconImages(DisplayUtils.getZapIconImages());\n  this.setVisible(false);\n  this.setTitle(Constant.PROGRAM_NAME);\n  final Dimension dim=restoreWindowSize();\n  if (dim == null) {\n    this.setSize(WINDOW_DEFAULT_WIDTH,WINDOW_DEFAULT_HEIGHT);\n  }\n  final Point point=restoreWindowLocation();\n  if (point == null) {\n    centerFrame();\n  }\n  restoreWindowState();\n  this.addWindowStateListener(new FrameWindowStateListener());\n  this.addComponentListener(new FrameResizedListener());\n}\n", "nl": "This method initializes this"}
{"code": "public boolean IsWindowsAuthEnabled(){\n  return this._windowsAuthEnabled;\n}\n", "nl": "get if Windows authentication is enabled or not"}
{"code": "private void muteDevice(String code){\n  resultBuilder.build(code);\n  AudioManager audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);\n  audioManager.setStreamVolume(AudioManager.STREAM_RING,DEFAULT_VOLUME,DEFAULT_FLAG);\n}\n", "nl": "Mute the device."}
{"code": "public TextOverflowHandle(TextHolderFigure owner){\n  super(owner);\n}\n", "nl": "Creates a new instance."}
{"code": "public void write(ByteCodeWriter out) throws IOException {\n  out.writeShort(_accessFlags);\n  out.writeUTF8Const(_name);\n  out.writeUTF8Const(_descriptor);\n  out.writeShort(_attributes.size());\n  for (int i=0; i < _attributes.size(); i++) {\n    Attribute attr=_attributes.get(i);\n    attr.write(out);\n  }\n}\n", "nl": "Writes the field to the output."}
{"code": "public static void exportWriter(Cursor cursor,BufferedWriter out,boolean header,String delim,char quote,ExportFilter filter) throws IOException {\n  String delimiter=(delim == null) ? DEFAULT_DELIMITER : delim;\n  Pattern needsQuotePattern=Pattern.compile(\"(?:\" + Pattern.quote(delimiter) + \")|(?:\"+ Pattern.quote(\"\" + quote)+ \")|(?:[\\n\\r])\");\n  List<? extends Column> origCols=cursor.getTable().getColumns();\n  List<Column> columns=new ArrayList<Column>(origCols);\n  columns=filter.filterColumns(columns);\n  Collection<String> columnNames=null;\n  if (!origCols.equals(columns)) {\n    columnNames=new HashSet<String>();\n    for (    Column c : columns) {\n      columnNames.add(c.getName());\n    }\n  }\n  if (header) {\n    for (Iterator<Column> iter=columns.iterator(); iter.hasNext(); ) {\n      writeValue(out,iter.next().getName(),quote,needsQuotePattern);\n      if (iter.hasNext()) {\n        out.write(delimiter);\n      }\n    }\n    out.newLine();\n  }\n  Object[] unfilteredRowData=new Object[columns.size()];\n  Row row;\n  while ((row=cursor.getNextRow(columnNames)) != null) {\n    for (int i=0; i < columns.size(); i++) {\n      unfilteredRowData[i]=columns.get(i).getRowValue(row);\n    }\n    Object[] rowData=filter.filterRow(unfilteredRowData);\n    if (rowData == null) {\n      continue;\n    }\n    for (int i=0; i < columns.size(); i++) {\n      Object obj=rowData[i];\n      if (obj != null) {\n        String value=null;\n        if (obj instanceof byte[]) {\n          value=ByteUtil.toHexString((byte[])obj);\n        }\n else {\n          value=String.valueOf(rowData[i]);\n        }\n        writeValue(out,value,quote,needsQuotePattern);\n      }\n      if (i < columns.size() - 1) {\n        out.write(delimiter);\n      }\n    }\n    out.newLine();\n  }\n  out.flush();\n}\n", "nl": "Copy a table in this database into a new delimited text file."}
{"code": "public void storeOriginals(){\n  mStartingStartTrim=mStartTrim;\n  mStartingEndTrim=mEndTrim;\n  mStartingRotation=mRotation;\n}\n", "nl": "If the start / end trim are offset to begin with, store them so that animation starts from that offset."}
{"code": "public InvertedGenerationalDistance(Problem problem,NondominatedPopulation referenceSet){\n  this(problem,referenceSet,Settings.getIGDPower());\n}\n", "nl": "Constructs an inverted generational distance evaluator for the specified problem and corresponding reference set."}
{"code": "public RegisteredProject removeProjectType(String projectPath,String type) throws ConflictException, ForbiddenException, NotFoundException, ServerException {\n  final RegisteredProject project=getProject(projectPath);\n  if (project == null) {\n    return null;\n  }\n  List<String> newMixins=project.getMixins();\n  String newType=project.getType();\n  if (newMixins.contains(type)) {\n    newMixins.remove(type);\n  }\n else   if (newType.equals(type)) {\n    if (project.isDetected()) {\n      projects.remove(project.getPath());\n      return null;\n    }\n    newType=BaseProjectType.ID;\n  }\n  final NewProjectConfig conf=new NewProjectConfig(project.getPath(),newType,newMixins,project.getName(),project.getDescription(),project.getAttributes(),project.getSource());\n  return putProject(conf,project.getBaseFolder(),true,project.isDetected());\n}\n", "nl": "Extension writer should call this method to apply changes which supposedly make the Project no longer have particular Project Type. In a case of removing primary project type: - if the project was NOT detected BASE Project Type will be set as primary - if the project was detected it will be converted back to the folder For example: - extension code knows that removing some file inside project's file system will (or may) cause removing particular project type"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public void quit(){\n}\n", "nl": "Called by the Console when the user is quitting the SimState.  A good place to stick stuff that you'd ordinarily put in a finalizer -- finalizers are tenuous at best. So here you'd put things like the code that closes the relevant display windows etc."}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public static String removeLeadingZeros(final String str){\n  String result=str;\n  if (str != null && str.length() != 0) {\n    int startIndex=0;\n    while (startIndex < str.length() - 1) {\n      final char ch=str.charAt(startIndex);\n      if (ch != '0') {\n        break;\n      }\n      startIndex++;\n    }\n    if (startIndex > 0) {\n      result=str.substring(startIndex);\n    }\n  }\n  return result;\n}\n", "nl": "Remove leading zeros from string."}
{"code": "public int readNonBlock(byte[] buffer,int offset,int length) throws IOException {\n  return readTimeout(buffer,offset,length,0);\n}\n", "nl": "Reads the next chunk from the stream in non-blocking mode."}
{"code": "public CommunicationException(String arg0){\n  super(arg0);\n}\n", "nl": "Creates a new instance of CommunicationException."}
{"code": "@SmallTest public void testPreconditions(){\n  assertNotNull(mLeftButton);\n  assertTrue(\"center button should be right of left button\",mLeftButton.getRight() < mCenterButton.getLeft());\n  assertTrue(\"right button should be right of center button\",mCenterButton.getRight() < mRightButton.getLeft());\n}\n", "nl": "The name 'test preconditions' is a convention to signal that if this test doesn't pass, the test case was not set up properly and it might explain any and all failures in other tests.  This is not guaranteed to run before other tests, as junit uses reflection to find the tests."}
{"code": "private JSONWriter end(char mode,char c) throws JSONException {\n  if (this.mode != mode) {\n    throw new JSONException(mode == 'a' ? \"Misplaced endArray.\" : \"Misplaced endObject.\");\n  }\n  this.pop(mode);\n  try {\n    this.writer.write(c);\n  }\n catch (  IOException e) {\n    throw new JSONException(e);\n  }\n  this.comma=true;\n  return this;\n}\n", "nl": "End something."}
{"code": "public static void initPrivateKey(Properties props) throws Exception {\n  String privateKeyFilePath=props.getProperty(PRIVATE_KEY_FILE_PROP);\n  privateKeyAlias=\"\";\n  privateKeyEncrypt=null;\n  if (privateKeyFilePath != null && privateKeyFilePath.length() > 0) {\n    KeyStore ks=KeyStore.getInstance(\"PKCS12\");\n    privateKeyAlias=props.getProperty(PRIVATE_KEY_ALIAS_PROP);\n    if (privateKeyAlias == null) {\n      privateKeyAlias=\"\";\n    }\n    String keyStorePass=props.getProperty(PRIVATE_KEY_PASSWD_PROP);\n    char[] passPhrase=(keyStorePass != null ? keyStorePass.toCharArray() : null);\n    FileInputStream privateKeyFile=new FileInputStream(privateKeyFilePath);\n    try {\n      ks.load(privateKeyFile,passPhrase);\n    }\n  finally {\n      privateKeyFile.close();\n    }\n    Key key=ks.getKey(privateKeyAlias,passPhrase);\n    Certificate keyCert=ks.getCertificate(privateKeyAlias);\n    if (key instanceof PrivateKey && keyCert instanceof X509Certificate) {\n      privateKeyEncrypt=(PrivateKey)key;\n      privateKeySignAlgo=((X509Certificate)keyCert).getSigAlgName();\n      privateKeySubject=((X509Certificate)keyCert).getSubjectDN().getName();\n    }\n  }\n}\n", "nl": "Load the private key of the server. This method is not thread safe."}
{"code": "public final Vector3d vectorTo(IMovingAgent agent){\n  Vector3d v=new Vector3d();\n  v.sub(agent.getLocation(),location);\n  return v;\n}\n", "nl": "Calculate the vector from this agent to the provided one."}
{"code": "@DSComment(\"Wifi subsystem\") @DSSpec(DSCat.WIFI) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:36:05.312 -0500\",hash_original_method=\"13D7026BA6E2310038D9CCEC7D1F5CA4\",hash_generated_method=\"68D6939781BFBE3ABBF2F3F61C7E9CDE\") public boolean disconnect(){\n  try {\n    mService.disconnect();\n    return true;\n  }\n catch (  RemoteException e) {\n    return false;\n  }\n}\n", "nl": "Disassociate from the currently active access point. This may result in the asynchronous delivery of state change events."}
{"code": "public DynamicGVTBuilder(){\n}\n", "nl": "Constructs a new builder."}
{"code": "public void searchRaceWithEntrant(String stream){\n  entrantToSearch=stream;\n  raceFinder.setLocationRelativeTo(parent);\n  raceFinder.open(stream);\n  if (isDataStale()) {\n    reload();\n  }\n else {\n    searchRaceWithEntrant(currentRaces);\n  }\n}\n", "nl": "Search for a race with the given entrant. Opens the race finder as appropriate feedback and either request data if it is old or immediately start searching in the cached data."}
{"code": "public static <V,V1 extends V,V2 extends V,V3 extends V,V4 extends V>Map<String,V> toMap(String name1,V1 value1,String name2,V2 value2,String name3,V3 value3,String name4,V4 value4){\n  return populateMap(new HashMap<String,V>(),name1,value1,name2,value2,name3,value3,name4,value4);\n}\n", "nl": "Create a map from passed nameX, valueX parameters"}
{"code": "synchronized private boolean scatter(final Value predecessor,final double newDist){\n  if (newDist < dist) {\n    dist=newDist;\n    this.predecessor.set(predecessor);\n    return true;\n  }\n  return false;\n}\n", "nl": "Update the vertex state to the new (reduced) distance."}
{"code": "@Override public void eSet(int featureID,Object newValue){\nswitch (featureID) {\ncase ImPackage.SNIPPET__CODE:\n    setCode((String)newValue);\n  return;\n}\nsuper.eSet(featureID,newValue);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static Instances read(InputStream stream) throws Exception {\n  DataSource source;\n  Instances result;\n  source=new DataSource(stream);\n  result=source.getDataSet();\n  return result;\n}\n", "nl": "convencience method for loading a dataset in batch mode from a stream."}
{"code": "private void updateLastKnown(List<AuthnProvider> knownProviders){\n  _lastKnownConfiguration=new HashMap<URI,Long>();\n  for (  AuthnProvider provider : knownProviders) {\n    _lastKnownConfiguration.put(provider.getId(),provider.getLastModified());\n  }\n  _lastKnownLdapConnectionTimeout=SystemPropertyUtil.getLdapConnectionTimeout(_coordinator);\n}\n", "nl": "update out last known provider config information"}
{"code": "public TestConfigurationBuilder(TestConfiguration initialConfig){\n  this.diagnosticFiles=new ArrayList<>(initialConfig.getDiagnosticFiles());\n  this.testSourceFiles=new ArrayList<>(initialConfig.getTestSourceFiles());\n  this.processors=new LinkedHashSet<>(initialConfig.getProcessors());\n  this.options=new SimpleOptionMap();\n  this.addOptions(initialConfig.getOptions());\n  this.shouldEmitDebugInfo=initialConfig.shouldEmitDebugInfo();\n}\n", "nl": "Create a builder that has all of the optoins in initialConfig"}
{"code": "public TDoubleHashSet(int initialCapacity,TDoubleHashingStrategy strategy){\n  super(initialCapacity,strategy);\n}\n", "nl": "Creates a new <code>TDoubleHash</code> instance whose capacity is the next highest prime above <tt>initialCapacity + 1</tt> unless that value is already prime."}
{"code": "public DistributedLogManager createDistributedLogManager(String nameOfLogStream,ClientSharingOption clientSharingOption,Optional<DistributedLogConfiguration> streamConfiguration,Optional<DynamicDistributedLogConfiguration> dynamicStreamConfiguration) throws InvalidStreamNameException, IOException {\n  return namespace.createDistributedLogManager(nameOfLogStream,clientSharingOption,streamConfiguration,dynamicStreamConfiguration);\n}\n", "nl": "Create a DistributedLogManager for <i>nameOfLogStream</i>, with specified client sharing options. This method allows the caller to override global configuration options by supplying stream configuration overrides. Stream config overrides come in two flavors, static and dynamic. Static config never changes, and DynamicDistributedLogConfiguration is a) reloaded periodically and b) safe to access from any context."}
{"code": "public static Bitmap createThumbnailBitmap(Bitmap bitmap,Context context){\n  int sIconWidth=-1;\n  int sIconHeight=-1;\n  final Resources resources=context.getResources();\n  sIconWidth=sIconHeight=(int)resources.getDimension(android.R.dimen.app_icon_size);\n  final Paint sPaint=new Paint();\n  final Rect sBounds=new Rect();\n  final Rect sOldBounds=new Rect();\n  Canvas sCanvas=new Canvas();\n  int width=sIconWidth;\n  int height=sIconHeight;\n  sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,Paint.FILTER_BITMAP_FLAG));\n  final int bitmapWidth=bitmap.getWidth();\n  final int bitmapHeight=bitmap.getHeight();\n  if (width > 0 && height > 0) {\n    if (width < bitmapWidth || height < bitmapHeight) {\n      final float ratio=(float)bitmapWidth / bitmapHeight;\n      if (bitmapWidth > bitmapHeight) {\n        height=(int)(width / ratio);\n      }\n else       if (bitmapHeight > bitmapWidth) {\n        width=(int)(height * ratio);\n      }\n      final Config c=(width == sIconWidth && height == sIconHeight) ? bitmap.getConfig() : Config.ARGB_8888;\n      final Bitmap thumb=Bitmap.createBitmap(sIconWidth,sIconHeight,c);\n      final Canvas canvas=sCanvas;\n      final Paint paint=sPaint;\n      canvas.setBitmap(thumb);\n      paint.setDither(false);\n      paint.setFilterBitmap(true);\n      sBounds.set((sIconWidth - width) / 2,(sIconHeight - height) / 2,width,height);\n      sOldBounds.set(0,0,bitmapWidth,bitmapHeight);\n      canvas.drawBitmap(bitmap,sOldBounds,sBounds,paint);\n      return thumb;\n    }\n else     if (bitmapWidth < width || bitmapHeight < height) {\n      final Config c=Config.ARGB_8888;\n      final Bitmap thumb=Bitmap.createBitmap(sIconWidth,sIconHeight,c);\n      final Canvas canvas=sCanvas;\n      final Paint paint=sPaint;\n      canvas.setBitmap(thumb);\n      paint.setDither(false);\n      paint.setFilterBitmap(true);\n      canvas.drawBitmap(bitmap,(sIconWidth - bitmapWidth) / 2,(sIconHeight - bitmapHeight) / 2,paint);\n      return thumb;\n    }\n  }\n  return bitmap;\n}\n", "nl": "Returns a Bitmap representing the thumbnail of the specified Bitmap. The size of the thumbnail is defined by the dimension android.R.dimen.launcher_application_icon_size. <p/> This method is not thread-safe and should be invoked on the UI thread only."}
{"code": "public void start(@NonNull Context context,@NonNull android.support.v4.app.Fragment fragment){\n  if (PermissionsUtils.checkReadStoragePermission(fragment.getActivity())) {\n    fragment.startActivityForResult(getIntent(context),REQUEST_CODE);\n  }\n}\n", "nl": "Send the Intent with a custom request code"}
{"code": "public ImageException(String message){\n  super(message);\n}\n", "nl": "Constructs a new exception with the specified detail message. The cause is not initialized."}
{"code": "public void shutdown(boolean waitForJobsToComplete){\nsynchronized (nextRunnableLock) {\n    getLog().debug(\"Shutting down threadpool...\");\n    isShutdown=true;\n    if (workers == null)     return;\n    Iterator<WorkerThread> workerThreads=workers.iterator();\n    while (workerThreads.hasNext()) {\n      WorkerThread wt=workerThreads.next();\n      wt.shutdown();\n      availWorkers.remove(wt);\n    }\n    nextRunnableLock.notifyAll();\n    if (waitForJobsToComplete == true) {\n      boolean interrupted=false;\n      try {\n        while (handoffPending) {\n          try {\n            nextRunnableLock.wait(100);\n          }\n catch (          InterruptedException _) {\n            interrupted=true;\n          }\n        }\n        while (busyWorkers.size() > 0) {\n          WorkerThread wt=(WorkerThread)busyWorkers.getFirst();\n          try {\n            getLog().debug(\"Waiting for thread \" + wt.getName() + \" to shut down\");\n            nextRunnableLock.wait(2000);\n          }\n catch (          InterruptedException _) {\n            interrupted=true;\n          }\n        }\n        workerThreads=workers.iterator();\n        while (workerThreads.hasNext()) {\n          WorkerThread wt=(WorkerThread)workerThreads.next();\n          try {\n            wt.join();\n            workerThreads.remove();\n          }\n catch (          InterruptedException _) {\n            interrupted=true;\n          }\n        }\n      }\n  finally {\n        if (interrupted) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      getLog().debug(\"No executing jobs remaining, all threads stopped.\");\n    }\n    getLog().debug(\"Shutdown of threadpool complete.\");\n  }\n}\n", "nl": "<p> Terminate any worker threads in this thread group. </p> <p> Jobs currently in progress will complete. </p>"}
{"code": "@Override public Collection<Object> values(){\n  checkInitialized();\n  return Collections.unmodifiableCollection(super.values());\n}\n", "nl": "Returns an unmodifiable Collection view of the property values contained in this provider."}
{"code": "@Override public void onSensorChanged(SensorEvent event){\n  assert (event.values.length == 3);\n  assert WebViewCore.THREAD_NAME.equals(Thread.currentThread().getName());\n  if (!mIsRunning) {\n    return;\n  }\nswitch (event.sensor.getType()) {\ncase Sensor.TYPE_ACCELEROMETER:\n    if (mGravityVector == null) {\n      mGravityVector=new float[3];\n    }\n  mGravityVector[0]=event.values[0];\nmGravityVector[1]=event.values[1];\nmGravityVector[2]=event.values[2];\ngetOrientationUsingGetRotationMatrix();\nbreak;\ncase Sensor.TYPE_MAGNETIC_FIELD:\nif (mMagneticFieldVector == null) {\nmMagneticFieldVector=new float[3];\n}\nmMagneticFieldVector[0]=event.values[0];\nmMagneticFieldVector[1]=event.values[1];\nmMagneticFieldVector[2]=event.values[2];\ngetOrientationUsingGetRotationMatrix();\nbreak;\ndefault :\nassert (false);\n}\n}\n", "nl": "SensorEventListener implementation. Callbacks happen on the thread on which we registered - the WebCore thread."}
{"code": "public static BufferedImage createRGBImageFromCMYK(Raster cmykRaster,ICC_Profile cmykProfile){\n  BufferedImage image;\n  int w=cmykRaster.getWidth();\n  int h=cmykRaster.getHeight();\n  if (cmykProfile != null) {\n    ColorSpace cmykCS=new ICC_ColorSpace(cmykProfile);\n    image=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);\n    WritableRaster rgbRaster=image.getRaster();\n    ColorSpace rgbCS=image.getColorModel().getColorSpace();\n    ColorConvertOp cmykToRgb=new ColorConvertOp(cmykCS,rgbCS,null);\n    cmykToRgb.filter(cmykRaster,rgbRaster);\n  }\n else {\n    int[] rgb=new int[w * h];\n    int[] C=cmykRaster.getSamples(0,0,w,h,0,(int[])null);\n    int[] M=cmykRaster.getSamples(0,0,w,h,1,(int[])null);\n    int[] Y=cmykRaster.getSamples(0,0,w,h,2,(int[])null);\n    int[] K=cmykRaster.getSamples(0,0,w,h,3,(int[])null);\n    for (int i=0, imax=C.length; i < imax; i++) {\n      int k=K[i];\n      rgb[i]=(255 - Math.min(255,C[i] + k)) << 16 | (255 - Math.min(255,M[i] + k)) << 8 | (255 - Math.min(255,Y[i] + k));\n    }\n    Raster rgbRaster=Raster.createPackedRaster(new DataBufferInt(rgb,rgb.length),w,h,w,new int[]{0xff0000,0xff00,0xff},null);\n    ColorSpace cs=ColorSpace.getInstance(ColorSpace.CS_sRGB);\n    ColorModel cm=new DirectColorModel(cs,24,0xff0000,0xff00,0xff,0x0,false,DataBuffer.TYPE_INT);\n    image=new BufferedImage(cm,(WritableRaster)rgbRaster,true,null);\n  }\n  return image;\n}\n", "nl": "Creates a buffered image from a raster in the CMYK color space, converting the colors to RGB using the provided CMYK ICC_Profile. As seen from a comment made by 'phelps' at http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4799903"}
{"code": "@SuppressWarnings(\"unchecked\") private void processFields(){\n  List<FieldNode> fields=cn.fields;\n  for (  FieldNode field : fields) {\n    if (DescriptorMapping.getInstance().isTransformedField(className,field.name,field.desc)) {\n      String newDesc=transformFieldDescriptor(className,field.name,field.desc);\n      logger.info(\"Transforming field \" + field.name + \" from \"+ field.desc+ \" to \"+ newDesc);\n      if (!newDesc.equals(field.desc))       TransformationStatistics.transformBooleanField();\n      field.desc=newDesc;\n    }\n  }\n}\n", "nl": "Handle transformation of fields defined in this class"}
{"code": "public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent){\n  Instant instant=persistentAuditEvent.getAuditEventDate().atZone(ZoneId.systemDefault()).toInstant();\n  return new AuditEvent(Date.from(instant),persistentAuditEvent.getPrincipal(),persistentAuditEvent.getAuditEventType(),convertDataToObjects(persistentAuditEvent.getData()));\n}\n", "nl": "Convert a PersistentAuditEvent to an AuditEvent"}
{"code": "@Override public String toString(){\n  StringBuffer buf=new StringBuffer();\nswitch (getType()) {\ncase Building.LIGHT:\n    buf.append(\"Light \");\n  break;\ncase Building.MEDIUM:\nbuf.append(\"Medium \");\nbreak;\ncase Building.HEAVY:\nbuf.append(\"Heavy \");\nbreak;\ncase Building.HARDENED:\nbuf.append(\"Hardened \");\nbreak;\ncase Building.WALL:\nbuf.append(\"\");\nbreak;\n}\nswitch (getBldgClass()) {\ncase Building.HANGAR:\nbuf.append(\"Hangar \");\nbreak;\ncase Building.FORTRESS:\nbuf.append(\"Fortress \");\nbreak;\ncase Building.GUN_EMPLACEMENT:\nbuf.append(\"Gun Emplacement\");\nbreak;\ndefault :\nbuf.append(\"Standard \");\n}\nbuf.append(name);\nreturn buf.toString();\n}\n", "nl": "Get a String for this building."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public static void checkForOutputExistence(String outDir){\n  try {\n    FileSystem fs=FileSystem.get(conf);\n    Path outDirectory=new Path(outDir);\n    FileStatus[] outFiles=fs.listStatus(outDirectory);\n    assertEquals(\"number of files in directory not 1\",1,outFiles.length);\n    FSDataInputStream fsout=fs.open(outFiles[0].getPath());\n    BufferedReader outIn=new BufferedReader(new InputStreamReader(fsout));\n    String outLine=outIn.readLine();\n    outIn.close();\n    assertNotNull(\"file is empty\",outLine);\n    assertTrue(\"file is empty\",outLine.length() > 0);\n  }\n catch (  IOException e) {\n    fail(\"unable to read \" + outDir + \": \"+ e.getMessage());\n  }\n}\n", "nl": "<p> Checks for matrix in directory existence. </p>"}
{"code": "public static <T>T decodeFromBase64(Coder<T> coder,String encodedValue) throws CoderException {\n  return decodeFromSafeStream(coder,new ByteArrayInputStream(Base64.decodeBase64(encodedValue)),Coder.Context.OUTER);\n}\n", "nl": "Parses a value from a base64-encoded String using the given coder."}
{"code": "public String toJava(){\n  if (isFull()) {\n    return \"Wildcards.FULL\";\n  }\n else   if (isExact()) {\n    return \"Wildcards.EXACT\";\n  }\n  StringBuilder b=new StringBuilder();\n  EnumSet<Flag> myFlags=getWildcardedFlags();\n  if (myFlags.size() < 3) {\n    b.append(\"Wildcards.of(\" + commaJoiner.join(prefix(\"Flag.\",myFlags.iterator())) + \")\");\n  }\n else {\n    EnumSet<Flag> invFlags=inverted().getWildcardedFlags();\n    b.append(\"Wildcards.ofMatches(\" + commaJoiner.join(prefix(\"Flag.\",invFlags.iterator())) + \")\");\n  }\n  if (Flag.NW_SRC.isPartiallyOn(flags)) {\n    b.append(\".setNwSrcMask(\" + getNwSrcMask() + \")\");\n  }\n  if (Flag.NW_DST.isPartiallyOn(flags)) {\n    b.append(\".setNwDstMask(\" + getNwDstMask() + \")\");\n  }\n  return b.toString();\n}\n", "nl": "a Java expression that constructs 'this' wildcards set"}
{"code": "@Override public int perimeter(int size){\n  int retval=0;\n  QuadTreeNode neighbor=gtEqualAdjNeighbor(NORTH);\n  if (neighbor == null || neighbor instanceof WhiteNode)   retval+=size;\n else   if (neighbor instanceof GreyNode) {\n    retval+=neighbor.sumAdjacent(Quadrant.cSouthEast,Quadrant.cSouthWest,size);\n  }\n  neighbor=gtEqualAdjNeighbor(EAST);\n  if (neighbor == null || neighbor instanceof WhiteNode)   retval+=size;\n else   if (neighbor instanceof GreyNode) {\n    retval+=neighbor.sumAdjacent(Quadrant.cSouthWest,Quadrant.cNorthWest,size);\n  }\n  neighbor=gtEqualAdjNeighbor(SOUTH);\n  if (neighbor == null || neighbor instanceof WhiteNode)   retval+=size;\n else   if (neighbor instanceof GreyNode) {\n    retval+=neighbor.sumAdjacent(Quadrant.cNorthWest,Quadrant.cNorthEast,size);\n  }\n  neighbor=gtEqualAdjNeighbor(WEST);\n  if (neighbor == null || neighbor instanceof WhiteNode)   retval+=size;\n else   if (neighbor instanceof GreyNode) {\n    retval+=neighbor.sumAdjacent(Quadrant.cNorthEast,Quadrant.cSouthEast,size);\n  }\n  return retval;\n}\n", "nl": "Compute the perimeter for a black node."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(attrnotspecifiedvalue.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "public ScaleIOSnapshotVolumeResponse snapshotVolume(String volId,String snapshotName,String systemId) throws Exception {\n  String uri=ScaleIOConstants.getSnapshotVolumesURI(systemId);\n  ScaleIOSnapshotVolumes spVol=new ScaleIOSnapshotVolumes();\n  spVol.addSnapshot(volId,snapshotName);\n  ClientResponse response=post(URI.create(uri),getJsonForEntity(spVol));\n  return getResponseObject(ScaleIOSnapshotVolumeResponse.class,response);\n}\n", "nl": "Create a snapshot of the volume"}
{"code": "public AbortException(List<LocalizedText> customerMessages,List<LocalizedText> providerMessages){\n  super(customerMessages);\n  this.providerMessages=providerMessages;\n}\n", "nl": "Constructs a new exception with the specified localized text messages."}
{"code": "public void runTest() throws Throwable {\n  String namespaceURI=\"http://www.example.com/\";\n  String qualifiedName;\n  Document doc;\n  Attr newAttr;\n  doc=(Document)load(\"hc_staff\",true);\n{\n    boolean success=false;\n    try {\n      newAttr=doc.createAttributeNS(namespaceURI,\"\");\n    }\n catch (    DOMException ex) {\n      success=(ex.code == DOMException.INVALID_CHARACTER_ERR);\n    }\n    assertTrue(\"throw_INVALID_CHARACTER_ERR\",success);\n  }\n}\n", "nl": "Runs the test case."}
{"code": "public void testBogusArguments() throws Exception {\n  IllegalArgumentException expected=expectThrows(IllegalArgumentException.class,null);\n  assertTrue(expected.getMessage().contains(\"Unknown parameters\"));\n}\n", "nl": "Test that bogus arguments result in exception"}
{"code": "public static DeactivateInstanceE parse(javax.xml.stream.XMLStreamReader reader) throws java.lang.Exception {\n  DeactivateInstanceE object=new DeactivateInstanceE();\n  int event;\n  java.lang.String nillableValue=null;\n  java.lang.String prefix=\"\";\n  java.lang.String namespaceuri=\"\";\n  try {\n    while (!reader.isStartElement() && !reader.isEndElement())     reader.next();\n    java.util.Vector handledAttributes=new java.util.Vector();\n    while (!reader.isEndElement()) {\n      if (reader.isStartElement()) {\n        if (reader.isStartElement() && new javax.xml.namespace.QName(\"http://oscm.org/xsd\",\"deactivateInstance\").equals(reader.getName())) {\n          object.setDeactivateInstance(org.oscm.xsd.DeactivateInstance.Factory.parse(reader));\n        }\n else {\n          throw new org.apache.axis2.databinding.ADBException(\"Unexpected subelement \" + reader.getLocalName());\n        }\n      }\n else {\n        reader.next();\n      }\n    }\n  }\n catch (  javax.xml.stream.XMLStreamException e) {\n    throw new java.lang.Exception(e);\n  }\n  return object;\n}\n", "nl": "static method to create the object Precondition: If this object is an element, the current or next start element starts this object and any intervening reader events are ignorable If this object is not an element, it is a complex type and the reader is at the event just after the outer start element Postcondition: If this object is an element, the reader is positioned at its end element If this object is a complex type, the reader is positioned at the end element of its outer element"}
{"code": "public TLongIntHashMapDecorator(TLongIntHashMap map){\n  super();\n  this._map=map;\n}\n", "nl": "Creates a wrapper that decorates the specified primitive map."}
{"code": "public StringExpr_ createStringExpr_(){\n  StringExpr_Impl stringExpr_=new StringExpr_Impl();\n  return stringExpr_;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public double evaluate(double time){\n  scoreMatrix.setTime(time);\n  return -scoreMatrix.getScore(sitePatterns);\n}\n", "nl": "compute function value"}
{"code": "public void testQueueManagement(){\n  Message m1=new Message(h1,h3,\"dummy\",BUFFER_SIZE - 1);\n  h1.createNewMessage(m1);\n  assertEquals(1,h1.getNrofMessages());\n  Message m2=new Message(h1,h3,msgId1,BUFFER_SIZE / 3);\n  h1.createNewMessage(m2);\n  assertEquals(1,h1.getNrofMessages());\n  assertEquals(msgId1,h1.getMessageCollection().iterator().next().getId());\n  mc.reset();\n  clock.advance(10);\n  Message m3=new Message(h1,h3,msgId2,BUFFER_SIZE / 3);\n  h1.createNewMessage(m3);\n  clock.advance(10);\n  Message m4=new Message(h1,h3,\"newestMsg\",BUFFER_SIZE / 3);\n  h1.createNewMessage(m4);\n  clock.advance(10);\n  Message m5=new Message(h2,h3,\"MSG_from_h2\",BUFFER_SIZE / 2);\n  h2.createNewMessage(m5);\n  checkCreates(3);\n  h2.connect(h1);\n  h2.update(true);\n  assertTrue(mc.next());\n  assertEquals(mc.TYPE_DELETE,mc.getLastType());\n  assertEquals(h1,mc.getLastFrom());\n  assertEquals(msgId1,mc.getLastMsg().getId());\n  assertTrue(mc.getLastDropped());\n  assertTrue(mc.next());\n  assertEquals(mc.TYPE_DELETE,mc.getLastType());\n  assertEquals(msgId2,mc.getLastMsg().getId());\n  assertEquals(1,h1.getNrofMessages());\n  assertTrue(mc.next());\n  assertEquals(mc.TYPE_START,mc.getLastType());\n  assertEquals(h2,mc.getLastFrom());\n  assertFalse(mc.next());\n  clock.advance(10);\n  updateAllNodes();\n  assertTrue(mc.next());\n  assertEquals(mc.TYPE_RELAY,mc.getLastType());\n  assertEquals(h1,mc.getLastTo());\n  assertFalse(mc.next());\n}\n", "nl": "Tests if the FIFO queue management works"}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "protected void appendLongInteger(long longInt){\n  int size;\n  long temp=longInt;\n  for (size=0; (temp != 0) && (size < LONG_INTEGER_LENGTH_MAX); size++) {\n    temp=(temp >>> 8);\n  }\n  appendShortLength(size);\n  int i;\n  int shift=(size - 1) * 8;\n  for (i=0; i < size; i++) {\n    append((int)((longInt >>> shift) & 0xff));\n    shift=shift - 8;\n  }\n}\n", "nl": "Append long integer into mMessage. it's used for really long integers. This implementation doesn't check the validity of parameter, since it assumes that the values are validated in the GenericPdu setter methods."}
{"code": "protected boolean eq(Object x,Object y){\n  return x == y || x.equals(y);\n}\n", "nl": "Check for equality of non-null references x and y."}
{"code": "public static Builder builder(QueryRequest request){\n  return new Builder(request);\n}\n", "nl": "Returns a query request builder for an existing request."}
{"code": "@Override public void onViewDragStateChanged(int state){\n  if (state == mDragState) {\n    return;\n  }\n  if ((mDragState == ViewDragHelper.STATE_DRAGGING || mDragState == ViewDragHelper.STATE_SETTLING) && state == ViewDragHelper.STATE_IDLE && (mDragOffset == mConfigView.getVerticalDragRange())) {\n    mConfigView.hideView();\n  }\n  mDragState=state;\n}\n", "nl": "Verify if container is dragging or idle and check mDragOffset is bigger than dragRange, if true, set the visible to gone."}
{"code": "public boolean hasValue(){\n  return getValue() != null;\n}\n", "nl": "Returns whether it has the value."}
{"code": "public void testDoc2_Query2_All_Slops_Should_match() throws Exception {\n  for (int slop=0; slop < 30; slop++) {\n    float freq1=checkPhraseQuery(DOC_2,QUERY_2,slop,1);\n    float freq2=checkPhraseQuery(DOC_2_B,QUERY_2,slop,1);\n    assertTrue(\"slop=\" + slop + \" freq2=\"+ freq2+ \" should be greater than freq1 \"+ freq1,freq2 > freq1);\n  }\n}\n", "nl": "Test DOC_2 and QUERY_2. QUERY_2 has an exact match to DOC_2, so all slop values should succeed. Before LUCENE-1310, 0 succeeds, 1 through 7 fail, and 8 or greater succeeds."}
{"code": "static RuleDay parse(String day){\n  RuleDay d=new RuleDay();\n  if (day.startsWith(\"last\")) {\n    d.lastOne=true;\n    d.dayName=day.substring(4);\n    d.dow=getDOW(d.dayName);\n  }\n else {\n    int index;\n    if ((index=day.indexOf(\">=\")) != -1) {\n      d.dayName=day.substring(0,index);\n      d.dow=getDOW(d.dayName);\n      d.soonerOrLater=1;\n      d.thanDayOfMonth=Integer.parseInt(day.substring(index + 2));\n    }\n else     if ((index=day.indexOf(\"<=\")) != -1) {\n      d.dayName=day.substring(0,index);\n      d.dow=getDOW(d.dayName);\n      d.soonerOrLater=-1;\n      d.thanDayOfMonth=Integer.parseInt(day.substring(index + 2));\n    }\n else {\n      d.thanDayOfMonth=Integer.parseInt(day);\n    }\n  }\n  return d;\n}\n", "nl": "Parses the \"ON\" field and constructs a RuleDay."}
{"code": "private void processDataLinks(List<Draft3DataLink> dataLinks,ApplicationPort port,Draft3Job job,boolean strip){\n  for (  Draft3DataLink dataLink : dataLinks) {\n    String source=dataLink.getSource();\n    String destination=dataLink.getDestination();\n    String scatter=null;\n    if (job.getId().contains(DOT_SEPARATOR)) {\n      String mod=job.getId().substring(job.getId().indexOf(DOT_SEPARATOR) + 1);\n      if (strip) {\n        mod=mod.substring(mod.indexOf(DOT_SEPARATOR) + 1);\n      }\n      scatter=mod + SLASH_SEPARATOR + Draft3SchemaHelper.normalizeId(port.getId());\n    }\n else {\n      scatter=port.getId();\n    }\n    if ((source.equals(scatter) || destination.equals(scatter)) && (dataLink.getScattered() == null || !dataLink.getScattered())) {\n      dataLink.setScattered(port.getScatter());\n    }\n  }\n}\n", "nl": "Process data links"}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase EipPackage.METADATA__KEY:\n    setKey(KEY_EDEFAULT);\n  return;\ncase EipPackage.METADATA__VALUES:\ngetValues().clear();\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public void createOverlay(DrawingView view,TextHolderFigure figure){\n  view.getComponent().add(textField,0);\n  textField.setText(figure.getText());\n  textField.setColumns(figure.getTextColumns());\n  textField.selectAll();\n  textField.setVisible(true);\n  editedFigure=figure;\n  editedFigure.addFigureListener(figureHandler);\n  this.view=view;\n  updateWidget();\n}\n", "nl": "Creates the overlay for the given Container using a specific font."}
{"code": "@Override public boolean onUsed(final RPEntity user){\n  if (user instanceof Player) {\n    String extra=\" \";\n    if (((Player)user).isQuestInState(\"mithril_cloak\",\"twilight_zone\")) {\n      StendhalRPZone zone=SingletonRepository.getRPWorld().getZone(\"hell\");\n      int x=5;\n      int y=5;\n      if (zone == null) {\n        user.sendPrivateText(\"Oh oh. For some strange reason the scroll did not teleport me to the right place.\");\n        logger.warn(\"twilight elixir to unknown zone hell,\" + \" teleported \" + user.getName() + \" to Semos instead\");\n        zone=SingletonRepository.getRPWorld().getZone(\"0_semos_city\");\n      }\n      ((Player)user).teleport(zone,x,y,null,(Player)user);\n      extra=\" Now you will go to hell, for thinking of yourself before you think of others.\";\n    }\n    user.sendPrivateText(\"Didn't you know, one man's drink is another man's poison? That elixir was meant for Ida in the twilight zone.\" + extra);\n    return super.onUsed(user);\n  }\n else {\n    logger.warn(\"some non player RPEntity just used a twilight elixir, which shouldn't be possible.\");\n    return false;\n  }\n}\n", "nl": "the overridden method verifies item is near to player. if so splits one single item of and calls consumeItem of the player - so they get poisoned, since that's what twilight elixir does"}
{"code": "protected GridNioFilterAdapter(String name){\n  assert name != null;\n  this.name=name;\n}\n", "nl": "Assigns filter name to a filter."}
{"code": "public void bindNull(int index){\n  mPreparedStatement.bindNull(index);\n}\n", "nl": "Bind null to an index. A prepareForInsert() or prepareForReplace() without a matching execute() must have already have been called."}
{"code": "public void show(ShareContent content,Mode mode){\n  isAutomaticMode=(mode == Mode.AUTOMATIC);\n  showImpl(content,isAutomaticMode ? BASE_AUTOMATIC_MODE : mode);\n}\n", "nl": "Call this to show the Share Dialog in a specific mode"}
{"code": "public GridPaneEx(){\n  setAlignment(Pos.TOP_LEFT);\n  setHgap(5);\n  setVgap(10);\n}\n", "nl": "Create pane."}
{"code": "@Override protected void onDestroy(){\n  RxBus.get().unregister(mouseMam);\n  ArrayList<Cat> cats=catMam.getCats();\n  for (  Cat cat : cats) {\n    RxBus.get().unregister(cat);\n  }\n  super.onDestroy();\n}\n", "nl": "Unregister the register object."}
{"code": "private void skipFragmentIgnorables() throws ParseException {\n  while (!tokens.isEmpty()) {\n    Token<HtmlTokenType> t=tokens.peek();\nswitch (t.type) {\ncase DIRECTIVE:\n      break;\ndefault :\n    return;\n}\ntokens.advance();\n}\n}\n", "nl": "Skip over top level doctypes, and whitespace only text nodes. Whitespace is significant for XML unless the schema specifies otherwise, but whitespace outside the root element is not.  There is one exception for whitespace preceding the prologue. Comments are ignored by the underlying TreeBuilder unless explicitly configured otherwise."}
{"code": "public int maxProfit(int k,int[] prices){\n  if (prices == null || prices.length < 2 || k == 0) {\n    return 0;\n  }\n  int n=prices.length;\n  int res=0;\n  if (k >= n / 2) {\n    for (int i=1; i < n; i++) {\n      if (prices[i] > prices[i - 1]) {\n        res+=prices[i] - prices[i - 1];\n      }\n    }\n    return res;\n  }\n  int[][] dp=new int[k + 1][n + 1];\n  for (int i=1; i <= k; i++) {\n    int curMax=Integer.MIN_VALUE;\n    for (int j=0; j < n; j++) {\n      dp[i][j + 1]=Math.max(Math.max(dp[i - 1][j + 1],dp[i][j]),prices[j] + curMax);\n      curMax=Math.max(curMax,dp[i - 1][j] - prices[j]);\n    }\n  }\n  return dp[k][n];\n}\n", "nl": "DP, bottom-up, O(kn) Time, O(kn) Space"}
{"code": "public static Location copyLocation(Location source,Location dest){\n  if (dest == null) {\n    return null;\n  }\n  dest.setWorld(source.getWorld());\n  dest.setX(source.getX());\n  dest.setY(source.getY());\n  dest.setZ(source.getZ());\n  dest.setPitch(source.getPitch());\n  dest.setYaw(source.getYaw());\n  return dest;\n}\n", "nl": "Copy the contents of one Location to another."}
{"code": "@Override public String toString(){\n  return this.years + \":\" + this.months+ \":\"+ this.days+ \":\"+ this.hours+ \":\"+ this.minutes+ \":\"+ this.seconds+ \":\"+ this.milliseconds;\n}\n", "nl": "Returns a <code>String</code> formatted as years:months:days:hours:minutes:seconds:millseconds."}
{"code": "public ImageReference(ImageDescriptor descriptor,boolean returnMissingImageOnError,Device device){\n  this.cache=getImageCache(descriptor,returnMissingImageOnError,device);\n  this.cache.register(this);\n}\n", "nl": "Create a new image reference and register it with an image described by an ImageDescriptor."}
{"code": "public ArrayOfDoublesUpdatableSketch build(){\n  if (dstMem_ == null) {\n    return new HeapArrayOfDoublesQuickSelectSketch(nomEntries_,resizeFactor_.lg(),samplingProbability_,numValues_,seed_);\n  }\n  return new DirectArrayOfDoublesQuickSelectSketch(nomEntries_,resizeFactor_.lg(),samplingProbability_,numValues_,seed_,dstMem_);\n}\n", "nl": "Returns an ArrayOfDoublesUpdatableSketch with the current configuration of this Builder."}
{"code": "private boolean isInherited(Scope scope,Declaration member){\n  return inInitializer() && scope.getInheritingDeclaration(member) == typeDeclaration;\n}\n", "nl": "Is this a reference to a member inherited by the type declaration from within the initializer section of the type declaration?"}
{"code": "public Volume prepareVolume(Volume volume,Project project,VirtualArray varray,VirtualPool vpool,String size,RPRecommendation recommendation,String label,BlockConsistencyGroup consistencyGroup,URI protectionSystemURI,Volume.PersonalityTypes personality,String rsetName,String internalSiteName,String rpCopyName,Volume sourceVolume,boolean vplex,Volume changeVpoolVolume,boolean isPreCreatedVolume){\n  volume=(changeVpoolVolume != null) ? changeVpoolVolume : volume;\n  boolean isNewVolume=(volume == null);\n  if (isNewVolume || isPreCreatedVolume) {\n    if (!isPreCreatedVolume) {\n      volume=new Volume();\n      volume.setId(URIUtil.createId(Volume.class));\n      volume.setOpStatus(new OpStatusMap());\n    }\n else {\n      volume=_dbClient.queryObject(Volume.class,volume.getId());\n    }\n    volume.setSyncActive(true);\n    volume.setLabel(label);\n    volume.setCapacity(SizeUtil.translateSize(size));\n    volume.setThinlyProvisioned(VirtualPool.ProvisioningType.Thin.toString().equalsIgnoreCase(vpool.getSupportedProvisioningType()));\n    volume.setVirtualPool(vpool.getId());\n    volume.setProject(new NamedURI(project.getId(),volume.getLabel()));\n    volume.setTenant(new NamedURI(project.getTenantOrg().getURI(),volume.getLabel()));\n    volume.setVirtualArray(varray.getId());\n    if (null != recommendation.getSourceStoragePool()) {\n      StoragePool pool=_dbClient.queryObject(StoragePool.class,recommendation.getSourceStoragePool());\n      if (null != pool) {\n        volume.setProtocol(new StringSet());\n        volume.getProtocol().addAll(VirtualPoolUtil.getMatchingProtocols(vpool.getProtocols(),pool.getProtocols()));\n        if (!vplex) {\n          volume.setPool(pool.getId());\n          volume.setStorageController(pool.getStorageDevice());\n          StorageSystem storageSystem=_dbClient.queryObject(StorageSystem.class,pool.getStorageDevice());\n          String systemType=storageSystem.checkIfVmax3() ? DiscoveredDataObject.Type.vmax3.name() : storageSystem.getSystemType();\n          volume.setSystemType(systemType);\n        }\n      }\n    }\n    volume.setVirtualArray(varray.getId());\n  }\n  if (personality.equals(Volume.PersonalityTypes.METADATA)) {\n    volume.addInternalFlags(Flag.INTERNAL_OBJECT);\n    volume.addInternalFlags(Flag.SUPPORTS_FORCE);\n    volume.setAccessState(Volume.VolumeAccessState.NOT_READY.name());\n  }\n else   if (personality.equals(Volume.PersonalityTypes.SOURCE)) {\n    volume.setAccessState(Volume.VolumeAccessState.READWRITE.name());\n    volume.setLinkStatus(Volume.LinkStatus.OTHER.name());\n  }\n else   if (personality.equals(Volume.PersonalityTypes.TARGET)) {\n    volume.setAccessState(Volume.VolumeAccessState.NOT_READY.name());\n    volume.setLinkStatus(Volume.LinkStatus.OTHER.name());\n  }\n  if (consistencyGroup != null) {\n    volume.setConsistencyGroup(consistencyGroup.getId());\n    if (changeVpoolVolume != null && !changeVpoolVolume.checkForRp() && RPHelper.isVPlexVolume(changeVpoolVolume,_dbClient)) {\n      if (consistencyGroup.getArrayConsistency()) {\n        if (null == changeVpoolVolume.getAssociatedVolumes() || changeVpoolVolume.getAssociatedVolumes().isEmpty()) {\n          _log.error(\"VPLEX volume {} has no backend volumes.\",changeVpoolVolume.forDisplay());\n          throw InternalServerErrorException.internalServerErrors.noAssociatedVolumesForVPLEXVolume(changeVpoolVolume.forDisplay());\n        }\n        for (        String backendVolumeId : changeVpoolVolume.getAssociatedVolumes()) {\n          Volume backingVolume=_dbClient.queryObject(Volume.class,URI.create(backendVolumeId));\n          String rgName=consistencyGroup.getCgNameOnStorageSystem(backingVolume.getStorageController());\n          if (rgName == null) {\n            rgName=consistencyGroup.getLabel();\n          }\n else {\n            VolumeGroup volumeGroup=ControllerUtils.getApplicationForCG(_dbClient,consistencyGroup,rgName);\n            if (volumeGroup != null) {\n              backingVolume.getVolumeGroupIds().add(volumeGroup.getId().toString());\n            }\n          }\n          _log.info(String.format(\"Preparing VPLEX volume [%s](%s) for RP Protection, \" + \"backend end volume [%s](%s) updated with replication group name: %s\",volume.getLabel(),volume.getId(),backingVolume.getLabel(),backingVolume.getId(),rgName));\n          backingVolume.setReplicationGroupInstance(rgName);\n          _dbClient.updateObject(backingVolume);\n        }\n      }\n    }\n  }\n  volume.setPersonality(personality.toString());\n  volume.setProtectionController(protectionSystemURI);\n  volume.setRSetName(rsetName);\n  volume.setInternalSiteName(internalSiteName);\n  volume.setRpCopyName(rpCopyName);\n  if (NullColumnValueGetter.isNotNullValue(vpool.getAutoTierPolicyName())) {\n    URI autoTierPolicyUri=StorageScheduler.getAutoTierPolicy(volume.getPool(),vpool.getAutoTierPolicyName(),_dbClient);\n    if (null != autoTierPolicyUri) {\n      volume.setAutoTieringPolicyUri(autoTierPolicyUri);\n    }\n  }\n  if (isNewVolume && !isPreCreatedVolume) {\n    _dbClient.createObject(volume);\n  }\n else {\n    _dbClient.updateObject(volume);\n  }\n  if (sourceVolume != null) {\n    if (sourceVolume.getRpTargets() == null) {\n      sourceVolume.setRpTargets(new StringSet());\n    }\n    sourceVolume.getRpTargets().add(volume.getId().toString());\n    _dbClient.updateObject(sourceVolume);\n  }\n  return volume;\n}\n", "nl": "Prepare Volume for a RecoverPoint protected volume"}
{"code": "protected void addAnnotationsPropertyDescriptor(Object object){\n  itemPropertyDescriptors.add(createItemPropertyDescriptor(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),getResourceLocator(),getString(\"_UI_AnnotatableElement_annotations_feature\"),getString(\"_UI_PropertyDescriptor_description\",\"_UI_AnnotatableElement_annotations_feature\",\"_UI_AnnotatableElement_type\"),TypesPackage.Literals.ANNOTATABLE_ELEMENT__ANNOTATIONS,true,false,true,null,null,null));\n}\n", "nl": "This adds a property descriptor for the Annotations feature. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public double num(XPathContext xctxt) throws javax.xml.transform.TransformerException {\n  return -(m_right.num(xctxt));\n}\n", "nl": "Evaluate this operation directly to a double."}
{"code": "public GetLatestTask(final Shell shell,final TFSRepository repository,final String localItem){\n  super(shell,repository);\n  this.serverItems=null;\n  this.localItem=localItem;\n}\n", "nl": "Create a task to \"get latest (recursive)\" for the specified local path."}
{"code": "public TypeRef value(){\n  return this.getTypeRef();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public GroupCategorySet(GroupCategory[] categories){\n  Assert.isNotNull(categories);\n  fContent=new ArrayList(categories.length);\n  for (int i=0; i < categories.length; i++) {\n    if (!fContent.contains(categories[i]))     fContent.add(categories[i]);\n  }\n}\n", "nl": "Creates a new set of group categories initialized from the given array of group categories"}
{"code": "public void test_ESTCARD() throws Exception {\n  doInsertbyURL(\"POST\",packagePath + \"test_estcard.ttl\");\n  final long rangeCount=m_repo.size();\n  assertEquals(7,rangeCount);\n}\n", "nl": "Test the ESTCARD method (fast range count)."}
{"code": "public RequestHandle patch(Context context,String url,HttpEntity entity,String contentType,ResponseHandlerInterface responseHandler){\n  return sendRequest(httpClient,httpContext,addEntityToRequestBase(new HttpPatch(getURI(url)),entity),contentType,responseHandler,context);\n}\n", "nl": "Perform a HTTP PATCH request and track the Android Context which initiated the request."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:20.375 -0500\",hash_original_method=\"28B9C3C3AF577CC75DD224D050447CF4\",hash_generated_method=\"2519B50D30B20B11517B949E5B02DAC4\") public void enableLogging(){\n  this.getStackLogger().enableLogging();\n}\n", "nl": "Globally enable message logging ( for debugging)"}
{"code": "protected Point computeLocation(Rectangle viewport,Rectangle controls){\n  double x;\n  double y;\n  if (this.locationCenter != null) {\n    x=this.locationCenter.x - controls.width / 2;\n    y=this.locationCenter.y - controls.height / 2;\n  }\n else   if (this.position.equals(AVKey.NORTHEAST)) {\n    x=viewport.getWidth() - controls.width - this.borderWidth;\n    y=viewport.getHeight() - controls.height - this.borderWidth;\n  }\n else   if (this.position.equals(AVKey.SOUTHEAST)) {\n    x=viewport.getWidth() - controls.width - this.borderWidth;\n    y=0d + this.borderWidth;\n  }\n else   if (this.position.equals(AVKey.NORTHWEST)) {\n    x=0d + this.borderWidth;\n    y=viewport.getHeight() - controls.height - this.borderWidth;\n  }\n else   if (this.position.equals(AVKey.SOUTHWEST)) {\n    x=0d + this.borderWidth;\n    y=0d + this.borderWidth;\n  }\n else {\n    x=viewport.getWidth() - controls.width - this.borderWidth;\n    y=viewport.getHeight() - controls.height - this.borderWidth;\n  }\n  if (this.locationOffset != null) {\n    x+=this.locationOffset.x;\n    y+=this.locationOffset.y;\n  }\n  return new Point((int)x,(int)y);\n}\n", "nl": "Compute the screen location of the controls overall rectangle bottom right corner according to either the location center if not null, or the screen position."}
{"code": "@Override public synchronized void clear(){\n  File[] files=mRootDirectory.listFiles();\n  if (files != null) {\n    for (    File file : files) {\n      file.delete();\n    }\n  }\n  mEntries.clear();\n  mTotalSize=0;\n  VolleyLog.d(\"Cache cleared.\");\n}\n", "nl": "Clears the cache. Deletes all cached files from disk."}
{"code": "public double optDouble(int index,double defaultValue){\n  try {\n    return this.getDouble(index);\n  }\n catch (  Exception e) {\n    return defaultValue;\n  }\n}\n", "nl": "Get the optional double value associated with an index. The defaultValue is returned if there is no value for the index, or if the value is not a number and cannot be converted to a number."}
{"code": "public S_Loop createS_Loop(){\n  S_LoopImpl s_Loop=new S_LoopImpl();\n  return s_Loop;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Path(\"remove\") @POST @Consumes(MediaType.APPLICATION_JSON) @Produces({MediaType.APPLICATION_JSON,MediaType.TEXT_PLAIN}) public CLIOutputResponse remove(final RemoveRequest request) throws ApiException, IOException {\n  request.setProjectPath(getAbsoluteProjectPath(request.getProjectPath()));\n  return this.subversionApi.remove(request);\n}\n", "nl": "Remove the selected paths to version control."}
{"code": "@Override public synchronized void remove(String key){\n  boolean deleted=getFileForKey(key).delete();\n  removeEntry(key);\n  if (!deleted) {\n    VolleyLog.d(\"Could not delete cache entry for key=%s, filename=%s\",key,getFilenameForKey(key));\n  }\n}\n", "nl": "Removes the specified key from the cache if it exists."}
{"code": "private void writeHeader() throws OpenStegoException {\n  int channelBits=1;\n  int noOfPixels=0;\n  int headerSize=0;\n  LSBDataHeader header=null;\n  try {\n    noOfPixels=this.imgWidth * this.imgHeight;\n    header=new LSBDataHeader(this.dataLength,channelBits,this.fileName,this.config);\n    headerSize=header.getHeaderSize();\n    while (true) {\n      if ((noOfPixels * 3 * channelBits) / 8.0 < (headerSize + this.dataLength)) {\n        channelBits++;\n        if (channelBits > ((LSBConfig)this.config).getMaxBitsUsedPerChannel()) {\n          throw new OpenStegoException(null,LSBPlugin.NAMESPACE,LSBErrors.IMAGE_SIZE_INSUFFICIENT);\n        }\n      }\n else {\n        break;\n      }\n    }\n    header.setChannelBitsUsed(channelBits);\n    write(header.getHeaderData());\n    if (this.currBit != 0) {\n      this.currBit=0;\n      writeCurrentBitSet();\n      nextPixel();\n    }\n    this.channelBitsUsed=channelBits;\n    this.bitSet=new byte[3 * channelBits];\n  }\n catch (  OpenStegoException osEx) {\n    throw osEx;\n  }\ncatch (  Exception ex) {\n    throw new OpenStegoException(ex);\n  }\n}\n", "nl": "Method to write header data to stream"}
{"code": "private EventsEntity(){\n}\n", "nl": "This utility class cannot be instantiated"}
{"code": "public boolean isSet(_Fields field){\n  if (field == null) {\n    throw new IllegalArgumentException();\n  }\nswitch (field) {\ncase HEADER:\n    return isSetHeader();\n}\nthrow new IllegalStateException();\n}\n", "nl": "Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise"}
{"code": "public AuthPermission(String name,String actions){\n  super(init(name),actions);\n}\n", "nl": "Creates an authentication permission with the specified target name."}
{"code": "public boolean configurationExists(final String name){\n  mSingleArg[0]=name;\n  final Cursor cursor=mDatabase.query(Tables.CONFIGURATIONS,NAME_PROJECTION,NAME_SELECTION + \" AND \" + NOT_DELETED_SELECTION,mSingleArg,null,null,null);\n  try {\n    return cursor.getCount() > 0;\n  }\n  finally {\n    cursor.close();\n  }\n}\n", "nl": "Returns true if a configuration with given name was found in the database."}
{"code": "public static void sort(int[] a){\n  int n=a.length;\n  int[] aux=new int[n];\n  sort(a,0,n - 1,0,aux);\n}\n", "nl": "Rearranges the array of 32-bit integers in ascending order. Currently assumes that the integers are nonnegative."}
{"code": "public void transitionToIntentReviewLayout(){\n  mCaptureLayout.setVisibility(View.GONE);\n  mIntentReviewLayout.setVisibility(View.VISIBLE);\n  mCancelLayout.setVisibility(View.GONE);\n  mMode=MODE_INTENT_REVIEW;\n}\n", "nl": "Perform a transition to the global intent review layout. The current layout state of the bottom bar is irrelevant."}
{"code": "private List createListaUsoObjeto(HttpServletRequest request){\n  List listaUsoObjeto=new ArrayList();\n  request.setAttribute(Constants.LISTA_USO_OBJETO,listaUsoObjeto);\n  return listaUsoObjeto;\n}\n", "nl": "Crea en la request una lista llamada listaUsoObjeto, para almacenar objetos de tipo UsoObjetoVO"}
{"code": "public ReplyException(String msg){\n  super(msg);\n}\n", "nl": "Constructs an instance of <code>ReplyException</code> with the specified detail message."}
{"code": "public byte readByte(){\n  return data[pos++];\n}\n", "nl": "Read one single byte."}
{"code": "public static String matchClusterCode(String clusterName){\n  if (clusterName == null) {\n    return null;\n  }\n  for (  ClusterInfo cluster : CLUSTER_LIST) {\n    if (clusterName.contains(cluster.getClusterCode())) {\n      return cluster.getClusterCode();\n    }\n  }\n  for (  ClusterInfo cluster : CLUSTER_LIST) {\n    if (clusterName.contains(cluster.getClusterShortName())) {\n      return cluster.getClusterCode();\n    }\n  }\n  return clusterName;\n}\n", "nl": "match the clusterName to the list of cluster info, return the matching clusterCode"}
{"code": "public void testBogusArguments() throws Exception {\n  IllegalArgumentException expected=expectThrows(IllegalArgumentException.class,null);\n  assertTrue(expected.getMessage().contains(\"Unknown parameters\"));\n}\n", "nl": "Test that bogus arguments result in exception"}
{"code": "private static void closeCache(){\n  if (cache != null && !cache.isClosed()) {\n    cache.close();\n    cache.getDistributedSystem().disconnect();\n  }\n}\n", "nl": "close the cache"}
{"code": "private View findFocusableViewInBoundsV(boolean topFocus,int top,int bottom){\n  List<View> focusables=getFocusables(View.FOCUS_FORWARD);\n  View focusCandidate=null;\n  boolean foundFullyContainedFocusable=false;\n  int count=focusables.size();\n  for (int i=0; i < count; i++) {\n    View view=focusables.get(i);\n    int viewTop=view.getTop();\n    int viewBottom=view.getBottom();\n    if (top < viewBottom && viewTop < bottom) {\n      final boolean viewIsFullyContained=(top < viewTop) && (viewBottom < bottom);\n      if (focusCandidate == null) {\n        focusCandidate=view;\n        foundFullyContainedFocusable=viewIsFullyContained;\n      }\n else {\n        final boolean viewIsCloserToBoundary=(topFocus && viewTop < focusCandidate.getTop()) || (!topFocus && viewBottom > focusCandidate.getBottom());\n        if (foundFullyContainedFocusable) {\n          if (viewIsFullyContained && viewIsCloserToBoundary) {\n            focusCandidate=view;\n          }\n        }\n else {\n          if (viewIsFullyContained) {\n            focusCandidate=view;\n            foundFullyContainedFocusable=true;\n          }\n else           if (viewIsCloserToBoundary) {\n            focusCandidate=view;\n          }\n        }\n      }\n    }\n  }\n  return focusCandidate;\n}\n", "nl": "<p> Finds the next focusable component that fits in the specified bounds. </p>"}
{"code": "public Object read(InputNode node,Object result) throws Exception {\n  Instance type=factory.getInstance(node);\n  if (type.isReference()) {\n    return type.getInstance();\n  }\n  type.setInstance(result);\n  if (result != null) {\n    return populate(node,result);\n  }\n  return result;\n}\n", "nl": "This <code>read</code> method will read the XML element map from the provided node and deserialize its children as entry types. Each entry type must contain a key and value so that the entry  can be inserted in to the map as a pair. If either the key or  value is composite it is read as a root object, which means its <code>Root</code> annotation must be present and the name of the object element must match that root element name."}
{"code": "public SVGOMFEOffsetElement(String prefix,AbstractDocument owner){\n  super(prefix,owner);\n  initializeLiveAttributes();\n}\n", "nl": "Creates a new SVGOMFEOffsetElement object."}
{"code": "public static TypeReference newExceptionReference(int exceptionIndex){\n  return new TypeReference((THROWS << 24) | (exceptionIndex << 8));\n}\n", "nl": "Returns a reference to the type of an exception, in a 'throws' clause of a method."}
{"code": "@Override public boolean supportsSavepoints(){\n  debugCodeCall(\"supportsSavepoints\");\n  return true;\n}\n", "nl": "Does the database support savepoints."}
{"code": "public void fileFound(String fileFound){\n  System.out.println(\"File found :). The following file \" + fileFound + \" has been successfully loaded\");\n}\n", "nl": "Print a message to tell that a file has been found"}
{"code": "public TLongObjectHashMap(int initialCapacity,TLongHashingStrategy strategy){\n  super(initialCapacity);\n  _hashingStrategy=strategy;\n}\n", "nl": "Creates a new <code>TLongObjectHashMap</code> instance whose capacity is the next highest prime above <tt>initialCapacity + 1</tt> unless that value is already prime."}
{"code": "@Override public String toString(){\n  if (eIsProxy())   return super.toString();\n  StringBuffer result=new StringBuffer(super.toString());\n  result.append(\" (greaterOp_1: \");\n  result.append(greaterOp_1);\n  result.append(')');\n  return result.toString();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "void startSourceFileForGeneratedImplementation(String nameOfGeneratedClass,TypeElement sourceClass){\n  messager.printMessage(Kind.NOTE,\"Creating class \" + nameOfGeneratedClass);\n  fileObject=getSourceFile(nameOfGeneratedClass,sourceClass);\n  if (fileObject == null) {\n    giveUp();\n    return;\n  }\n  writer=getWriter(fileObject);\n  if (writer == null) {\n    giveUp();\n    return;\n  }\n  currentIndentationLevel=0;\n}\n", "nl": "Start a source file for a new implementation class."}
{"code": "public long[] decode(String hash){\n  long[] ret={};\n  if (hash.equals(\"\"))   return ret;\n  return this._decode(hash,this.alphabet);\n}\n", "nl": "Decrypt string to numbers"}
{"code": "private void updatePositionNeeds(){\n  needQBs=2 - teamQBs.size();\n  needRBs=4 - teamRBs.size();\n  needWRs=6 - teamWRs.size();\n  needOLs=10 - teamOLs.size();\n  needKs=2 - teamKs.size();\n  needSs=2 - teamSs.size();\n  needCBs=6 - teamCBs.size();\n  needF7s=14 - teamF7s.size();\n  if (dataAdapterPosition != null) {\n    positions=new ArrayList<String>();\n    positions.add(\"QB (Need: \" + needQBs + \")\");\n    positions.add(\"RB (Need: \" + needRBs + \")\");\n    positions.add(\"WR (Need: \" + needWRs + \")\");\n    positions.add(\"OL (Need: \" + needOLs + \")\");\n    positions.add(\"K (Need: \" + needKs + \")\");\n    positions.add(\"S (Need: \" + needSs + \")\");\n    positions.add(\"CB (Need: \" + needCBs + \")\");\n    positions.add(\"F7 (Need: \" + needF7s + \")\");\n    positions.add(\"Top 100 Recruits\");\n    dataAdapterPosition.clear();\n    for (    String p : positions) {\n      dataAdapterPosition.add(p);\n    }\n    dataAdapterPosition.notifyDataSetChanged();\n  }\n}\n", "nl": "Update needs for each position"}
{"code": "private BinarySearch(){\n}\n", "nl": "This class should not be instantiated."}
{"code": "public static String quote(String string){\n  StringWriter sw=new StringWriter();\nsynchronized (sw.getBuffer()) {\n    try {\n      return quote(string,sw).toString();\n    }\n catch (    IOException ignored) {\n      return \"\";\n    }\n  }\n}\n", "nl": "Produce a string in double quotes with backslash sequences in all the right places. A backslash will be inserted within </, producing <\\/, allowing JSON text to be delivered in HTML. In JSON text, a string cannot contain a control character or an unescaped quote or backslash."}
{"code": "public RemoteObjectInvocationHandler(RemoteRef ref){\n  super(ref);\n  if (ref == null) {\n    throw new NullPointerException();\n  }\n}\n", "nl": "Creates a new <code>RemoteObjectInvocationHandler</code> constructed with the specified <code>RemoteRef</code>."}
{"code": "public Categories addCategory(Category category){\n  super.addElement(Category.KEY,category);\n  return this;\n}\n", "nl": "Adds a new category."}
{"code": "public static void append(File file,byte[] bytes) throws IOException {\n  OutputStream stream=null;\n  try {\n    stream=new FileOutputStream(file,true);\n    stream.write(bytes,0,bytes.length);\n    stream.flush();\n    OutputStream temp=stream;\n    stream=null;\n    temp.close();\n  }\n  finally {\n    closeWithWarning(stream);\n  }\n}\n", "nl": "Append bytes to the end of a File.  It <strong>will not</strong> be interpreted as text."}
{"code": "public DescriptorImpl(final String description,final String label){\n  this.description=description;\n  this.label=label;\n}\n", "nl": "Construct descriptor."}
{"code": "@Nullable public synchronized V remove(K key){\n  V oldValue=mMap.remove(key);\n  mSizeInBytes-=getValueSizeInBytes(oldValue);\n  return oldValue;\n}\n", "nl": "Removes the element from the map."}
{"code": "public MediaConfig createChannelFileAttachment(String file,MediaConfig config){\n  config.addCredentials(this);\n  String xml=POSTFILE(this.url + \"/create-channel-attachment\",file,config.name,config.toXML());\n  Element root=parse(xml);\n  if (root == null) {\n    return null;\n  }\n  try {\n    MediaConfig media=new MediaConfig();\n    media.parseXML(root);\n    return media;\n  }\n catch (  Exception exception) {\n    this.exception=SDKException.parseFailure(exception);\n    throw this.exception;\n  }\n}\n", "nl": "Create a new file/image/media attachment for a chat channel."}
{"code": "public static boolean matchUserStatus(String id,User user){\n  if (id.equals(\"$mod\")) {\n    if (user.isModerator()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$sub\")) {\n    if (user.isSubscriber()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$turbo\")) {\n    if (user.hasTurbo()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$admin\")) {\n    if (user.isAdmin()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$broadcaster\")) {\n    if (user.isBroadcaster()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$staff\")) {\n    if (user.isStaff()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$bot\")) {\n    if (user.isBot()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$globalmod\")) {\n    if (user.isGlobalMod()) {\n      return true;\n    }\n  }\n else   if (id.equals(\"$anymod\")) {\n    if (user.isAdmin() || user.isBroadcaster() || user.isGlobalMod()|| user.isModerator()|| user.isStaff()) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "Checks if the id matches the given User. The id can be one of: $mod, $sub, $turbo, $admin, $broadcaster, $staff, $bot. If the user has the appropriate user status, this returns true. If the id is unknown or the user doesn't have the required status, this returns false."}
{"code": "public static Selection createFromStartLength(int s,int l){\n  Assert.isTrue(s >= 0 && l >= 0);\n  Selection result=new Selection();\n  result.fStart=s;\n  result.fLength=l;\n  result.fExclusiveEnd=s + l;\n  return result;\n}\n", "nl": "Creates a new selection from the given start and length."}
{"code": "public static byte[] hash(InputStream in) throws IOException {\n  if (HASH_DIGEST == null) {\n    throw new EvernoteUtilException(EDAM_HASH_ALGORITHM + \" not supported\",new NoSuchAlgorithmException(EDAM_HASH_ALGORITHM));\n  }\n  byte[] buf=new byte[1024];\n  int n;\n  while ((n=in.read(buf)) != -1) {\n    HASH_DIGEST.update(buf,0,n);\n  }\n  return HASH_DIGEST.digest();\n}\n", "nl": "Returns an MD5 checksum of the contents of the provided InputStream."}
{"code": "@LayoutlibDelegate static long uptimeMillis(){\n  return System.currentTimeMillis() - sBootTime;\n}\n", "nl": "Returns milliseconds since boot, not counting time spent in deep sleep. <b>Note:</b> This value may get reset occasionally (before it would otherwise wrap around)."}
{"code": "void unregisterDownloadFileChangeListener(OnDownloadFileChangeListener onDownloadFileChangeListener){\n  mDownloadFileCacher.unregisterDownloadFileChangeListener(onDownloadFileChangeListener);\n}\n", "nl": "unregister an OnDownloadFileChangeListener"}
{"code": "public DateParser(){\n  this(DateFormat.getDateInstance(DateFormat.SHORT));\n}\n", "nl": "Create a new DateParser."}
{"code": "public ShoppingCartItem(ShoppingCartItem item){\n  this.delegator=item.getDelegator();\n  try {\n    this._product=item.getProduct();\n  }\n catch (  IllegalStateException e) {\n    this._product=null;\n  }\n  try {\n    this._parentProduct=item.getParentProduct();\n  }\n catch (  IllegalStateException e) {\n    this._parentProduct=null;\n  }\n  this.delegatorName=item.delegatorName;\n  this.prodCatalogId=item.getProdCatalogId();\n  this.productId=item.getProductId();\n  this.supplierProductId=item.getSupplierProductId();\n  this.parentProductId=item.getParentProductId();\n  this.externalId=item.getExternalId();\n  this.itemType=item.getItemType();\n  this.itemGroup=item.getItemGroup();\n  this.productCategoryId=item.getProductCategoryId();\n  this.itemDescription=item.itemDescription;\n  this.reservStart=item.getReservStart();\n  this.reservLength=item.getReservLength();\n  this.reservPersons=item.getReservPersons();\n  this.accommodationMapId=item.getAccommodationMapId();\n  this.accommodationSpotId=item.getAccommodationSpotId();\n  this.quantity=item.getQuantity();\n  this.setBasePrice(item.getBasePrice());\n  this.setDisplayPrice(item.getDisplayPrice());\n  this.setRecurringBasePrice(item.getRecurringBasePrice());\n  this.setRecurringDisplayPrice(item.getRecurringDisplayPrice());\n  this.setSpecialPromoPrice(item.getSpecialPromoPrice());\n  this.reserv2ndPPPerc=item.getReserv2ndPPPerc();\n  this.reservNthPPPerc=item.getReservNthPPPerc();\n  this.listPrice=item.getListPrice();\n  this.setIsModifiedPrice(item.getIsModifiedPrice());\n  this.selectedAmount=item.getSelectedAmount();\n  this.requirementId=item.getRequirementId();\n  this.quoteId=item.getQuoteId();\n  this.quoteItemSeqId=item.getQuoteItemSeqId();\n  this.associatedOrderId=item.getAssociatedOrderId();\n  this.associatedOrderItemSeqId=item.getAssociatedOrderItemSeqId();\n  this.orderItemAssocTypeId=item.getOrderItemAssocTypeId();\n  this.setStatusId(item.getStatusId());\n  if (UtilValidate.isEmpty(item.getOrderItemAttributes())) {\n    this.orderItemAttributes=FastMap.<String,String>newInstance();\n    this.orderItemAttributes.putAll(item.getOrderItemAttributes());\n  }\n  this.attributes=item.getAttributes() == null ? new HashMap<String,Object>() : new HashMap<String,Object>(item.getAttributes());\n  this.setOrderItemSeqId(item.getOrderItemSeqId());\n  this.locale=item.locale;\n  this.setShipBeforeDate(item.getShipBeforeDate());\n  this.setShipAfterDate(item.getShipAfterDate());\n  this.setEstimatedShipDate(item.getEstimatedShipDate());\n  this.setCancelBackOrderDate(item.getCancelBackOrderDate());\n  this.contactMechIdsMap=item.getOrderItemContactMechIds() == null ? null : new HashMap<String,String>(item.getOrderItemContactMechIds());\n  this.orderItemPriceInfos=item.getOrderItemPriceInfos() == null ? null : new LinkedList<GenericValue>(item.getOrderItemPriceInfos());\n  this.itemAdjustments.addAll(item.getAdjustments());\n  this.isPromo=item.getIsPromo();\n  this.promoQuantityUsed=item.promoQuantityUsed;\n  this.quantityUsedPerPromoCandidate=new HashMap<GenericPK,BigDecimal>(item.quantityUsedPerPromoCandidate);\n  this.quantityUsedPerPromoFailed=new HashMap<GenericPK,BigDecimal>(item.quantityUsedPerPromoFailed);\n  this.quantityUsedPerPromoActual=new HashMap<GenericPK,BigDecimal>(item.quantityUsedPerPromoActual);\n  this.additionalProductFeatureAndAppls=item.getAdditionalProductFeatureAndAppls() == null ? null : new HashMap<String,GenericValue>(item.getAdditionalProductFeatureAndAppls());\n  if (item.getAlternativeOptionProductIds() != null) {\n    List<String> tempAlternativeOptionProductIds=FastList.newInstance();\n    tempAlternativeOptionProductIds.addAll(item.getAlternativeOptionProductIds());\n    this.setAlternativeOptionProductIds(tempAlternativeOptionProductIds);\n  }\n  if (item.configWrapper != null) {\n    this.configWrapper=new ProductConfigWrapper(item.configWrapper);\n  }\n  this.featuresForSupplier.addAll(item.featuresForSupplier);\n}\n", "nl": "Clone an item."}
{"code": "public void writeText(char text[],int off,int len) throws IOException {\n  if (text == null) {\n    throw new NullPointerException(\"Argument Error: One or more parameters are null.\");\n  }\n  if (off < 0 || off > text.length || len < 0 || len > text.length) {\n    throw new IndexOutOfBoundsException();\n  }\n  closeStartIfNecessary();\n  if (dontEscape) {\n    writer.write(text,off,len);\n  }\n else {\n    Util.writeText(writer,buffer,text,off,len);\n  }\n}\n", "nl": "<p>Write properly escaped text from a character array. If there is an open element that has been created by a call to <code>startElement()</code>, that element will be closed first.</p> <p/> <p>All angle bracket occurrences in the argument must be escaped using the &amp;gt; &amp;lt; syntax.</p>"}
{"code": "public void pleaseStop(){\n  stopping=true;\n  mc.pleaseStop();\n}\n", "nl": "Requests that the MCMC chain stop prematurely."}
{"code": "public static boolean checkTransactionLockTime(Transaction transaction,int locktime){\n  if (Math.abs(transaction.getLockTime() - locktime) > 5 * 60) {\n    System.out.println(\"Locktime not correct. Should be: \" + locktime + \" Is: \"+ transaction.getLockTime()+ \" Diff: \"+ Math.abs(transaction.getLockTime() - locktime));\n    return false;\n  }\n  if (locktime == 0) {\n    return true;\n  }\n  for (  TransactionInput input : transaction.getInputs()) {\n    if (input.getSequenceNumber() == 0) {\n      return true;\n    }\n  }\n  System.out.println(\"No Sequence Number is 0..\");\n  return false;\n}\n", "nl": "Check transaction lock time."}
{"code": "@Override public void renderLimitLines(Canvas c){\n  List<LimitLine> limitLines=mXAxis.getLimitLines();\n  if (limitLines == null || limitLines.size() <= 0)   return;\n  float[] pts=new float[2];\n  Path limitLinePath=new Path();\n  for (int i=0; i < limitLines.size(); i++) {\n    LimitLine l=limitLines.get(i);\n    mLimitLinePaint.setStyle(Paint.Style.STROKE);\n    mLimitLinePaint.setColor(l.getLineColor());\n    mLimitLinePaint.setStrokeWidth(l.getLineWidth());\n    mLimitLinePaint.setPathEffect(l.getDashPathEffect());\n    pts[1]=l.getLimit();\n    mTrans.pointValuesToPixel(pts);\n    limitLinePath.moveTo(mViewPortHandler.contentLeft(),pts[1]);\n    limitLinePath.lineTo(mViewPortHandler.contentRight(),pts[1]);\n    c.drawPath(limitLinePath,mLimitLinePaint);\n    limitLinePath.reset();\n    String label=l.getLabel();\n    if (label != null && !label.equals(\"\")) {\n      float xOffset=Utils.convertDpToPixel(4f);\n      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;\n      mLimitLinePaint.setStyle(l.getTextStyle());\n      mLimitLinePaint.setPathEffect(null);\n      mLimitLinePaint.setColor(l.getTextColor());\n      mLimitLinePaint.setStrokeWidth(0.5f);\n      mLimitLinePaint.setTextSize(l.getTextSize());\n      if (l.getLabelPosition() == LimitLine.LimitLabelPosition.POS_RIGHT) {\n        mLimitLinePaint.setTextAlign(Align.RIGHT);\n        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);\n      }\n else {\n        mLimitLinePaint.setTextAlign(Align.LEFT);\n        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);\n      }\n    }\n  }\n}\n", "nl": "Draws the LimitLines associated with this axis to the screen. This is the standard YAxis renderer using the XAxis limit lines."}
{"code": "public static void showCommandLineOptions(){\n  showCommandLineOptions(new TextUICommandLine());\n}\n", "nl": "Print command line options synopses to stdout."}
{"code": "public WordEntry find(final String str){\n  final WordEntry entry=words.get(trimWord(str));\n  return entry;\n}\n", "nl": "Find an entry for a given word."}
{"code": "private void registerListener(final String requestUrl,final String target,String[] methods,Integer expireTime,String filter){\n  registerListener(requestUrl,target,methods,expireTime,filter,null);\n}\n", "nl": "Registers a listener."}
{"code": "public AbstractTestContext(){\n  super();\n}\n", "nl": "Constructs a new <code>AbstractTestContext</code> instance."}
{"code": "public final String value(int valIndex){\n  if (!isNominal() && !isString()) {\n    return \"\";\n  }\n else {\n    Object val=m_Values.elementAt(valIndex);\n    if (val instanceof SerializedObject) {\n      val=((SerializedObject)val).getObject();\n    }\n    return (String)val;\n  }\n}\n", "nl": "Returns a value of a nominal or string attribute.  Returns an empty string if the attribute is neither nominal nor a string attribute."}
{"code": "public static void readSkel(BufferedReader reader) throws IOException {\n  Vector lines=new Vector();\n  StringBuffer section=new StringBuffer();\n  String ln;\n  while ((ln=reader.readLine()) != null) {\n    if (ln.startsWith(\"---\")) {\n      lines.addElement(section.toString());\n      section.setLength(0);\n    }\n else {\n      section.append(ln);\n      section.append(NL);\n    }\n  }\n  if (section.length() > 0)   lines.addElement(section.toString());\n  if (lines.size() != size) {\n    Out.error(ErrorMessages.WRONG_SKELETON);\n    throw new GeneratorException();\n  }\n  line=new String[size];\n  for (int i=0; i < size; i++)   line[i]=(String)lines.elementAt(i);\n}\n", "nl": "Reads an external skeleton file from a BufferedReader."}
{"code": "@Override public void finishTerm(BlockTermState _state) throws IOException {\n  IntBlockTermState state=(IntBlockTermState)_state;\n  assert state.docFreq > 0;\n  assert state.docFreq == docCount : state.docFreq + \" vs \" + docCount;\n  final int singletonDocID;\n  if (state.docFreq == 1) {\n    singletonDocID=docDeltaBuffer[0];\n  }\n else {\n    singletonDocID=-1;\n    for (int i=0; i < docBufferUpto; i++) {\n      final int docDelta=docDeltaBuffer[i];\n      final int freq=freqBuffer[i];\n      if (!writeFreqs) {\n        docOut.writeVInt(docDelta);\n      }\n else       if (freqBuffer[i] == 1) {\n        docOut.writeVInt((docDelta << 1) | 1);\n      }\n else {\n        docOut.writeVInt(docDelta << 1);\n        docOut.writeVInt(freq);\n      }\n    }\n  }\n  final long lastPosBlockOffset;\n  if (writePositions) {\n    assert state.totalTermFreq != -1;\n    if (state.totalTermFreq > BLOCK_SIZE) {\n      lastPosBlockOffset=posOut.getFilePointer() - posStartFP;\n    }\n else {\n      lastPosBlockOffset=-1;\n    }\n    if (posBufferUpto > 0) {\n      int lastPayloadLength=-1;\n      int lastOffsetLength=-1;\n      int payloadBytesReadUpto=0;\n      for (int i=0; i < posBufferUpto; i++) {\n        final int posDelta=posDeltaBuffer[i];\n        if (writePayloads) {\n          final int payloadLength=payloadLengthBuffer[i];\n          if (payloadLength != lastPayloadLength) {\n            lastPayloadLength=payloadLength;\n            posOut.writeVInt((posDelta << 1) | 1);\n            posOut.writeVInt(payloadLength);\n          }\n else {\n            posOut.writeVInt(posDelta << 1);\n          }\n          if (payloadLength != 0) {\n            posOut.writeBytes(payloadBytes,payloadBytesReadUpto,payloadLength);\n            payloadBytesReadUpto+=payloadLength;\n          }\n        }\n else {\n          posOut.writeVInt(posDelta);\n        }\n        if (writeOffsets) {\n          int delta=offsetStartDeltaBuffer[i];\n          int length=offsetLengthBuffer[i];\n          if (length == lastOffsetLength) {\n            posOut.writeVInt(delta << 1);\n          }\n else {\n            posOut.writeVInt(delta << 1 | 1);\n            posOut.writeVInt(length);\n            lastOffsetLength=length;\n          }\n        }\n      }\n      if (writePayloads) {\n        assert payloadBytesReadUpto == payloadByteUpto;\n        payloadByteUpto=0;\n      }\n    }\n  }\n else {\n    lastPosBlockOffset=-1;\n  }\n  long skipOffset;\n  if (docCount > BLOCK_SIZE) {\n    skipOffset=skipWriter.writeSkip(docOut) - docStartFP;\n  }\n else {\n    skipOffset=-1;\n  }\n  state.docStartFP=docStartFP;\n  state.posStartFP=posStartFP;\n  state.payStartFP=payStartFP;\n  state.singletonDocID=singletonDocID;\n  state.skipOffset=skipOffset;\n  state.lastPosBlockOffset=lastPosBlockOffset;\n  docBufferUpto=0;\n  posBufferUpto=0;\n  lastDocID=0;\n  docCount=0;\n}\n", "nl": "Called when we are done adding docs to this term"}
{"code": "public ApiException(int code,ObjectNode jsonResponse){\n  super((jsonResponse.get(ApiMethod.ERROR_NODE) != null) ? JsonUtils.stringFromJsonNode(jsonResponse.get(ApiMethod.ERROR_NODE),\"message\") : \"No message returned\");\n  this.code=code;\n}\n", "nl": "Construct exception from JSON response"}
{"code": "@Override public boolean isActive(){\n  return amIActive;\n}\n", "nl": "Used by the Whitebox GUI to tell if this plugin is still running."}
{"code": "public void testReorderAppDeploymentsAfterConfigurationVersionAndBeforeAdminServerName() throws Exception {\n  WAR war=createWar();\n  deployer.createElementForDeployableInDomain(war,domain);\n  deployer.reorderAppDeploymentsAfterConfigurationVersion(domain);\n  String xml=this.xmlUtil.toString(domain);\n  int indexOfConfigurationVersion=xml.indexOf(\"configuration-version\");\n  int indexOfAppDeployment=xml.indexOf(\"app-deployment\");\n  int indexOfAdminServerName=xml.indexOf(\"admin-server-name\");\n  assertTrue(indexOfAppDeployment > indexOfConfigurationVersion);\n  assertTrue(indexOfAppDeployment < indexOfAdminServerName);\n}\n", "nl": "Test application deployment reordering."}
{"code": "public static int decode(byte[] data,OutputStream out) throws IOException {\n  int off=0;\n  int length=data.length;\n  int endOffset=off + length;\n  int bytesWritten=0;\n  while (off < endOffset) {\n    byte ch=data[off++];\n    if (ch == '_') {\n      out.write(' ');\n    }\n else     if (ch == '=') {\n      if (off + 1 >= endOffset) {\n        throw new IOException(\"Invalid quoted printable encoding; truncated escape sequence\");\n      }\n      byte b1=data[off++];\n      byte b2=data[off++];\n      if (b1 == '\\r') {\n        if (b2 != '\\n') {\n          throw new IOException(\"Invalid quoted printable encoding; CR must be followed by LF\");\n        }\n      }\n else {\n        int c1=hexToBinary(b1);\n        int c2=hexToBinary(b2);\n        out.write((c1 << UPPER_NIBBLE_SHIFT) | c2);\n        bytesWritten++;\n      }\n    }\n else {\n      out.write(ch);\n      bytesWritten++;\n    }\n  }\n  return bytesWritten;\n}\n", "nl": "Decode the encoded byte data writing it to the given output stream."}
{"code": "public boolean isFovVisible(){\n  return (frustum.getSceneHints().getCullHint() != CullHint.Always);\n}\n", "nl": "Get FOV visibility"}
{"code": "public NotificationChain basicSetTypeArg(TypeArgument newTypeArg,NotificationChain msgs){\n  TypeArgument oldTypeArg=typeArg;\n  typeArg=newTypeArg;\n  if (eNotificationRequired()) {\n    ENotificationImpl notification=new ENotificationImpl(this,Notification.SET,TypeRefsPackage.TYPE_TYPE_REF__TYPE_ARG,oldTypeArg,newTypeArg);\n    if (msgs == null)     msgs=notification;\n else     msgs.add(notification);\n  }\n  return msgs;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static String join(String separator,float[] elements){\n  if (elements == null || elements.length == 0) {\n    return \"\";\n  }\n  List<Float> list=new ArrayList<Float>(elements.length);\n  for (  Float element : elements) {\n    list.add(element);\n  }\n  return join(separator,list);\n}\n", "nl": "Returns a string containing all float numbers concatenated by a specified separator."}
{"code": "public Position(int offset){\n  this(offset,0);\n}\n", "nl": "Creates a new position with the given offset and length 0."}
{"code": "protected void onUnhandledException(WebURL webUrl,Throwable e){\n  String urlStr=(webUrl == null ? \"NULL\" : webUrl.getURL());\n  logger.warn(\"Unhandled exception while fetching {}: {}\",urlStr,e.getMessage());\n  logger.info(\"Stacktrace: \",e);\n}\n", "nl": "This function is called when a unhandled exception was encountered during fetching"}
{"code": "private void createLdifFilesDirectory() throws FileOperationFailedException {\n  String schemaExportDirName=getSchemaFilesDirectory();\n  _log.info(\"Schema ldif files directory {}\",schemaExportDirName);\n  File schemaExportDir=new File(schemaExportDirName);\n  if (!schemaExportDir.exists()) {\n    if (!schemaExportDir.mkdirs()) {\n      throw new FileOperationFailedException(\"create\",\"directory\",schemaExportDirName);\n    }\n  }\n  schemaExportDir.deleteOnExit();\n  String configExportDirName=getConfigFilesDirectory();\n  _log.info(\"Config ldif files directory {}\",configExportDirName);\n  File configExportDir=new File(configExportDirName);\n  if (!configExportDir.exists()) {\n    if (!configExportDir.mkdirs()) {\n      throw new FileOperationFailedException(\"create\",\"directory\",configExportDirName);\n    }\n  }\n  configExportDir.deleteOnExit();\n}\n", "nl": "Creates the dummy directory for the ldif files."}
{"code": "public void assertNull(Object object){\n  TestUtils.assertNull(object);\n}\n", "nl": "This method just invokes the test utils method, it is here for convenience"}
{"code": "public static String escapeXml(String s){\n  initializeEscapeMap();\n  if (s == null || s.length() == 0) {\n    return s;\n  }\n  char[] sChars=s.toCharArray();\n  StringBuilder sb=new StringBuilder();\n  int lastReplacement=0;\n  for (int i=0; i < sChars.length; i++) {\n    if (isInvalidXMLCharacter(sChars[i])) {\n      sb.append(sChars,lastReplacement,i - lastReplacement);\n      sb.append(sChars[i] == 0xFFFE ? \"\\\\ufffe\" : xmlLowValueEscapeStrings[sChars[i]]);\n      lastReplacement=i + 1;\n    }\n  }\n  if (lastReplacement < sChars.length) {\n    sb.append(sChars,lastReplacement,sChars.length - lastReplacement);\n  }\n  return StringEscapeUtils.escapeXml(sb.toString());\n}\n", "nl": "Escape XML entities and illegal characters in the given string. This enhances the functionality of org.apache.commons.lang.StringEscapeUtils.escapeXml by escaping low-valued unprintable characters, which are not permitted by the W3C XML 1.0 specification."}
{"code": "public ButtonGroup(){\n}\n", "nl": "Creates a new <code>ButtonGroup</code>."}
{"code": "public JSONArray names(){\n  JSONArray ja=new JSONArray();\n  Iterator<String> keys=this.keys();\n  while (keys.hasNext()) {\n    ja.put(keys.next());\n  }\n  return ja.length() == 0 ? null : ja;\n}\n", "nl": "Produce a JSONArray containing the names of the elements of this JSONObject."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public boolean isHasBack(){\n  FacesContext realContext=FacesContext.getCurrentInstance(), copyContext=createShadowFacesContext(realContext);\n  NavigationHandler nav=copyContext.getApplication().getNavigationHandler();\n  nav.handleNavigation(copyContext,null,\"back\");\n  return compareUIViewRoots(realContext.getViewRoot(),copyContext.getViewRoot());\n}\n", "nl": "<p>Check to see whether the current page should have a back button</p>"}
{"code": "public LongSparseArrayDataRow(int size){\n  super(size);\n  values=new long[size];\n}\n", "nl": "Creates a sparse array data row of the given size."}
{"code": "public PropertyAtom(final String id,final String key,final Object val){\n  super(id);\n  this.key=key;\n  this.val=val;\n}\n", "nl": "Fully construct a property atom."}
{"code": "public void print(final CharSequence text) throws IOException {\n  final int size=text.length();\n  int pos=0;\n  for (int i=0; i < size; i++) {\n    if (text.charAt(i) == '\\n') {\n      write(text.subSequence(pos,size),i - pos + 1);\n      pos=i + 1;\n      atStartOfLine=true;\n    }\n  }\n  write(text.subSequence(pos,size),size - pos);\n}\n", "nl": "Print text to the output stream."}
{"code": "private boolean isClosureProgram2(IStep step){\n  if (step == null)   throw new IllegalArgumentException();\n  if (step.isRule())   return false;\n  final IProgram program=(IProgram)step;\n  if (program.isClosure())   return true;\n  final Iterator<IStep> itr=program.steps();\n  while (itr.hasNext()) {\n    if (isClosureProgram2(itr.next()))     return true;\n  }\n  return false;\n}\n", "nl": "<code>true</code> iff this program is or contains a closure operation."}
{"code": "public void destroy(){\n  super.destroy();\n}\n", "nl": "Destruction of the servlet. <br>"}
{"code": "public void expandAll(){\n  if (!chkExpand.isChecked())   chkExpand.setChecked(true);\n  TreeUtils.expandAll(menuTree);\n}\n", "nl": "expand all node"}
{"code": "public static SavedAdStyles run(AdSense adsense,int maxPageSize) throws Exception {\n  System.out.println(\"=================================================================\");\n  System.out.printf(\"Listing all saved ad styles for default account\\n\");\n  System.out.println(\"=================================================================\");\n  String pageToken=null;\n  SavedAdStyles savedAdStyles=null;\n  do {\n    savedAdStyles=adsense.savedadstyles().list().setMaxResults(maxPageSize).setPageToken(pageToken).execute();\n    if (savedAdStyles.getItems() != null && !savedAdStyles.getItems().isEmpty()) {\n      for (      SavedAdStyle savedAdStyle : savedAdStyles.getItems()) {\n        System.out.printf(\"Saved ad style with name \\\"%s\\\" was found.\\n\",savedAdStyle.getName());\n      }\n    }\n else {\n      System.out.println(\"No saved ad styles found.\");\n    }\n    pageToken=savedAdStyles.getNextPageToken();\n  }\n while (pageToken != null);\n  System.out.println();\n  return savedAdStyles;\n}\n", "nl": "Runs this sample."}
{"code": "public static Border createEtchedLowered(){\n  Border b=new Border();\n  b.type=TYPE_ETCHED_LOWERED;\n  b.themeColors=true;\n  return b;\n}\n", "nl": "Creates a lowered etched border with default colors, highlight is derived from the component and shadow is a plain dark color"}
{"code": "public void reset(){\n  m_currentSearchIndex=0;\n}\n", "nl": "Resets the cursor to the beginning."}
{"code": "public static void minimizeApp(Context context){\n  Intent startMain=new Intent(Intent.ACTION_MAIN);\n  startMain.addCategory(Intent.CATEGORY_HOME);\n  startMain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  context.startActivity(startMain);\n}\n", "nl": "Minimizes the app"}
{"code": "public static void logDeviceInfo(String tag){\n  Log.d(tag,\"Android SDK: \" + Build.VERSION.SDK_INT + \", \"+ \"Release: \"+ Build.VERSION.RELEASE+ \", \"+ \"Brand: \"+ Build.BRAND+ \", \"+ \"Device: \"+ Build.DEVICE+ \", \"+ \"Id: \"+ Build.ID+ \", \"+ \"Hardware: \"+ Build.HARDWARE+ \", \"+ \"Manufacturer: \"+ Build.MANUFACTURER+ \", \"+ \"Model: \"+ Build.MODEL+ \", \"+ \"Product: \"+ Build.PRODUCT);\n}\n", "nl": "Information about the current build, taken from system properties."}
{"code": "private void writePostResource(String path,Element postResourceEl){\n  if (getFileHandler().isDirectory(path)) {\n    writeDirectoryPostResource(postResourceEl,path);\n  }\n else   if (path.toLowerCase().endsWith(\".jar\")) {\n    writeJarPostResource(postResourceEl,path);\n  }\n else {\n    writeFilePostResource(postResourceEl,path);\n  }\n}\n", "nl": "Write post Resources using with a PostResources xml element"}
{"code": "private Producer<CloseableReference<CloseableImage>> newBitmapCacheGetToBitmapCacheSequence(Producer<CloseableReference<CloseableImage>> inputProducer){\n  BitmapMemoryCacheProducer bitmapMemoryCacheProducer=mProducerFactory.newBitmapMemoryCacheProducer(inputProducer);\n  BitmapMemoryCacheKeyMultiplexProducer bitmapKeyMultiplexProducer=mProducerFactory.newBitmapMemoryCacheKeyMultiplexProducer(bitmapMemoryCacheProducer);\n  ThreadHandoffProducer<CloseableReference<CloseableImage>> threadHandoffProducer=mProducerFactory.newBackgroundThreadHandoffProducer(bitmapKeyMultiplexProducer);\n  return mProducerFactory.newBitmapMemoryCacheGetProducer(threadHandoffProducer);\n}\n", "nl": "Bitmap cache get -> thread hand off -> multiplex -> bitmap cache"}
{"code": "static Pair<byte[],Long> decomposeName(Column column){\n  ByteBuffer nameBuffer;\n  if (column.isSetName()) {\n    nameBuffer=column.bufferForName();\n  }\n else {\n    nameBuffer=ByteBuffer.wrap(column.getName());\n  }\n  return decompose(nameBuffer);\n}\n", "nl": "Convenience method to get the name buffer for the specified column and decompose it into the name and timestamp."}
{"code": "public synchronized boolean hasMoreTokens(){\n  return (this.pos < this.sourceLength);\n}\n", "nl": "Does this tokenizer have more tokens available?"}
{"code": "public String sanitizeString(String string){\n  StringBuilder retval=new StringBuilder();\n  StringCharacterIterator iterator=new StringCharacterIterator(string);\n  char character=iterator.current();\n  while (character != java.text.CharacterIterator.DONE) {\n    if (character == '<') {\n      retval.append(\"&lt;\");\n    }\n else     if (character == '>') {\n      retval.append(\"&gt;\");\n    }\n else     if (character == '&') {\n      retval.append(\"&amp;\");\n    }\n else     if (character == '\\\"') {\n      retval.append(\"&quot;\");\n    }\n else     if (character == '\\t') {\n      addCharEntity(9,retval);\n    }\n else     if (character == '!') {\n      addCharEntity(33,retval);\n    }\n else     if (character == '#') {\n      addCharEntity(35,retval);\n    }\n else     if (character == '$') {\n      addCharEntity(36,retval);\n    }\n else     if (character == '%') {\n      addCharEntity(37,retval);\n    }\n else     if (character == '\\'') {\n      addCharEntity(39,retval);\n    }\n else     if (character == '(') {\n      addCharEntity(40,retval);\n    }\n else     if (character == ')') {\n      addCharEntity(41,retval);\n    }\n else     if (character == '*') {\n      addCharEntity(42,retval);\n    }\n else     if (character == '+') {\n      addCharEntity(43,retval);\n    }\n else     if (character == ',') {\n      addCharEntity(44,retval);\n    }\n else     if (character == '-') {\n      addCharEntity(45,retval);\n    }\n else     if (character == '.') {\n      addCharEntity(46,retval);\n    }\n else     if (character == '/') {\n      addCharEntity(47,retval);\n    }\n else     if (character == ':') {\n      addCharEntity(58,retval);\n    }\n else     if (character == ';') {\n      addCharEntity(59,retval);\n    }\n else     if (character == '=') {\n      addCharEntity(61,retval);\n    }\n else     if (character == '?') {\n      addCharEntity(63,retval);\n    }\n else     if (character == '@') {\n      addCharEntity(64,retval);\n    }\n else     if (character == '[') {\n      addCharEntity(91,retval);\n    }\n else     if (character == '\\\\') {\n      addCharEntity(92,retval);\n    }\n else     if (character == ']') {\n      addCharEntity(93,retval);\n    }\n else     if (character == '^') {\n      addCharEntity(94,retval);\n    }\n else     if (character == '_') {\n      addCharEntity(95,retval);\n    }\n else     if (character == '`') {\n      addCharEntity(96,retval);\n    }\n else     if (character == '{') {\n      addCharEntity(123,retval);\n    }\n else     if (character == '|') {\n      addCharEntity(124,retval);\n    }\n else     if (character == '}') {\n      addCharEntity(125,retval);\n    }\n else     if (character == '~') {\n      addCharEntity(126,retval);\n    }\n else {\n      retval.append(character);\n    }\n    character=iterator.next();\n  }\n  return retval.toString();\n}\n", "nl": "Sanitize strings for output. Copy from anet_java_sdk_sample_app\\common\\helper.jsp"}
{"code": "public void install(RSyntaxTextArea textArea){\n  if (this.textArea != null) {\n    uninstall();\n  }\n  this.textArea=textArea;\n  textArea.addCaretListener(this);\n}\n", "nl": "Installs this listener on a text area. If it is already installed on another text area, it is uninstalled first."}
{"code": "public static int schemaInitialId(){\n  return FNV1_OFFSET_BASIS;\n}\n", "nl": "Schema initial ID."}
{"code": "public long remainder(long instant){\n  throw unsupported();\n}\n", "nl": "Always throws UnsupportedOperationException"}
{"code": "public Vertex randomSynthesize(Vertex source){\n  log(\"random synthesize\",Level.FINE);\n  return synthesizeResponse(null,null,null,true,null,source.getNetwork());\n}\n", "nl": "Self API for synthesizing a new response."}
{"code": "public final void testGetEncryptedData03() throws IOException {\n  boolean performed=false;\n  for (int i=0; i < EncryptedPrivateKeyInfoData.algName0.length; i++) {\n    try {\n      AlgorithmParameters ap=AlgorithmParameters.getInstance(EncryptedPrivateKeyInfoData.algName0[i][0]);\n      ap.init(EncryptedPrivateKeyInfoData.getParametersEncoding(EncryptedPrivateKeyInfoData.algName0[i][0]));\n      EncryptedPrivateKeyInfo epki=new EncryptedPrivateKeyInfo(ap,EncryptedPrivateKeyInfoData.encryptedData);\n      assertTrue(Arrays.equals(EncryptedPrivateKeyInfoData.encryptedData,epki.getEncryptedData()));\n      performed=true;\n    }\n catch (    NoSuchAlgorithmException allowedFailure) {\n    }\n  }\n  assertTrue(\"Test not performed\",performed);\n}\n", "nl": "Test #3 for <code>getEncryptedData()</code> method <br> Assertion: returns the encrypted data <br> Test preconditions: test object created using ctor which takes algorithm parameters and encrypted data as a parameters <br> Expected: the equivalent encrypted data must be returned"}
{"code": "@HLEFunction(nid=0x7D2F3D7F,version=271) public int sceJpegFinishMJpeg(){\n  return 0;\n}\n", "nl": "Finishes the MJpeg library"}
{"code": "@Override public void save(){\n  if (hasItem()) {\n    EventLogConfiguration config=getItem().getEventLogConfiguration();\n    config.clear();\n    if (mBinaryLogger.isSelected()) {\n      config.addLogger(EventLogType.BINARY_MESSAGE);\n    }\n    if (mDecodedLogger.isSelected()) {\n      config.addLogger(EventLogType.DECODED_MESSAGE);\n    }\n    if (mCallEventLogger.isSelected()) {\n      config.addLogger(EventLogType.CALL_EVENT);\n    }\n  }\n  setModified(false);\n}\n", "nl": "Saves the current configuration as the stored configuration"}
{"code": "public static VOPricedParameter toVOPricedParameter(PricedParameter pricedParam,LocalizerFacade facade){\n  Parameter parameter=pricedParam.getParameter();\n  VOParameterDefinition paraDef=ParameterDefinitionAssembler.toVOParameterDefinition(parameter.getParameterDefinition(),facade);\n  VOPricedParameter result=new VOPricedParameter(paraDef);\n  result.setPricePerUser(pricedParam.getPricePerUser());\n  result.setPricePerSubscription(pricedParam.getPricePerSubscription());\n  result.setPricedOptions(ParameterOptionAssembler.toVOPricedOptions(pricedParam,facade));\n  result.setParameterKey(parameter.getKey());\n  result.setRoleSpecificUserPrices(PricedProductRoleAssembler.toVOPricedProductRoles(pricedParam.getRoleSpecificUserPrices(),facade));\n  result.setSteppedPrices(SteppedPriceAssembler.toVOSteppedPrices(pricedParam.getSteppedPrices()));\n  updateValueObject(result,pricedParam);\n  return result;\n}\n", "nl": "Converts a priced parameter to the appropriate value object."}
{"code": "boolean isSimulation(){\n  return this.simulation;\n}\n", "nl": "Returns true if this is a simulation."}
{"code": "public boolean easyConfig(String ssid,String password,boolean isVersion2){\n  JsonObject initJsonObjectParams=broadlinkStandardParams(BroadlinkConstants.CMD_EASY_CONFIG_ID,BroadlinkConstants.CMD_EASY_CONFIG);\n  initJsonObjectParams.addProperty(\"ssid\",ssid);\n  initJsonObjectParams.addProperty(\"password\",password);\n  initJsonObjectParams.addProperty(\"broadlinkv2\",isVersion2 ? 1 : 0);\n  JsonObject out=broadlinkExecuteCommand(initJsonObjectParams);\n  int code=out.get(BroadlinkConstants.CODE).getAsInt();\n  return code == 0;\n}\n", "nl": "Magic config"}
{"code": "public Object newInstance(String owner) throws IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException {\n  return itemCtor.newInstance(owner);\n}\n", "nl": "Called by the APIProviderImpl to construct the API wrapper passed to it on its construction."}
{"code": "public static boolean canWrite(String fileName){\n  return FilePath.get(fileName).canWrite();\n}\n", "nl": "Check if the file is writable. This method is similar to Java 7 <code>java.nio.file.Path.checkAccess(AccessMode.WRITE)</code>"}
{"code": "public boolean implies(Permission p){\n  return true;\n}\n", "nl": "Checks if the specified permission is \"implied\" by this object. This method always returns true."}
{"code": "@DSComment(\"Utility function\") @DSSafe(DSCat.UTIL_FUNCTION) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:27:51.466 -0500\",hash_original_method=\"A988E80FBF926E38476CB13622AE0017\",hash_generated_method=\"7C5E5705B6EC3452A5193A1A55FAF86A\") public static boolean isWellFormedSmsAddress(String address){\n  String networkPortion=PhoneNumberUtils.extractNetworkPortion(address);\n  return (!(networkPortion.equals(\"+\") || TextUtils.isEmpty(networkPortion))) && isDialable(networkPortion);\n}\n", "nl": "Return true iff the network portion of <code>address</code> is, as far as we can tell on the device, suitable for use as an SMS destination address."}
{"code": "public List<Map<String,Object>> query(final String indexName,final String q,final Operator operator,final int offset,final int count){\n  assert count > 1;\n  SearchRequestBuilder request=elasticsearchClient.prepareSearch(indexName).setQuery(QueryBuilders.multiMatchQuery(q,\"_all\").operator(operator).zeroTermsQuery(ZeroTermsQuery.ALL)).setFrom(offset).setSize(count);\n  SearchResponse response=request.execute().actionGet();\n  SearchHit[] hits=response.getHits().getHits();\n  ArrayList<Map<String,Object>> result=new ArrayList<Map<String,Object>>();\n  for (  SearchHit hit : hits) {\n    Map<String,Object> map=hit.getSource();\n    result.add(map);\n  }\n  return result;\n}\n", "nl": "Query with a string and boundaries. The string is supposed to be something that the user types in without a technical syntax. The mapping of the search terms into the index can be different according to a search type. Please see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html. A better way to do this would be the usage of a cursor. See the delete method to find out how cursors work."}
{"code": "public static boolean isPattern(String pattern){\n  return pattern.indexOf('*') != -1 || pattern.indexOf('?') != -1;\n}\n", "nl": "Returns <code>true</code> if the specified pattern string contains wildcard characters."}
{"code": "public static void sort(int[] array,int start,int end){\n  DualPivotQuicksort.sort(array,start,end);\n}\n", "nl": "Sorts the specified range in the array in ascending numerical order."}
{"code": "public static void main(String[] args) throws Exception {\n  int timeout=Integer.MIN_VALUE;\n  int maxContentLength=Integer.MIN_VALUE;\n  String logLevel=\"info\";\n  boolean followTalk=false;\n  boolean keepConnection=false;\n  boolean dumpContent=false;\n  String urlString=null;\n  String usage=\"Usage: Ftp [-logLevel level] [-followTalk] [-keepConnection] [-timeout N] [-maxContentLength L] [-dumpContent] url\";\n  if (args.length == 0) {\n    System.err.println(usage);\n    System.exit(-1);\n  }\n  for (int i=0; i < args.length; i++) {\n    if (args[i].equals(\"-logLevel\")) {\n      logLevel=args[++i];\n    }\n else     if (args[i].equals(\"-followTalk\")) {\n      followTalk=true;\n    }\n else     if (args[i].equals(\"-keepConnection\")) {\n      keepConnection=true;\n    }\n else     if (args[i].equals(\"-timeout\")) {\n      timeout=Integer.parseInt(args[++i]) * 1000;\n    }\n else     if (args[i].equals(\"-maxContentLength\")) {\n      maxContentLength=Integer.parseInt(args[++i]);\n    }\n else     if (args[i].equals(\"-dumpContent\")) {\n      dumpContent=true;\n    }\n else     if (i != args.length - 1) {\n      System.err.println(usage);\n      System.exit(-1);\n    }\n else {\n      urlString=args[i];\n    }\n  }\n  Ftp ftp=new Ftp();\n  ftp.setFollowTalk(followTalk);\n  ftp.setKeepConnection(keepConnection);\n  if (timeout != Integer.MIN_VALUE)   ftp.setTimeout(timeout);\n  if (maxContentLength != Integer.MIN_VALUE)   ftp.setMaxContentLength(maxContentLength);\n  Content content=ftp.getProtocolOutput(urlString,WebPage.newBuilder().build()).getContent();\n  System.err.println(\"Content-Type: \" + content.getContentType());\n  System.err.println(\"Content-Length: \" + content.getMetadata().get(Response.CONTENT_LENGTH));\n  System.err.println(\"Last-Modified: \" + content.getMetadata().get(Response.LAST_MODIFIED));\n  if (dumpContent) {\n    System.out.print(new String(content.getContent()));\n  }\n  ftp=null;\n}\n", "nl": "For debugging."}
{"code": "public void write(ArrayList data){\n  data.add(xCoord);\n  data.add(yCoord);\n  data.add(zCoord);\n  data.add(dimensionId);\n}\n", "nl": "Writes this Coord4D's data to an ArrayList for packet transfer."}
{"code": "public String toString(){\n  if (_name != null)   return \"Lifecycle[\" + _name + \", \"+ getStateName()+ \"]\";\n else   return \"Lifecycle[\" + getStateName() + \"]\";\n}\n", "nl": "Debug string value."}
{"code": "public SVG12DOMImplementation(){\n  factories=svg12Factories;\n  registerFeature(\"CSS\",\"2.0\");\n  registerFeature(\"StyleSheets\",\"2.0\");\n  registerFeature(\"SVG\",new String[]{\"1.0\",\"1.1\",\"1.2\"});\n  registerFeature(\"SVGEvents\",new String[]{\"1.0\",\"1.1\",\"1.2\"});\n}\n", "nl": "Creates a new SVGDOMImplementation object."}
{"code": "private static <T>T attemptLoad(final Class<T> ofClass,final String className){\n  if (LOG.isLoggable(Level.FINEST)) {\n    LOG.finest(\"Attempting service load: \" + className);\n  }\n  Level level;\n  Exception thrown;\n  try {\n    Class clazz=Class.forName(className);\n    if (!ofClass.isAssignableFrom(clazz)) {\n      if (LOG.isLoggable(Level.WARNING)) {\n        LOG.warning(clazz.getName() + \" is not assignable to \" + ofClass.getName());\n      }\n      return null;\n    }\n    return ofClass.cast(clazz.newInstance());\n  }\n catch (  ClassNotFoundException ex) {\n    level=Level.FINEST;\n    thrown=ex;\n  }\ncatch (  InstantiationException ex) {\n    level=Level.WARNING;\n    thrown=ex;\n  }\ncatch (  IllegalAccessException ex) {\n    level=Level.WARNING;\n    thrown=ex;\n  }\n  LOG.log(level,\"Could not load \" + ofClass.getSimpleName() + \" instance: \"+ className,thrown);\n  return null;\n}\n", "nl": "Attempts to load the specified implementation class. Attempts will fail if - for example - the implementation depends on a class not found on the classpath."}
{"code": "@Override public void write(byte b[]) throws IOException {\n  write(b,0,b.length);\n}\n", "nl": "Write <code>b.length</code> bytes from the specified byte array to our output stream."}
{"code": "protected POInfo initPO(Properties ctx){\n  POInfo poi=POInfo.getPOInfo(ctx,Table_ID,get_TrxName());\n  return poi;\n}\n", "nl": "Load Meta Data"}
{"code": "public int countTestCases(){\n  return 1;\n}\n", "nl": "Counts the number of test cases executed by run(TestResult result)."}
{"code": "public void overwriteSetSelectedText(String str){\n  if (!overwrite || selectionStart != selectionEnd) {\n    setSelectedText(str);\n    return;\n  }\n  int caret=getCaretPosition();\n  int caretLineEnd=getLineEndOffset(getCaretLine());\n  if (caretLineEnd - caret <= str.length()) {\n    setSelectedText(str);\n    return;\n  }\n  document.beginCompoundEdit();\n  try {\n    document.remove(caret,str.length());\n    document.insertString(caret,str,null);\n  }\n catch (  BadLocationException bl) {\n    bl.printStackTrace();\n  }\n finally {\n    document.endCompoundEdit();\n  }\n}\n", "nl": "Similar to <code>setSelectedText()</code>, but overstrikes the appropriate number of characters if overwrite mode is enabled."}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Element testEmployee;\n  Attr domesticAttr;\n  doc=(Document)load(\"hc_staff\",true);\n  elementList=doc.getElementsByTagName(\"acronym\");\n  testEmployee=(Element)elementList.item(0);\n  domesticAttr=testEmployee.getAttributeNode(\"invalidAttribute\");\n  assertNull(\"elementGetAttributeNodeNullAssert\",domesticAttr);\n}\n", "nl": "Runs the test case."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:30:30.339 -0500\",hash_original_method=\"72982976B71B01DF2412198462460DF0\",hash_generated_method=\"3FC970F17DE45AAF7F1BC31C989BC4E0\") final public boolean isVisible(){\n  return isAdded() && !isHidden() && mView != null && mView.getWindowToken() != null && mView.getVisibility() == View.VISIBLE;\n}\n", "nl": "Return true if the fragment is currently visible to the user.  This means it: (1) has been added, (2) has its view attached to the window, and  (3) is not hidden."}
{"code": "public boolean checkError(){\n  Writer delegate=out;\n  if (delegate == null) {\n    return ioError;\n  }\n  flush();\n  return ioError || delegate.checkError();\n}\n", "nl": "Flushes this writer and returns the value of the error flag."}
{"code": "private boolean showHelpOnFirstLaunch(){\n  try {\n    PackageInfo info=getPackageManager().getPackageInfo(PACKAGE_NAME,0);\n    int currentVersion=info.versionCode;\n    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);\n    int lastVersion=prefs.getInt(PreferencesActivity.KEY_HELP_VERSION_SHOWN,0);\n    if (currentVersion > lastVersion) {\n      prefs.edit().putInt(PreferencesActivity.KEY_HELP_VERSION_SHOWN,currentVersion).commit();\n      Intent intent=new Intent(this,HelpActivity.class);\n      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);\n      String page=lastVersion == 0 ? HelpActivity.DEFAULT_PAGE : HelpActivity.WHATS_NEW_PAGE;\n      intent.putExtra(HelpActivity.REQUESTED_PAGE_KEY,page);\n      startActivity(intent);\n      return true;\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    Log.w(TAG,e);\n  }\n  return false;\n}\n", "nl": "We want the help screen to be shown automatically the first time a new version of the app is run. The easiest way to do this is to check android:versionCode from the manifest, and compare it to a value stored as a preference."}
{"code": "public boolean isReviewer(ReviewDb db,@Nullable ChangeData cd) throws OrmException {\n  if (getUser().isIdentifiedUser()) {\n    Collection<Account.Id> results=changeData(db,cd).reviewers().all();\n    return results.contains(getUser().getAccountId());\n  }\n  return false;\n}\n", "nl": "Is this user a reviewer for the change?"}
{"code": "public CLocalEdgeCommentWrapper(final INaviEdge edge){\n  m_edge=edge;\n}\n", "nl": "Creates a new wrapper object."}
{"code": "public void reverse(){\n  long tmp;\n  int limit=size / 2;\n  int j=size - 1;\n  long[] theElements=elements;\n  for (int i=0; i < limit; ) {\n    tmp=theElements[i];\n    theElements[i++]=theElements[j];\n    theElements[j--]=tmp;\n  }\n}\n", "nl": "Reverses the elements of the receiver. Last becomes first, second last becomes second first, and so on."}
{"code": "@Override public Boolean visitArray_Array(final AnnotatedArrayType type1,final AnnotatedArrayType type2,final VisitHistory visited){\n  if (!arePrimeAnnosEqual(type1,type2)) {\n    return false;\n  }\n  return areEqual(type1.getComponentType(),type2.getComponentType(),visited);\n}\n", "nl": "Two arrays are equal if: 1) Their sets of primary annotations are equal 2) Their component types are equal"}
{"code": "private void addRoleBasedRecuringCharges(PriceConverter formatter,RDOUserFees userFee,List<RDORole> roles){\n  for (  RDORole role : roles) {\n    RDORole existingRole=userFee.getRole(role.getRoleId());\n    if (existingRole == null) {\n      userFee.getRoles().add(role);\n    }\n else {\n      existingRole.setBasePrice(role.getBasePrice());\n      existingRole.setFactor(ValueRounder.roundValue(new BigDecimal(role.getFactor()),formatter.getActiveLocale(),ValueRounder.SCALING_FACTORS));\n      existingRole.setPrice(role.getPrice());\n    }\n  }\n}\n", "nl": "Merge the given RDORoles into the given RDOUserFees"}
{"code": "public StreamStatusWriter(String path,TwitchApi api){\n  this.path=path;\n  this.api=api;\n}\n", "nl": "Creates a new instance."}
{"code": "private static void addWeaponQuirk(List<QuirkEntry> quirkEntries,@Nullable Mounted m,int loc,int slot,String unitId,Entity entity){\n  if (m == null) {\n    return;\n  }\n  if (m.countQuirks() > 0) {\n    WeaponQuirks weapQuirks=m.getQuirks();\n    Enumeration<IOptionGroup> quirksGroup=weapQuirks.getGroups();\n    Enumeration<IOption> quirkOptions;\n    while (quirksGroup.hasMoreElements()) {\n      IOptionGroup group=quirksGroup.nextElement();\n      quirkOptions=group.getSortedOptions();\n      while (quirkOptions.hasMoreElements()) {\n        IOption option=quirkOptions.nextElement();\n        if (!option.booleanValue()) {\n          continue;\n        }\n        QuirkEntry qe=new QuirkEntry(option.getName(),entity.getLocationAbbr(loc),slot,m.getType().getInternalName(),unitId);\n        quirkEntries.add(qe);\n      }\n    }\n  }\n}\n", "nl": "Convenience method for adding a weapon quirk to the quirk entries list."}
{"code": "public static void toggleFavorite(){\n  try {\n    if (musicPlaybackService != null) {\n      musicPlaybackService.toggleFavorite();\n    }\n  }\n catch (  final RemoteException ignored) {\n  }\n}\n", "nl": "Toggles the current song as a favorite."}
{"code": "public void onSwapRemove(int cnt){\n  swapRemoves.addAndGet(cnt);\n  if (delegate != null)   delegate.onSwapRemove(cnt);\n}\n", "nl": "Swap remove callback."}
{"code": "private final void nextToken(){\n  if (m_queueMark < m_ops.getTokenQueueSize()) {\n    m_token=(String)m_ops.m_tokenQueue.elementAt(m_queueMark++);\n    m_tokenChar=m_token.charAt(0);\n  }\n else {\n    m_token=null;\n    m_tokenChar=0;\n  }\n}\n", "nl": "Retrieve the next token from the command and store it in m_token string."}
{"code": "public static int dp2px(Context context,float dp){\n  float px=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,dp,context.getResources().getDisplayMetrics());\n  return Math.round(px);\n}\n", "nl": "Convert a dp float value to pixels"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile;\n  String outputFile;\n  int progress;\n  int i, n;\n  int numFeatures;\n  int oneHundredthTotal;\n  ShapeType shapeType, outputShapeType;\n  GeometryFactory factory=new GeometryFactory();\n  double distTolerance=10;\n  boolean loseNoFeatures=false;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputFile=args[0];\n  outputFile=args[1];\n  distTolerance=Double.parseDouble(args[2]);\n  loseNoFeatures=Boolean.parseBoolean(args[3]);\n  if ((inputFile == null) || (outputFile == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    ShapeFile input=new ShapeFile(inputFile);\n    shapeType=input.getShapeType();\n    if (shapeType.getBaseType() != ShapeType.POLYGON && shapeType.getBaseType() != ShapeType.POLYLINE) {\n      showFeedback(\"This tool only works with shapefiles of a polygon or line base shape type.\");\n      return;\n    }\n    if (shapeType.getBaseType() == ShapeType.POLYGON) {\n      outputShapeType=ShapeType.POLYGON;\n    }\n else     if (shapeType.getBaseType() == ShapeType.POLYLINE) {\n      outputShapeType=ShapeType.POLYLINE;\n    }\n else {\n      showFeedback(\"This tool only works with shapefiles of a polygon or line base shape type.\");\n      return;\n    }\n    int numOutputFields=input.getAttributeTable().getFieldCount() + 1;\n    int numInputFields=input.getAttributeTable().getFieldCount();\n    DBFField[] inputFields=input.getAttributeTable().getAllFields();\n    DBFField fields[]=new DBFField[numOutputFields];\n    fields[0]=new DBFField();\n    fields[0].setName(\"PARENT_ID\");\n    fields[0].setDataType(DBFField.DBFDataType.NUMERIC);\n    fields[0].setFieldLength(10);\n    fields[0].setDecimalCount(0);\n    System.arraycopy(inputFields,0,fields,1,numInputFields);\n    ShapeFile output=new ShapeFile(outputFile,outputShapeType,fields);\n    output.setProjectionStringFromOtherShapefile(input);\n    numFeatures=input.getNumberOfRecords();\n    oneHundredthTotal=numFeatures / 100;\n    n=0;\n    progress=0;\n    com.vividsolutions.jts.geom.Geometry[] recJTS=null;\n    int recordNum;\n    for (    ShapeFileRecord record : input.records) {\n      recordNum=record.getRecordNumber();\n      Object[] attData=input.getAttributeTable().getRecord(recordNum - 1);\n      recJTS=record.getGeometry().getJTSGeometries();\n      ArrayList<com.vividsolutions.jts.geom.Geometry> geomList=new ArrayList<>();\n      for (int a=0; a < recJTS.length; a++) {\n        geomList.add(recJTS[a]);\n      }\n      DouglasPeuckerSimplifier dps=new DouglasPeuckerSimplifier(factory.buildGeometry(geomList));\n      dps.setDistanceTolerance(distTolerance);\n      com.vividsolutions.jts.geom.Geometry outputGeom=dps.getResultGeometry();\n      if (outputGeom.isEmpty() && loseNoFeatures) {\n        outputGeom=factory.buildGeometry(geomList);\n      }\n      if (!outputGeom.isEmpty()) {\n        for (int a=0; a < outputGeom.getNumGeometries(); a++) {\n          com.vividsolutions.jts.geom.Geometry g=outputGeom.getGeometryN(a);\n          if (g instanceof com.vividsolutions.jts.geom.Polygon && !g.isEmpty()) {\n            com.vividsolutions.jts.geom.Polygon p=(com.vividsolutions.jts.geom.Polygon)g;\n            ArrayList<ShapefilePoint> pnts=new ArrayList<>();\n            int[] parts=new int[p.getNumInteriorRing() + 1];\n            Coordinate[] buffCoords=p.getExteriorRing().getCoordinates();\n            if (!Topology.isLineClosed(buffCoords)) {\n              System.out.println(\"Exterior ring not closed.\");\n            }\n            if (Topology.isClockwisePolygon(buffCoords)) {\n              for (i=0; i < buffCoords.length; i++) {\n                pnts.add(new ShapefilePoint(buffCoords[i].x,buffCoords[i].y));\n              }\n            }\n else {\n              for (i=buffCoords.length - 1; i >= 0; i--) {\n                pnts.add(new ShapefilePoint(buffCoords[i].x,buffCoords[i].y));\n              }\n            }\n            for (int b=0; b < p.getNumInteriorRing(); b++) {\n              parts[b + 1]=pnts.size();\n              buffCoords=p.getInteriorRingN(b).getCoordinates();\n              if (!Topology.isLineClosed(buffCoords)) {\n                System.out.println(\"Interior ring not closed.\");\n              }\n              if (Topology.isClockwisePolygon(buffCoords)) {\n                for (i=buffCoords.length - 1; i >= 0; i--) {\n                  pnts.add(new ShapefilePoint(buffCoords[i].x,buffCoords[i].y));\n                }\n              }\n else {\n                for (i=0; i < buffCoords.length; i++) {\n                  pnts.add(new ShapefilePoint(buffCoords[i].x,buffCoords[i].y));\n                }\n              }\n            }\n            PointsList pl=new PointsList(pnts);\n            whitebox.geospatialfiles.shapefile.Polygon wbPoly=new whitebox.geospatialfiles.shapefile.Polygon(parts,pl.getPointsArray());\n            Object[] rowData=new Object[numOutputFields];\n            rowData[0]=new Double(recordNum - 1);\n            System.arraycopy(attData,0,rowData,1,numInputFields);\n            output.addRecord(wbPoly,rowData);\n          }\n else           if (g instanceof com.vividsolutions.jts.geom.LineString && !g.isEmpty()) {\n            LineString ls=(LineString)g;\n            ArrayList<ShapefilePoint> pnts=new ArrayList<>();\n            int[] parts={0};\n            Coordinate[] coords=ls.getCoordinates();\n            for (i=0; i < coords.length; i++) {\n              pnts.add(new ShapefilePoint(coords[i].x,coords[i].y));\n            }\n            PointsList pl=new PointsList(pnts);\n            whitebox.geospatialfiles.shapefile.PolyLine wbGeometry=new whitebox.geospatialfiles.shapefile.PolyLine(parts,pl.getPointsArray());\n            Object[] rowData=new Object[numOutputFields];\n            rowData[0]=new Double(recordNum - 1);\n            System.arraycopy(attData,0,rowData,1,numInputFields);\n            output.addRecord(wbGeometry,rowData);\n          }\n        }\n      }\n      n++;\n      if (n >= oneHundredthTotal) {\n        n=0;\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress++;\n        updateProgress(progress);\n      }\n    }\n    output.write();\n    updateProgress(\"Displaying vector: \",0);\n    returnData(outputFile);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "private boolean isIdentifier(String token){\n  int size=token.length();\n  for (int i=0; i < size; i++) {\n    char c=token.charAt(i);\n    if (isOperator(c))     return false;\n  }\n  if (token.startsWith(\"'\") && token.endsWith(\"'\"))   return false;\n else {\n    try {\n      new BigDecimal(token);\n      return false;\n    }\n catch (    NumberFormatException e) {\n    }\n  }\n  if (isSQLFunctions(token))   return false;\n  return true;\n}\n", "nl": "Check if token is a valid sql identifier"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader;\n  String outputHeader;\n  int row, col;\n  int progress=0;\n  double z, w, wN;\n  int i, n;\n  int[] dX={1,1,1,0,-1,-1,-1,0};\n  int[] dY={-1,0,1,1,1,0,-1,-1};\n  double largeValue=Float.MAX_VALUE;\n  double smallValue=0.0001;\n  boolean somethingDone;\n  int loopNum=1;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputHeader=args[0];\n  outputHeader=args[1];\n  smallValue=Double.parseDouble(args[2]);\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    WhiteboxRaster DEM=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=DEM.getNumberRows();\n    int cols=DEM.getNumberColumns();\n    double noData=DEM.getNoDataValue();\n    double noDataOutput=-32768.0;\n    WhiteboxRaster output;\n    if (smallValue < 0.01 && smallValue > 0) {\n      output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.DOUBLE,largeValue);\n    }\n else {\n      output=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,largeValue);\n    }\n    output.setNoDataValue(noDataOutput);\n    double[] data=null;\n    for (row=0; row < rows; row++) {\n      data=DEM.getRowValues(row);\n      if (row == 0 || row == (rows - 1)) {\n        for (col=0; col < cols; col++) {\n          if (data[col] != noData) {\n            output.setValue(row,col,data[col]);\n          }\n else {\n            output.setValue(row,col,noDataOutput);\n          }\n        }\n      }\n else {\n        for (col=0; col < cols; col++) {\n          z=data[col];\n          if (z == noData) {\n            output.setValue(row,col,noDataOutput);\n          }\n else {\n            output.setValue(row,col,z);\n            break;\n          }\n        }\n        for (col=cols - 1; col >= 0; col--) {\n          z=data[col];\n          if (z == noData) {\n            output.setValue(row,col,noDataOutput);\n          }\n else {\n            output.setValue(row,col,z);\n            break;\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * row / (rows - 1));\n      updateProgress(\"Loop 1:\",progress);\n    }\n    i=0;\n    do {\n      loopNum++;\n      somethingDone=false;\nswitch (i) {\ncase 0:\n        for (row=1; row < (rows - 1); row++) {\n          for (col=1; col < (cols - 1); col++) {\n            z=DEM.getValue(row,col);\n            w=output.getValue(row,col);\n            if (w > z) {\n              for (n=0; n < 8; n++) {\n                wN=output.getValue(row + dY[n],col + dX[n]) + smallValue;\n                if (z == noData && wN == noDataOutput) {\n                  w=noDataOutput;\n                  output.setValue(row,col,w);\n                }\n                if (wN < w) {\n                  if (wN > z) {\n                    output.setValue(row,col,wN);\n                    w=wN;\n                  }\n else {\n                    output.setValue(row,col,z);\n                    break;\n                  }\n                  somethingDone=true;\n                }\n              }\n            }\n          }\n          if (cancelOp) {\n            cancelOperation();\n            return;\n          }\n          progress=(int)(100f * row / (rows - 1));\n          updateProgress(\"Loop \" + loopNum + \":\",progress);\n        }\n      break;\ncase 1:\n    for (row=(rows - 2); row >= 1; row--) {\n      for (col=(cols - 2); col >= 1; col--) {\n        z=DEM.getValue(row,col);\n        w=output.getValue(row,col);\n        if (w > z) {\n          for (n=0; n < 8; n++) {\n            wN=output.getValue(row + dY[n],col + dX[n]) + smallValue;\n            if (z == noData && wN == noDataOutput) {\n              w=noDataOutput;\n              output.setValue(row,col,w);\n            }\n            if (wN < w) {\n              if (wN > z) {\n                output.setValue(row,col,wN);\n                w=wN;\n              }\n else {\n                output.setValue(row,col,z);\n                break;\n              }\n              somethingDone=true;\n            }\n          }\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(int)(100f * (rows - row) / (rows - 1));\n      updateProgress(\"Loop \" + loopNum + \":\",progress);\n    }\n  break;\ncase 2:\nfor (row=1; row < (rows - 1); row++) {\n  for (col=(cols - 2); col >= 1; col--) {\n    z=DEM.getValue(row,col);\n    w=output.getValue(row,col);\n    if (w > z) {\n      for (n=0; n < 8; n++) {\n        wN=output.getValue(row + dY[n],col + dX[n]) + smallValue;\n        if (z == noData && wN == noDataOutput) {\n          w=noDataOutput;\n          output.setValue(row,col,w);\n        }\n        if (wN < w) {\n          if (wN > z) {\n            output.setValue(row,col,wN);\n            w=wN;\n          }\n else {\n            output.setValue(row,col,z);\n            break;\n          }\n          somethingDone=true;\n        }\n      }\n    }\n  }\n  if (cancelOp) {\n    cancelOperation();\n    return;\n  }\n  progress=(int)(100f * row / (rows - 1));\n  updateProgress(\"Loop \" + loopNum + \":\",progress);\n}\nbreak;\ncase 3:\nfor (row=(rows - 2); row >= 1; row--) {\nfor (col=1; col < (cols - 1); col++) {\nz=DEM.getValue(row,col);\nw=output.getValue(row,col);\nif (w > z) {\n  for (n=0; n < 8; n++) {\n    wN=output.getValue(row + dY[n],col + dX[n]) + smallValue;\n    if (z == noData && wN == noDataOutput) {\n      w=noDataOutput;\n      output.setValue(row,col,w);\n    }\n    if (wN < w) {\n      if (wN > z) {\n        output.setValue(row,col,wN);\n        w=wN;\n      }\n else {\n        output.setValue(row,col,z);\n        break;\n      }\n      somethingDone=true;\n    }\n  }\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(int)(100f * (rows - row) / (rows - 1));\nupdateProgress(\"Loop \" + loopNum + \":\",progress);\n}\nbreak;\n}\ni++;\nif (i > 3) {\ni=0;\n}\n}\n while (somethingDone);\nloopNum++;\ndouble zN;\ndX=new int[]{-1,0,1,1,-1};\ndY=new int[]{-1,-1,-1,0,0};\nfor (row=0; row < rows; row++) {\nfor (col=0; col < cols; col++) {\nz=DEM.getValue(row,col);\nif (z == noData && output.getValue(row,col) != noDataOutput) {\nfor (i=0; i < 5; i++) {\nzN=output.getValue(row + dY[i],col + dX[i]);\nif (zN == noDataOutput) {\noutput.setValue(row,col,noDataOutput);\nbreak;\n}\n}\n}\n}\nfor (col=cols - 1; col >= 0; col--) {\nz=DEM.getValue(row,col);\nif (z == noData && output.getValue(row,col) != noDataOutput) {\nfor (i=0; i < 5; i++) {\nzN=output.getValue(row + dY[i],col + dX[i]);\nif (zN == noDataOutput) {\noutput.setValue(row,col,noDataOutput);\nbreak;\n}\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(int)(100f * row / (rows - 1));\nupdateProgress(\"Loop \" + loopNum + \":\",progress);\n}\nloopNum++;\ndX=new int[]{-1,0,1,1,-1};\ndY=new int[]{1,1,1,0,0};\nfor (row=rows - 1; row >= 0; row--) {\nfor (col=0; col < cols; col++) {\nz=DEM.getValue(row,col);\nif (z == noData && output.getValue(row,col) != noDataOutput) {\nfor (i=0; i < 5; i++) {\nzN=output.getValue(row + dY[i],col + dX[i]);\nif (zN == noDataOutput) {\noutput.setValue(row,col,noDataOutput);\nbreak;\n}\n}\n}\n}\nfor (col=cols - 1; col >= 0; col--) {\nz=DEM.getValue(row,col);\nif (z == noData && output.getValue(row,col) != noDataOutput) {\nfor (i=0; i < 5; i++) {\nzN=output.getValue(row + dY[i],col + dX[i]);\nif (zN == noDataOutput) {\noutput.setValue(row,col,noDataOutput);\nbreak;\n}\n}\n}\n}\nif (cancelOp) {\ncancelOperation();\nreturn;\n}\nprogress=(int)(100f * (rows - row) / (rows - 1));\nupdateProgress(\"Loop \" + loopNum + \":\",progress);\n}\noutput.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\noutput.addMetadataEntry(\"Created on \" + new Date());\nDEM.close();\noutput.flush();\noutput.findMinAndMaxVals();\noutput.close();\nreturnData(outputHeader);\n}\n catch (OutOfMemoryError oe) {\nmyHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n}\ncatch (Exception e) {\nmyHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\nmyHost.logException(\"Error in \" + getDescriptiveName(),e);\n}\n finally {\nupdateProgress(\"Progress: \",0);\namIActive=false;\nmyHost.pluginComplete();\n}\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public boolean isModified(){\n  return modified;\n}\n", "nl": "This returns if the json object has been modified"}
{"code": "private static List<Result> queryContacts(ContentResolver resolver,String input,HashSet<String> addressesRetVal){\n  String where=null;\n  String[] whereArgs=null;\n  if (!TextUtils.isEmpty(input)) {\n    where=CONTACTS_WHERE;\n    String param1=input + \"%\";\n    String param2=\"% \" + input + \"%\";\n    whereArgs=new String[]{param1,param2,param1,param2};\n  }\n  Cursor c=resolver.query(CommonDataKinds.StructuredPostal.CONTENT_URI,CONTACTS_PROJECTION,where,whereArgs,Contacts.DISPLAY_NAME + \" ASC\");\n  try {\n    Map<String,List<Result>> nameToAddresses=new HashMap<String,List<Result>>();\n    c.moveToPosition(-1);\n    while (c.moveToNext()) {\n      String name=c.getString(CONTACTS_INDEX_DISPLAY_NAME);\n      String address=c.getString(CONTACTS_INDEX_ADDRESS);\n      if (name != null) {\n        List<Result> addressesForName=nameToAddresses.get(name);\n        Result result;\n        if (addressesForName == null) {\n          Uri contactPhotoUri=null;\n          if (c.getLong(CONTACTS_INDEX_PHOTO_ID) > 0) {\n            contactPhotoUri=ContentUris.withAppendedId(Contacts.CONTENT_URI,c.getLong(CONTACTS_INDEX_CONTACT_ID));\n          }\n          addressesForName=new ArrayList<Result>();\n          nameToAddresses.put(name,addressesForName);\n          result=new Result(name,address,R.drawable.ic_contact_picture,contactPhotoUri);\n        }\n else {\n          result=new Result(null,address,null,null);\n        }\n        addressesForName.add(result);\n        addressesRetVal.add(address);\n      }\n    }\n    List<Result> allResults=new ArrayList<Result>();\n    for (    List<Result> result : nameToAddresses.values()) {\n      allResults.addAll(result);\n    }\n    return allResults;\n  }\n  finally {\n    if (c != null) {\n      c.close();\n    }\n  }\n}\n", "nl": "Matches the input string against contacts names and addresses."}
{"code": "public static <K,V>ObjectObjectHashMap<K,V> newMap(int expectedElements){\n  return new ObjectObjectHashMap<>(expectedElements);\n}\n", "nl": "Returns a new map with the given number of expected elements."}
{"code": "public VisorTaskArgument(Collection<UUID> nodes,boolean debug){\n  this(nodes,null,debug);\n}\n", "nl": "Create Visor task argument with nodes, but without actual argument."}
{"code": "public void addBitmapToCache(String data,BitmapDrawable value){\n  if (data == null || value == null) {\n    return;\n  }\n  if (mMemoryCache != null) {\n    if (RecyclingBitmapDrawable.class.isInstance(value)) {\n      ((RecyclingBitmapDrawable)value).setIsCached(true);\n    }\n    mMemoryCache.put(data,value);\n  }\n}\n", "nl": "Adds a bitmap to both memory and disk cache."}
{"code": "public void duration(long duration){\n  min=Math.min(min,duration);\n  max=Math.max(max,duration);\n  sum+=duration;\n  cnt++;\n}\n", "nl": "Adds this value to statistics."}
{"code": "public Decimal subtract(Decimal decimal){\n  assertDefined();\n  if (null == m_value) {\n    return (decimal);\n  }\n  BigDecimal value=m_value.subtract(decimal.getBigDecimalValue());\n  return new Decimal(value,SCALE);\n}\n", "nl": "Subtracts two decimal objects"}
{"code": "public Population(){\n  super();\n  data=new ArrayList<Solution>();\n}\n", "nl": "Constructs an empty population."}
{"code": "public void clear() throws SchedulerException {\n  sched.clear();\n}\n", "nl": "<p> Calls the equivalent method on the 'proxied' <code>QuartzScheduler</code>. </p>"}
{"code": "private Set intersectIP(Set permitted,Set ips){\n  Set intersect=new HashSet();\n  for (Iterator it=ips.iterator(); it.hasNext(); ) {\n    byte[] ip=ASN1OctetString.getInstance(((GeneralSubtree)it.next()).getBase().getName()).getOctets();\n    if (permitted == null) {\n      if (ip != null) {\n        intersect.add(ip);\n      }\n    }\n else {\n      Iterator it2=permitted.iterator();\n      while (it2.hasNext()) {\n        byte[] _permitted=(byte[])it2.next();\n        intersect.addAll(intersectIPRange(_permitted,ip));\n      }\n    }\n  }\n  return intersect;\n}\n", "nl": "Returns the intersection of the permitted IP ranges in <code>permitted</code> with <code>ip</code>."}
{"code": "public int addBlocks(int resId){\n  InputStream blockIs=mResources.openRawResource(resId);\n  try {\n    return loadBlocks(blockIs);\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(\"Failed to load block defintions from resource: \" + mResources.getResourceEntryName(resId));\n  }\n}\n", "nl": "Loads and adds block templates from a resource."}
{"code": "public Element(Locator locator,String uri,String localName,String qName,Attributes atts,boolean retainAttributes,List<PrefixMapping> prefixMappings){\n  super(locator);\n  this.uri=uri;\n  this.localName=localName;\n  this.qName=qName;\n  if (retainAttributes) {\n    this.attributes=atts;\n  }\n else {\n    this.attributes=new AttributesImpl(atts);\n  }\n  this.prefixMappings=prefixMappings;\n}\n", "nl": "The contructor."}
{"code": "public Mono<T> mono(){\n  return Mono.from(flux());\n}\n", "nl": "Create a pushable Mono"}
{"code": "public static Resource parseResource(String nTriplesResource,ValueFactory valueFactory) throws IllegalArgumentException {\n  if (nTriplesResource.startsWith(\"<\")) {\n    return parseURI(nTriplesResource,valueFactory);\n  }\n else   if (nTriplesResource.startsWith(\"_:\")) {\n    return parseBNode(nTriplesResource,valueFactory);\n  }\n else {\n    throw new IllegalArgumentException(\"Not a legal N-Triples resource: \" + nTriplesResource);\n  }\n}\n", "nl": "Parses an N-Triples resource, creates an object for it using the supplied ValueFactory and returns this object."}
{"code": "public void reset(ActionMapping mapping,HttpServletRequest request){\n  op=\"\";\n  distPrefId=\"\";\n  distType=Preference.BLANK_PREF_VALUE;\n  prefLevel=Preference.BLANK_PREF_VALUE;\n  subjectArea=DynamicList.getInstance(new ArrayList(),factory);\n  courseNbr=DynamicList.getInstance(new ArrayList(),factory);\n  exam=DynamicList.getInstance(new ArrayList(),factory);\n  filterSubjectAreaId=null;\n  filterCourseNbr=null;\n  filterSubjectAreas=new ArrayList();\n  iExamType=null;\n}\n", "nl": "Method reset"}
{"code": "@Deprecated public static char[] encode(final String unescapedComponent,final BitSet allowed,final String charset) throws URIException {\n  return URI.encode(unescapedComponent,allowed,charset);\n}\n", "nl": "Escape and encode a given string with allowed characters not to be escaped."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:00:51.416 -0500\",hash_original_method=\"E1FBF626549ACB1158CD9E14F440ADC4\",hash_generated_method=\"0E00904E93A6F196E058B95B3DFA9B3A\") public static void validate(int[] oid){\n  if (oid == null) {\n    throw new IllegalArgumentException(\"oid == null\");\n  }\n  if (oid.length < 2) {\n    throw new IllegalArgumentException(\"OID MUST have at least 2 subidentifiers\");\n  }\n  if (oid[0] > 2) {\n    throw new IllegalArgumentException(\"Valid values for first subidentifier are 0, 1 and 2\");\n  }\n else   if (oid[0] != 2 && oid[1] > 39) {\n    throw new IllegalArgumentException(\"If the first subidentifier has 0 or 1 value the \" + \"second subidentifier value MUST be less than 40\");\n  }\n  for (  int anOid : oid) {\n    if (anOid < 0) {\n      throw new IllegalArgumentException(\"Subidentifier MUST have positive value\");\n    }\n  }\n}\n", "nl": "Validates ObjectIdentifier (OID)."}
{"code": "boolean implementsAlg(String serv,String alg,String attribute,String val){\n  String servAlg=serv + \".\" + alg;\n  String prop=getPropertyIgnoreCase(servAlg);\n  if (prop == null) {\n    alg=getPropertyIgnoreCase(\"Alg.Alias.\" + servAlg);\n    if (alg != null) {\n      servAlg=serv + \".\" + alg;\n      prop=getPropertyIgnoreCase(servAlg);\n    }\n  }\n  if (prop != null) {\n    if (attribute == null) {\n      return true;\n    }\n    return checkAttribute(servAlg,attribute,val);\n  }\n  return false;\n}\n", "nl": "Returns true if this provider implements the given algorithm. Caller must specify the cryptographic service and specify constraints via the attribute name and value."}
{"code": "public void wipeDevice(String code,String data){\n  String inputPin;\n  String savedPin=Preference.getString(context,resources.getString(R.string.shared_pref_pin));\n  try {\n    JSONObject wipeKey=new JSONObject(data);\n    inputPin=(String)wipeKey.get(resources.getString(R.string.shared_pref_pin));\n    String status;\n    if (inputPin.trim().equals(savedPin.trim())) {\n      status=resources.getString(R.string.shared_pref_default_status);\n    }\n else {\n      status=resources.getString(R.string.shared_pref_false_status);\n    }\n    resultBuilder.build(code,status);\n    if (inputPin.trim().equals(savedPin.trim())) {\n      Toast.makeText(context,resources.getString(R.string.toast_message_wipe),Toast.LENGTH_LONG).show();\n      try {\n        Thread.sleep(PRE_WIPE_WAIT_TIME);\n      }\n catch (      InterruptedException e) {\n        Log.e(TAG,\"Wipe pause interrupted :\" + e.toString());\n      }\n      devicePolicyManager.wipeData(ACTIVATION_REQUEST);\n    }\n else {\n      Toast.makeText(context,resources.getString(R.string.toast_message_wipe_failed),Toast.LENGTH_LONG).show();\n    }\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON format.\" + e);\n  }\n}\n", "nl": "Wipe the device."}
{"code": "public double coefficientOfVariance(){\n  return Math.sqrt(variance()) / mean();\n}\n", "nl": "Returns the coefficient of variance."}
{"code": "int parseYear(String source,String token,int ofs) throws ParseException {\n  int year=parseNumber(source,ofs,\"year\",-1,-1);\n  int len=source.length();\n  int tokenLen=token.length();\n  int thisYear=Calendar.getInstance().get(Calendar.YEAR);\n  if ((len == 2) && (tokenLen < 3)) {\n    int c=(thisYear / 100) * 100;\n    year+=c;\n    if (year > (thisYear + 20)) {\n      year-=100;\n    }\n  }\n  validateNumber(year,ofs,\"year\",1000,thisYear + 1000);\n  return year;\n}\n", "nl": "Parse a year value. If the year is a two digit value, if the value is within 20 years ahead of the current year, current century will be used (ie. if current year is 2013, a value of \"33\" will return 2033), otherwise previous century is used (ie. with current year of 2012, a value of 97 will return \"1997\"). See Java 6 documentation for more details of this algorithm."}
{"code": "public boolean isWildcardExport(){\n  return wildcardExport;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public final void testGetItemId(){\n  CharSequence[] entries=new CharSequence[]{\"entry1\",\"entry2\"};\n  ProxySpinnerAdapter proxySpinnerAdapter=createAdapter(entries);\n  assertEquals(proxySpinnerAdapter.getAdapter().hasStableIds(),proxySpinnerAdapter.hasStableIds());\n  assertEquals(-1,proxySpinnerAdapter.getItemId(0));\n  assertEquals(0,proxySpinnerAdapter.getItemId(1));\n  assertEquals(1,proxySpinnerAdapter.getItemId(2));\n}\n", "nl": "Tests the functionality of the getItemId-method."}
{"code": "public static byte[] patternToHash(List<LockPatternView.Cell> pattern){\n  if (pattern == null) {\n    return null;\n  }\n else {\n    int size=pattern.size();\n    byte[] res=new byte[size];\n    for (int i=0; i < size; i++) {\n      LockPatternView.Cell cell=pattern.get(i);\n      res[i]=(byte)cell.getIndex();\n    }\n    MessageDigest md=null;\n    try {\n      md=MessageDigest.getInstance(\"SHA-1\");\n      return md.digest(res);\n    }\n catch (    NoSuchAlgorithmException e) {\n      e.printStackTrace();\n      return res;\n    }\n  }\n}\n", "nl": "Generate an SHA-1 hash for the pattern. Not the most secure, but it is at least a second level of protection. First level is that the file is in a location only readable by the system process."}
{"code": "private static SecretKeySpec generateKey(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n  final MessageDigest digest=MessageDigest.getInstance(HASH_ALGORITHM);\n  byte[] bytes=password.getBytes(\"UTF-8\");\n  digest.update(bytes,0,bytes.length);\n  byte[] key=digest.digest();\n  SecretKeySpec secretKeySpec=new SecretKeySpec(key,\"AES\");\n  return secretKeySpec;\n}\n", "nl": "Generates SHA256 hash of the password which is used as key"}
{"code": "protected void invoke(String path) throws TomcatManagerException, IOException {\n  invoke(path,null,null);\n}\n", "nl": "Invokes Tomcat manager with the specified command."}
{"code": "private void analize(){\n  StringTokenizer tokenizer=new StringTokenizer(sourceData,\",\");\n  String nextToken=null;\n  style=Integer.parseInt(tokenizer.nextToken());\n  iconSrc=Integer.parseInt(tokenizer.nextToken());\n  iconId=Integer.parseInt(tokenizer.nextToken());\n  nextToken=tokenizer.nextToken();\n  tooltip=nextToken.substring(1,nextToken.length() - 1);\n  actionType=Integer.parseInt(tokenizer.nextToken());\n  actionId=Integer.parseInt(tokenizer.nextToken());\n}\n", "nl": "Private methods"}
{"code": "public static DistributionConfigImpl produce(Properties props){\n  if (props != null) {\n    Object o=props.get(DS_CONFIG_NAME);\n    if (o instanceof DistributionConfigImpl) {\n      return (DistributionConfigImpl)o;\n    }\n  }\n  return new DistributionConfigImpl(props,false,false);\n}\n", "nl": "Produce a DistributionConfigImpl for the given properties and return it."}
{"code": "synchronized void useMultiplexer(ConnectionMultiplexer newMultiplexer){\n  multiplexer=newMultiplexer;\n  usingMultiplexer=true;\n}\n", "nl": "Use given connection multiplexer object to obtain new connections through this channel."}
{"code": "public JSearchPanel createSearchPanel(boolean monitorKeystrokes){\n  JSearchPanel jsp=new JSearchPanel(m_set,m_field,monitorKeystrokes);\n  if (m_lock != null) {\n    jsp.setLock(m_lock);\n  }\n  return jsp;\n}\n", "nl": "Create a new search text panel for searching over the data."}
{"code": "@NotNull public String readCurrentBranch(){\n  return branchExist() ? DvcsUtil.tryLoadFileOrReturn(myCurrentBranch,HgRepository.DEFAULT_BRANCH) : HgRepository.DEFAULT_BRANCH;\n}\n", "nl": "Return current branch"}
{"code": "public static void uiImpl(){\n  UIManager.put(\"ToolBar.isPaintPlainBackground\",Boolean.FALSE);\n  UIManager.put(\"ToolBar.shadow\",new ColorUIResource(new Color(180,183,187)));\n  UIManager.put(\"ToolBar.highlight\",new ColorUIResource(Color.white));\n  UIManager.put(\"ToolBar.dockingBackground\",new ColorUIResource(BeautyEyeLNFHelper.commonBackgroundColor));\n  UIManager.put(\"ToolBar.floatingBackground\",new ColorUIResource(BeautyEyeLNFHelper.commonBackgroundColor));\n  UIManager.put(\"ToolBar.background\",new ColorUIResource(BeautyEyeLNFHelper.commonBackgroundColor));\n  UIManager.put(\"ToolBar.foreground\",new ColorUIResource(BeautyEyeLNFHelper.commonForegroundColor));\n  UIManager.put(\"ToolBar.border\",new BorderUIResource(new org.jb2011.lnf.beautyeye.ch8_toolbar.BEToolBarUI.ToolBarBorder(UIManager.getColor(\"ToolBar.shadow\"),UIManager.getColor(\"ToolBar.highlight\"),new Insets(6,0,11,0))));\n  UIManager.put(\"ToolBarSeparatorUI\",org.jb2011.lnf.beautyeye.ch8_toolbar.BEToolBarSeparatorUI.class.getName());\n  UIManager.put(\"ToolBarUI\",org.jb2011.lnf.beautyeye.ch8_toolbar.BEToolBarUI.class.getName());\n}\n", "nl": "Ui impl."}
{"code": "public void fireScrollEvent(int scrollX,int scrollY,int oldscrollX,int oldscrollY){\n  if (listeners == null || listeners.size() == 0) {\n    return;\n  }\n  boolean isEdt=Display.getInstance().isEdt();\n  if (isEdt && listeners.size() == 1) {\n    ScrollListener a=(ScrollListener)listeners.get(0);\n    a.scrollChanged(scrollX,scrollY,oldscrollX,oldscrollY);\n    return;\n  }\n  ScrollListener[] array;\nsynchronized (this) {\n    array=new ScrollListener[listeners.size()];\n    int alen=array.length;\n    for (int iter=0; iter < alen; iter++) {\n      array[iter]=(ScrollListener)listeners.get(iter);\n    }\n  }\n  if (isEdt) {\n    fireScrollSync(array,scrollX,scrollY,oldscrollX,oldscrollY);\n  }\n else {\n    scrollListenerArray=true;\n    Runnable cl=new CallbackClass(array,new int[]{scrollX,scrollY,oldscrollX,oldscrollY});\n    if (blocking) {\n      Display.getInstance().callSeriallyAndWait(cl);\n    }\n else {\n      Display.getInstance().callSerially(cl);\n    }\n  }\n}\n", "nl": "Fires the event safely on the EDT without risk of concurrency errors"}
{"code": "private void savePreset(Preset preset){\n  String key=\"presets.\" + preset.pref + \".\";\n  preset.jar=jdbcDrvJarTf.getText();\n  setStringProp(key + \"jar\",preset.jar);\n  preset.drv=jdbcDrvClsTf.getText();\n  setStringProp(key + \"drv\",preset.drv);\n  preset.url=jdbcUrlTf.getText();\n  setStringProp(key + \"url\",preset.url);\n  preset.user=userTf.getText();\n  setStringProp(key + \"user\",preset.user);\n  savePreferences();\n}\n", "nl": "Save preset."}
{"code": "protected OMGraphic createOMGraphicFromBufferedImage(BufferedImage bi,int x,int y,int zoomLevel,Projection proj) throws InterruptedException {\n  OMGraphic raster=null;\n  if (bi != null) {\n    BufferedImage rasterImage=preprocessImage(bi,bi.getWidth(),bi.getHeight());\n    if (proj instanceof Mercator) {\n      raster=getTileMatchingProjectionType(rasterImage,x,y,zoomLevel);\n    }\n else {\n      raster=getTileNotMatchingProjectionType(rasterImage,x,y,zoomLevel);\n    }\n    if (mapTileLogger.isLoggable(Level.FINE)) {\n      raster.putAttribute(OMGraphic.LABEL,new OMTextLabeler(\"Tile: \" + zoomLevel + \"|\"+ x+ \"|\"+ y,OMText.JUSTIFY_CENTER));\n      raster.setSelected(true);\n    }\n  }\n  return raster;\n}\n", "nl": "Creates an OMRaster appropriate for projection and other parameters from a buffered image."}
{"code": "public Builder enableLog(final boolean logEnable){\n  this.logEnable=logEnable;\n  return this;\n}\n", "nl": "Set the Context used to instantiate the EasyGcm"}
{"code": "protected void onEntranceTransitionStart(){\n}\n", "nl": "Callback when entrance transition is started."}
{"code": "public void clear(){\n  oredCriteria.clear();\n  orderByClause=null;\n  distinct=false;\n}\n", "nl": "This method was generated by MyBatis Generator. This method corresponds to the database table address"}
{"code": "private void groupPlayerStandingCSV(){\n  for (  PlayerQB p : teamQBs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerRB p : teamRBs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerWR p : teamWRs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerK p : teamKs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerOL p : teamOLs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerS p : teamSs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerCB p : teamCBs) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n  for (  PlayerF7 p : teamF7s) {\n    if (p.year == 0)     teamRSs.add(p);\n else     if (p.year == 1)     teamFRs.add(p);\n else     if (p.year == 2)     teamSOs.add(p);\n else     if (p.year == 3)     teamJRs.add(p);\n else     if (p.year == 4)     teamSRs.add(p);\n  }\n}\n", "nl": "For news stories or other info gathering, setup player groups by student standing Run through each type of player, add them to the appropriate year"}
{"code": "public boolean isWasAdmin(){\n  return wasAdmin;\n}\n", "nl": "Gets the wasAdmin value for this Usuario."}
{"code": "@Override public final boolean onCreateOptionsMenu(final Menu menu){\n  final MenuInflater inflater=getMenuInflater();\n  inflater.inflate(R.menu.control_menu,menu);\n  return true;\n}\n", "nl": "Create context menu with start and stop buttons for \"tracking\" mode."}
{"code": "protected void sequence_VariableRef(ISerializationContext context,VariableRef semanticObject){\n  if (errorAcceptor != null) {\n    if (transientValues.isValueTransient(semanticObject,GamlPackage.Literals.VARIABLE_REF__REF) == ValueTransient.YES)     errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject,GamlPackage.Literals.VARIABLE_REF__REF));\n  }\n  SequenceFeeder feeder=createSequencerFeeder(context,semanticObject);\n  feeder.accept(grammarAccess.getVariableRefAccess().getRefVarDefinitionValid_IDParserRuleCall_1_0_1(),semanticObject.getRef());\n  feeder.finish();\n}\n", "nl": "Contexts: Expression returns VariableRef Pair returns VariableRef Pair.Pair_1_0_0 returns VariableRef If returns VariableRef If.If_1_0 returns VariableRef Or returns VariableRef Or.Expression_1_0 returns VariableRef And returns VariableRef And.Expression_1_0 returns VariableRef Cast returns VariableRef Cast.Cast_1_0_0 returns VariableRef Comparison returns VariableRef Comparison.Expression_1_0_0 returns VariableRef Addition returns VariableRef Addition.Expression_1_0_0 returns VariableRef Multiplication returns VariableRef Multiplication.Expression_1_0_0 returns VariableRef Exponentiation returns VariableRef Exponentiation.Expression_1_0_0 returns VariableRef Binary returns VariableRef Binary.Binary_1_0_0 returns VariableRef Unit returns VariableRef Unit.Unit_1_0_0 returns VariableRef Unary returns VariableRef Access returns VariableRef Access.Access_1_0 returns VariableRef Primary returns VariableRef AbstractRef returns VariableRef VariableRef returns VariableRef Constraint: ref=[VarDefinition|Valid_ID]"}
{"code": "void initFromCameraParameters(Camera camera){\n  Camera.Parameters parameters=camera.getParameters();\n  previewFormat=parameters.getPreviewFormat();\n  previewFormatString=parameters.get(\"preview-format\");\n  Log.d(TAG,\"Default preview format: \" + previewFormat + '/'+ previewFormatString);\n  WindowManager manager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);\n  Display display=manager.getDefaultDisplay();\n  screenResolution=new Point(display.getWidth(),display.getHeight());\n  Log.d(TAG,\"Screen resolution: \" + screenResolution);\n  Point screenResolutionForCamera=new Point();\n  screenResolutionForCamera.x=screenResolution.x;\n  screenResolutionForCamera.y=screenResolution.y;\n  if (screenResolution.x < screenResolution.y) {\n    screenResolutionForCamera.x=screenResolution.y;\n    screenResolutionForCamera.y=screenResolution.x;\n  }\n  cameraResolution=getCameraResolution(parameters,screenResolutionForCamera);\n  Log.d(TAG,\"Camera resolution: \" + screenResolution);\n}\n", "nl": "Reads, one time, values from the camera that are needed by the app."}
{"code": "static void testValidity(Object o) throws JSONException {\n  if (o != null) {\n    if (o instanceof Double) {\n      if (((Double)o).isInfinite() || ((Double)o).isNaN()) {\n        throw new JSONException(\"JSON does not allow non-finite numbers.\");\n      }\n    }\n else     if (o instanceof Float) {\n      if (((Float)o).isInfinite() || ((Float)o).isNaN()) {\n        throw new JSONException(\"JSON does not allow non-finite numbers.\");\n      }\n    }\n  }\n}\n", "nl": "Throw an exception if the object is an NaN or infinite number."}
{"code": "private void animateProperty(int constantName,float toValue){\n  float fromValue=getValue(constantName);\n  float deltaValue=toValue - fromValue;\n  animatePropertyBy(constantName,fromValue,deltaValue);\n}\n", "nl": "Utility function, called by the various x(), y(), etc. methods. This stores the constant name for the property along with the from/delta values that will be used to calculate and set the property during the animation. This structure is added to the pending animations, awaiting the eventual start() of the underlying animator. A Runnable is posted to start the animation, and any pending such Runnable is canceled (which enables us to end up starting just one animator for all of the properties specified at one time)."}
{"code": "public static boolean validateThreads(final CFlags flags){\n  if (flags.isSet(THREADS_FLAG)) {\n    final int threads=(Integer)flags.getValue(THREADS_FLAG);\n    if (threads <= 0) {\n      Diagnostic.error(ErrorType.INVALID_MIN_INTEGER_FLAG_VALUE,\"--\" + THREADS_FLAG,threads + \"\",\"1\");\n      return false;\n    }\n    final int maxThreads=Environment.getAvailableProcessors() * 10;\n    if (threads > maxThreads) {\n      Diagnostic.error(ErrorType.INVALID_MAX_INTEGER_FLAG_VALUE,\"--\" + THREADS_FLAG,threads + \"\",maxThreads + \"\");\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Validate the threads flags."}
{"code": "public final CC gapTop(String boundsSize){\n  ver.setGapBefore(ConstraintParser.parseBoundSize(boundsSize,true,false));\n  return this;\n}\n", "nl": "Sets the gap above the component."}
{"code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "nl": "Used to communicate a progress update between a plugin tool and the main Whitebox user interface."}
{"code": "public ZDT3(int numberOfVariables){\n  super(numberOfVariables);\n}\n", "nl": "Constructs a ZDT3 test problem with the specified number of decision variables."}
{"code": "public boolean pageScroll(int direction){\n  int width=getWidth();\n  int height=getHeight();\n  if (direction == View.FOCUS_UP) {\n    mTempRect.top=getScrollY() - height;\n    if (mTempRect.top < 0) {\n      mTempRect.top=0;\n    }\n    mTempRect.bottom=mTempRect.top + height;\n    return scrollAndFocusVertically(direction,mTempRect.top,mTempRect.bottom);\n  }\n else   if (direction == View.FOCUS_DOWN) {\n    mTempRect.top=getScrollY() + height;\n    int count=getChildCount();\n    if (count > 0) {\n      View view=getChildAt(count - 1);\n      if (mTempRect.top + height > view.getBottom()) {\n        mTempRect.top=view.getBottom() - height;\n      }\n    }\n    mTempRect.bottom=mTempRect.top + height;\n    return scrollAndFocusVertically(direction,mTempRect.top,mTempRect.bottom);\n  }\n else   if (direction == View.FOCUS_LEFT) {\n    mTempRect.left=getScrollX() - width;\n    if (mTempRect.left < 0) {\n      mTempRect.left=0;\n    }\n    mTempRect.right=mTempRect.left + width;\n    return scrollAndFocusHorizontally(direction,mTempRect.left,mTempRect.right);\n  }\n else {\n    mTempRect.left=getScrollX() + width;\n    int count=getChildCount();\n    if (count > 0) {\n      View view=getChildAt(0);\n      if (mTempRect.left + width > view.getRight()) {\n        mTempRect.left=view.getRight() - width;\n      }\n    }\n    mTempRect.right=mTempRect.left + width;\n    return scrollAndFocusHorizontally(direction,mTempRect.left,mTempRect.right);\n  }\n}\n", "nl": "<p>Handles scrolling in response to a \"page up/down\" shortcut press. This method will scroll the view by one page left or right and give the focus to the leftmost/rightmost component in the new visible area. If no component is a good candidate for focus, this scrollview reclaims the focus.</p>"}
{"code": "public static void i(String msg,Throwable thr){\n  log(LEVEL.INFO,null,msg,thr);\n}\n", "nl": "Send a INFO log message and log the exception."}
{"code": "protected ReactionPropertyImpl(){\n  super();\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void disableConnectionReuseIfNecessary(){\n  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.FROYO) {\n    System.setProperty(\"http.keepAlive\",\"false\");\n  }\n}\n", "nl": "Workaround for bug pre-Froyo, see here for more info: http://android-developers.blogspot.com/2011/09/androids-http-clients.html"}
{"code": "public void addMethodRefs(Map<String,ConfigurationMethodRef> configs){\n  methodInvocationRef.putAll(configs);\n}\n", "nl": "Adds cache configs for method invocations for from-clause."}
{"code": "public static void applyFilters(List<Integer> filterIds,Script script){\n  ScriptFilterDao dao=new ScriptFilterDao();\n  applyFiltersToScript(dao.findForIds(filterIds),script);\n}\n", "nl": "Applys the filters specified by filterIds"}
{"code": "private void writeXMLContent(char[] content,int start,int length,boolean escapeChars) throws XMLStreamException {\n  if (!escapeChars) {\n    _writer.write(content,start,length);\n    return;\n  }\n  int startWritePos=start;\n  final int end=start + length;\n  for (int index=start; index < end; index++) {\n    char ch=content[index];\n    if (!_writer.canEncode(ch)) {\n      _writer.write(content,startWritePos,index - startWritePos);\n      _writer.write(ENCODING_PREFIX);\n      _writer.write(Integer.toHexString(ch));\n      _writer.write(SEMICOLON);\n      startWritePos=index + 1;\n      continue;\n    }\nswitch (ch) {\ncase OPEN_START_TAG:\n      _writer.write(content,startWritePos,index - startWritePos);\n    _writer.write(\"&lt;\");\n  startWritePos=index + 1;\nbreak;\ncase AMPERSAND:\n_writer.write(content,startWritePos,index - startWritePos);\n_writer.write(\"&amp;\");\nstartWritePos=index + 1;\nbreak;\ncase CLOSE_START_TAG:\n_writer.write(content,startWritePos,index - startWritePos);\n_writer.write(\"&gt;\");\nstartWritePos=index + 1;\nbreak;\n}\n}\n_writer.write(content,startWritePos,end - startWritePos);\n}\n", "nl": "Writes XML content to underlying writer. Escapes characters unless escaping character feature is turned off."}
{"code": "public Set<String> addIncrementalContent(IndependentDistribution content,boolean followPrevious){\n  if (!paused) {\n    curState.addToState_incremental(content.toDiscrete(),followPrevious);\n    return update();\n  }\n else {\n    log.info(\"system is paused, ignoring content \" + content);\n    return Collections.emptySet();\n  }\n}\n", "nl": "Adds the incremental content (expressed as a distribution over variables) to the current dialogue state, and subsequently updates it. If followPrevious is set to true, the content is concatenated with the current distribution for the variable."}
{"code": "@Override public Object parseObject(final String source,final ParsePosition pos){\n  return parser.parseObject(source,pos);\n}\n", "nl": "Uses the parser Format instance."}
{"code": "protected CCProgressTimer(CCTexture2D texture){\n  super();\n  sprite_=CCSprite.sprite(texture);\n  percentage_=0.f;\n  vertexDataCount_=0;\n  setAnchorPoint(CGPoint.ccp(.5f,.5f));\n  setContentSize(sprite_.getContentSize());\n  type_=kCCProgressTimerTypeRadialCCW;\n}\n", "nl": "Creates a progress timer with the texture as the shape the timer goes through"}
{"code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 184) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "nl": "Unpacks the compressed character translation table."}
{"code": "@Override public ScoringFunction createNewScoringFunction(Person person){\n  final CharyparNagelScoringParameters parameters=params.getScoringParameters(person);\n  SumScoringFunction sumScoringFunction=new SumScoringFunction();\n  sumScoringFunction.addScoringFunction(new CharyparNagelActivityScoring(parameters));\n  sumScoringFunction.addScoringFunction(new CharyparNagelLegScoring(parameters,this.network));\n  sumScoringFunction.addScoringFunction(new CharyparNagelMoneyScoring(parameters));\n  sumScoringFunction.addScoringFunction(new CharyparNagelAgentStuckScoring(parameters));\n  return sumScoringFunction;\n}\n", "nl": "In every iteration, the framework creates a new ScoringFunction for each Person. A ScoringFunction is much like an EventHandler: It reacts to scoring-relevant events by accumulating them. After the iteration, it is asked for a score value. Since the factory method gets the Person, it can create a ScoringFunction which depends on Person attributes. This implementation does not. <li>The fact that you have a person-specific scoring function does not mean that the \"creative\" modules (such as route choice) are person-specific.  This is not a bug but a deliberate design concept in order  to reduce the consistency burden.  Instead, the creative modules should generate a diversity of possible solutions.  In order to do a better job, they may (or may not) use person-specific info.  kai, apr'11 </ul>"}
{"code": "FieldArray(){\n  this(10);\n}\n", "nl": "Creates a new FieldArray containing no fields."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  return sage.plugin.CorePluginManager.getInstance().getLatestRepoPlugins();\n}\n", "nl": "Returns an array of Plugin objects which represent all the plugins available in the plugin repository."}
{"code": "@Override public void visit(NodeVisitor v){\n  if (v.visit(this)) {\n    for (    AstNode label : labels) {\n      label.visit(v);\n    }\n    statement.visit(v);\n  }\n}\n", "nl": "Visits this node, then each label in the label-list, and finally the statement."}
{"code": "static String build(final String accountId,final String region,final DateTime instanceLaunchTime){\n  return Paths.get(accountId,region,instanceLaunchTime.toString(\"YYYY\"),instanceLaunchTime.toString(\"MM\"),instanceLaunchTime.toString(\"dd\")).toString() + \"/\";\n}\n", "nl": "Builds the prefix that will be prepended to the 'bucketname'<br/> Something like '123456789/eu-west-1/2015/06/12/'"}
{"code": "public GVTGlyphVector createGlyphVector(FontRenderContext frc,char[] chars){\n  StringCharacterIterator sci=new StringCharacterIterator(new String(chars));\n  GlyphVector gv=awtFont.createGlyphVector(frc,chars);\n  return new AWTGVTGlyphVector(gv,this,scale,sci);\n}\n", "nl": "Returns a new GlyphVector object created with the specified array of characters and the specified FontRenderContext."}
{"code": "public Long deleteRoom(Rooms r){\n  log.debug(\"deleteRoom\");\n  try {\n    r.setDeleted(\"true\");\n    r.setUpdatetime(new Date());\n    if (r.getRooms_id() == null) {\n      em.persist(r);\n    }\n else {\n      if (!em.contains(r)) {\n        em.merge(r);\n      }\n    }\n    return r.getRooms_id();\n  }\n catch (  Exception ex2) {\n    log.error(\"[deleteRoomsOrganisation] \",ex2);\n  }\n  return null;\n}\n", "nl": "deletes a Room by given Room-Object"}
{"code": "public ExternalEvent nextEvent(){\n  int responseSize=0;\n  int msgSize;\n  int interval;\n  int from;\n  int to;\n  from=drawHostAddress(this.hostRange);\n  to=drawToAddress(hostRange,from);\n  msgSize=drawMessageSize();\n  interval=drawNextEventTimeDiff();\n  MessageCreateEvent mce=new MessageCreateEvent(from,to,this.getID(),msgSize,responseSize,this.nextEventsTime);\n  this.nextEventsTime+=interval;\n  if (this.msgTime != null && this.nextEventsTime > this.msgTime[1]) {\n    this.nextEventsTime=Double.MAX_VALUE;\n  }\n  return mce;\n}\n", "nl": "Returns the next message creation event"}
{"code": "public void sortByKeys(SortOrder order){\n  final int size=this.keys.size();\n  final DefaultKeyedValue[] data=new DefaultKeyedValue[size];\n  for (int i=0; i < size; i++) {\n    data[i]=new DefaultKeyedValue((Comparable)this.keys.get(i),(Number)this.values.get(i));\n  }\n  Comparator comparator=new KeyedValueComparator(KeyedValueComparatorType.BY_KEY,order);\n  Arrays.sort(data,comparator);\n  clear();\n  for (int i=0; i < data.length; i++) {\n    final DefaultKeyedValue value=data[i];\n    addValue(value.getKey(),value.getValue());\n  }\n}\n", "nl": "Sorts the items in the list by key."}
{"code": "protected void moveRandomly(float factor){\n  double hor=Math.random() - .5;\n  double vert=Math.random() - .5;\n  setLat(getLat() + (float)vert / factor);\n  setLon(getLon() + (float)hor / factor);\n}\n", "nl": "A little method that will cause the location to move around a little."}
{"code": "public static String defaultString(Object obj){\n  return defaultString(obj,\"\");\n}\n", "nl": "<p> Returns either the passed in <code>Object</code> as a String, or, if the <code>Object</code> is <code>null</code> , an empty String. </p>"}
{"code": "public DimensionalNode parent(IMultiPoint value){\n  if (value == null) {\n    throw new IllegalArgumentException(\"unable to insert null value into KDTree\");\n  }\n  if (root == null) {\n    return null;\n  }\n  DimensionalNode node=root;\n  DimensionalNode next;\n  while (node != null) {\n    if (node.isBelow(value)) {\n      next=node.getBelow();\n      if (next == null) {\n        break;\n      }\n else {\n        node=next;\n      }\n    }\n else {\n      next=node.getAbove();\n      if (next == null) {\n        break;\n      }\n else {\n        node=next;\n      }\n    }\n  }\n  return node;\n}\n", "nl": "Return the parent of the point IF the point were to be inserted into the kd-tree. Returns null only if the tree is empty to begin with (i.e., there are no parents). Note that you will have to inspect the dimension for the DimensionalNode to determine if this is a Below or an Above parent."}
{"code": "protected void makeInputNodes(MethodScope methodScope,LoopScope loopScope,Node node,boolean updateUsages){\n  Edges edges=node.getNodeClass().getEdges(Edges.Type.Inputs);\n  for (int index=0; index < edges.getDirectCount(); index++) {\n    if (skipEdge(node,edges,index,true,true)) {\n      continue;\n    }\n    int orderId=readOrderId(methodScope);\n    Node value=ensureNodeCreated(methodScope,loopScope,orderId);\n    edges.initializeNode(node,index,value);\n    if (updateUsages && value != null && !value.isDeleted()) {\n      edges.update(node,null,value);\n    }\n  }\n  for (int index=edges.getDirectCount(); index < edges.getCount(); index++) {\n    if (skipEdge(node,edges,index,false,true)) {\n      continue;\n    }\n    int size=methodScope.reader.getSVInt();\n    if (size != -1) {\n      NodeList<Node> nodeList=new NodeInputList<>(node,size);\n      edges.initializeList(node,index,nodeList);\n      for (int idx=0; idx < size; idx++) {\n        int orderId=readOrderId(methodScope);\n        Node value=ensureNodeCreated(methodScope,loopScope,orderId);\n        nodeList.initialize(idx,value);\n        if (updateUsages && value != null && !value.isDeleted()) {\n          edges.update(node,null,value);\n        }\n      }\n    }\n  }\n}\n", "nl": "Process the input edges of a node. Input nodes that have not yet been created must be non-fixed nodes (because fixed nodes are processed in reverse postorder. Such non-fixed nodes are created on demand (recursively since they can themselves reference not yet created nodes)."}
{"code": "synchronized protected void timeout(){\n  if (progState != NOTPROGRAMMING) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"timeout!\");\n    }\n    progState=NOTPROGRAMMING;\n    if (tc.getProtocol() == Mx1Packetizer.ASCII) {\n      tc.sendMx1Message(tc.getCommandStation().resetModeMsg(),this);\n    }\n    notifyProgListenerEnd(_val,jmri.ProgListener.FailedTimeout);\n  }\n}\n", "nl": "Internal routine to handle a timeout"}
{"code": "public boolean isPlaylistSessionReady(){\n  return mSessionReady;\n}\n", "nl": "Returns whether or not the playlist session is ready to be played"}
{"code": "@Override public boolean isCellEditable(int row,int col){\n  return false;\n}\n", "nl": "Is the cell at the given row and column position editable?"}
{"code": "public JDIPermission(String name){\n  super(name);\n  if (!name.equals(\"virtualMachineManager\")) {\n    throw new IllegalArgumentException(\"name: \" + name);\n  }\n}\n", "nl": "The <code>JDIPermission</code> class represents access rights to the <code>VirtualMachineManager</code>"}
{"code": "public static Angle average(Angle a,Angle b,Angle c){\n  if (a == null || b == null || c == null) {\n    String message=Logging.getMessage(\"nullValue.AngleIsNull\");\n    Logging.logger().severe(message);\n    throw new IllegalArgumentException(message);\n  }\n  return Angle.fromDegrees((a.degrees + b.degrees + c.degrees) / 3);\n}\n", "nl": "Obtains the average of three angles. The order of parameters does not matter."}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Node employeeNode;\n  NodeList childList;\n  Node createdNode;\n  Node lchild;\n  String childName;\n  Node appendedChild;\n  doc=(Document)load(\"hc_staff\",true);\n  elementList=doc.getElementsByTagName(\"p\");\n  employeeNode=elementList.item(1);\n  childList=employeeNode.getChildNodes();\n  createdNode=doc.createElement(\"br\");\n  appendedChild=employeeNode.appendChild(createdNode);\n  lchild=employeeNode.getLastChild();\n  childName=lchild.getNodeName();\n  assertEqualsAutoCase(\"element\",\"nodeName\",\"br\",childName);\n}\n", "nl": "Runs the test case."}
{"code": "private void create3WayNetwork(Scenario sc){\n  Network net=sc.getNetwork();\n  NetworkFactory fac=net.getFactory();\n  Node n1, n2, n3, n4;\n  Link l;\n  n1=fac.createNode(Id.create(1,Node.class),new Coord(0.0,0.0));\n  net.addNode(n1);\n  double x=-10.0;\n  n2=fac.createNode(Id.create(2,Node.class),new Coord(x,10.0));\n  net.addNode(n2);\n  n3=fac.createNode(Id.create(3,Node.class),new Coord(0.0,10.0));\n  net.addNode(n3);\n  n4=fac.createNode(Id.create(4,Node.class),new Coord(10.0,8.0));\n  net.addNode(n4);\n  l=fac.createLink(Id.create(13,Link.class),n1,n3);\n  net.addLink(l);\n  l=fac.createLink(Id.create(31,Link.class),n3,n1);\n  net.addLink(l);\n  l=fac.createLink(Id.create(23,Link.class),n2,n3);\n  net.addLink(l);\n  l=fac.createLink(Id.create(32,Link.class),n3,n2);\n  net.addLink(l);\n  l=fac.createLink(Id.create(34,Link.class),n3,n4);\n  net.addLink(l);\n  l=fac.createLink(Id.create(43,Link.class),n4,n3);\n  net.addLink(l);\n}\n", "nl": "Creates a three waynetwork that looks like: <p> 2----- 3 ------ 4 |      |  | 1 </p>"}
{"code": "public static void assertEqual(byte expected,byte actual,String errorMessage){\n  if (verbose) {\n    log(\"assertEqual(\" + expected + \", \"+ actual+ \", \"+ errorMessage+ \")\");\n  }\n  assertBool(expected == actual,errorMessage);\n}\n", "nl": "Asserts that the given bytes are equal"}
{"code": "public static double pdf(double x,double m,double shape){\n  double a=Math.sqrt(shape / (2.0 * Math.PI * x* x* x));\n  double b=((-shape) * (x - m) * (x - m)) / (2.0 * m * m* x);\n  return a * Math.exp(b);\n}\n", "nl": "probability density function"}
{"code": "public TwoColumnOutput(OutputStream out,int leftWidth,int rightWidth,String spacer){\n  this(new OutputStreamWriter(out),leftWidth,rightWidth,spacer);\n}\n", "nl": "Constructs an instance."}
{"code": "private void recordSlavePartitionsText(){\n  try {\n    ITypedRegion[] partitions=TextUtilities.computePartitioning(tempDocument,partitioning,0,tempDocument.getLength(),false);\n    savedPartitionText=new String[partitions.length];\n    for (int i=0; i < savedPartitionText.length; i++) {\n      if (!isSlaveContentType(partitions[i].getType())) {\n        continue;\n      }\n      savedPartitionText[i]=tempDocument.get(partitions[i].getOffset(),partitions[i].getLength());\n    }\n  }\n catch (  BadLocationException e) {\n  }\n}\n", "nl": "Records the text of partitions for which we have a slave formatting strategy."}
{"code": "public void testDivideRoundCeilingNeg(){\n  String a=\"-92948782094488478231212478987482988429808779810457634781384756794987\";\n  int aScale=-24;\n  String b=\"7472334223847623782375469293018787918347987234564568\";\n  int bScale=13;\n  String c=\"-1.24390557635720517122423359799283E+53\";\n  int resScale=-21;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  BigDecimal result=aNumber.divide(bNumber,resScale,BigDecimal.ROUND_CEILING);\n  assertEquals(\"incorrect value\",c,result.toString());\n  assertEquals(\"incorrect scale\",resScale,result.scale());\n}\n", "nl": "Divide: rounding mode is ROUND_CEILING, result is negative"}
{"code": "public static int instanceOf(Object o,Class<?> c){\n  if (o == null)   return FALSE;\n  return c.isAssignableFrom(o.getClass()) ? TRUE : FALSE;\n}\n", "nl": "Replacement function for the Java instanceof instruction, which returns a distance integer"}
{"code": "public ServiceExtensionManager(ImsModule imsModule,Context ctx,Core core,RcsSettings rcsSettings){\n  mCtx=ctx;\n  mCore=core;\n  mRcsSettings=rcsSettings;\n  mSupportedExtensionUpdater=new SupportedExtensionUpdater(mCtx,imsModule,mRcsSettings,this);\n}\n", "nl": "Monitor the application package changes to update RCS supported extensions"}
{"code": "public TextureAtlas(int initialWidth,int initialHeight,int maxWidth,int maxHeight){\n  this(initialWidth,initialHeight,maxWidth,maxHeight,DEFAULT_USE_MIP_MAPS,DEFAULT_USE_ANISOTROPY);\n}\n", "nl": "Constructs a texture atlas with the specified initial and maximum dimensions. All dimensions must be greater than zero, and the maximum dimensions must be greater than or equal to the initial dimensions. The constructed texture atlas generates mip-maps and applies an anisotropic filter to each element."}
{"code": "public void testMergeOneFilterIntoDocumentWithSameFilterAndParam() throws Exception {\n  String srcXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"  </filter>\"+ \"</web-app>\";\n  WebXml srcWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(srcXml.getBytes(\"UTF-8\")),null);\n  String mergeXml=\"<web-app>\" + \"  <filter>\" + \"    <filter-name>f1</filter-name>\"+ \"    <filter-class>fclass1</filter-class>\"+ \"    <init-param>\"+ \"      <param-name>f1param1</param-name>\"+ \"      <param-value>f1param1value</param-value>\"+ \"    </init-param>\"+ \"  </filter>\"+ \"</web-app>\";\n  WebXml mergeWebXml=WebXmlIo.parseWebXml(new ByteArrayInputStream(mergeXml.getBytes(\"UTF-8\")),null);\n  WebXmlMerger merger=new WebXmlMerger(srcWebXml);\n  merger.mergeFilters(mergeWebXml);\n  assertTrue(WebXmlUtils.hasFilter(srcWebXml,\"f1\"));\n  List<String> initParams=WebXmlUtils.getFilterInitParamNames(srcWebXml,\"f1\");\n  assertEquals(1,initParams.size());\n  assertEquals(\"f1param1\",initParams.get(0));\n}\n", "nl": "Tests whether a filter initialization parameter is merged into the descriptor only once."}
{"code": "private void generateSerializerRegistration() throws SAXException {\n  final SerializerCreation sc=this.creation.getSerializerCreation();\n  if (sc == null) {\n    return;\n  }\n  handler.startElement(\"\",TOP_SERIALIZER_REGISTRATION,TOP_SERIALIZER_REGISTRATION,EMPTY);\n  for (  Class c : sc.getSerializerRegistrations()) {\n    handler.startElement(\"\",SERIALIZER_REGISTRATION,SERIALIZER_REGISTRATION,EMPTY);\n    handler.startElement(\"\",CLASS_NAME,CLASS_NAME,EMPTY);\n    handler.characters(c.getName().toCharArray(),0,c.getName().length());\n    handler.endElement(\"\",CLASS_NAME,CLASS_NAME);\n    handler.endElement(\"\",SERIALIZER_REGISTRATION,SERIALIZER_REGISTRATION);\n  }\n  for (  Map.Entry<Class,Integer> e : sc.getInstantiatorRegistrations().entrySet()) {\n    Class c=e.getKey();\n    Integer i=e.getValue();\n    AttributesImpl atts=new AttributesImpl();\n    atts.addAttribute(\"\",\"\",ID,\"\",i.toString());\n    handler.startElement(\"\",INSTANTIATOR_REGISTRATION,INSTANTIATOR_REGISTRATION,atts);\n    handler.startElement(\"\",CLASS_NAME,CLASS_NAME,EMPTY);\n    handler.characters(c.getName().toCharArray(),0,c.getName().length());\n    handler.endElement(\"\",CLASS_NAME,CLASS_NAME);\n    handler.endElement(\"\",INSTANTIATOR_REGISTRATION,INSTANTIATOR_REGISTRATION);\n  }\n  handler.endElement(\"\",TOP_SERIALIZER_REGISTRATION,TOP_SERIALIZER_REGISTRATION);\n}\n", "nl": "Generates the <code>serializer-registration</code> element."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public static void sort(Object[] array){\n  ComparableTimSort.sort(array);\n}\n", "nl": "Sorts the specified array in ascending natural order."}
{"code": "@action(name=\"cfp\",args={@arg(name=GamaMessageType.MESSAGE_STR,type=IType.MESSAGE,optional=false,doc=@doc(\"The message to be replied\")),@arg(name=GamaMessage.CONTENTS,type=IType.LIST,optional=false,doc=@doc(\"The content of the replying message\"))},doc=@doc(\"Replies a message with a 'cfp' performative message.\")) public Object primCfp(final IScope scope) throws GamaRuntimeException {\n  final IList originals=getMessageArg(scope);\n  if (originals == null || originals.size() == 0) {\n    throw GamaRuntimeException.error(\"No message to reply\",scope);\n  }\n  return replyMessage(scope,originals,CFP,getContentArg(scope));\n}\n", "nl": "Prim cfp."}
{"code": "public Command show(int top,int bottom,int left,int right,boolean includeTitle,boolean modal){\n  this.top=top;\n  this.bottom=bottom;\n  if (isRTL()) {\n    this.left=right;\n    this.right=left;\n  }\n else {\n    this.left=left;\n    this.right=right;\n  }\n  setDisposed(false);\n  this.modal=modal;\n  lastCommandPressed=null;\n  showModal(this.top,this.bottom,this.left,this.right,includeTitle,modal,false);\n  return lastCommandPressed;\n}\n", "nl": "This method shows the form as a modal alert allowing us to produce a behavior of an alert/dialog box. This method will block the calling thread even if the calling thread is the EDT. Notice that this method will not release the block until dispose is called even if show() from another form is called! <p>Modal dialogs Allow the forms \"content\" to \"hang in mid air\" this is especially useful for dialogs where you would want the underlying form to \"peek\" from behind the  form."}
{"code": "public static StartupSettings fromJSONFile(File jsonFile) throws JSONException, FileNotFoundException, IOException {\n  StringBuffer buffer=new StringBuffer();\n  try (BufferedReader br=new BufferedReader(new FileReader(jsonFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      buffer.append(line.trim());\n    }\n  }\n   JSONObject jsonObject=new JSONArray(buffer.toString()).getJSONObject(0);\n  int port=jsonObject.getInt(\"port\");\n  String id=jsonObject.getString(\"id\");\n  int gossipInterval=jsonObject.getInt(\"gossip_interval\");\n  int cleanupInterval=jsonObject.getInt(\"cleanup_interval\");\n  String cluster=jsonObject.getString(\"cluster\");\n  if (cluster == null) {\n    throw new IllegalArgumentException(\"cluster was null. It is required\");\n  }\n  StartupSettings settings=new StartupSettings(id,port,new GossipSettings(gossipInterval,cleanupInterval),cluster);\n  String configMembersDetails=\"Config-members [\";\n  JSONArray membersJSON=jsonObject.getJSONArray(\"members\");\n  for (int i=0; i < membersJSON.length(); i++) {\n    JSONObject memberJSON=membersJSON.getJSONObject(i);\n    RemoteGossipMember member=new RemoteGossipMember(memberJSON.getString(\"cluster\"),memberJSON.getString(\"host\"),memberJSON.getInt(\"port\"),\"\");\n    settings.addGossipMember(member);\n    configMembersDetails+=member.getAddress();\n    if (i < (membersJSON.length() - 1))     configMembersDetails+=\", \";\n  }\n  log.info(configMembersDetails + \"]\");\n  return settings;\n}\n", "nl": "Parse the settings for the gossip service from a JSON file."}
{"code": "public void ensureCapacity(int minCapacity){\n  elements=cern.colt.Arrays.ensureCapacity(elements,minCapacity);\n}\n", "nl": "Ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver."}
{"code": "public void skipWhile(String skip) throws IOException {\n  char ch;\n  do {\n    ch=read();\n  }\n while (skip.indexOf(ch) > -1);\n  unreadCharacter(ch);\n}\n", "nl": "Skips char any contiguous characters in skip. Will also skip comments."}
{"code": "public DeleteWarmerRequest names(@Nullable String... names){\n  this.names=names;\n  return this;\n}\n", "nl": "The name (or wildcard expression) of the index warmer to delete, or null to delete all warmers."}
{"code": "public boolean arrayContains(int[] ar,int value){\n  for (int i=0; i < ar.length; i++) {\n    if (ar[i] == value) {\n      return true;\n    }\n  }\n  return false;\n}\n", "nl": "See if an integer array contains the desired value."}
{"code": "private void skipSynchOrStartServiceOnPeer(Operation peerOp,String link,SynchronizePeersRequest request){\n  if (request.options.contains(ServiceOption.ON_DEMAND_LOAD)) {\n    peerOp.complete();\n    return;\n  }\n  Operation checkGet=Operation.createGet(UriUtils.buildUri(peerOp.getUri(),link)).addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_FORWARDING).setConnectionSharing(true).setExpiration(Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(2))).setCompletion(null);\n  sendRequest(checkGet);\n}\n", "nl": "The service state on the peer node is identical to best state. We should skip sending a synchronization POST, if the service is already started"}
{"code": "public static final boolean isIplSpecificIdentityReportMessage(LocoNetMessage m,Integer hostMfr,Integer hostDevice){\n  if (!isIplIdentityReportMessage(m)) {\n    return false;\n  }\n  if ((m.getElement(4) == hostMfr) && (m.getElement(5) == hostDevice)) {\n    return true;\n  }\n  return false;\n}\n", "nl": "Checks message m to determine if it contains a IPL Identity Report message for a specific host manufacturer and specific host device type."}
{"code": "public static boolean isBetween(double val,double theshold1,double theshold2){\n  return theshold2 > theshold1 ? val > theshold1 && val < theshold2 : val > theshold2 && val < theshold1;\n}\n", "nl": "Used to determine whether a value is between two thresholds."}
{"code": "public void testFloatingPrecision1() throws Exception {\n  new BufferValidator(100,\"LINESTRING (331771 5530174, 331776 5530175, 331782 5530177, 331787 5530177, 331791 5530178, 331796 5530178, 331800 5530178, 331805 5530177, 331811 5530176, 331817 5530175, 331823 5530173, 331828 5530171, 331832 5530169, 331835 5530167, 331839 5530163, 331843 5530160, 331846 5530157, 331849 5530154, 331853 5530150, 331855 5530145, 331857 5530141)\").test();\n}\n", "nl": "The #testFloatingPrecisionN tests were taken from bufferError-dist 100.jml."}
{"code": "public AttributeCertificateHolder(int digestedObjectType,String digestAlgorithm,String otherObjectTypeID,byte[] objectDigest){\n  holder=new Holder(new ObjectDigestInfo(digestedObjectType,new ASN1ObjectIdentifier(otherObjectTypeID),new AlgorithmIdentifier(digestAlgorithm),Arrays.clone(objectDigest)));\n}\n", "nl": "Constructs a holder for v2 attribute certificates with a hash value for some type of object. <p> <code>digestedObjectType</code> can be one of the following: <ul> <li>0 - publicKey - A hash of the public key of the holder must be passed. <li>1 - publicKeyCert - A hash of the public key certificate of the holder must be passed. <li>2 - otherObjectDigest - A hash of some other object type must be passed. <code>otherObjectTypeID</code> must not be empty. </ul> <p> This cannot be used if a v1 attribute certificate is used."}
{"code": "public void incrementTargetsCountAll(){\n  targetsCountAll.incrementAndGet();\n}\n", "nl": "increments the targets all counter."}
{"code": "@Override protected boolean isSuccessful(final Player player){\n  return getState() > 0;\n}\n", "nl": "Decides if the activity was successful."}
{"code": "void mutateStaticField(String field){\n  PurityNode node=PurityGlobalNode.node;\n  mutated.put(node,field);\n  nodes.add(node);\n  if (doCheck)   sanityCheck();\n}\n", "nl": "Store a primitive type into a static field left.field = v"}
{"code": "public void testFlipBitException(){\n  byte aBytes[]={-1,-128,56,100,-2,-76,89,45,91,3,-15,35,26};\n  int aSign=1;\n  int number=-7;\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  try {\n    aNumber.flipBit(number);\n    fail(\"ArithmeticException has not been caught\");\n  }\n catch (  ArithmeticException e) {\n  }\n}\n", "nl": "flipBit(int n) of a negative n"}
{"code": "private static long sublong(String value,int begin_index,int end_index){\n  String substring=value.substring(begin_index,end_index);\n  return (substring.length() > 0) ? Long.parseLong(substring) : -1;\n}\n", "nl": "Returns a substring of the given string value from the given begin index to the given end index as a long. If the substring is empty, then -1 will be returned."}
{"code": "private void processBlockChanges(){\nsynchronized (blockChanges) {\n    List<BlockChangeMessage> messages=new ArrayList<>(blockChanges);\n    blockChanges.clear();\n    Map<Key,Map<BlockVector,BlockChangeMessage>> chunks=new HashMap<>();\n    for (    BlockChangeMessage message : messages) {\n      if (message != null) {\n        Key key=new Key(message.getX() >> 4,message.getZ() >> 4);\n        if (canSeeChunk(key)) {\n          Map<BlockVector,BlockChangeMessage> map=chunks.get(key);\n          if (map == null) {\n            map=new HashMap<>();\n            chunks.put(key,map);\n          }\n          map.put(new BlockVector(message.getX(),message.getY(),message.getZ()),message);\n        }\n      }\n    }\n    for (    Map.Entry<Key,Map<BlockVector,BlockChangeMessage>> entry : chunks.entrySet()) {\n      Key key=entry.getKey();\n      List<BlockChangeMessage> value=new ArrayList<>(entry.getValue().values());\n      if (value.size() == 1) {\n        session.send(value.get(0));\n      }\n else       if (value.size() > 1) {\n        session.send(new MultiBlockChangeMessage(key.getX(),key.getZ(),value));\n      }\n    }\n    List<Message> postMessages=new ArrayList<>(afterBlockChanges);\n    afterBlockChanges.clear();\n    postMessages.forEach(null);\n  }\n}\n", "nl": "Process and send pending BlockChangeMessages."}
{"code": "@Override public void onConnected(Bundle connectionHint){\n  mLastLocation=LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);\n  if (mLastLocation != null) {\n    mLatitudeText.setText(String.valueOf(mLastLocation.getLatitude()));\n    mLongitudeText.setText(String.valueOf(mLastLocation.getLongitude()));\n  }\n}\n", "nl": "Runs when a GoogleApiClient object successfully connects."}
{"code": "public void runTest() throws Throwable {\n  Document doc;\n  NodeList elementList;\n  Attr newAttribute;\n  Node testAddress;\n  NamedNodeMap attributes;\n  Attr districtNode;\n  String attrValue;\n  Node setNode;\n  doc=(Document)load(\"hc_staff\",true);\n  elementList=doc.getElementsByTagName(\"acronym\");\n  testAddress=elementList.item(1);\n  newAttribute=doc.createAttribute(\"class\");\n  attributes=testAddress.getAttributes();\n  setNode=attributes.setNamedItem(newAttribute);\n  districtNode=(Attr)attributes.getNamedItem(\"class\");\n  attrValue=districtNode.getNodeValue();\n  assertEquals(\"namednodemapSetNamedItemThatExistsAssert\",\"\",attrValue);\n}\n", "nl": "Runs the test case."}
{"code": "@Nullable @Override public final ImageFormat determineFormat(byte[] headerBytes,int headerSize){\n  Preconditions.checkNotNull(headerBytes);\n  if (WebpSupportStatus.isWebpHeader(headerBytes,0,headerSize)) {\n    return getWebpFormat(headerBytes,headerSize);\n  }\n  if (isJpegHeader(headerBytes,headerSize)) {\n    return DefaultImageFormats.JPEG;\n  }\n  if (isPngHeader(headerBytes,headerSize)) {\n    return DefaultImageFormats.PNG;\n  }\n  if (isGifHeader(headerBytes,headerSize)) {\n    return DefaultImageFormats.GIF;\n  }\n  if (isBmpHeader(headerBytes,headerSize)) {\n    return DefaultImageFormats.BMP;\n  }\n  return ImageFormat.UNKNOWN;\n}\n", "nl": "Tries to match imageHeaderByte and headerSize against every known image format. If any match succeeds, corresponding ImageFormat is returned."}
{"code": "public SymbolTableEntryOriginal createSymbolTableEntryOriginal(){\n  SymbolTableEntryOriginalImpl symbolTableEntryOriginal=new SymbolTableEntryOriginalImpl();\n  return symbolTableEntryOriginal;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public boolean isPrinted(){\n  Object oo=get_Value(COLUMNNAME_IsPrinted);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Printed."}
{"code": "public TaskDescriptionCompat(String label,Bitmap icon,int colorPrimary){\n  if ((colorPrimary != 0) && (Color.alpha(colorPrimary) != 255)) {\n    throw new RuntimeException(\"A TaskDescription's primary color should be opaque\");\n  }\n  mLabel=label;\n  mIcon=icon;\n  mColorPrimary=colorPrimary;\n}\n", "nl": "Creates the TaskDescription to the specified values."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:49.464 -0400\",hash_original_method=\"31F26CED2D9DD4AAAFE52ACDE68992E7\",hash_generated_method=\"11FC7D3D554A594833AA979DB176E76F\") private int handleX(String value,DoubleMetaphoneResult result,int index){\n  if (index == 0) {\n    result.append('S');\n    index++;\n  }\n else {\n    if (!((index == value.length() - 1) && (contains(value,index - 3,3,\"IAU\",\"EAU\") || contains(value,index - 2,2,\"AU\",\"OU\")))) {\n      result.append(\"KS\");\n    }\n    index=contains(value,index + 1,1,\"C\",\"X\") ? index + 2 : index + 1;\n  }\n  return index;\n}\n", "nl": "Handles 'X' cases"}
{"code": "protected void sequence_TStructMemberList_ThisTypeRefStructural_TypeRefWithoutModifiers(ISerializationContext context,ThisTypeRefStructural semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: TypeRefWithoutModifiers returns ThisTypeRefStructural Constraint: (definedTypingStrategy=TypingStrategyUseSiteOperator astStructuralMembers+=TStructMember* dynamic?='+'?)"}
{"code": "public void openOSM(File file){\n  osm=new OSM(file.getPath());\n  LOG.info(\"Read OSM\");\n}\n", "nl": "TODO Javadoc. What is this for?"}
{"code": "void initNullKeyForUrl(String url){\n  initNullKeyForUrlInternal(url,false);\n}\n", "nl": "init null key for url"}
{"code": "@VisibleForTesting void overrideDecidedStateForTesting(boolean decidedState){\n  mDidOverrideDecidedStateForTesting=true;\n  mDecidedStateForTesting=decidedState;\n}\n", "nl": "Overrides the decided/undecided state for the user preference."}
{"code": "private GPOUtils(){\n}\n", "nl": "This class should not be instantiated"}
{"code": "public Object eval(CallStack callstack,Interpreter interpreter) throws EvalError {\n  try {\n    NameSpace namespace=callstack.top();\n    BSHType typeNode=getTypeNode();\n    Class type=typeNode.getType(callstack,interpreter);\n    BSHVariableDeclarator[] bvda=getDeclarators();\n    for (int i=0; i < bvda.length; i++) {\n      BSHVariableDeclarator dec=bvda[i];\n      Object value=dec.eval(typeNode,callstack,interpreter);\n      try {\n        namespace.setTypedVariable(dec.name,type,value,modifiers);\n      }\n catch (      UtilEvalError e) {\n        throw e.toEvalError(this,callstack);\n      }\n    }\n  }\n catch (  EvalError e) {\n    e.reThrow(\"Typed variable declaration\");\n  }\n  return Primitive.VOID;\n}\n", "nl": "evaluate the type and one or more variable declarators, e.g.: int a, b=5, c;"}
{"code": "public static boolean isVisible(Class<?> clazz,ClassLoader classLoader){\n  if (classLoader == null) {\n    return true;\n  }\n  try {\n    Class<?> actualClass=classLoader.loadClass(clazz.getName());\n    return (clazz == actualClass);\n  }\n catch (  ClassNotFoundException ex) {\n    return false;\n  }\n}\n", "nl": "Check whether the given class is visible in the given ClassLoader."}
{"code": "public final static HeaderElement parseHeaderElement(final String value,HeaderValueParser parser) throws ParseException {\n  if (value == null) {\n    throw new IllegalArgumentException(\"Value to parse may not be null\");\n  }\n  if (parser == null)   parser=BasicHeaderValueParser.DEFAULT;\n  CharArrayBuffer buffer=new CharArrayBuffer(value.length());\n  buffer.append(value);\n  ParserCursor cursor=new ParserCursor(0,value.length());\n  return parser.parseHeaderElement(buffer,cursor);\n}\n", "nl": "Parses an element with the given parser."}
{"code": "private SnapshotIndexCommit snapshot(SnapshotIndexCommit commit) throws IOException {\n  SnapshotHolder snapshotHolder=snapshots.get(commit.getGeneration());\n  if (snapshotHolder == null) {\n    snapshotHolder=new SnapshotHolder(0);\n    snapshots.put(commit.getGeneration(),snapshotHolder);\n  }\n  snapshotHolder.counter++;\n  return new OneTimeReleaseSnapshotIndexCommit(this,commit);\n}\n", "nl": "Helper method to snapshot a give commit."}
{"code": "public static boolean[] hexDigitMsb0ToBinary(final char hexDigit){\nswitch (hexDigit) {\ncase '0':\n    return FFFF.clone();\ncase '1':\n  return FFFT.clone();\ncase '2':\nreturn FFTF.clone();\ncase '3':\nreturn FFTT.clone();\ncase '4':\nreturn FTFF.clone();\ncase '5':\nreturn FTFT.clone();\ncase '6':\nreturn FTTF.clone();\ncase '7':\nreturn FTTT.clone();\ncase '8':\nreturn TFFF.clone();\ncase '9':\nreturn TFFT.clone();\ncase 'a':\ncase 'A':\nreturn TFTF.clone();\ncase 'b':\ncase 'B':\nreturn TFTT.clone();\ncase 'c':\ncase 'C':\nreturn TTFF.clone();\ncase 'd':\ncase 'D':\nreturn TTFT.clone();\ncase 'e':\ncase 'E':\nreturn TTTF.clone();\ncase 'f':\ncase 'F':\nreturn TTTT.clone();\ndefault :\nthrow new IllegalArgumentException(\"Cannot interpret '\" + hexDigit + \"' as a hexadecimal digit\");\n}\n}\n", "nl": "<p> Converts a hexadecimal digit into binary (represented as boolean array) using the Msb0 bit ordering. </p> <p> '1' is converted as follow: (0, 0, 0, 1) </p>"}
{"code": "public static <E>SortedSet<E> synchronizedSortedSet(SortedSet<E> set){\n  if (set == null) {\n    throw new NullPointerException();\n  }\n  return new SynchronizedSortedSet<E>(set);\n}\n", "nl": "Returns a wrapper on the specified sorted set which synchronizes all access to the sorted set."}
{"code": "private void cleanMapping(){\n  ArrayList<Integer> toRemove=new ArrayList<Integer>();\n  int size=mListMapping.size();\n  for (int i=0; i < size; ++i) {\n    if (mListMapping.keyAt(i) == mListMapping.valueAt(i)) {\n      toRemove.add(mListMapping.keyAt(i));\n    }\n  }\n  size=toRemove.size();\n  for (int i=0; i < size; ++i) {\n    mListMapping.delete(toRemove.get(i));\n  }\n}\n", "nl": "Remove unnecessary mappings from sparse array."}
{"code": "public void onMessage(Message message){\n}\n", "nl": "Empty implementation of MessageListener."}
{"code": "private void add(Geometry geom){\n  if (geom.isEmpty())   return;\n  if (geom instanceof Point) {\n    addPoint(geom.getCoordinate());\n  }\n else   if (geom instanceof LineString) {\n    addLineSegments(geom.getCoordinates());\n  }\n else   if (geom instanceof Polygon) {\n    Polygon poly=(Polygon)geom;\n    add(poly);\n  }\n else   if (geom instanceof GeometryCollection) {\n    GeometryCollection gc=(GeometryCollection)geom;\n    for (int i=0; i < gc.getNumGeometries(); i++) {\n      add(gc.getGeometryN(i));\n    }\n  }\n}\n", "nl": "Adds a Geometry to the centroid total."}
{"code": "@Override public boolean contractorBillNumberChangeRequired(final EgBillregister bill,final WorkOrder workOrder,final CFinancialYear financialYear){\n  return true;\n}\n", "nl": "The method return true if the bill number has to be re-generated"}
{"code": "@Override public void eUnset(int featureID){\nswitch (featureID) {\ncase N4JSPackage.EXPORTED_VARIABLE_STATEMENT__ANNOTATION_LIST:\n    setAnnotationList((AnnotationList)null);\n  return;\ncase N4JSPackage.EXPORTED_VARIABLE_STATEMENT__DECLARED_MODIFIERS:\ngetDeclaredModifiers().clear();\nreturn;\n}\nsuper.eUnset(featureID);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public int alloc(final RWStore store,final int size,final IAllocationContext context){\n  try {\n    if (size <= 0)     throw new IllegalArgumentException(\"Allocate requires positive size, got: \" + size);\n    if (size > m_size)     throw new IllegalArgumentException(\"FixedAllocator with slots of \" + m_size + \" bytes requested allocation for \"+ size+ \" bytes\");\n    if (m_freeBits == 0) {\n      throw new IllegalStateException(\"Request to allocate from \" + m_size + \"byte slot FixedAllocator with zero bits free - should not be on the Free List\");\n    }\n    int addr=-1;\n    if (m_size <= m_store.cSmallSlot) {\n      return allocFromIndex(size);\n    }\n    final Iterator<AllocBlock> iter=m_allocBlocks.iterator();\n    int count=-1;\n    while (addr == -1 && iter.hasNext()) {\n      count++;\n      final AllocBlock block=iter.next();\n      checkBlock(block);\n      addr=block.alloc(m_size);\n    }\n    if (addr != -1) {\n      addr+=3;\n      if (--m_freeBits == 0) {\n        if (s_islogTrace)         log.trace(\"Remove from free list\");\n        removeFromFreeList();\n        if (m_freeList.size() > 0) {\n          if (s_islogDebug) {\n            final FixedAllocator nxt=(FixedAllocator)m_freeList.get(0);\n            log.debug(\"Freelist head: \" + nxt.getSummaryStats());\n          }\n        }\n      }\n      addr+=(count * 32 * m_bitSize);\n      final int value=-((m_index << RWStore.OFFSET_BITS) + addr);\n      if (m_statsBucket != null) {\n        m_statsBucket.allocate(size);\n      }\n      return value;\n    }\n else {\n      StringBuilder sb=new StringBuilder();\n      sb.append(\"FixedAllocator returning null address, with freeBits: \" + m_freeBits + \"\\n\");\n      for (      AllocBlock ab : m_allocBlocks) {\n        sb.append(ab.show() + \"\\n\");\n      }\n      log.error(sb);\n      return 0;\n    }\n  }\n  finally {\n    if (s_islogDebug)     checkBits();\n  }\n}\n", "nl": "The introduction of IAllocationContexts has added some complexity to the older concept of a free list.  With AllocationContexts it is possibly for allocator to have free space available but this being restricted to a specific AllocationContext. <p> In addition to the standard free allocation search we want to add a \"density\" restriction for small slots to encourage the aggregation of writes (by increasing the likelihood of sibling slot allocation). <p> There is some \"Do What I mean\" complexity here, with difficulty in  determining a good rule to identify an initial allocation point.  There is a danger of significantly reducing the allocation efficiency of short transactions if we too naively check committed bit density.  We should only do this when identifying the initial allocation, and when the allocIndex is incremented."}
{"code": "private static String generateIB(final long offset,final ITranslationEnvironment environment,final List<ReilInstruction> instructions,final String registerNodeValue,final String wBit,final IOperandTreeNode rootNodeOfRegisterList){\n  final String startAddress=environment.getNextVariableString();\n  final String endAddress=environment.getNextVariableString();\n  final Integer numberOfSetBits=rootNodeOfRegisterList.getChildren().size();\n  long baseOffset=offset;\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue,dw,String.valueOf(4),dw,startAddress));\n  instructions.add(ReilHelpers.createAdd(baseOffset++,dw,registerNodeValue,dw,String.valueOf(numberOfSetBits * 4),dw,endAddress));\n  if (wBit.equals(\"2\")) {\n    instructions.add(ReilHelpers.createStr(baseOffset++,dw,endAddress,dw,registerNodeValue));\n  }\n  return startAddress;\n}\n", "nl": "Increment before IB ( LDMIB || LDMED ) || ( STMIB || STMFA ) start_address = Rn + 4 end_address = Rn + (Number_Of_Set_Bits_In(register_list) * 4) if ConditionPassed(cond) and W == 1 then Rn = Rn + (Number_Of_Set_Bits_In(register_list) * 4)"}
{"code": "@DSComment(\"From safe class list\") @DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:34:20.267 -0500\",hash_original_method=\"41C1A121517CD12760C521BBD9AF1967\",hash_generated_method=\"AF18146D80DB438DD0A2F77C34F0CB67\") public void drawRoundRect(RectF rect,float rx,float ry,Paint paint){\n  if (rect == null) {\n    throw new NullPointerException();\n  }\n  native_drawRoundRect(mNativeCanvas,rect,rx,ry,paint.mNativePaint);\n}\n", "nl": "Draw the specified round-rect using the specified paint. The roundrect will be filled or framed based on the Style in the paint."}
{"code": "private static String prettyPrintObject(LzPersistentBaseImpl<? extends GenericPK> object,PrettyPrintOptions options){\n  if (options != null && options.getStyle() == ReferenceStyle.NAME) {\n    if (options.isExplicitType()) {\n      return PrettyPrintConstant.IDENTIFIER_TAG + AnalysisScope.AXIS + \":\"+ PrettyPrintConstant.OPEN_IDENT+ object.getName()+ PrettyPrintConstant.CLOSE_IDENT;\n    }\n else {\n      return PrettyPrintConstant.OPEN_IDENT + object.getName() + PrettyPrintConstant.CLOSE_IDENT;\n    }\n  }\n else {\n    return PrettyPrintConstant.IDENTIFIER_TAG + PrettyPrintConstant.OPEN_IDENT + object.getOid()+ PrettyPrintConstant.CLOSE_IDENT;\n  }\n}\n", "nl": "utility method to pretty-print a object id"}
{"code": "public AbstractPreferencePagePresenter(String title,String category,ImageResource icon){\n  this.title=title;\n  this.category=category;\n  this.icon=icon;\n}\n", "nl": "Create preference page."}
{"code": "public static void inexistentField(String targetFieldName,String targetClassName){\n  throw new MappingErrorException(MSG.INSTANCE.message(mappingErrorException5,targetFieldName,targetClassName));\n}\n", "nl": "Thrown when the target field doesn't exist."}
{"code": "public static String displaySymbolTable(LocalVariableMap symbolTable){\n  StringBuilder sb=new StringBuilder();\n  Set<String> keys=symbolTable.keySet();\n  if (keys.isEmpty()) {\n    sb.append(\"None\\n\");\n  }\n else {\n    int count=0;\n    for (    String key : keys) {\n      sb.append(\"  [\");\n      sb.append(++count);\n      sb.append(\"]\");\n      sb.append(\" (\");\n      sb.append(determineOutputTypeAsString(symbolTable,key));\n      sb.append(\") \");\n      sb.append(key);\n      sb.append(\": \");\n      sb.append(symbolTable.get(key));\n      sb.append(\"\\n\");\n    }\n  }\n  return sb.toString();\n}\n", "nl": "Display the keys and values in the symbol table"}
{"code": "public ReilBlock(final List<ReilInstruction> instructions){\n  Preconditions.checkNotNull(instructions,\"Error: Instructions argument can not be null\");\n  for (  final ReilInstruction instruction : instructions) {\n    Preconditions.checkNotNull(instruction,\"Error: Instructions list contains a null-element\");\n  }\n  m_instructions=new ArrayList<ReilInstruction>(instructions);\n}\n", "nl": "Creates a new REIL block."}
{"code": "public void assertValidRange(int range[],String sname) throws SettingsError {\n  if (range.length != 2) {\n    throw new SettingsError(\"Range setting \" + getFullPropertyName(sname) + \" should contain only two comma separated integer values\");\n  }\n  if (range[0] > range[1]) {\n    throw new SettingsError(\"Range setting's \" + getFullPropertyName(sname) + \" first value should be smaller or equal to second value\");\n  }\n}\n", "nl": "Checks that the given integer array contains a valid range. I.e., the length of the array must be two and <code>first_value <= second_value</code>."}
{"code": "public GenericValue findByPrimaryKey(GenericPK primaryKey) throws GenericEntityException {\n  if (primaryKey == null) {\n    return null;\n  }\n  GenericValue genericValue=GenericValue.create(primaryKey);\n  genericDAO.select(genericValue);\n  return genericValue;\n}\n", "nl": "Find a Generic Entity by its Primary Key"}
{"code": "public static boolean hideSoftInput(Activity activity){\n  if (activity.getCurrentFocus() != null) {\n    InputMethodManager imm=(InputMethodManager)activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n    return imm.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(),0);\n  }\n  return false;\n}\n", "nl": "Hide Soft Input"}
{"code": "public TeamCommand(Server server){\n  super(server,\"t\",\"Allows players on the same team to chat with each other in the game.\");\n}\n", "nl": "Creates new WhoCommand"}
{"code": "public T caseNamespace_(Namespace_ object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>Namespace </em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "public Portfolio findById(Integer id){\n  try {\n    EntityManager entityManager=EntityManagerHelper.getEntityManager();\n    entityManager.getTransaction().begin();\n    Portfolio instance=entityManager.find(Portfolio.class,id);\n    instance.getPortfolioAccounts().size();\n    entityManager.getTransaction().commit();\n    return instance;\n  }\n catch (  Exception re) {\n    EntityManagerHelper.rollback();\n    throw re;\n  }\n finally {\n    EntityManagerHelper.close();\n  }\n}\n", "nl": "Method findById."}
{"code": "public void unlock(long stamp){\n  long a=stamp & ABITS, m, s;\n  WNode h;\n  while (((s=state) & SBITS) == (stamp & SBITS)) {\n    if ((m=s & ABITS) == 0L)     break;\n else     if (m == WBIT) {\n      if (a != m)       break;\n      U.putLongVolatile(this,STATE,(s+=WBIT) == 0L ? ORIGIN : s);\n      if ((h=whead) != null && h.status != 0)       release(h);\n      return;\n    }\n else     if (a == 0L || a >= WBIT)     break;\n else     if (m < RFULL) {\n      if (U.compareAndSwapLong(this,STATE,s,s - RUNIT)) {\n        if (m == RUNIT && (h=whead) != null && h.status != 0)         release(h);\n        return;\n      }\n    }\n else     if (tryDecReaderOverflow(s) != 0L)     return;\n  }\n  throw new IllegalMonitorStateException();\n}\n", "nl": "If the lock state matches the given stamp, releases the corresponding mode of the lock."}
{"code": "public void remove(int start,int end){\n  checkWidget();\n  this.table.remove(start,end);\n}\n", "nl": "Removes the items from the receiver's list which are between the given zero-relative start and end indices (inclusive)."}
{"code": "private void defineInternalFrameMenuButtons(UIDefaults d){\n  String p=\"InternalFrame:InternalFrameTitlePane:\\\"InternalFrameTitlePane.menuButton\\\"\";\n  String c=PAINTER_PREFIX + \"TitlePaneMenuButtonPainter\";\n  d.put(p + \".WindowNotFocused\",new TitlePaneMenuButtonWindowNotFocusedState());\n  d.put(p + \".contentMargins\",new InsetsUIResource(0,0,0,0));\n  d.put(p + \"[Enabled].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_ENABLED));\n  d.put(p + \"[Disabled].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_DISABLED));\n  d.put(p + \"[MouseOver].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_MOUSEOVER));\n  d.put(p + \"[Pressed].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_PRESSED));\n  d.put(p + \"[Enabled+WindowNotFocused].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_ENABLED_WINDOWNOTFOCUSED));\n  d.put(p + \"[MouseOver+WindowNotFocused].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_MOUSEOVER_WINDOWNOTFOCUSED));\n  d.put(p + \"[Pressed+WindowNotFocused].iconPainter\",new LazyPainter(c,TitlePaneMenuButtonPainter.Which.ICON_PRESSED_WINDOWNOTFOCUSED));\n  d.put(p + \".icon\",new SeaGlassIcon(p,\"iconPainter\",19,18));\n}\n", "nl": "Initialize the internal frame menu button settings."}
{"code": "public void sourcesAreProperForm(final SteadyStateEvolutionState state,final BreedingPipeline[] breedingPipelines){\n  for (int x=0; x < breedingPipelines.length; x++) {\n    ((SteadyStateBSourceForm)(breedingPipelines[x])).sourcesAreProperForm(state);\n  }\n}\n", "nl": "Called to check to see if the breeding sources are correct -- if you use this method, you must call state.output.exitIfErrors() immediately  afterwards."}
{"code": "@SuppressFBWarnings(\"DM_EXIT\") @VisibleForTesting void prepareNativeLibraries(){\n  try {\n    BrowserStartupController.get(getApplicationContext(),LibraryProcessType.PROCESS_BROWSER).startBrowserProcessesSync(false);\n  }\n catch (  ProcessInitException e) {\n    Log.e(TAG,\"ProcessInitException while starting the browser process\");\n    System.exit(-1);\n  }\n}\n", "nl": "Attempt to start up the browser processes and load the native libraries."}
{"code": "public int numKeys(){\n  int result=basic.numKeys();\n  for (  DeterministicKeyChain chain : chains)   result+=chain.numKeys();\n  return result;\n}\n", "nl": "Returns the number of keys managed by this group, including the lookahead buffers."}
{"code": "private void requestExpressionFocus(){\n  currentExpression.requestFocusInWindow();\n}\n", "nl": "Requests focus on the expression text"}
{"code": "public boolean isSignedSet(){\n  if (signed == null)   return false;\n else   return true;\n}\n", "nl": "Returns true only if the signed flag has been set explicitly and is not in the default state."}
{"code": "private static int decode4to3(byte[] source,int srcOffset,byte[] destination,int destOffset,int options){\n  if (source == null) {\n    throw new NullPointerException(\"Source array was null.\");\n  }\n  if (destination == null) {\n    throw new NullPointerException(\"Destination array was null.\");\n  }\n  if (srcOffset < 0 || srcOffset + 3 >= source.length) {\n    throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and still process four bytes.\",source.length,srcOffset));\n  }\n  if (destOffset < 0 || destOffset + 2 >= destination.length) {\n    throw new IllegalArgumentException(String.format(\"Destination array with length %d cannot have offset of %d and still store three bytes.\",destination.length,destOffset));\n  }\n  byte[] DECODABET=getDecodabet(options);\n  if (source[srcOffset + 2] == EQUALS_SIGN) {\n    int outBuff=((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);\n    destination[destOffset]=(byte)(outBuff >>> 16);\n    return 1;\n  }\n else   if (source[srcOffset + 3] == EQUALS_SIGN) {\n    int outBuff=((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);\n    destination[destOffset]=(byte)(outBuff >>> 16);\n    destination[destOffset + 1]=(byte)(outBuff >>> 8);\n    return 2;\n  }\n else {\n    int outBuff=((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6)| ((DECODABET[source[srcOffset + 3]] & 0xFF));\n    destination[destOffset]=(byte)(outBuff >> 16);\n    destination[destOffset + 1]=(byte)(outBuff >> 8);\n    destination[destOffset + 2]=(byte)(outBuff);\n    return 3;\n  }\n}\n", "nl": "Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying  <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to accomodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var> + 3 for the <var>destination</var> array. This method returns the actual number of bytes that  were converted from the Base64 encoding. <p>This is the lowest level of the decoding methods with all possible parameters.</p>"}
{"code": "public String addAndStartProcess(ClusterProcess clusterProcess){\n  return addAndStartProcess(clusterProcess,clusterConfig.getTimeout());\n}\n", "nl": "Starts a container. This container will be removed when the Mesos cluster is shut down. The method is used by frameworks"}
{"code": "SAXParserMMImpl(SAXParserFactoryMMImpl spf,Hashtable features) throws SAXException {\n  this(spf,features,false);\n}\n", "nl": "Create a SAX parser with the associated features"}
{"code": "public ComponentPrinter(PrintableComponent... components){\n  this.components=components;\n}\n", "nl": "The given components that should be printed."}
{"code": "@Override public boolean containsValue(Object val){\n  return _map.containsValue(unwrapValue((V)val));\n}\n", "nl": "Checks for the presence of <tt>val</tt> in the values of the map."}
{"code": "public final boolean sendMessageAtFrontOfQueue(Message msg){\n  return mExec.sendMessageAtFrontOfQueue(msg);\n}\n", "nl": "Enqueue a message at the front of the message queue, to be processed on the next iteration of the message loop.  You will receive it in callback, in the thread attached to this handler. <b>This method is only for use in very special circumstances -- it can easily starve the message queue, cause ordering problems, or have other unexpected side-effects.</b>"}
{"code": "public NotificationData clone(){\n  NotificationData result=new NotificationData();\n  return result;\n}\n", "nl": "Deep clone"}
{"code": "private static void initTestFile(File blah,long size) throws Exception {\n  if (blah.exists())   blah.delete();\n  FileOutputStream fos=new FileOutputStream(blah);\n  BufferedWriter awriter=new BufferedWriter(new OutputStreamWriter(fos,\"8859_1\"));\n  for (int i=0; i < size; i++) {\n    awriter.write(\"e\");\n  }\n  awriter.flush();\n  awriter.close();\n}\n", "nl": "Creates file blah of specified size in bytes."}
{"code": "protected boolean useFastVectorHighlighter(SolrParams params,SchemaField schemaField){\n  boolean useFvhParam=params.getFieldBool(schemaField.getName(),HighlightParams.USE_FVH,false);\n  if (!useFvhParam)   return false;\n  boolean termPosOff=schemaField.storeTermPositions() && schemaField.storeTermOffsets();\n  if (!termPosOff) {\n    log.warn(\"Solr will use the standard Highlighter instead of FastVectorHighlighter because the {} field \" + \"does not store TermVectors with TermPositions and TermOffsets.\",schemaField.getName());\n  }\n  return termPosOff;\n}\n", "nl": "Determines if we should use the FastVectorHighlighter for this field."}
{"code": "public void write(char cbuf[],int off,int len){\n  if ((off < 0) || (off > cbuf.length) || (len < 0)|| ((off + len) > cbuf.length)|| ((off + len) < 0)) {\n    throw new IndexOutOfBoundsException();\n  }\n else   if (len == 0) {\n    return;\n  }\n  buf.append(cbuf,off,len);\n}\n", "nl": "Write a portion of an array of characters."}
{"code": "@Override final public Constant<E> clone(){\n  return this;\n}\n", "nl": "Clone is overridden to reduce heap churn."}
{"code": "private void updateContact(int index){\n  Contact contact=contacts.get(index);\n  Intent intent=new Intent(this,ViewActivity.class);\n  intent.putExtra(\"CONTACT\",contact);\n  startActivity(intent);\n}\n", "nl": "Start ViewActivity to update a Contact."}
{"code": "private List<IsilonNetworkPool> discoverNetworkPools(StorageSystem storageSystem) throws IsilonCollectionException {\n  List<IsilonNetworkPool> isilonNetworkPoolList=new ArrayList<IsilonNetworkPool>();\n  URI storageSystemId=storageSystem.getId();\n  _log.info(\"discoverNetworkPools for storage system {} - start\",storageSystemId);\n  List<IsilonNetworkPool> isilonNetworkPoolsTemp=null;\n  try {\n    if (VersionChecker.verifyVersionDetails(ONEFS_V8,storageSystem.getFirmwareVersion()) >= 0) {\n      _log.info(\"Isilon release version {} and storagesystem label {}\",storageSystem.getFirmwareVersion(),storageSystem.getLabel());\n      IsilonApi isilonApi=getIsilonDevice(storageSystem);\n      isilonNetworkPoolsTemp=isilonApi.getNetworkPools(null);\n      if (isilonNetworkPoolsTemp != null) {\n        isilonNetworkPoolList.addAll(isilonNetworkPoolsTemp);\n      }\n    }\n else {\n      IsilonSshApi sshDmApi=new IsilonSshApi();\n      sshDmApi.setConnParams(storageSystem.getIpAddress(),storageSystem.getUsername(),storageSystem.getPassword());\n      Map<String,List<String>> networkPools=sshDmApi.getNetworkPools();\n      List<String> smartconnects=null;\n      IsilonNetworkPool isiNetworkPool=null;\n      for (      Map.Entry<String,List<String>> networkpool : networkPools.entrySet()) {\n        smartconnects=networkpool.getValue();\n        if (smartconnects != null) {\n          for (          String smartconnect : smartconnects) {\n            isiNetworkPool=new IsilonNetworkPool();\n            isiNetworkPool.setAccess_zone(networkpool.getKey());\n            isiNetworkPool.setSc_dns_zone(smartconnect);\n            isilonNetworkPoolList.add(isiNetworkPool);\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    _log.error(\"discover of NetworkPools is failed. %s\",e.getMessage());\n  }\n  return isilonNetworkPoolList;\n}\n", "nl": "discover the network interface of given Isilon storage cluster"}
{"code": "void callbackJavascript(final String instanceId,final String callback,final Object data,boolean keepAlive){\n  if (TextUtils.isEmpty(instanceId) || TextUtils.isEmpty(callback) || mJSHandler == null) {\n    return;\n  }\n  addJSTask(METHOD_CALLBACK,instanceId,callback,data,keepAlive);\n  sendMessage(instanceId,WXJSBridgeMsgType.CALL_JS_BATCH);\n}\n", "nl": "Callback to Javascript function."}
{"code": "public Aspects findAspectsByClassName(String aspectClassName) throws PersistentModelException {\n  try {\n    if (\"org.trade.persistent.dao.Strategy\".equals(aspectClassName)) {\n      List<Strategy> items=m_strategyHome.findAll();\n      Aspects aspects=new Aspects();\n      for (      Object item : items) {\n        aspects.add((Aspect)item);\n      }\n      aspects.setDirty(false);\n      return aspects;\n    }\n else     if (\"org.trade.persistent.dao.Portfolio\".equals(aspectClassName)) {\n      List<Portfolio> items=m_portfolioHome.findAll();\n      Aspects aspects=new Aspects();\n      for (      Object item : items) {\n        aspects.add((Aspect)item);\n      }\n      aspects.setDirty(false);\n      return aspects;\n    }\n else {\n      return m_aspectHome.findByClassName(aspectClassName);\n    }\n  }\n catch (  Exception ex) {\n    throw new PersistentModelException(\"Error finding Aspects: \" + ex.getMessage());\n  }\n}\n", "nl": "Method findAspectsByClassName."}
{"code": "public Builder collapseKey(String value){\n  collapseKey=value;\n  return this;\n}\n", "nl": "Sets the collapseKey property."}
{"code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return HEADER;\ncase 2:\n  return NODE_ID;\ncase 3:\nreturn AUTH_SCHEME;\ncase 4:\nreturn AUTH_CHALLENGE_RESPONSE;\ndefault :\nreturn null;\n}\n}\n", "nl": "Find the _Fields constant that matches fieldId, or null if its not found."}
{"code": "public long optLong(int index){\n  return optLong(index,0);\n}\n", "nl": "Get the optional long value associated with an index. Zero is returned if there is no value for the index, or if the value is not a number and cannot be converted to a number."}
{"code": "public Set<Map.Entry<String,JsonElement>> entrySet(){\n  return Collections.unmodifiableSet(members.entrySet());\n}\n", "nl": "Returns a set of members of this object. The set is ordered alphabetically."}
{"code": "public JSONObject put(String key,Collection<?> value) throws JSONException {\n  this.put(key,new JSONArray(value));\n  return this;\n}\n", "nl": "Put a key/value pair in the JSONObject, where the value will be a JSONArray which is produced from a Collection."}
{"code": "public static IgniteState state(){\n  return state(null);\n}\n", "nl": "Gets state of grid default grid."}
{"code": "public static void deleteDirectory(final File directory) throws IOException {\n  if (!directory.exists()) {\n    return;\n  }\n  if (!isSymlink(directory)) {\n    cleanDirectory(directory);\n  }\n  if (!directory.delete()) {\n    final String message=\"Unable to delete directory \" + directory + \".\";\n    throw new IOException(message);\n  }\n}\n", "nl": "Deletes a directory recursively."}
{"code": "public Writer write(Writer writer) throws JSONException {\n  return this.write(writer,0,0);\n}\n", "nl": "Write the contents of the JSONArray as JSON text to a writer. For compactness, no whitespace is added. <p> Warning: This method assumes that the data structure is acyclical."}
{"code": "public GeneralRuntimeException(){\n  super();\n}\n", "nl": "Creates new <code>GeneralException</code> without detail message."}
{"code": "private ClassControlFlowGraph computeCCFG(String className){\n  if (rawCFGs.get(className) == null)   throw new IllegalArgumentException(\"can't compute CCFG, don't know CFGs for class \" + className);\n  ClassCallGraph ccg=new ClassCallGraph(classLoader,className);\n  if (Properties.WRITE_CFG)   ccg.toDot();\n  ClassControlFlowGraph ccfg=new ClassControlFlowGraph(ccg);\n  if (Properties.WRITE_CFG)   ccfg.toDot();\n  return ccfg;\n}\n", "nl": "Computes the CCFG for the given class If no CFG is known for the given class, an IllegalArgumentException is thrown"}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public boolean isPingPongSupported(){\n  return clientVersion >= Pong.MIN_PROTOCOL_VERSION;\n}\n", "nl": "Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION. If it is then ping() is usable."}
{"code": "public boolean isCompleted(){\n  return isCompleted;\n}\n", "nl": "Returns true if the dispatch completed for this future."}
{"code": "@Override public NotificationChain eInverseRemove(InternalEObject otherEnd,int featureID,NotificationChain msgs){\nswitch (featureID) {\ncase DatatypePackage.ENTITY__PROPERTIES:\n    return ((InternalEList<?>)getProperties()).basicRemove(otherEnd,msgs);\n}\nreturn super.eInverseRemove(otherEnd,featureID,msgs);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "SelectableLabel(String text){\n  super(text);\n  setEditable(false);\n  setBorder(null);\n  setOpaque(false);\n  JLabel tmp=new JLabel();\n  setFont(tmp.getFont());\n}\n", "nl": "creates a new SelectableLabel"}
{"code": "protected void sequence_PatternCharacter_Term(ISerializationContext context,PatternCharacter semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: Disjunction returns PatternCharacter Disjunction.Disjunction_0_1_0 returns PatternCharacter Alternative returns PatternCharacter Alternative.Sequence_1_0 returns PatternCharacter Term returns PatternCharacter Constraint: ( ( value=PATTERN_CHARACTER_NO_DASH |  value=UNICODE_LETTER |  value=UNICODE_DIGIT |  value='-' |  value=',' |  value='=' |  value=':' |  value='!' |  value='{' |  value='}' |  value=']' )  quantifier=Quantifier? )"}
{"code": "private static int gallopRight(Comparable<Object> key,Object[] a,int base,int len,int hint){\n  if (DEBUG)   assert len > 0 && hint >= 0 && hint < len;\n  int ofs=1;\n  int lastOfs=0;\n  if (key.compareTo(a[base + hint]) < 0) {\n    int maxOfs=hint + 1;\n    while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {\n      lastOfs=ofs;\n      ofs=(ofs << 1) + 1;\n      if (ofs <= 0)       ofs=maxOfs;\n    }\n    if (ofs > maxOfs)     ofs=maxOfs;\n    int tmp=lastOfs;\n    lastOfs=hint - ofs;\n    ofs=hint - tmp;\n  }\n else {\n    int maxOfs=len - hint;\n    while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {\n      lastOfs=ofs;\n      ofs=(ofs << 1) + 1;\n      if (ofs <= 0)       ofs=maxOfs;\n    }\n    if (ofs > maxOfs)     ofs=maxOfs;\n    lastOfs+=hint;\n    ofs+=hint;\n  }\n  if (DEBUG)   assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\n  lastOfs++;\n  while (lastOfs < ofs) {\n    int m=lastOfs + ((ofs - lastOfs) >>> 1);\n    if (key.compareTo(a[base + m]) < 0)     ofs=m;\n else     lastOfs=m + 1;\n  }\n  if (DEBUG)   assert lastOfs == ofs;\n  return ofs;\n}\n", "nl": "Like gallopLeft, except that if the range contains an element equal to key, gallopRight returns the index after the rightmost equal element."}
{"code": "public PerfDataBuffer(VmIdentifier vmid) throws MonitorException {\n  try {\n    ByteBuffer bb=perf.attach(vmid.getLocalVmId(),vmid.getMode());\n    createPerfDataBuffer(bb,vmid.getLocalVmId());\n  }\n catch (  IllegalArgumentException e) {\n    try {\n      String filename=PerfDataFile.getTempDirectory() + PerfDataFile.dirNamePrefix + Integer.toString(vmid.getLocalVmId());\n      File f=new File(filename);\n      FileChannel fc=new RandomAccessFile(f,\"r\").getChannel();\n      ByteBuffer bb=fc.map(FileChannel.MapMode.READ_ONLY,0L,(int)fc.size());\n      fc.close();\n      createPerfDataBuffer(bb,vmid.getLocalVmId());\n    }\n catch (    FileNotFoundException e2) {\n      throw new MonitorException(vmid.getLocalVmId() + \" not found\",e);\n    }\ncatch (    IOException e2) {\n      throw new MonitorException(\"Could not map 1.4.1 file for \" + vmid.getLocalVmId(),e2);\n    }\n  }\ncatch (  IOException e) {\n    throw new MonitorException(\"Could not attach to \" + vmid.getLocalVmId(),e);\n  }\n}\n", "nl": "Create a PerfDataBuffer instance for accessing the specified instrumentation buffer."}
{"code": "public void print(CharSequence text) throws IOException {\n  int size=text.length();\n  int pos=0;\n  for (int i=0; i < size; i++) {\n    if (text.charAt(i) == '\\n') {\n      write(text.subSequence(pos,size),i - pos + 1);\n      pos=i + 1;\n      atStartOfLine=true;\n    }\n  }\n  write(text.subSequence(pos,size),size - pos);\n}\n", "nl": "Print text to the output stream."}
{"code": "@DSSpec(DSCat.IO) @DSSource({DSSourceKind.IO}) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:56:45.235 -0500\",hash_original_method=\"469514DB0DA90571D02A531A0FA63D6F\",hash_generated_method=\"A9605FE51958909BD225DA582AF5352D\") public final long readLong() throws IOException {\n  readFully(scratch,0,SizeOf.LONG);\n  return Memory.peekLong(scratch,0,ByteOrder.BIG_ENDIAN);\n}\n", "nl": "Reads a big-endian 64-bit long from the current position in this file. Blocks until eight bytes have been read, the end of the file is reached or an exception is thrown."}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "public boolean isTimeout(){\n  return m_timeout;\n}\n", "nl": "Timeout - i.e process did not complete"}
{"code": "public boolean isWorking(){\n  return working;\n}\n", "nl": "Determine if a ring is working."}
{"code": "public static Map<String,List<User>> createRoleMap(List<User> users){\n  Map<String,List<User>> roles=new HashMap<String,List<User>>();\n  for (  User user : users) {\n    for (    String role : user.getRoles()) {\n      List<User> usersForRole;\n      if (roles.containsKey(role)) {\n        usersForRole=roles.get(role);\n      }\n else {\n        usersForRole=new ArrayList<User>();\n      }\n      if (!usersForRole.contains(user)) {\n        usersForRole.add(user);\n      }\n      roles.put(role,usersForRole);\n    }\n  }\n  return roles;\n}\n", "nl": "Create a user map indexed on the roles."}
{"code": "void invalidate(){\n  m_row=-1;\n}\n", "nl": "Invalidates this tuple. Called by an enclosing table when a row  is deleted."}
{"code": "public void uninstallUI(JComponent a){\n  for (int i=0; i < uis.size(); i++) {\n    ((ComponentUI)(uis.elementAt(i))).uninstallUI(a);\n  }\n}\n", "nl": "Invokes the <code>uninstallUI</code> method on each UI handled by this object."}
{"code": "public double toDouble(){\n  if (m_length == 0)   return Double.NaN;\n  int i;\n  char c;\n  String valueString=fsb().getString(m_start,m_length);\n  for (i=0; i < m_length; i++)   if (!XMLCharacterRecognizer.isWhiteSpace(valueString.charAt(i)))   break;\n  if (i == m_length)   return Double.NaN;\n  if (valueString.charAt(i) == '-')   i++;\n  for (; i < m_length; i++) {\n    c=valueString.charAt(i);\n    if (c != '.' && (c < '0' || c > '9'))     break;\n  }\n  for (; i < m_length; i++)   if (!XMLCharacterRecognizer.isWhiteSpace(valueString.charAt(i)))   break;\n  if (i != m_length)   return Double.NaN;\n  try {\n    return new Double(valueString).doubleValue();\n  }\n catch (  NumberFormatException nfe) {\n    return Double.NaN;\n  }\n}\n", "nl": "Convert a string to a double -- Allowed input is in fixed notation ddd.fff. %OPT% CHECK PERFORMANCE against generating a Java String and converting it to double. The advantage of running in native machine code -- perhaps even microcode, on some systems -- may more than make up for the cost of allocating and discarding the additional object. We need to benchmark this.  %OPT% More importantly, we need to decide whether we _care_ about the performance of this operation. Does XString.toDouble constitute any measurable percentage of our typical runtime? I suspect not!"}
{"code": "@NonNull public List<TrayItem> queryProviderSafe(@NonNull final Uri uri){\n  try {\n    return queryProvider(uri);\n  }\n catch (  TrayException e) {\n    return new ArrayList<>();\n  }\n}\n", "nl": "sends a query for TrayItems to the provider, doesn't throw when the database access couldn't be established"}
{"code": "public static void dropTable(SQLiteDatabase db,boolean ifExists){\n  String sql=\"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"'PICTURE_CACHE'\";\n  db.execSQL(sql);\n}\n", "nl": "Drops the underlying database table."}
{"code": "@DSSafe(DSCat.SAFE_LIST) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 14:59:57.174 -0400\",hash_original_method=\"5A37259F0EF0B23F2917794B45619826\",hash_generated_method=\"75DEA827C7EB00AC33348C52A8F99A33\") protected File[] filterDirectoryContents(File directory,int depth,File[] files) throws IOException {\n  return files;\n}\n", "nl": "Overridable callback method invoked with the contents of each directory. <p> This implementation returns the files unchanged"}
{"code": "static boolean isInstanceOfNotEqualConditionEvaluator(Object o){\n  return o instanceof RangeJunction.NotEqualConditionEvaluator;\n}\n", "nl": "Test method which checks if the Filter operand is of type NotEqualConditionEvaluator"}
{"code": "protected float floatSpeed(int lSpeed){\n  if (lSpeed == 0) {\n    return 0.f;\n  }\n else   if (lSpeed == 1) {\n    return -1.f;\n  }\n else {\n    return ((lSpeed - 1) / 126.f);\n  }\n}\n", "nl": "Convert a CBUS speed integer to a float speed value"}
{"code": "public Geo cross(Geo b){\n  return cross(b,new Geo());\n}\n", "nl": "Vector cross product."}
{"code": "public String globalInfo(){\n  return \"Class for running an arbitrary clusterer on data that has been passed \" + \"through an arbitrary filter. Like the clusterer, the structure of the filter \" + \"is based exclusively on the training data and test instances will be processed \"+ \"by the filter without changing their structure.\";\n}\n", "nl": "Returns a string describing this clusterer."}
{"code": "public NearestNeighbour(int k,boolean weighted,DistanceMetric distanceMetric,VectorCollectionFactory<VecPaired<Vec,Double>> vcf){\n  this.mode=null;\n  this.vcf=vcf;\n  this.k=k;\n  this.weighted=weighted;\n  this.distanceMetric=distanceMetric;\n}\n", "nl": "Constructs a new Nearest Neighbor Classifier"}
{"code": "public StatusDetail withDetail(final String key,final String value){\n  final LinkedHashMap<String,String> newDetails=new LinkedHashMap<>(details);\n  newDetails.put(key,value);\n  return statusDetail(name,status,message,newDetails);\n}\n", "nl": "Create a copy of this StatusDetail, add a detail and return the new StatusDetail."}
{"code": "public IntIteratorSpliterator(PrimitiveIterator.OfInt iterator,long size,int characteristics){\n  this.it=iterator;\n  this.est=size;\n  this.characteristics=(characteristics & Spliterator.CONCURRENT) == 0 ? characteristics | Spliterator.SIZED | Spliterator.SUBSIZED : characteristics;\n}\n", "nl": "Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics."}
{"code": "public static DetailPostWebFragment newInstance(String param1,String param2){\n  DetailPostWebFragment fragment=new DetailPostWebFragment();\n  Bundle args=new Bundle();\n  args.putString(ARG_PARAM1,param1);\n  args.putString(ARG_PARAM2,param2);\n  fragment.setArguments(args);\n  return fragment;\n}\n", "nl": "Use this factory method to create a new instance of this fragment using the provided parameters."}
{"code": "@Override public boolean hasActiveShield(int location){\n  if ((location != Mech.LOC_RARM) && (location != Mech.LOC_LARM)) {\n    return false;\n  }\n  if (isShutDown() || (getCrew().isKoThisRound() || getCrew().isUnconscious())) {\n    return false;\n  }\n  for (int slot=0; slot < this.getNumberOfCriticals(location); slot++) {\n    CriticalSlot cs=getCritical(location,slot);\n    if (cs == null) {\n      continue;\n    }\n    if (cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {\n      continue;\n    }\n    if (cs.isDamaged()) {\n      continue;\n    }\n    Mounted m=cs.getMount();\n    EquipmentType type=m.getType();\n    if ((type instanceof MiscType) && ((MiscType)type).isShield() && m.curMode().equals(MiscType.S_ACTIVE_SHIELD)) {\n      return m.getCurrentDamageCapacity(this,m.getLocation()) > 0;\n    }\n  }\n  return false;\n}\n", "nl": "Does the mech have an active shield This should only be called by hasActiveShield(location,rear)"}
{"code": "public static void notifyNativeGestureStarted(View view,MotionEvent event){\n  RootViewUtil.getRootView(view).onChildStartedNativeGesture(event);\n}\n", "nl": "Helper method that should be called when a native view starts a native gesture (e.g. a native ScrollView takes control of a gesture stream and starts scrolling). This will handle dispatching the appropriate events to JS to make sure the gesture in JS is canceled."}
{"code": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, java.io.NotActiveException, ClassNotFoundException {\n  s.defaultReadObject();\n  thisX500Name=new X500Name(name);\n}\n", "nl": "Reads this object from a stream (i.e., deserializes it)"}
{"code": "public static boolean gitLocalConfig(final AtomicReference<String> path) throws IOException {\n  return gitLocalConfig(Environment.getCurrentDirectory(),path);\n}\n", "nl": "Gets the path to the Git local configuration file based on the current working directory."}
{"code": "public void clear(){\n  fullyLock();\n  try {\n    for (Node<E> p, h=head; (p=h.next) != null; h=p) {\n      h.next=h;\n      p.item=null;\n    }\n    head=last;\n    if (count.getAndSet(0) == capacity)     notFull.signal();\n  }\n  finally {\n    fullyUnlock();\n  }\n}\n", "nl": "Atomically removes all of the elements from this queue. The queue will be empty after this call returns."}
{"code": "public static final double show(Window owner){\n  ApplyTorqueDialog atd=new ApplyTorqueDialog(owner);\n  atd.setLocationRelativeTo(owner);\n  atd.setVisible(true);\n  if (!atd.canceled) {\n    double t=atd.torquePanel.getTorque();\n    return t;\n  }\n  return 0.0;\n}\n", "nl": "Shows a dialog used to accept input for applying a torque to a body. <p> Returns zero if the dialog is closed or canceled."}
{"code": "public final void sort(){\n  flushLocal();\n  ((SortTODSharedDeque)queue).sort();\n}\n", "nl": "Sort the address on the shared stack."}
{"code": "private void writeAttribute(java.lang.String prefix,java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (xmlWriter.getPrefix(namespace) == null) {\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  xmlWriter.writeAttribute(namespace,attName,attValue);\n}\n", "nl": "Util method to write an attribute with the ns prefix"}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputHeader1=null;\n  String inputHeader2=null;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputHeader1=args[0];\n  inputHeader2=args[1];\n  if (inputHeader1 == null || inputHeader2 == null) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    int row, col;\n    double x, y;\n    float progress=0;\n    WhiteboxRaster image1=new WhiteboxRaster(inputHeader1,\"r\");\n    int rows=image1.getNumberRows();\n    int cols=image1.getNumberColumns();\n    double noData1=image1.getNoDataValue();\n    int image1Min=(int)image1.getMinimumValue();\n    int image1Max=(int)image1.getMaximumValue();\n    int image1Range=image1Max - image1Min + 1;\n    WhiteboxRaster image2=new WhiteboxRaster(inputHeader2,\"r\");\n    if (rows != image2.getNumberRows() || cols != image2.getNumberColumns()) {\n      showFeedback(\"The input images must have the same dimensions (rows and columns).\");\n      return;\n    }\n    double noData2=image2.getNoDataValue();\n    int image2Min=(int)image2.getMinimumValue();\n    int image2Max=(int)image2.getMaximumValue();\n    int image2Range=image2Max - image2Min + 1;\n    long[][] contingencyTable=new long[image1Range][image2Range];\n    double[] data1, data2;\n    for (row=0; row < rows; row++) {\n      data1=image1.getRowValues(row);\n      data2=image2.getRowValues(row);\n      for (col=0; col < cols; col++) {\n        x=data1[col];\n        y=data2[col];\n        if (x != noData1 && y != noData2) {\n          contingencyTable[(int)(x - image1Min)][(int)(y - image2Min)]++;\n        }\n      }\n      if (cancelOp) {\n        cancelOperation();\n        return;\n      }\n      progress=(float)(100f * row / (rows - 1));\n      updateProgress((int)progress);\n    }\n    DecimalFormat df=new DecimalFormat(\"###,###,###,###\");\n    String retstr=null;\n    retstr=\"CROSS-TABULATION REPORT\\n\\n\";\n    retstr+=\"Input Image 1 (X):\\t\\t\" + image1.getShortHeaderFile() + \"\\n\";\n    retstr+=\"Input Image 2 (Y):\\t\\t\" + image2.getShortHeaderFile() + \"\\n\\n\";\n    String contingency=\"\\t\\tImage 1\\nImage 2\";\n    for (int a=0; a < image1Range; a++) {\n      contingency+=\"\\t\" + (a + image1Min);\n    }\n    contingency+=\"\\n\";\n    for (int b=0; b < image2Range; b++) {\n      contingency+=(b + image2Min);\n      for (int a=0; a < image1Range; a++) {\n        contingency+=\"\\t\" + df.format(contingencyTable[a][b]);\n      }\n      contingency+=\"\\n\";\n    }\n    retstr+=contingency;\n    returnData(retstr);\n    image1.close();\n    image2.close();\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "void remove(String key){\n  map.remove(key);\n}\n", "nl": "Remove a session attribute from the map."}
{"code": "public static Map<String,Object> findProductById(DispatchContext ctx,Map<String,Object> context){\n  Delegator delegator=ctx.getDelegator();\n  String idToFind=(String)context.get(\"idToFind\");\n  String goodIdentificationTypeId=(String)context.get(\"goodIdentificationTypeId\");\n  String searchProductFirstContext=(String)context.get(\"searchProductFirst\");\n  String searchAllIdContext=(String)context.get(\"searchAllId\");\n  boolean searchProductFirst=UtilValidate.isNotEmpty(searchProductFirstContext) && \"N\".equals(searchProductFirstContext) ? false : true;\n  boolean searchAllId=UtilValidate.isNotEmpty(searchAllIdContext) && \"Y\".equals(searchAllIdContext) ? true : false;\n  GenericValue product=null;\n  List<GenericValue> productsFound=null;\n  try {\n    productsFound=ProductWorker.findProductsById(delegator,idToFind,goodIdentificationTypeId,searchProductFirst,searchAllId);\n  }\n catch (  GenericEntityException e) {\n    Debug.logError(e,module);\n    return ServiceUtil.returnError(e.getMessage());\n  }\n  if (UtilValidate.isNotEmpty(productsFound)) {\n    product=EntityUtil.getFirst(productsFound);\n    productsFound.remove(0);\n  }\n  Map<String,Object> result=ServiceUtil.returnSuccess();\n  result.put(\"product\",product);\n  result.put(\"productsList\",productsFound);\n  return result;\n}\n", "nl": "Finds productId(s) corresponding to a product reference, productId or a GoodIdentification idValue"}
{"code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeDouble(knnDistance);\n}\n", "nl": "Calls the super method and writes the knn distance of this entry to the specified stream."}
{"code": "public Number parse(String text,ParsePosition parsePosition){\n  String s=text.substring(parsePosition.getIndex());\n  long tot=0, max=0;\n  char ch[]=s.toUpperCase().toCharArray();\n  int i, p;\n  for (p=ch.length - 1; p >= 0; p--) {\n    for (i=0; i < syms.length; i++) {\n      if (syms[i].symbol == ch[p]) {\n        if (syms[i].value >= max)         tot+=(max=syms[i].value);\n else         tot-=syms[i].value;\n      }\n    }\n  }\n  parsePosition.setIndex(s.length());\n  return new Long(tot);\n}\n", "nl": "This method converts a Roman Numeral string to a long integer. It does not check that the string is in the correct format - for some incorrectly formatted numbers, i.e. iix, it will produce a number. For others, it will throw an exception."}
{"code": "public static String encodeWithinQuery(final String unescaped) throws URIException {\n  return encodeWithinQuery(unescaped,URI.getDefaultProtocolCharset());\n}\n", "nl": "Escape and encode a string regarded as within the query component of an URI with the default protocol charset. When a query comprise the name and value pairs, it is used in order to encode each name and value string. The reserved special characters within a query component are being included in encoding the query."}
{"code": "protected void removeValues() throws Exception {\n  int i, j;\n  int flag, count;\n  count=m_vals.size();\n  j=0;\n  for (i=0; i < count; i++) {\n    flag=m_editFlags.get(j);\n    if ((flag == FolderEditFlag.NONE) || (flag == FolderEditFlag.UPDATE)) {\n      flag=FolderEditFlag.REMOVE;\n      m_editFlags.set(j,flag);\n      j=j + 1;\n    }\n else     if (flag == FolderEditFlag.NEW) {\n      m_editFlags.remove(j);\n      m_vals.remove(j);\n    }\n  }\n}\n", "nl": "Elimina todos los valores asociados al campo multivalor"}
{"code": "public boolean equals(Object obj){\n  if (this == obj) {\n    return true;\n  }\n  if (obj instanceof AttributeSet) {\n    AttributeSet attrs=(AttributeSet)obj;\n    return isEqual(attrs);\n  }\n  return false;\n}\n", "nl": "Compares this object to the specified object. The result is <code>true</code> if the object is an equivalent set of attributes."}
{"code": "protected void reset(int linksSize,int varArraySize){\n  _frameTop=0;\n  _linksTop=0;\n  if (_links == null) {\n    _links=new int[linksSize];\n  }\n  _links[_linksTop++]=0;\n  _stackFrames=new XObject[varArraySize];\n}\n", "nl": "Reset the stack to a start position."}
{"code": "public SimpleDateFormat(){\n  super();\n}\n", "nl": "Construct a SimpleDateFormat with no pattern."}
{"code": "private static double[][] powerSymmMatrix(double[][] inMatrix,double power){\n  EigenValueDecompositionSymm eigenDeco=new EigenValueDecompositionSymm(inMatrix);\n  int m=Matrix.getNumOfRows(inMatrix);\n  double[][] eigenVectors=eigenDeco.getV();\n  double[] eigenValues=eigenDeco.getRealEigenvalues();\n  for (int i=0; i < m; ++i) {\n    eigenValues[i]=Math.pow(eigenValues[i],power);\n  }\n  return (Matrix.mult(Matrix.mult(eigenVectors,Matrix.diag(eigenValues)),Matrix.transpose(eigenVectors)));\n}\n", "nl": "Calculates the power of a symmetric matrix."}
{"code": "public boolean isValid(){\n  if (!_parameters.hasParameter(\"required\") && !_parameters.hasParameter(\"if_available\")) {\n    _log.warn(\"One of 'required' or 'if_available' parameters must be present.\");\n    return false;\n  }\n  if (!_parameters.hasParameter(\"mode\") || !\"fetch_request\".equals(_parameters.getParameterValue(\"mode\"))) {\n    _log.warn(\"Invalid mode value in fetch_request: \" + _parameters.getParameterValue(\"mode\"));\n    return false;\n  }\n  if (_parameters.hasParameter(\"required\")) {\n    String[] aliases=_parameters.getParameterValue(\"required\").split(\",\");\n    for (int i=0; i < aliases.length; i++) {\n      String alias=aliases[i];\n      if (!_parameters.hasParameter(\"type.\" + alias)) {\n        _log.warn(\"Type missing for attribute alias: \" + alias);\n        return false;\n      }\n      if (!checkCount(alias))       return false;\n    }\n  }\n  if (_parameters.hasParameter(\"if_available\")) {\n    String[] aliases=_parameters.getParameterValue(\"if_available\").split(\",\");\n    for (int i=0; i < aliases.length; i++) {\n      String alias=aliases[i];\n      if (!_parameters.hasParameter(\"type.\" + alias)) {\n        _log.warn(\"Type missing for attribute alias: \" + alias);\n        return false;\n      }\n      if (!checkCount(alias))       return false;\n    }\n  }\n  Iterator it=_parameters.getParameters().iterator();\n  while (it.hasNext()) {\n    String paramName=((Parameter)it.next()).getKey();\n    if (!paramName.equals(\"mode\") && !paramName.startsWith(\"type.\") && !paramName.startsWith(\"count.\")&& !paramName.equals(\"required\")&& !paramName.equals(\"if_available\")&& !paramName.equals(\"update_url\")) {\n      _log.warn(\"Invalid parameter name in fetch request: \" + paramName);\n    }\n  }\n  return true;\n}\n", "nl": "Checks the validity of the extension. <p> Used when constructing a extension from a parameter list."}
{"code": "private void breakBarrier(){\n  generation.broken=true;\n  count=parties;\n  trip.signalAll();\n}\n", "nl": "Sets current barrier generation as broken and wakes up everyone. Called only while holding lock."}
{"code": "@RequestMapping(value=\"/foos/{id}\",method=RequestMethod.DELETE,produces=MediaType.APPLICATION_JSON_VALUE) @Timed public ResponseEntity<Void> deleteFoo(@PathVariable Long id){\n  log.debug(\"REST request to delete Foo : {}\",id);\n  fooRepository.delete(id);\n  return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert(\"foo\",id.toString())).build();\n}\n", "nl": "DELETE  /foos/:id -> delete the \"id\" foo."}
{"code": "private static boolean isViewDescendantOf(View child,View parent){\n  if (child == parent) {\n    return true;\n  }\n  final ViewParent theParent=child.getParent();\n  return (theParent instanceof ViewGroup) && isViewDescendantOf((View)theParent,parent);\n}\n", "nl": "Return true if child is a descendant of parent, (or equal to the parent)."}
{"code": "protected RrdNioBackend(String path,boolean readOnly,int syncPeriod) throws IOException {\n  super(path,readOnly);\n  try {\n    mapFile();\n    if (!readOnly) {\n      fileSyncTimer.schedule(syncTask,syncPeriod * 1000L,syncPeriod * 1000L);\n    }\n  }\n catch (  final IOException ioe) {\n    super.close();\n    throw ioe;\n  }\n}\n", "nl": "Creates RrdFileBackend object for the given file path, backed by java.nio.* classes."}
{"code": "private static Device findAvailableDevice(){\n  Device device=Display.getCurrent();\n  if (device == null) {\n    device=Display.getDefault();\n  }\n  if (device == null)   throw new IllegalStateException(\"No display available\");\n  return device;\n}\n", "nl": "Find an available device to create image with."}
{"code": "public static final int max(int a,int b,int c){\n  return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);\n}\n", "nl": "Returns the maximum value of three ints."}
{"code": "public void commit() throws IOException {\n  if (hasErrors) {\n    completeEdit(this,false);\n    remove(entry.key);\n  }\n else {\n    completeEdit(this,true);\n  }\n}\n", "nl": "Commits this edit so it is visible to readers.  This releases the edit lock so another edit may be started on the same key."}
{"code": "public void updateOwners(Property property,BasicProperty basicProp,Address ownerAddress){\n  int orderNo=0;\n  basicProp.getPropertyOwnerInfo().clear();\n  for (  final PropertyOwnerInfo ownerInfo : property.getBasicProperty().getPropertyOwnerInfoProxy()) {\n    if (ownerInfo != null) {\n      User user=null;\n      if (StringUtils.isNotBlank(ownerInfo.getOwner().getAadhaarNumber()))       user=userService.getUserByAadhaarNumber(ownerInfo.getOwner().getAadhaarNumber());\n else       user=(User)find(\"From User where name = ? and mobileNumber = ? and gender = ? \",ownerInfo.getOwner().getName(),ownerInfo.getOwner().getMobileNumber(),ownerInfo.getOwner().getGender());\n      if (user == null) {\n        orderNo++;\n        final Citizen newOwner=new Citizen();\n        newOwner.setAadhaarNumber(ownerInfo.getOwner().getAadhaarNumber());\n        newOwner.setMobileNumber(ownerInfo.getOwner().getMobileNumber());\n        newOwner.setEmailId(ownerInfo.getOwner().getEmailId());\n        newOwner.setGender(ownerInfo.getOwner().getGender());\n        newOwner.setGuardian(ownerInfo.getOwner().getGuardian());\n        newOwner.setGuardianRelation(ownerInfo.getOwner().getGuardianRelation());\n        newOwner.setName(ownerInfo.getOwner().getName());\n        newOwner.setSalutation(ownerInfo.getOwner().getSalutation());\n        newOwner.setPassword(\"NOT SET\");\n        newOwner.setUsername(propertyTaxUtil.generateUserName(ownerInfo.getOwner().getName()));\n        userService.createUser(newOwner);\n        ownerInfo.setBasicProperty(basicProp);\n        ownerInfo.setOwner(newOwner);\n        ownerInfo.setOrderNo(orderNo);\n        LOGGER.debug(\"createOwners: OwnerAddress: \" + ownerAddress);\n        ownerInfo.getOwner().addAddress(ownerAddress);\n      }\n else {\n        user.setAadhaarNumber(ownerInfo.getOwner().getAadhaarNumber());\n        user.setMobileNumber(ownerInfo.getOwner().getMobileNumber());\n        user.setName(ownerInfo.getOwner().getName());\n        user.setGender(ownerInfo.getOwner().getGender());\n        user.setEmailId(ownerInfo.getOwner().getEmailId());\n        user.setGuardian(ownerInfo.getOwner().getGuardian());\n        user.setGuardianRelation(ownerInfo.getOwner().getGuardianRelation());\n        ownerInfo.setOwner(user);\n        ownerInfo.setBasicProperty(basicProp);\n      }\n    }\n    basicProp.addPropertyOwners(ownerInfo);\n  }\n}\n", "nl": "Update the owners for a property"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  MediaFile mf=getMediaFile(stack);\n  return Boolean.valueOf(mf != null && mf.isPicture());\n}\n", "nl": "Returns true if this MediaFile's content represents a picture file"}
{"code": "@Override protected EClass eStaticClass(){\n  return StextPackage.Literals.EXIT_EVENT;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public String globalInfo(){\n  return \"Class for visualizing class probability estimates.\\n\\n\" + \"For more information, see\\n\\n\" + getTechnicalInformation().toString();\n}\n", "nl": "Returns a string describing this tool"}
{"code": "public void write(Out out,int value) throws IOException {\n  int code=codes[value];\n  int bitCount=30 - Integer.numberOfLeadingZeros(code);\n  Node n=tree;\n  for (int i=bitCount; i >= 0; i--) {\n    boolean goRight=((code >> i) & 1) == 1;\n    int prob=(int)((long)MAX_PROBABILITY * n.right.frequency / n.frequency);\n    out.writeBit(goRight,prob);\n    n=goRight ? n.right : n.left;\n  }\n}\n", "nl": "Write a value."}
{"code": "public TreeRTGAcaciaAbyssinica(){\n  super();\n  this.logBlock=Blocks.LOG2.getDefaultState();\n  this.leavesBlock=Blocks.LEAVES2.getDefaultState();\n  this.trunkSize=12;\n}\n", "nl": "<b>Acacia Abyssinica (Flat-top Acacia)</b><br><br> <u>Relevant variables:</u><br> logBlock, logMeta, leavesBlock, leavesMeta, trunkSize, <s>crownSize</s>, noLeaves<br><br> <u>DecoTree example:</u><br> DecoTree decoTree = new DecoTree(new TreeRTGAcaciaAbyssinica());<br> decoTree.treeType = DecoTree.TreeType.RTG_TREE;<br> decoTree.treeCondition = DecoTree.TreeCondition.NOISE_GREATER_AND_RANDOM_CHANCE;<br> decoTree.distribution = new DecoTree.Distribution(100f, 6f, 0.8f);<br> decoTree.treeConditionNoise = 0f;<br> decoTree.treeConditionChance = 4;<br> decoTree.logBlock = Blocks.LOG2;<br> decoTree.logMeta = (byte)0;<br> decoTree.leavesBlock = Blocks.LEAVES2;<br> decoTree.leavesMeta = (byte)0;<br> decoTree.minTrunkSize = 6;<br> decoTree.maxTrunkSize = 16;<br> decoTree.noLeaves = false;<br> this.addDeco(decoTree); <br><br> <a href=\"http://i.imgur.com/aPVtMV2.png\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAADaCAIAAAAHaYMlAAAAB3RJTUUH4AUBBi0uUr1ypQAAAAlwSFlzAAAewQAAHsEBw2lUUwAAAARnQU1BAACxjwv8YQUAAQLFSURBVHja7L0HuF1XeSa811q7nnq7uizJNu42BhfMYAxj0w1hbCYkgUAKISQZ0iY9GZwECCnzD/MTEhISSAKTQskQHBJKsDGm2djYlrtlW/1KuvXcU3ff63+/b517LXfJllX49/fouTr33F1Xedf71SV+97PaKqWUUko5EcQ+1g9QSimllPLEIh73TQlYpZRSyvEi4ukOKAGrlFJKOdrytMD0ZFICVinPuTzj0VkK5PvDxnykxoBdDqZSSjmepZyhB4s81g9QSimllHKoUqqEpZRSyokgTDVLwCqllFKOG3k6BbgErFJKKeXYyWGa6ErAKuWoSGk6PhT5/vAIPl6OXO/b5UgqpZTjRcrJ+HRSeglLKaWUE0ZKwCqllFJODBGlDauUUko5PuUJ9eMSsEoppZRjJodrtSsBq5RSSjlK8uydCmUuYSmllHLCSGl0L6WUUk4YKQGrlFJKOWGkBKxSSinlhJESsEoppZQTRkrAKqWUUk4YKcMaSimllONSxBN8UQJWKaWUcuxEPMVvTyAlYJVSSilHRQ4Tm55QyvIypTyNlAOklONHykj3Ukop5YSR0ktYSimlnDBSAlYppZRywkgJWKWUUsoJIyVglVJKKSeMlGENpZRSynEkT+0GLAGrlFJKOQbyDOOwyrCGUkop5fiVRyNUybBKKaWUYy2HzJtKwCqllFKeYyl3fi6llFL+fyglwyqllFKOd1mhVSVglVJKKcdSDkvHKwGrlFJKORpyRIxPZVhDKaWUcsJImZpTSimlnDBSqoSllFLKcSlPpP2VgFVKKaUcdRHP8I9lHFYppZRytOUZo05pdC+llFJOGCmN7qWUUsoJI6UNq5RSSjkBxOiCJWCVUkopx4UcinmqBKxSSinlaMhhmMuf/NDS6F5KKaUcFTkSWFOGNZRSSiknjJQqYSmllHLs5RCJUwlYpZRSynMuR0qRK21YpZRSyokgDFUlwyqllFKOhRwaV3rMUaXRvZRSSjk28gywp1QJSymllBNGSpWwlFJKOd6l3ISilFJKOWYiDumrJ5BSJSzlcVKOiVKOVymN7qWUUsrxK4/zEpZSSimlPPdSbvNVSimlfL/IIdqwSpWwlFJKOSZSxmGVUkop389S1nQvpZRSThixRUmxSimllBNESoZVSimlnDBS2rBKKaWUE0ZKL2EppZRywkjJsEoppZQTRkqjeymllHLCSGl0L6WUUk4YKRlWKaWUcsJIacMqpZRSThgpGVYppZTynEsUtga9GSFEGhdCWrqwlC2kwhdWEtE3B3bf3e9OBzXl+GppJrZdUWQWvl+14ZxNz7t85TpleZlSSinlyEuWRbsfvHH3A7eH4YHpnTf2u3OW6ACetLbcQNqOjMO8v5Q5rgBCCaHxE1iGf1KKatPOUo3DgGXnibc/CrBKhlVKKaUcrkSDpbC/+OBdXx30Zmf23rE4f1Ohw347A9bgr3mm27OxcoWUVlC3s7gAADme7LbS0dWeUqK7kNiudDwRdnO/Zidh0ZmPcACBVJgrR+Sp7iwkRa7jQX4wRpWAVUoppTy9JHF3Zs+du7bdDOVuxwNf6Szsj6IF6HQ617YHKqQBJNURO6irhb2hcqVbkYN2VmmosJv1FtP6uOPXVHXEgSbYb6e4oHJkddQJaoXjizQp8NdK3fHrarCU4dzOXOK4EgfjIo8CrDKuoZRSvp8kzzPQnx0PfNUNVNTL6Jss27ntukrTAVtJohxAIKQQ0nJ91WsRdri+POeiH9l48sukfMRGlKbh9vu/3J6f37v9m7P771ia35cmfaCMVFYaFSBBoD+WpqJWg0629tRq2MkdX7bnEnwHoBFCAcvyzAIeeQEZq9KwiLI87GfNSbfIRNwn6oSL9A5AMZS6sABkeVbg2TrzKUAQMJUm2q/lcdjCL3lu4XjxF1/Vx7qFSymllMOWxdkd0ztv7XV3QrcCZED5UracPbB1/85ti/P3AYMAK5j2wALJ5u2wkwFfQF6kFEVhAcvws1JXABfgAmDoze/89zXrL1m5/teu/cA3v/R+RjAoaEWhKYsPkAHlTnFwAeCpyK0i03x9Aqk01gCjsEecCFCIW2cJAZBXUWRfpytZWaJxgF9VWlu1EQcX6cwnpDC6EvQKx0OdxOf2bIJf8Wp4TrzX2Bp/ZkcfOmOpEpZSyokhmMphv7Vz27d2bLtu17Yb24t7bS+DMqWU8KoK3AfYAZICqkLW66gYWQUio4EL3fkEkOEGBFUAC2BHnurxdb5hQ5aE2pU6niA7U5Gu3E7Z2nbpyCzNARy4SxYX0pZKFzbolSboKfLCq9i4Bz6DRgV1uTAd2o4EXNZHHcDbwnTkBcA1uhSOAb/DBSsNG1/GYYEHwI2aq1zwL0Ae7l+p272lFBBWadojq7z2XFxpOADLA9v7zSkPB4uPXl8yrFJKOX6lKIrbv/PRB26/YWbfd/vdOV1omrGsiwGVRld7wCyyJRUW/gR6gumNz4IIF2GEX1PgR6A5OA1gASjh83FZbXQ6OtIBEaOAA6kkLg3eBGQJajaAA2QH1wSaGHKEU4QSQVUZWmf0yhQwRJAk+620OmL7VTAu6Ik5bgEAwgMM2hlUyIW9cZYWjXEHEIkj8bQTGwGiAjQQUAi6111IcHBzwoXqCgjG9dsziVdTwNYe/lQn27wtS4ZVSinHq8RRd8/2m//1k78CjQ/zH8AEiIFeBDCKB4XjK0AADoMmBbzQWuBX4BfQx/VIC3M8q79E+pfjKaiE0L/Cbg7MgraFyZ+GFAAltbADEBzZXYjBa8CPgEpgZIA5QNugm9ls81JkhiJyBDTEuQCvoG4Dj0DZCtw6KcJ2hrOAod2FEOACYIKG2JhwWvvjQTcHg6uNOUBDPAkROl/hqYCMaZjTdTWhZGPcBYLO7Y6Chh2HhH3KFZWa3dof4ZjuQkrxECVglVLKcSh33vpPN13/lwf23pnGMduwieOA7NCHnD6Aodi+BGlKE2hkhRsATZywk2JGe74CrgE78hzfE4jgeHAWAJZLhie9NMNKYkUSjVpIwG46+6PmlAu0SqLCIa9fTrTIFsCdJAZ5I8s66A/gCQeMr/WBhiBN+DXq58zRhBNIXJOgM9OuJ/FUeNT2fOJWcKgAU1vcFxsL/egqH6pr1M+qtsO8Kcfj+RWwOAvgaBPXywGIti1Gpjy8Jl4ePC4vNDOs0k1YSinHnxzYfc++nbdC1SJulRfKJmwC4gARvIAs1kAHcrG1UtsRdkUBVqBJVUcdKFk4BRAAShI0FKABqMRsS2DCU5STLUbXeKA2gBJjiQfcgP4AFHAF/CMwsoEREqoi8AiqYqXp+FULwGGT8qhA8eIeoQyRIFvURp2F6QjP3JlLQMGAm64n3IoNPtWeBRqSWxAPjH84GASt10qAejgLD4PnJ6pVWCCGeLWAbVjVpgPOBTie2x2SzhsX/SXQK1UyrFJKOe6E4hLCpfkD22jSugK4AN4BrPFrdpEVgANMYKAJFCsABw4gHS3KgTiAKiAajmzPp2TYriooZYwROkt1d7HwqoQvOAVIAWDqdzK2MTHHSTWUR1IJXYrezFm1NLcGfiWkuFngRD5Zr+iCYFUjq11iagFUUTJyAd3wPZ6tAOSNOL39kU1+w8LYsByynWnzPBnzRGCQ2egLWir+j/u5+ayUxLPh88LeCG+EW+CvwNbGeK3ISsAq5TmQ+dmHdJFqst9aRpdZ+VAQZVBTa0471s/49DI3cz9bptPt275GliMlwHdo/oMs5FBhahs2v7g5st7z60fwplkaf+yDP7D9/m+aQIEsLUBqoh4ZnvA5w/yv2pq8ahYYB45PAG+kDyp24Yl+O/Mrstq0yTpOza6BI4ab4ODW/pjdhfbidFwfczqLCauK0tICaiMwDshSY46WFhbuSxaxuDBuPvL0URCWsc2L7mIah+Qu7CykdiejYIUOASjuIrUVLRDipLiuJQaLOamURlirpQ/mC0H/rQQq4K3qjclqYxwf1mw4e3R8Pb5cv+n8+sgqfFi78dyg0hT/8O3SS1jK4cmgv/itG/6ou5i0l3bO7dvmsVdI5yYwR2NlbremMcDxJYa4ReF/RZ7o+rjTZ7MI5kOlsq5gq8oVr3/vmee+4eg89u4dNw26bUyq7Q/cmOeRkBT6SLFCKVGJLFvavf0W8yXmIVShQThNDx8XzDIIcwmzMtLONAmFIL3lp//xeWe+5kg94Rc+/Vtbv/vZ9uI+6GgWmdK1SVJRtoUHw0Pi1ngGl2hU7vgEWINOBjaEL0GO8JmsSDEpVsCpuV0DHJPTO1IGjEl8AfahC3BNYAc6gtcSbQIdcC/bE8ZgRHau2RjtgD+ZJGRobYQy7GIsGDMUBaI7+OCj46FEKuVquiRYHB7zwNK+yCLYwrG51l6NzGrUbIXlePaWU16OW2/YTGCEVx2f2jy1ltawoDoKVHqKJrLLUPdSDpYo7Nx+y6ezJHl42w2YGBjumJbdzvT+vfdiWKYhZi0tiZi3fkWRQ12KQagpcppDCilCp6DJTBCGlbZPbB9/wrlLswkmDAUgWrrX3wuS0unqxQMP2c9/Dl/nwftu+Pw//dpS60HMRgCTS+bkggKmFYcxDtd2/EeWXTyb+cI8OdQfc0BBFAFYjBej+WxpDgiwBCAg7M2LIoGadESedtCb7yztZx5qmdgligWXHFIQE0c1FiiKX8c3HGCZRgQKeHKwJ3xIewUeOW7n/BqsZ9G59JtJLebXGfKanDQ7weBLRIzM2VpAU4ucjKINHPJIFkSIhDlFr/AkoJJ0Rr0p26Ymchwny0iVC3wvSTPf89IstVcpN6QnB3HDRXAFE3FKkRBu8LO/+S/PrIkAi8/hcCnlhJM4WvzCZ3+FUiUoMpCWbow5pSiuL09z25MmDsiDDkKWCNFbSit1m2dR7tcUZg7UClAnDFMs2rogPQUrMmDC4/kfMxBEg1wyim297VNx0sZYP+v5V67f+MIj/jrf/tpHZ/bdH9SIMlBEZaINh8Ij2ZxcwiFLPIGlxfkfmmOaKHwJuOBVbHaZFSrANCO2gldmxRAITczxXz718zd+9YPnvOANr3r97z6b59z50PduvvHv7r/ri1gJbDYGadJGCWXoRrE1pCccrqkZOZLwEU0L0rScgdAVt0I8yfUrQYUgmOlIJ2y3ui2AiHlNyyC10cwKok6S673E4JIOA3cGajQENTEEdfofYwD9q4jNAf4dGxilJKAqimL8vVLx8RkSRmSAd6tUj8F1qfXQ4/GAUpopqCKQ41Njzxh2SoZVyqNESVpUhW+F3axSd4zxwrh4IJRHlhHvx0TCTE7jHOoD/mzyPPAr1JY6BeAUIWY7hT4rfJOnVmPCxjxP2TdE5hVervEnoMn0zvtwqclVmzZtOpKAdf89N/z75645sO8uL5BJXHi+zEDueLTjvoAwEyOuiTAKBgi8PK3/NEl5AhvaSMqg1hTwnRDlAaPB0xq+AFULR7ZaO5cW9j7LeTS7/+7v3Pg3GTPWghsKHDAPi5WW5z5Y5jhGI7OEy+8TCPAW5ThVHwDiENdzPRcf8BvBnmVN1CdBnWaXZvgsx7VdKHF4dNeBykfqra1kC8wq6RKgW0SLJOOUtC0KHCWzo8Cz4XsTR4qxIXNRq+JPhTAi6bPvullGwfUgWbunY5DouJejAQdLKbW9tM6+8Pz779g6MrZ26y2fytn1yQ9orVl3xroN5x1KQ4HTHcFBUsqJKmkaXfelD+HDnbf9q80mD7awWqBLkukVLbyYSJpCDQuiGOSZInWAUjq0X6f4GJxlzK6sNpETvSAiQ4Oyu5gSVRkQ+Oncqo5S/CFWXay9uUuuJUHT5oi9ThT1rv/3D07v3UpZb6QVEY8AAAFliGJoqz2XSLamDS042bI1nbWkIiNimEZWEQpMqigCO0kPvj5PUatSbazbdPLpZ7/klDMueZYPb9t0a4cILGGTGxBXzTPL+MQ4TJTadmhIYvwCSFFkupQDNJ1U5L2zjHZLPwxakU5XAJdlza/5kz4Ohl5s4ChJ0ka17rluyq/W6XfoxKFKbJlw+kDX3MJT0oZ4oG4UXkp4Pr1/e05sNKdkH/qAZyUlNE4SHEFPXuTNCUco1ijpGSywLRy7e/s91VFn947bdu34GYIqNh2gLRuN1fXGuhdc9MbLLv+5p2kopyzhVwrZxeMvXfsHZGPKiPNrFyODUsygGWHoYpSCpIDSG9gylmDMLhArSmEddcNOinFHZQBs0llwGNEQqA8WYQFWWuNp4tRVoTwRdXNiPdArEz1g5/oX/u81X/7CH2Kq/e4H7nAc/1m+zvbdd9yz9XrBGhB7/Qs292qbgEh5jh8o6cTS9YJCiU5/CepQLRixfEc5cv/iPqHInT/hrms26piT+/s74zzEfDv1jBf95M/+3Ypf3XbcWn38iLT/5OTGF1585V23Xx+nA2iFhbFBFfyTogGIW7H5T0D9DoQbeE3Hth3HqVUrCWBCqsWlNtvEKb8vB0oVpLAZ0xIOA+IkaYqlJ7Wzfj8EVOC9FMEN9YjmiE1JiX1iqClr0vprVsNRbpplylK1oGbsWGmaTWwcLULHSQRhqiCaJws8d4tM+KDnGDlKg63imuDc+AnqvZwvTVX6QPMsRisq+UDujqK1sG9paf/Gk84BdwdLfIqGOrEDRxfnp9MsZL6qTfIU6+S8ilpibHzdsx/6FnuaFxf2kuFDDBcEWjfYljy1+mTxfZE+Dk3Q9kjRw6vlbNmJB5SfATRBq5IGlFAFSEYfWlEp5FpSNixGdq+VmYs4y0MtzdlcYgnHdmgOWIL859qCkmDsLpIIhQg7ORcD0OSwbyw5XjeJwdr0sx+Tnu9Prd7Sae9L4ghMEPNfYbXXIrWKSjAyXp/wPDeKE8xYqBgj1RFwrcEg9H0POu1obSylcyzHcTkbBlN3VdWVL3zRq089/UXjE2uei/Y/+7yX4x8+bH/we73u0pMNqaDSOOX0C2f2PvzHv/w6PJvr0hqimdqQuZBS/jBE2bMhBKgToCrnjEFmZAKNH8cppe2hC8C2MtBnVWicSCVAg7q9TEWJo3lV2w0dcuqBvdl2HCdRHLPyJ91iDChWSKxDPvDL87zMCgdpi1Q8xnqotNUROxrQrU3FGNBYIGBnPjEGuNqIQ9FhbFK0uDZWlubfuOHjD2674SUv/aktz7tg85YLn7AFTlR+9ad/9CMLrQdarX2WiKN+jmatNBQXzaCiPFglFqbjiakNGLhYUj3KTsjZ5kKdNTV1+ur1G2f2b1tc2I3WRD/hgph1tVGbyhtSNQw60irIEYN2H3TDPdt3NCZcVuOp1AZH31Gqwdr1p2KQcPye5IgVlYT5medcQR4XYW3afEFjdBwz9OTnXRhUjmS0zhEXIPsPXPW+e7fe8MC9N/eWFow1ur+UGQXEIUuOyCO7WmvSaM7ypXgRA68JcuVQDn2r08qLbMP4JouNU3OdmX7Uw582TW2mmJ1Bd8/cbnMjY/TVnLtrqnrjF9cjKITa5frqiMD/llMu+OM/2zo/uweqrskTNpJE4V9c81Z8GJ3auHfnA0UcZUJ41WoK8AKqxREm8KqRNef+p9fFSXrHdZ8ppHX5D//Gi1/5lsN9gHDQ2fHw96xhwSgdhu0dD98ComF7kpx3YVFt2uTgE6LaqG3Z8uLTzryMvXTWllOf3pBHmitghlhUwV5LAqQXX371A3fetLR4gBGBeBbQioa7Zg1XkcWqPxjQSazK4X9gTZJmQL0iyw8yUxpDHmX24C5AK65vpVzXBUcDvoO1ZWmGDzb5YujuuGBSZGzWpCRpo9smIdnjhuY2Sn5U0BrJbJ+zN1aRRxKrCGdWk6dSUd61NT+383Of+a1Xv/5Xv98AK9WLM/sfyqiOD0X3YnZ1FlIThksW3y7F1y7M7TGunPqYQ/EpLR33KRNq3+5t4jaKWwEkJUkh57CsWMqV83OUI04DYt4KOxkQClA4vZsKnnGQsSZHWJUr+3AqJpBudvYhdAxADT1EyvyihqZzgB6sMLMxJ6MJdCXnnT//Vxe86OpDf8G//eg7t95+rbGqkBVYEnoS35agD7VNm16EMXXZFT+OETA2trFSpdAVHLz1tn/bdv8NxigzzD5LcDotepVgcv2G87acesH6jWc9wThwvCte/XP4l2XDNRCyZ9fdt930L53OIl6n323t3nbHRGUEo7zX74/6Lg5rYJWQGIiYFqpQGusomTMsvW5ifWP9Fs/zF7bfn2d51a+dvekco56EaQjOg4tPbHzexKqTrGUI27DpLCwwFg3uIxMiQLfgCz5q2CTxhS+7CsRq+4N3hVHse5QyYiUppmKjViPdqNBnnnfZeS967d9/+DdUEODFoDa2lw6Qdsao11qc3rPz7vvu/lqWkhXM89Xu7ffP7N+OAYADKNgyIXt5EtK0BnHA23GFFlrMzJJJiS8cg2oK3RkF8C0/9sH9e7e3lnZKDgfxK8HJp1x60SU/ZNtPoB+BZ130n69WeSZJxMTazePrTt56038szE1DDURvkEHddcCwiEYRt1XQu0wcL4EIm+DQj4EvjMOBVEjySlIlBqxVlapNmNKvBNQCZEpXjl0N/P4gpK4m6jzEF4ZFMqApy1bCTgbDsg1ZwjogbpVx+Ct4Vl5wxHzBCTpW1M2HEfxRjqPcAFw+xSwTrJy63pMqRuKr956QgaOf/8z7v/C5P0ITgExhKbCsYZUMYz3Fr4N2hlECTEkZUFiDI+Nxezbhw2g1oEFGlJVK+Zj4QIuSA7LamBP3c6MDGkAEVJGSz/QVLAzfAJ/CfobD0NaVpgIuuMTLdNTNjLmB0jgdAg4MRwyFn/6lj19y6Q8e4tt9+u9/7ds3fjLLIhOSYwYxWavZQ1dQlAC6mQIIHZ9K0Pp1O+NUrOqIQ5HE7Pgm8gLNLsptjkI06t4P/ugfvOr1735mbX7nTV/6/MfeQybhyuhvfOgrg97S//zFVyZJguF6+Zt+/vkvfs0fvOulFveEVwne/HP/T6Va+6vff7tFCqDCEDSk4PKrfualr3/HsR4+1l+87x0P3PEN16GsYug7mL3VamBCsX71f/8HUPvDv/NDi63phf6sX6umRYe5gGVSiEGiLUpGkQGHcaBhAUDAacfEfJDSy2m6jmDGYeF4TVU9lfE54jomNrUo2CJusyFJGFtVwSsfhYzhv//5Z7v94FCJ+V++7x133fo14EiSpIHvN+pVY8MyF5f0OYNaRz+T1GiII416zsZySDudH+SdLMWqYzHlsWr22ER9ikzy2hofH4HKNrewyBoh1k5jbgfyDiMb8NNz3X1z+23pcDMOvYdVgJ1UFBsmhXJcu1pP2SkAxbbeGDdegpM2nzs2sZZHDplZMH+nVp/qedUnfM0ThmFhGUqSULMHhCoBpQnAaNDJCJIwFXONZRNjAgSKUJ97HT+5qjTtwEHlwZKC8kWhOQ9yrgpEg6bfyWpNWsQwRChelxQEBVUIGIflgiqaMa03mSVUdqNKDBmX0pKGpuRELVPasbeYNSbdwVKqjTUx1zGjZ0rZqlIemqkLPf2B333J/PzDaZIYGycWPc2Pp3PQQGFKsvlVm3PxdcHOI0rLkIRroOYWeb4sU4dkWBpJDPNO8b633PRZDLUXX/Yj1dro4XbBhpPPecOPv8cifWfwmb/4bbROFHG8OK3PutacGF936vz+7RbV/8bD6w2nnKeVl6LXMug+6nnnvcQPqpNrtxzrocTvsuWsPdtuoSknFbQbzHDboeltakTd/q1/S+NuhhGXxXk/ATCxzZLLQpHyIswqYnJTzBIiyZcmuI6K1EAJKbhiFKXsUvAaR35gVGCsBjVKDKAoVioOw6ZolwgXrXlcLgaEhzRHLI1xn8k11LHgad+IkZI0QaI7aZKFMmePIU4umAKZsgesodJkwSMBuRyHAu2wlLz1p/7X2Re9wlzq/nu+mcT9bbd/a/vWb6NNfM/r9QeSWJvLk8+CdomW6He7MRFFMqWpah2N8IILX3XvHd+goa5oVJCJjfikDKCcar3ljAt/9Ff+/Fl23AkDWODhf/h7lxl2Q5uaKeFWFNAK/ALr3vi6YGE6nN0VUpJXncwRFGgiZLVJ5Qqh32Gg1EadXiutjbo0t2n2ysX98ciUi5FEmeWaIk1wIgYTpZIQ7FCta6rKCjBqpehzO6BkhMXFxGTMu1z41atQMcbFAzG6iUo7AtFyC8+AUyg62aJxDBjdetsXFxf24vlHxsde9sqfeLLX3L/vvv3T99EnSSQ7S4nDm5pHlokYorWddIpMWAxelA1rnPGOicYrTMCONuYDQ69IQ2SyvfPh27Zvu+3U0y95BoA1OrkO//ChNTf9r3/3fn4SWl0LQfdiwy0PaFJDKPBQ4XfPjeMBvhyE4Svf/Eur1h0XaAUZGV/FKYGZIlYEJU6mpME5gJrFmd07tt++NJgPrS5WOyqVyQueZt8ZUSdP1ho2PofAIEW5Muig5SAPAhqcohwKVUWn+BVgEBEu7gsaTqQKORSrilNMIFI0yDk2DboCxdyypZoWm9/5lTNw8AsuvvIdP/N/DqV31m44FZp7u72QS9XP8lqlAiymbbUce9Dr4/Hr9Zr5BoNq34E5NnUR/qLvDuy8R1kFVGOQTar3gLljexQqpSTaJ4szybkLQeAnBHN2kmYJjznHImN/bXT12OqT2q15ygrg1Rk/JldtPOO8S8l9HFQwUCdWb3z2HXfCABbTHwKCfisdWeVhEMRhDhIESHIDuTAdEV2vkBUwT/L+gHcTcoQpyUpsi0tH18cxlCzet4Pq3leb9jBlXGu/JkGsTFhjc9Jtz8ajfBeA19Jsgm+gRYLQpTwufcqDLzwxDIzscw4XTuR0drJngf5Qzpdxq2laQr9z46dvsj6NBWnVmi1PAVg+NJDK2tl9u4zFpGBnnC+Dhh+IxImTvEjTTtwytM8FZlaCtIPlviDDkMC7kwHFk5VmpRknSTdqZ3kqxLD+5IaTLgr80c2nnD82seHQW97i+gF4c01ZhK12a3+nNWd0CqOoYs4maWgyPCiUgbjeMCopzUjjMK6lYz2CHiXnXvzKqdUnfexPfi4DHcoK8mRaImRH4T988Ge3zzwUZT2MGcANvWNMpU54+SFi5UP3TygAXVIMP+chmegAyzIVYLAsmSRKfJtwqDqGBxUv1lg7c4CgxVZzwgWbyRrnElBYpkeOI9sxEGmIG+f9HYK8+V3vxc+brvvs33/419mMBVVXObYNGpVmWZRlFd8H0HAfFVlWZGlaqxJxI8Au9J3f+eK226/v9vqERxQDka1fu2p8dKTV7hi9EkehcXCFKAKvKihAtNDVWsUEhk3vfmj3jgc0raoWWtPzwAD0+Ze98fI3vvPIdtwJA1gm5BqgVRuhQGr0IvgCOWIlFBBNNMehyoRkhaRIG3DsIo5II3OpVFCKmUwF+T1KarVMtUMOZgPbZ29rCtXbpb09KGYHy6THBYYMVaGUukybgmSVptNbSonBudK4FKnbCPjItQ9KD5CiurRsvKeB65KaCbAzahqFWeZPNf7GJ076ww/dffA34aD9jx/6xbk92/r9EHwGI+HN73xPUG/qzHpo67d23n1Tp9sH+Xvzr7zfcfzVa08bn9xw7cd/77ZvXivz6F3v+duzLnj5wVc7OAhjxbhOGrXOlxPozdR7xLOG70FQ0zSChtJemimK1K/W3viO3xoste7betP9W7+tbPWlf/p/r/vsn+EczA6HTWif+OC7MQ2q9dFXXPUzqzacgjkxMr76WA+iR6Q+MoF/UFgw8aDymPhuITW6p0itian1YTowVlE0R+ASw8rj9qCz5Gg5gBru+EHg2Vq0ZpcqXqXuUJ25pcVerBObUostx5Gu7ToF9EZFph7bHnNUf9DBepgsUsAaOfpJMfN1YYLryTcHNDzjrIvrzTFjrBQUli43bDrn0N+LItfJu515LvkTiOpamDUKSAOs4dQZECjFlnK5EiAqeUlhjZh+BcDhG8/zkrSnyc8ISsiF2/Pcs0i5w+kFB4ml4YBN5gGnEtH0JMwSVn10EnepVBtHvONOGMCyaJ3XXEvMzmLiHdEga4x78SBLwhz4Qu7VzBLopoK9MBll7VIoozXclQjEJx7QygMcIRch57tSvoVDiyiOoSR1Nktx4qvNG36QrXr42TKWb1pFmdWTzTvu5wEnzZnEBdYQQb4yUl3JcjEMCjfh1OjRPNL2xNMYsx4T2FWpjrzoird0WzNf+cyHsHLaUu65796rfvI9S/P7d971PShkgOb66tqdW79g0fUzKyqW9u/Nw7Ax3rzp239/34NfsWXg+gHo+0te/rZ6YznQUbPFg9Xg1uJ0GHbIXgaVF3OUHNb28sMoP6jX6hNeUKsUoyMja6HidlqzkxMnN8dWDaL4gTu/QxZoqcxIxXqRkvPb4ToAutOa33DqeSefceSTBI+I/ML7P/Wtr/zjrV/7DF740it/4htf+Hg18DeeduHV7/7fjz+4211YWjiAD/t2bfvUh3+z6dfQOq+48he+fu3HAt9DR1z9pv+eJsm3v/iJaiXA3O71+s3RervT8zzSlClPOFc5OaQ1GrlWqwALrnz7b7/wpf/lCL6RNsSNVHVeJDWZrwrO2zZBCYTKFPyZsl9Q8+LE/kq2oqPnEwp8JxtckiaEdzSqwSgz0hKJSmdoqyRJCraxkv/bccCjcUGO87KMH+Nnr/nk+KrDY/GHKMcpYPV6i5//7DU5EWNFQbmC0iguf/W7MDlbC9OUHyLUyNiakzafL9kpiLa7+47rstPSFRvzo3rxFGvvg1vD7qLIrZzjUPJ5StTwhYjCsNvBzFVnX3i551ejfnv/Q3dxpKPodHtkg5cyb+U+J84TAMXFRIUmdBQn8SAGfEw1Tptcu4nWG3lwZZ9hESiLXdd4vk2nntdsrsYfgqB6uK1x1oVkDb35y38TxxQfuPfhu6Z33KsIaHVOcQS6sWpsaXEaPCjvZtkSlT3TrldZNQ7leHZ/WKlVvagJSnDzNz99xWt/5uArSy5cUqtPApLiqM/u8CBNIsf1OcVDcMLHMFOWUQkQT39FIybRAH8Pqk3eTbNI4j7NgSQaliwpMlp7wVrVcTrGIKs3nFJtjHHsJTkNyHwOXtAce8KD6/XxOse161wH1YZfqaHFqrURy6xkRVGvjyVxxCFOhbE25ly5An1kjNzGC2Y7nh/U0B1srn6U/x7f9Lut5ZIRJkxfm0gra+WzKS4mV3J0HjXkTj3n4je98z3DbSqE+OxHfx/XhIpXqfiVgBRAYBaYXbvTrVYqBcWaktsBh599yauXFhfuvfVr5GQMfDzzgQPzYFI4y8Re4efr3vqbp57/8j/+5de35vaZhB7iaPR29MTkGVfQRfKgUl2xCRxxOU7DGr547R+FgwE3pbDJfinYNtmrN0c8v6FsSSimnI2bz9205fxDueAn/tfPP3D71w1aGXJrsZrpujbH2enf/NCXJ9actOehOz/+ATIwAQf6g9DicYAV0la2yep0cYIiiylWTsOcX/PDv/TKq991FNpk3457ZvY+9K1r/3Rxqbdq7UZLqNkDe5Oo1+32N5x8dsV3+p1FPFoaR9XRdZhRQX3klDMvXlrYf+6LX/cU1u5hZjOIZ9jP0gRgBOJlOy6oGz4/3vaEY/I0CQc93MLxPDM077v9G3/+ez+m2ShLHkklTRmQ8/7TlT/4rvcfhcZ5xvKlz/zZVz79p/Va9eyLXnHxFT9MHsNqc3TqkNjB773r5a6IAAAbTnnBrp0Pz+/fAT0Rr49GwDhrLXWotpRLWiVwC8NpbLSJ9rzgZVe/9i2/vnKRxfm9H/ng27gnKMPloQduXYYqiwwdNpsjopwNGlKbAB4uy2WCMPKUwlnMpfyKbXGmJ47HY5CxbH7M+EZGm01wuoxyFEjrGwwGpiYMG99oFe84e1UauGmTIJXiPMhy1qiBLAac6EPyAz9+zTmXvHbv9nta8/s/+oF3kZmMlF0y8/UH5Ea85PI34V9zfPX46ueEXlnHLcN6zRt+/THfhP3Otq3fHF990votZz2DCxoCbFK90zQbBrzxUqYNERpW0aAjgU0AJsGfTRQLeppSEHyPIK/IXYAo6DFFGhRHLTVn7eazyEBH2laxOLuHynrEiYkCBOEaHxvBkKJVFMPIq3rVEfzfWjiwbvPZT+2b40UbFAk6rJ/zRk6OFwD1/GrtCY8nVyCYVRxBzXzk3ZkEmHpReZ5hSS/YGH+IwRzHXKjuTdjdeOohFQx49InEKeqjE97MzPArTdHhEa+Lyx6JlILCOcyIgjnFo9aAOB48vO27ph84W3MYjmR0MY6nI8ev2cjLnIohaHMWnqJgHZNrzqVgmNaA0Sd6GEuFHsjTzPUcxesHVDnPcbkKBSDPbFdDVixDu5SWOjE9SLjmBz4hFwW2c/qH6/ImYBYmYLU+aiygZj0zvYzhN4ahdtaFh9F8hy9HFbBAob/1jb+jPs0tw5BNkqdp7pXc2mI5gd6cZbax5kgiOb9tz0MPf4cjX8hMWKuNvfDiQ6xXOawihM4YVvnRJurX4jgUvTC7Fy2+OLvPeGTNRBtmVhDfLzhALjUdD/ziEPTiaLYeZPVJZ2w448WD730Vq3dA40lhMDXqNeAnSP7mk9ZjGRfe6IZTzmkvztVGJ8684PL1m884pEtzm5IPX4LPZm5QeYpjAZomgmFFRifWvuzKH0ObPHz3TaCBGONnX3A5ltkNz2h1OcqCpQvr0AUvO9Sw3hV56y/8CVDku1/753u+9w3HFiPNOtofYM3mQRozvu9haLmOEzj26kblsrf+DhTPxtgqc/rM/oc/+de/CIZlUdwJ27ATbZwzfk2ZcBaK4LHJ/JqnOsk4kJBDxlOu50d7wacU12JqkJkpY0IrqMBDmJNJnwI3CuCOrz3SJ9nOSI4UHtL8O+kTwqHgLZ/qAuYOl53J0gzqoe8PAU4s59lYy7W5WM+lTET86W0//8fN8TWTa45A4MJTy9EDrF5v8YF7v/a5T/82ZXJk1kqRHZP0AFSi/H40QErBUBznSTGTtLl2gJ6wOE9daRNO5DtgNpZW9ebkvr33X3nVrz4tzbnqJ96DpYwT0/VDd9987d+933ATZdMIiNP0w+95m8WeYKwknOVPfQlKjD7q98MoiiiPNM9BYRwucEHxRxykd+rZFx+1NoRMrNkSnXZB9/ZvmRpseCSbXoGA1SzpI+Or52emN532/AsufUOldqhuGmHClgFDpEHYTxuF8JgGX73+5De943/gw//50K/O7H0YA/38l77x3IsuP5ot84yFxlWhJ9acdLgnnnzGBfh5/9Zv9TrzI80GDQxhVSo+xQ0weECjikFqiJuo2Pa2nHFRfXRq5fQo6t5759eG7UllyHj9ppVbmirMJscen8Hn4z6FMQc8Iygh2aWdk40dC5hVG7WzjDw/JkzPBEuDLvWtxYoexfP0en38qcLJOFxsL5ibb0GBlRxxAgVWtEcchjNojlAvJPMsx3Uvv/rdrGfQQ6466fTh01p8FhFq/mnpzWe88OgE2R09wOq2Zx647+uXvORHV1Tu2X3bd267Hc29bvOZm08/2+QVm0j2HffdMn9g1/otz1+1fksSLW278yaoaSOja8dXrdl+391XvOKnN245i4IlyXNxSOa9xtgjA6U1u8eYFcgapTWTXkJEinlTyve8KI4xgjHycl4nTfoCDsPIDio+rTyk4RPgYlC53tNHIR9BufgVb8G/2d+5amF2GlAVxXpxqbNh3epaNQhGN73zfR/GGLr2k39Sb04cOlqtiFI2j/hnbjE1NuATq4IFa6/iGZtyoSKd/5IfEEWy9aav8BJCVoKxihcNoBcWy9m/DhaSg9EKsnHTuR/9h0WL/I/z133xr9qtGabsWjqyNb9j90O3VysuIOysC6644zv/7kowotjKZK0+GoVLCWVr2FjUKZnYUnnMicRxYXtQ21SRamCOTkVlslkskG6I6SPY4h7HieNQiRiyVSmqc0aBC1iqhUOmEiurVqTvUUkZGwxBqosu/6HHv7LrV/xKI6R68rnkRJyj1llHD7DWrDvjR97+oYO/2bv9nvvvuHF6x339bmssOGXTaS844/xLzZ/++a+uuXnfP59+ymWv+q//7auf/dMZe1eYxfWs9ryNL3nDVddMrdvybIofsH7HuQPs3BEmAoemK3HflMHLZv8up26Qlz9jc6Wm5N6clUphlibS6o/F5JxcdyoAy3ijFLultLQn124xmtq6Tac/98ajJ7m+NqV1TyTAksYG9ExPP/fiV+Lf/l0P3HTDtaMjzTRNq9UKKMyWRnN+oVWvNTB+1m466wd//sOPOREjyPTX6NjaN73lmoP/9K0v/+P0ndvHxkcxxK5+8/vuvv6boG+TDTIavvuaz7/vZy8HNXISsqGEMvKwaHIpBc9NLC28jC1WmT7t4ktf96O/dc07LzWQ5LoOZSDzuFVsX2RfYsG8iuIWLR72VLwBi3SWS6MGPpFU6yNjk2umd7Y1D0EO1TpKvrtjaXTH0oR/O+7/3nWf+8v/+L8fmVq75bZvfuGlr33bhpPP2rfrfmjsi7PTn/noNQ/c8Y3Lrvyxr//bJ4LxdWdd/Or1W858lvddvfG0//KO30MT33Prdffcer3J1TQmLnCtTqeHbjT5B4I9MmZpomIEGB9hzEmIzrkveg0gTFKYwtA4XVDwcGiZ2LtlGbRnBu3FysiqSuPRzvLH9K8YVosc/iKMwirNZ4ONw5K9LFe/6w/f+1MXFeyxDnwPy6Yd1K58228cfMVj0qdmiOdD2+SJIc+SYS2/uHS9iuNS5ori5CRp8qgkBTEdbndc9PKrTjn74o+854c8x/rGtR8Jggr7OsiffeCur3NtVHNxUbMFEblh/ASl75nQ+02nnj82ueHuW64zJWjIyR4nddvmiqDsYcwyaXaxob0oTLoyKSwm0p0yGZR6ih0fDKviMkHksD9qS9Sx9xJuPv2F//Wn3/v1L/zt1z7/11imzr34FQCsscl1+3Y/uGPb1m57ERr1jgfvesdvfCSoNY+Ingxyfv5LXm+xHf6u715nbOqmeJCJeOAFhvqeg0vJmgP10CInS9rr97lMgvX2X/6gRZasOBwstBa3Z0m4uPfuKO6I4WIDTZNKcNjaiuPcOeDglzwFiYMG6YKqeY5DBTipMpotybsjScFlY6cyhWmYw3EMFLkG8dN1KsqUjKBSkfZZF75q0G+DooZRdulr3hrUjkzpy2cpphiTes7CcJ6lpHGYpWFOhQcLizOL4qht8i57nX2OLx5ZNCyxslcD5yERIfK8Bg0JabvuY4PpVm849b1/8118+PP/8YNRd8aTLkaLCRl96RveufnMFx3Wczqu1++0BoN+ZXxs2+1ff9XVP3nZG//b3/zJu+++5auf/PgHHD9IuOICgZTjFpSxVZgNbKIortXwbNq15aYzX/SxD7yzWqu4jtMYW3P1T/3+tZ/4473b76ZhKcWakYape6WU108ypeiNCq5LtXbLuWtOOsPiCP0ne8IVKycapjk6Nfrc1DV8vBxjwDKTuzE69bq3/PfRyXVAjP/47J/928feizElKB28BXad5foH3vZrU2s3meMH/VYc9yxTaYxxPUujNO2bC3KyPdhvDcud59VsEwBpWZ3WniyPeWgaZwfBQa89Q+Uu2S1iIrOMixD8gLix4yQpFZ+VSpmkOYoqUFRqFqvSbbf+Tbe7L4lCbVGmDnW8FFmUe7yJHec4FMqiGo9Zpr0YSxYF1EjtKM8VGmuXH/i+5Fx2zTRdsefbSlJOE7SSLLdcg3jStb0iF06tITkqn8rkKHXOS/7z3B5A+jcHcXTKOReOTa5vz++ivCQJ5k8p/3meHEIHoMXSdmvXAPPW0p0996VFmIuUrLBUyUnWR0+qTQxTamxwCKdeH12Pu1CpmywRjyKGREctNsSafLVDeoCDBE/SXdxLT16kHGuiV7KFuKy4p5S/HMjKUawrWzJQ4JKinY65miAk7i1mWcTPQPuUcVhLziF4WZYmRRpnuAWWlDzpt6YJj6SY233HYGkn55YYTovGd00UMhWBYnbDUeHa8aqV8XVP9hZ5Hit+NspfKahmqePZY4cf9r3h5LOv+slrTOB4r7P4r5/4wIE9D2ApFQKDIedRLThzU5ocTqHsWnOiNX9AsfO7022zI5ti2bHENRojYAZY8jkNSye6UE7VURRvhWGXWVAUvDhJFMdknXTGRZe+9seeprOW7VYUnOj5R82Se1QBKwxbaRLedes/79t1Z68b014drfmFhfswpTHbgSfkYu2KMKP1WXnADHHJVS/vdWe//o33SiYccRzG0cC0l6Zeo1US8yqP9Kmbz69WRqVvEw1h05Oq+sod1j8rwkjmmqLCwacpnILqnywsbhMOtCouosbprBS6UhQeYEQXWMSM643qK/oeVxfKWNkhI+bNN/+5ndiOolqm2mj7mGWxWnXyKaTApUUWpq6NIWthWqe+g3e0bSfPrEo1iIuiGnhL7aLikf+IBiGVOqCKEWTCZFblkF9aZspRropSspTFrRalW1A0BnF1zKcommdVVi8sPBzrxZVFD0jaH6h77hyYKW24GjsoHsvbO9P3h+FSKjITrY1mxZNbyziACd7u7Lb24tVoMaa0HVWtrztNOdSqw5CQR+sC7c5eE0EyvfcWrxEe/CdH+L5TlVQUWfBAz1kdSdIcfCcfglPBtU64hNhBarPgKiVKD7PuFGcNu0py9ZJhBc6MUnppTBTL51CxZb6RpTjkPNNYBTXlCmIcZHmapVTZKY2HRex6XepvWZgneQQNhzRbrDxKolVvbo+2l/MPrYO2Mrb0+LpVs7vCXn9gU04MJU7dd/1nosHi6uedflBj0Lm2dHy71hg/yXYroDmPaUmQrBddMYy0+PaX//6mr35qYmzE93wMQvS957rojqWlDp4Tizov5KHtJONjI4CtbrsFBeXzH/31VVPjL339Oy959dvNddgAi3FONIrKVJEuKFNOPDShoTZTqkMhyKwBCHY9qeJoGbCo0R5vLduz53ZwloO/abX2zszc//iTuT6GyHl/WlPhRDnDObNn9239/sJjju/1ZpK4T4X1uIYUxS6k2mydIrlmD2aMM0XZIvggFCXg3Pj1j8fDzThpZHKgCvHzqJdzsprFpaBo+RvdUG2HjhVaTyYUTGEee/FAEnWLIu32kuedH3Q7sZOoh7ZFJrzE8SjODj032+lTTpBSw4JkFONHmwG4jrt6wrVnkvZ8a6Ie9HqRqCjpiSTJhRL92fZw5NLD4ZTElF6huBVLDsIIl0NLVQKfTf60TW6l7lOAslyuUSsdcENzEd/3lodamiTEK/Mwl54sMMdD8APfJOU/vPM6e59TrBSWYZCabVNOpdkb5slMDAJ6aVrYHEoCrRSzWahh8jNVxxeWHdF2fVRBtyIFFW+S8zt24YOBPoZXKinhujYVwBVqsHjATIPO9AMzVo82BCZ9VutUeJNTqhIMYx+H7AmgCIYKGM50YUJwiTgAXlagVWY8GpyhWZzJD72Strk+rwmy1Mv1dPJCDjcbpibQylpW7Cx8X6R4RM1VgwkNKSIk1UnUp1s7dph1RFZQbjB3N5pFmhA8oVPa0MHURacbSYvnM9MtKgWrMWW5EqRLe76fvHb9/K493V7fpMLg5ntmDyzd+K/Pj/ZxarISHu/4DrUMXd1sTs9u5diF4PF9hHfzpM/7JS6df8mlM/d8D6stBYXyE5522gvvu+eOXreNXwdUQSHHaPE9b3L1hqV2O0kSSmnkahkHz/FhAWVN8b1D27sQxmJrQiMNPXwKI3rUby/NPZQmfd6jkBs0i/ftvNmUoAChVcudh350/WqlOlGrr+aF6kgA1l//+Y/Pzz+0f+92KjIdU6gz1ckjK47mCpy0Z6TZ9wnIggcKasrsj0I1oaoUaQjYwq+U104vQ9sKDDUFqlJG5bpxBVw55n0fTd0CYJDjy6GtRlDIVQ5q6mRU9G6hAGe3HSokxNtzF2GPrm9q0VnWcCMmnsNUykdxVU886v59d5oqJurROy4d1PgUZWc2xSt4a1yR6vYc6ZKhR2s9g4UEmUryIiI9kSu6Ebd3eMsVuo7rulAzZqPu/HyIxWr3Esf1FUoPOM8r0+AjbMjkfesocUUMK7Es77JrYla7XItwGJ26SN/TVnQ8l6mSbFTwznRWUHgXbt5Y2LRjntVPfa0W+oP6qB9RjSWdEJhSC7Zb23SSV10n7CWeb1tUTEJF3dQtgIxeP0qV7+B2rsOVUV0HLVyhTcapXWKqb+yEolCBDZaChdtgScb1vLMhXGq7Jzn/m/bAy/CTgw8LDiZMRZH6quBac1kRm2S6VjqrkozgJDYvaekDDzJ75M21mLXQKsWFBdFpktDeZmvdsHKBqZm33IXDHFGqYEDl4Wh2kRsEEw8qeE5RKkMENGGNiqORwXGUMIqqxR4VWwtFdep1jPYCKcuhIHbMrg1hd07kPQoKNJdiczKIMrUTVanmMpvOsGJ1lg4xmzpOkeoJhpT2cptKjGrZiOy25D0gbN6YC32fHYh3mlhlnbAfpeB1YVYzRzQlR6lpbH41SamDPIekghrujU5tOOPk+2+/xQ0Ch/etSdJ0x923yCzDLbr9viQTpwPW1A/D6YfvWhtYxcjE6vPOxkP28p3fvXlYNu+cy87cvu3WXqvtulavH+JcStvmkPdTL3q+JI6vHdcVjdZ3b/7IwZOoWl21Yt6DkhR1ZtOUNn8xNi983r39mxabwCi1kAPiBWUIZRRkIeXU8y5Vw+1gdK263raHGZQc++cdHmDdc++11I4OuABFmWM82B7F45iarcZOxAV/hQ0NB23iDtcsj0oF6e5CyrXNLMm7BFMN9Qi4QNCGRdsUPKByZdCWBlxCiDe2IUebO1z2JaOSTdvb0cqX837ieTbcooZr2lsmhJeigTVVtsIHnOX6kqpHY8IJgob779iFcxuj1Y2nrsoiaIkYlYVIOC4m1pJDTyUxGk6NABYHAv/EON2DMs9FQsYsaYJKNAfOaWO34p+kD6KDwzAmc5Vlu1WV53z3XA/aqanVbd4lCankKRV+oxoP2uyIZy2bcBl5aWdwU7PYrZArMOzQGxJMVykKFMvDEN0qWXdUD/dG90WUZf6qoL2QaDRFrKuOu8g+yca8aDuFIK1TAt00KZdFXrUSqTMrKVwMKwI3vGUuCihShdR9NuvjCR1bdZg7UGZlLAeZSVcTGP8Jwyvtluqo2AAuwCLFWJSA+CwsAmknWRF4boFupaAQiWXNrOFifgnankelKoYgUjjaBmJIK/Ul8R2cgothKXKMM5Tg7xADepb3LeYmTSzTVstKKucJpcZboofJCo+c8Ej6ApMvq1d0zCCcLw64aCl0TW5wkukVWmA5GYPKgGTDSVukhZeZA6gIXgh23e9nfmF5xBO9uq5vKnbc0oYSh4On1jr1RpzumVaOlw3rITONFWJhfm4QdlOn8KueS1tg5bbwHc8mrjDMKBa2X7H6EnNK1nKAnUqp5HA/yztmIxwoK0lar9eCgBI/5+cXi3rVkhVfWYlNtSXmlvbPLdGCVy2qvggcjh9k40bBSc5c2Upbk9UqFuYhsk/vjdnPq8kDSMx/IB5a6UeziFAGI4cHUax7mvZ3PURpQLZmvacY9hCDPn52btpBVR6FtWKXNP85dtXzxkyxgsmTrhhZ9fynB6z2bGKIAKk/tMu1TAeYiXppJnEDUwqBLNmm1Odw/0gutxh1odsNqQu+DGo2VSlbysJ+ZvO+dcRHfFooQBaSmCvA8MBMU6rnCxJBs9qh/ax9ziowNVjYKWMFdSrmSdtbg0PZVNUTqwfVxuax5hI7k4NOVmRs3M6pbDYjms6XcnF/jMkrA2nRTNBOwxV1zGk1XCGUWFkbzcMnCdlhTeAJ4CYVVEbSJLKPsXrYTkD66FWFm6dWWKgUN4oW0izWJnnC8CaMQbSY2UmU0XY5/8ei/fiojiBX+KfGoVxuQnPSoM3MElzrAVpXQvsJoxck19jN0vzO7+1YU2msmxzDbWJNO4AnDqiXEmtk1IOGRla8Xh3TX7bDeMz2OgeiZtOn6jphHlh24WOeWW7B7mchoepD/4xt0CfeXqmAzjVMpcRqRbBlWxk4hYOpUQwZqmetfKYfwTB4RwdWJKgw68AKyTNO+2xaicq4NWTHH9g+MxZygZJGRjTT4Q5MGcETWpFFImQMUOCMTWPW5pVSMN0YNqweQo+TqGEPav4ThgzgtlC0GZ6lk8A2RQx4CBGBI8PCIwFWhEMy105ixf6KSUrrxS4XYCncXYu+I9tR7GHkKN4LXhXatQZQgLnYv2CDJm/KapHF01tOBgAE55kVaDuwV9S6grPP2OZtRX5SBGawdR8z/YA2Tt9yIivwirGa3+rlvaQtXFWv+Vh7sBiESdpRC/W6C264cVzMzmZLXW2zR8AobjzMJCW6upQj06jXquOyNpI5RR7P7jYb5LiRcK1Kfyxs+yrMoDzQ2HaYkqRZxnVD7Xt3XC5UxVouFLGsgdOMfcREd5BmGSe3KdUzGaNpXrtv/2uUnFn5KwMbFKzcC9SyVwZDLX9ErTg48I0+RWr/5yYmdztu0KxvLvIm/yG2nQfU8p7aSgWjI+fSzjFo1147qzRp4x5gRBoW0SDH3CMtZCmjSaio0jlwARMbwMQjwiIdPOGdfrlWr+BCsabsFHgHHc/FNs0G316gzJZ2oG+AJ8WcCxTDkBHctDOXVkbQEaLasHG7Xis1eBI07MYEVQFtz6VUVC/MCW2oZFVm6uqhzwkWOUq7WldTJ42KkUCyHd2EHYOJgCDgsChMrcgSZHBRYNat+VCGzMuxqIbUFzkX9jXFNPAr2LLwsCQCUpck21azopt5XdpjsmI0l2Hml8klwjemzDwagdDZlAHhSSi4GFvOlY5TDsqh8vAV4iRUuDEnhlip232uaBr3Ca/xJLgUOhYccY9uj5w1RkaaEI9VZIu57hbjkd/tsv8KrKdPVXdzpWOgie90q2YUuL3l8ePkdg9QQrgjIusR9KFNRsVw43hSB7SkLfxM6wntp1Tby/EUZ+3mQaI4MM2Kksx3bNA9TFEMQhWLOMuNLX02tozJz27V7bzB6CNykFeLCtXZlqQCeS7U2Y1aV6keWZzTuM9rQnaFiPLi5NinUACiYMZSJDOvsr3IcHBPVIYTiBLQ0ZhA+2ykKCZd7w7wyby/WuuGtHtusI9hRVu8+7xpA0ftt71HGTjBkqDfhiqBEgPuPDcChIVyW/RID5BZL1NYFeh0aYYihbq0M7fpYMpjfVDFI3GVTvWJDDRDBYJMg0/GF+SUY02RBwN6yQI0k1GptC8GOgVvYCOClSonF5WUiKrIZBRlzP/J9mQMT2RUde0oinzPI9e250DzGQHgYsCi+z3SNNpeNgPldr6Zpc00eRhLGbTlwjBhy2wVpA8cMD6Zg8o2ioOTB6lRVmKksfwC6KhsDgdqYd4cmKlD29Ncw0+qJWm3/MoeXDaW9ztmR2rZUs4c2tBxn9iYFUV5f/qrKyHZT8qwWEMRZgtSKvsLUKCuoNmFbvNryiSORz2CMOAOVzrSZvMFSTvW5JWmY9fobYdV6/LlDEyPzhK0xxTRJZv3F6G8zaQgU5eiY8C2aNMRW7AFraB6e5TZRHVmqeqeSxsRU/4BVRESw/1jKc+AeIrKwaKIPK/dNEourEIUUSEWrWIhWlWv7Z8fGLyQmahXyQ5YsBOOopoAwVr4NceqW6Ku0iTpLgx0iwCLWPHyZt+u6+YckgeaBTIpcUNBz2ZTnT9e8APe2cmVZk8twv2lLCfeRDlGQ4bFl0rDnDHabJdCyiBZkYBKkngWTqctEUOq5mwyK41yrbnA0KgbUPn4XaRch7qoB26SWNKz+yNWCoRvgVpYLVk0JsHWZErr/dCERz7RXEsfaqFuF7GXqzhM3cDW7RxsKvAdGv1Z0ZQe0ROLKIPKLEwI0MtYF4m9cSAC6MVJj3aoD+VmIaiEE/0NwFfoODvN6ikDjYS/wcO4Zze7ybL24OnnogviJohASn9eHqJ+7UFTiEBae803LhW97wOPlN2XKras7U9dLcyE5T5JBPb2Jzie7G2PKrIKsDReC8HJ9sIVRKjJf8xp7dP4gxbQLapUquVR+JNbo/Oq2nM6cdHKQm8EEKHiKC1q0mk4RZwBFCXGi5JRO87ZyWms41kKziqZZdO1HzMbUwAmeThpwBhGZlXAxEKTcqwCmsEHVGreoTZh+YS6qdMT7T0ij021GNr4hyxKFpWTLJqazAgHPzmnJzruHBTEAyLi6vu20TJs3naQJqz/ELngDspSkPac6y9kyWgaDzOK/MqDtqNNkHVvpm3SCUljsQf1yY84/qLiVxMALEW6jzFmYalb2YzyydCKbjeXZQuY2DpHY/mSCpADbR2qsLLi+yLAIgcf71BkcUmKzBi8l3ffo808CNNFdYRstLQ/YkQwEHYoO7zo581JL+xlaajz3CRwFsAvs5te2M1oa3JFBTxp0HLGOZtCqUo/V+mkeU7bAlkiGQg3IFc+9CxMqqxvVR2PCC30sNhqQt+sOzgFB4xXK1EI3ueMVoP5dt+x5aiuzHf7eSAwYmgRr6muU6jAo3hMLlVsiLgSvsXBx1DjMiJMvEOkK+ce7izN94QP9R6dVBTgEayIFLTxnGNyBtkhAgUwdwJl24LtdMQNvZpKBgWQ2jJoOLSYyCJlG1aam53XAPSm2r/Z3In2XgVlyyS7L3C0aoAVQgXu5w3fF1XyNijbqm72sJDnVWKBAzPysHhZhdQuW6HZtcaqVh7lUGSzfq4y6taGdlpLYU05GfAocKIcPEarwE9AkjIRRVUh14cD2SdLjzWTnUH9lehigDc+BZ0sLWNMjbB8Kn+3rUJOc0UDSi0jb3InWV/UYKxy/cHrMU6iAtPdQU7PKpqrrm+uOlR7qlLxk8ITO4hXcOcJoco4NNI9kZpyJWtqj6QbKNZOaN90K8c4xODnA6T3CGpkee46jpmn9oijZ8CkC8B7UrHsUcepO0MnkiuizRQEAI7s9l0nxHrn4sGLXl5bRM94YtnNOd+JhbG6UqCACmZl0NWVht3ppJkoxsZqiQTPJ4115kBv9ZpGInLafwAomlHyYRoCvZgAymHpGMwR6B0W+zugH9OfnEK6oAiFqYZMaczkw8jSWj+MilrHI4pgK6OnA/psv0NPRlF6loypHintXu/YeBnNASbN0b+i6nPA6rq33KV6xdBOhmDiErQyGavuvDPArB/a18XArz9gytQs451Y4bZqKU95rKomSAsbkZ/IZy1HyS6sQ3B+aBK51SIzLJVIUHniEUdNA8sBQgCJgD5kpQpzNzUAaQVV263IpQPkkgcXAH7Fg4w3N6ZN7qAnkrU4UKBFcUiVhYFNhEG8YwK/EteK1lxan37SA0Gbo1LWNlua2Dxcq/trqI6G2wsDp+n2eoOcg4Cw+lVch7L5ssT2reaYPbLOxlwJ45RsbcC1NC8qcoHewo+zYl8W2+s9jsiisHIs2lCO1Igdt5JikQyKdSCkZy+2wnoFZM9anAlXNapRnA3CdGyi3kpkB+tGnapTJ9B5RUVyiHmE0UUbrimzISX1k4pd3i/T4vxtDCGigTbZ0R1XVSyMbSfW0JaCPJZFkm/aYPUikVlmx9Z0MIh83wVfy0XRiQc1uzrcbUkna0+qPqYXaRICvtEz/bQCVhVBNbPDuaiqXKzHHuuwvXYiJEXGul1RPQC9TMReYRdjB0Qt85y2c2rWS6dTkaRrdFIv+qOWrsqhy2tYzNv12tLu2u68O9KiqVscqDYfMtUybXdBqvQQEedgg4TWlj5SgTnLmzYfzJIei2jW0LbibPDzTkq2OY4ku/CsV3z7ji9xWhwHMmQ6xQpKZfCUKWFkHnLQ07YMiB23YukxuZ60BHo+4kiWXmJD22UVgba2ckVKCqsSDRVBi7E4ciu3Ywojy4abGgFVJpxiMbfmNNmktc6q4HRQbQV0NivNoAHXcq5OlYnKkuQMdUNt7ChJyV9V8FBnl6TF4Q/gDL5Lj43lmayO4PF4qtxq21krHZZSwEyrYinenodx3FjtgR7WQCQd4YCFOERlaWdr2iglK/QwTp02izdGLtdp7M0UG90yriAP3sdp2FgqqFxE3kqrWL1HnNb+PhCv0fQFExSTA0ArAtb6ugrbieSgBtJZV5gaVHbopk87gioK1FKMHNS5FHBDfeT1CivKsUKI2LKBVmZ7ZLZki0E3G5lygT79FhmJwJ7MXn6MNbTn9aBDm/qBs/F2WMS5iECRd0yv5FVScCNxXx33i4D25JNRLxtpVprrqPBdfbRC6qcuxiUV0M1yK9xmqlURH84ojFJEcbK64Y417e4gmao6Tp9sud3ZxCvUSMNj+yx7lH3d6WXhUjI2UgXAobfn20m14tWh+Ajd6hQRWzrsCYnfPei4GfpPBlNehP4rbLuQfbdIBgBQy+zKCyqkEvJCop2qFT+OE1MZ2djoa6ohMzezQ1b7hRNhIBe1qlo7NU6BWoVO4gT00pVuJ+3STKs0KwOs1OGgsBzhra3YGNQDSqmmyrMYdnGRrD+7giepJDIM06ifjjk+Bqvv2kmSNXI3TIt+nI02glaWBtUgS1RoU52+broJQ7DvVXVItd9m4/MXu28gr01PpqRte0SIFMVHShUG1b3aBR61hNNyvDnMsKA+1J6ETKU8snl/ehi6cZgieO81KNR6mBbDXz5u43rqhpwN+Tmh2GMIV76Y2YUrJqyzNrz4wtOvSNL41nuvBychSoKTyJBahP20oOQrdtcACTCqq5R5EMeFzamjtMOgT/ubrKRScMCGCSE20cUrHseVp3+kACQlfdoidDigjOFAj6hBU4fkbiT/9DxFuA1RVm0MZrPCzYfOy5y2jaAlP89tzhZQbCal08C/SHcVBa4HuoM/uYX2lqTcQ6Up2cZayIDYH1UJYm+/yoUvbHAbJxFWj25XoaJzKuYNywqKWiuGO7hCwW/oXHI6Yjcx7Yy5mqecaGhlIIaxlYhuqgNiaenynkncLHS0Gwqw+xzLsyb3tGFez1IEuL6zjGXWMALcBmZAo+F8FOqPSt2OegWUtUpDdZme0LZ9PgDTkRRCl0+NjnAPWnbhZTpWFsXBRRxxg3bAcNED7XmUSBXYtqa4YfIxO04RZHKiLfG+q4rKvXNgZs6Akoop0mR+cR7MGWQ74DhJinZDx+fC0TJouIWyMnb7eA1XVkTLy82IdiNGxoZyJvwubkV6m6Um/UEgQztXiZVM2naF5ncPD1Cx8theBFuhoCrR6oWjIxUrzFrzg43jk2NuHSvm6KrKwkJvBzt0SUtNeEtUXiTJFujqRmUEnE9YI0spVb+l95WyKWlP8NzxwAc5yFFztB6HR/QV6GYnyaIobjTqGReuGfQHtSqld4XgeGl6UuTM99JqLnQkMFIyBxizqu85YWJ33fFUqL48aS4fj8PE6p/MOa/L3QlGmO2wxS0WWXZHHdmRbugGFGgeNLZT6IGz6Cyb3Y+acFKLyIvDZli1lrAHoj8hASJVxx7IPJVPdJFimW09kTEEtPrKy98FLbDT7bcWF6L5nrOQW7zpLZZkdjGQIVEkNGNtck5qRR5BjBWQacG16Dh4HcMm1wclm3PF2oymM83h3OS3aFPW7vHgTIHNixZtL8pEptuKZJxzDiibpRxyAXPNMQZc3wqXjdsMVcPIX0blIcXEl7wFJVm7KGKfmoG8pKkHEmSZvWwxQZd8GrGiprbL0ERQmtuRsubQ7pkg6clDVLCBAt2ZH3ENXo6yWGVTaX7ap1GbjZ3CXkLVd9N8pXi8SbZdIv9J0cfsLTC8uWypJdOGBagSvu0cubGE/q/ndiKKUHElCaz6GjwOgGPlGAQTtQrBU5yNTAQjo5V9c33bpV3HwVKJEyYUqD1SV2MjI5hpFuO/kPU0SWmACrJbpEVmmcgps3cQuU5VjdulWyinIpy1TuHLmSAv+lJ3oEzZ3AoUtBXnCfsl2BQI2gJSvcaK1qosspaKzKsSI4KmP+ilFp6wQq71pEph2VFcxO3UbnjKJXs/2Ja7KEYaQa8bRb1kQ7PZ11l3Pp6crLf7RQ9Er+FS1EbfanSxJDlg7l4kwNOLhkgCbU95emYgeCPJQRjxWMnXnVvxarR/BemE7by/mPo+GSzCKMpyvb+Tg2dtACeSOrWtJTbMYYUZd+ywlbCeIGuuvdrOFygGmFTLOEmoAFFwhluZekCuTtx0XwLtcrzIJuxIpmndbtkpBYVJUzuNg5TIbed5i0HzHmF3hlv4ZPvCaera5qobRtZ9+8gNlWcuQ6P44afud5vaauoiAk2QbYui5lbsVgcbzh/PuQ4WNeLccNen4zQcrY6tba2b7e1QUx7jnvaYAuW9rEjMvKOHTHs5qH4e53k/TzqZ03SscdsmLzaVdQTdM9jEGZekRXJ0YWEKZ5MVmDfmsgjOTHArLfkm1C7PcIBjjOhJSJvEW8s7ANJZDBgUT+ByqrvNw+KRaBvabIw0WbN51kG4bYDShJjzAYU7ZVw5hIh4GDK+Kw7JZkzkvhBG/82SIqFUDWEqe3uez3HqmlHQCvvaqUvFYd6CaKYolE6XyNQMZSnaG6dZAXDTS2SftuNCkbpWmGLOWNoX9/dth99Bcpkmc3dMBKpDT9DxDMYSrg6d9+BfQQTsDXK8GNWNKnRkudgdiBFlV6GwOJiSUUjeQArw1TLT5IAiwtjtWwZudRHgqV1grHJdnA3siC2eoP1B1KiTtyctyIiEswDk1Ya0x8nJGM6HVqyyzMQuCY76I2q6ftQfm3BAd6NEjNa8ADrPfqs1H6f9fHKc3IdgKwcWQxw5Oi7NpiFkGw6JSddi6SoORMRcdml/OUV39KFDCixCm70lt8ipMFHQqnBtDsufl5oDL2Tbz5OBpaDh+zrqZlR/g2q+57ayORWsaPYsJxadVrq26nUGSR4C4NUjLl7eIsm2wJBEpIDxhLzVagVLT7dH6Qu0r0G9sT+Oe/12jar6++1uD2tbvfETFLg4rzmgOc1T5bih58/Wmg/isfz6Lm3FXOWjL2UCVc5EMHAl1OH26ElXD5jCUrpwspy8raSUhw8YR06K4mlVwmGIz2Nie6xH26oeASn7MF6nm1BC2EIv3j877VSkCTdbgVB77FEMwH/qay0rehTuRxhEyhd+0r4Paa6XeYdpc9IVmDQZD7IJasnZAeESV6ro5cSpPB8CH+Mgl43IyE9jkj2BlexAtw0FMw8yZDcEiGx9y83z5EU+jE0oChOiwIhGdjvy+9PYA7GqSLdqy0Fe+/+Ie7NeS7LsPGwPEXGGO+RYVVnV7CLFltnstkFCpDjA4IPpBwOCbcjmqwG9CwIE+C/45xgwBL4ZAvwoELIAW6RlUc2hq4vd1TVkVuYdzxARe2/vtb611o5zM6ubtEg7Wcy+ee+550Ts2HsN3/rWtw6DH9zLYQxjYOk3ZodU7x3JqgxH51+N225Vv3dWE6KY+2qS78ruSBfy6raeJLL8EzUYxFSfyCbVuKce/mrQaizx5ac3Xk3kQHT/mrtRPDmcU3K4Pu/7bde5+B8j01YNVo22Ove9Vc3Y67ruKFUmJe+68V+lap7K4ydhvHXl1ape6OE4JhrEQC3BdSF/+cPna1++eH1Tr7hbx3oIyZreShcSFpr46+ypJlZ+jdf+8/99qqft/v5Yn8whFZqezfsbYfV3fum8vuyuGvSLun7d3PFzf953H3Vfb+R5+BekAPKSejFks5dc17u7rulRIki+Zqh1P72Jc42QD9fTYXe4uFilXb55tXv/8Xmpu+2qXF8f+y5enPevf7rvsn/6ePv6euySf3oxuJvqiGbpca9OrLqurtv752X1tXvR/7R/tFu/mKYwfb31VGf5UxrKNtHm/fE9MWVrLmw68SiyEMc2CDBHJfVx6td+8ziuL/zZ038Zutt+8znX+ceSh9jfxo7G6tal44GB/MUhJ21IRrdm13P/12Gm5kK/5Znpo389849i3SgdO7dCHOhUMobd01R0YlTx5f2tQAzv/MN5TuYW8Z+RHGgTzeLP4EhEnC6b6BnMzMynm5v/NaxXv/Tiu5+/+avbmyt7CwKz+tYuzZPeU/Ud9W9CG/lBMGmAWAVUy54KvXk5gaHe/lOP+vjmsK5RUA7HMg8ljONclzcdmLmW3e4wd+c1jEpjmkMKeceNrlRrlgCK2kZJV4rrkl2wFnTPPG0pK2eBSNuEXWmOdJZy8vl4d0Ny1l9Hs3rGlJRZqgpkvsZ0/On+o3F7saKWqO5YParnTmf+AL6GGm6cv6xWc1hRU2QYaDn7muPtN5RyUjbc+alu8FB2sSDuGxI+PcuKuw4N7MS9OlBYVPcezQDd00fc30x10/Z93JwRhYAnFlN0+f8C6+w2Uzju5ppAuc4/8avNun/zZn88TP3sf+HxxesYv6IuXcKVagZEA/zYj9TDsSNOIy3mQKr4HEJntOP5vqOhWHRjE4pRZbjM8f1+/0NSBSBRBi4ikgwLV3G6ob/4oP/6g8xLUC1Fv89un1OgCnuoEfWYph4aBZ0/HtL+OD7pyIxevzmsYnhyubm+3h9fH58/OfOkgHx4sl2vh+71LdmeanbjPuwn3/fEnyRC5jgGT/TttDqbV/71ur+fn+/C85fr6ntW/us/itzuBWXk+tQ/f/3fxbuP6BlMmGxUA7gU47/y3Z97JdfVG6r7oVrEK+7reXN9U+/s8aOLGmrd3e+vrm/OttsaXV3d3G76+J3fBZH33UkcHiL3HsRqgFBeYTDYI1kAc4c3NHnx2FO7BHcvkf2vWQlz6Dwf4MJjV8T1UUsTxQJ/h1PjMZgDg2EkmeHydFGTI9w0jkradi1u/XUebiIVds7D4TjltZ/XuRqJYbOa+5RuU+Rm5svD+T/4+B/99vfdD37yb3762V/e/PTHx3mmjsobevdqsY+Oymf1CqrBi8nPNTsgKmycaxx+yH4Ih1j3z7T6uJ5FogITCYtaeYhE6jvizbqh2pgSX/nh5fz0bmARO8/kcLc7MgN+jtx+F/Lt9Pgu3Bbqd6p7lZzDTJW4SPSg8ZCIt3KTxu2TdTznoTiEl5EFqcfg/Mm64w6TeqHENIph4AP8Nz3CGoWxH2KpBfsRPfqNrzs9PRvGn5TrbV2QUD4Rdhif1wyItgzh/nndSSkPuW6Vepq7voBUwSXluJm3a1IUymccFSLenLk7Rae7ON6fC95JESuMHBatHbfjkQC+e9oe5D4JmO4pk6U9Cv7jz7n/7snruDvmcl+v0eVNjaCpO3QbB/8oHM79vE/lyomhp55yajGvzzBdva4ZWEeBmP/6vqaONDUoslupOU+9VJqrTjQ6bu04D5vHXc8pN9ogkKhP89St/Le/t/WT++CXL/Y3x2PNyI75/Y8ur7/e766PH2zP6ol9fTWVqTyvEREdQn9/zNf36fyxq1HS4XXpzx1VAPfdcZVniEY8j1dnNfB+fz4rY42o3LOw/qh+5Gf3x1C+RwIE1fDs3+9314fDex1plfgpkWehOiNd5L+OnKUiVaMm2/5Vvxq2j/4CUo399tMYj/P+Ztr56b6U637ou2maD4kqeh0vkWPwoh+6iasscJ6FZ5lwS/nP3oJhUDIRNwl7pjXSrVU3wERTiMy44SJ0T+f6Kb4elwCpQae9appPhf+PBYuFtFTt5v5uotYlamlITPoW9SwhKvCohXp5w6qjKnO1F9QdkfvbuhM7IuNcUw4yRHeY6oYmP0GqituZQtrrcDn/vf3ukL74yTlBAI6Xmf5w/gUCEXUxE+kjdPk4DShDHsul717t3dMfxbFGnaRMQKeyWsr9cSa5msHd7o9nq9XGRWrJf9QduA2VmcFlf+C2Tu5sp0TuwA0AmK5Fg5Aj0W5nqjKVeogcDePpd+68PqwrFjxi3Yvs4tV+v70b6tvEobtLx/B0+PBbF1OgNqm6fVIfdleksbTe9kAAkExSY0B1ReWva9Xokqm9pKxvwtinN+OBkCkSfCAq5VAjHNHSqt8Yhw9PiAeoOdjj6jizrr/xzg+CMEDSCBHhnnPSnabYHMbNNikCMQOJ+BbVUFIqQISRWD0HxcLp3ffYffktntRRVqRIFf3XNYL+cI0jdVfTxkflKStZPi59cf3+x305UPT0yZcvBxa9o47HDHWQapsjGylCf6A1Xl9ZX7CZ/O4n+Trlm7sdHCwR+1n4aN11j6ori/HJj9zqGK/3NMHt7Cs/HoNbr1LvhqGeyT734SU5Q7KYu7sX19vz+02fJ39/9h1qx61R7qGaq1/sKY0kSzO/Sq5cVsM6szcYeAYJyw9Qf25kWzQMu2H9Z+hFpSJLt1uff1Gf5GdXI8fLIqtQr+fZx3+4efTwUQ01e34W96983jkPq8CDLXoexny+WT1Z9zO6XLn6+/6vcZuhf8QDUX4WLM04aA2UqEAj4CvjgHBTLFBBR70j5S8Ks0n+i+LBjArdz9nFRdEj/1ZWdrLZ3/q9omdAp7mcpFSyL+W26pXeXR0OR8dtCYxSq++lrDbI7ucuDDdydrGvN3U+1W+sVxQnrG/dMJHjoFnem8CVKoqVDqu765uvtpsnwzDkTbx9Tu8dx7x71G5OdvboSGuCOIEj18ECo/fki+bbalPcaj3klCA5UO3dZrtikQ33/tn5MeXduhzXfnc26Wog8+KZvlzIp+GAT8KYqCeEda/45wSrU6sWYQA1+t25uO4TyXeRpiOh1APlZXHvq4G73Kxqwlj95tnoLiY30JxMEp7dHadNjl/udquncX3BFK2xHFg0rkzpdkXtQZsaqG/j8foYh9htuunA4HGNObo8hL6GosR1eDVTf2jvDm5c74knJY8PuldgXTGDtC7mg8cd4t/AydFz5J6tv5U/JbV96VeewIHSLqYrHfZh+xYyO2pJOeup3S9N3OHvN5c1o6rJPNHhwHZF61B1oswSCz3PY6yxBvfiFSovcsB5Q8XWiQuohWdeAwjNNYzrqlP9xf6Qn3w6E0HgWJOx3Xc/G9NwGadDf7z9xcKczHF3ltMHHcPJGLoz9mKMOgrp66ffrocDserqLa1/UsIdES/ImNJ23l58KuSgcDtsXv685Z+L4q2EKp4KCMzTqZ5AdJv3iKOSb+oeoSbEO2b+XV6c3zsqkgbAE7yT2awXljMQ98V5H2lOLEElz1Ua/g3OnCI1OcGA0sJH1KeQAuhvFQL+T6zM0hj502/asfZqhpx7+Lv6GvKcM5S/CRGjbt0poX/IL8sOQ0CRKNcwqJ/qrx9HJKnqqIPcY+yhAE4RFnekUsiJoZOoKyWKq/z9I7cTnYSTaez1tP/pH/3LIW67zcWb+ev7M17M83fc97hB7mnCmMA9+Z/n3RcE1TYC2vKVpP9w+rnSVyeJD0pvdCumskmo2ZjLwl5SVXHOda0IpJ8Ld8Z2AHvIgz7bHIqfCIXONRWsHxjWfkI3VkndNu53aUhhtXdrIiHQ726rq8r++n4cvzg+Oe8fXaxvd4dLxsoO/bSZS7cajtNY09luKHfTsXfdikMIyn/79bwKx/PEY6ITTS2hq0sDiSAGoKv/fw0BeMefRWLI+BHvn0jrl4+lyyGNL+fDfozsW6orv7olqPZsjE+fDjXbu72rMa5/vBnWgz/c7if6lX67Wdf/Xl/dOHKJ1Cny9MnjugqHw7g/kOQKZI9YUi1DoYKGCOWyfvRfxeHJ+blLxxdxeFbz9p9+mefjI5pM2EdUkSlU6cLMBGWumRxZ6SRsz/8qxH3c/BCAZog33fpzAbnjLsTDf8wqLdaLEgTHhAYkMceak8QEjgxRDbUnFNGMP6tXM/S7Ffsu0SJhNd66LahimLupv0yvPrt1ojfnQcnhI0rh0jSyvY8eY3vA06lm+p0R+CLSWXwX/1wEbsW3Y+YfvOztvenf/U+ehE7lsONh5jy0kJwOTFhGb3mRGlmPwkk5TMfuwqHa5Ryq7J5bQbnrEAkgC4gO6w7dYDzTWDoE7e5OLmfxz/qCcXM1u+vD/Pm1P/rl3TVFZfzr5Bf9chXeii0ffITSRd3yevy7ok5lmVczEd/+6drUVFgJLqe3Ylpf1k8Iov88zqzzITOcC/Xcb44j9WyQ6gSRr/xqzDU4qGlEyiQnvaW2m7rMvmPZxZBqgEW4ej6mNYm5EfGKBtavV/Udbi9ZzqRmsgnzBFW7pOuY3fq3SJ/6O/lT2L/QOr//l/3Lq2NMNWj15ySyGO93x1U9NDUO31AtpW5G17urdV5Xm//E9YdVOXbv9U/rqbq927PgdZFWLI53XNPY40aFeuBHCrpq/khsz/VvbTYfu3CTVrRqfThuz36cqyWiPHnuN58UyK23PvgfiL4FRzx/h2iMfghFhYkiQRaTpBCy77tBsmTX8MXCbas1dzvWYzu5Lb388dM4nFGo6QNpLu+uZx4HkPoiG8LGizQWNaZec+jklU9on7U8Mw8SyQffeceRe2DUFi9bnsmHy1AELWflHIoa6m1ysZySO3qsbKSod4+DTdL/OtBWomEaLFbHFa2IyJRIjpSs1F/i8llkUV3SpPcob/Vc2RQ1HgHAxN+/+1EH9yqM7p0vOP2Ot9tcKGHxF+Wt77xjid7++u0/bxtWUE8WP1XEju49Pnimy+d4csFgcnR+PKuxl8V9hRzy886Xrn7xcp9YgDFR7EG/L5xXiRVi2KU0VnsZcNbbPRZJCklyHiQMFK9dWdisb1iZh+v2Ta9/5+/+Lf3p9k9K2fbzUMb58pP8mMRDzt8jetPd34u3dOc1xZl3351f5tWatBCn/QdPh3/R+R+yxN0c4rOhv1mvV9c3d6isMY+UFVSwMvqH+GNd+OA7/8v6bD1svvybX+rfmW706WNIrBYvJpOj5XomD/eSPiTUjPnvojP4KBt6lGtqQzxADp3oB2vSxjGsB6RB+xywkN1bbvxkG5zalLdNzAMj9U2/8vafdwYUrAWUiGHENWnksYyaU2EI8DkYSVgHYUhOGPdU5i48OXQrahivljseJ8IK/eDTypU91R18tU3UssWnpetqvlSdZE2WamxfvWPv+zzM3UVHolUpRVdNGkkWx1UsBOFRSWc+5CCVBb36yFlnF1SXj/FaBzwR2kFkJWuc2G87Uoh0rOAxUzXz29/6+13oP7/6tJpcMq+kuUK/RR0dwIBYyZ2V0YK0joG8+E37qPysp/nwIZaH33Tf5D8efJ+/Tlu7ELsgnbtFFYLUjKDtbl4hGefFVSV6rCmthoE0+n37xBP787Zx1y9OPOhbV/jOw/WNVuyvZ+NqDNn9+dV/O+6ez+OTGu50nkZXz6zYT9EX6eD6kWWh66MMhJ4OXTzcl3+03v5w7qZn3yl+ft0f/8/6C6/fXBMhngvnmGhS14PUeOfy9Bc226fdxfMVyRUM185du7+NP8uiQ1hiQLZAP9vwv7WIDA/zXFXZoI6NbLy9Ovg+Fy3NI6PhYTosit15/oJ4gwLEAAJTjXa8P7GZvwFrf/BNgxPKMqdbfPHuZ7kMncrpLZ+87l3fQNqiqvzHHeua1/AoFZErZoIFFQGikYYC921QFVztGj2Q+rJqkjb3gWaZBZJYnm8p6ogHYuESVdoRxXegUSB9NUPbIY5z7ge/Geg7AOLHHNc0LqbcHmoSNG+7eH/M4dyNg59flHDejTdj3bq+9/lu2ryKU5nOhyH5fL9K3VUOFyFvgjtWF9KRHPu+PL2jPplpnKoZrVez2nQHn59fPv3t3/uDr978qK+7fvb//v/4V599/oOyy90qvLnfdTXGWZV6+V21tGfd4Xiotzb4bp+O1c7e3B/cNmwfram+mWZ3bJW7JVfj3Wv+Mw8nB7PN2GCAyElEZtnuaQpsn86dI99wZGTSBG3RmcWUdG5zsKvCfniHJXrwhRcj6N4GKN65vX8+lfitdTv9Hh2o7Lp8+5t1Y0aOFOjQrd505dBtPu/7O5RUfbjrN5913TGuXs77b3frn/hFu+x0E+5+RNNimYGGTQv8hI76NFMZ8fzp8PTb7yYVt9aTdz1RxKuQ82ZyMLF7oSqF38XJ5CEqYjKYM6lRuDvxG+15l5MvHGu9I/Hh9xSYjylhFBCwHHOHo0sHkmMjnK2AyYGMGb9tLNo/RY98ufxvfWF7dPnrC0T8Z6Unyhl/uDn8N77Y0WSeGkqQUmjaUxUZcFJN3LeXsXreaoMGfWiUGB5JrNErbkU54zHVF4C1wCJ/NTan1/rJxQM119TYaCLRGb5xzwFP59Z957jDedV3x0IMvsfbdd0n3oVtT34u1fjLBWj+DY7EMOsGeFZfk/z1m/Hitlt19SLrS+Lt3f58Qy6C6oejO++H9V2NpZz/OpMoB7HBIiWg7HQz0R7DtuspIjz6p6vV9V/85d2vXT+7/DbXbsqZO/v1X/n99z7+le355b/+X//n1z/54TAG1ulw5aYMU7zcrqopOMvrevfhLl75aftBta3janQvwzFv3dnFJi61rt4RLklI/s6DwAEsWQ9GS7O2FMKAmNILpSlBZkc4EFBzbhspsQgaIf2JQ1lNKHHKSNGf5m+CVqrFlaA4HLdtL82lQwHdWwOrfYzsop8byy/u/eF3aBdFnqpXMvrqaqRco+nAsouJcttQb2bYDKQpsOlr6FtdSPfs2/+i335iHxnivQ/zN31qv/30wXfCKm+/5eYb9+zp4+owr65voUsfikx1D0TI80iI0JFQitqaxSPk6BvcSLKjVHZhkJIm7KCkwU0M67PeDBwRefrQr7pgyCcs/TdgBG+v7CIqAXjk2CQl0nLp687OKHJdPFmvL5hFE/2J8zm1O61mZmahhUjlRBzWDBk7DeBND3f5EiB/u4bzIH70J7/6zu0itaDF5ddgN+7K7qMaVHt5P6+KQKuuX7VfqM8iLuimYqRY8KQaevqRdIfwZazd/oKgSC628eg2VrZnCqu7D3OkXlwal1Xf8X6YA0+3YDmQzILIrtvzZiYCQECf7219QNWUXedY87fJEf7i8uPzVfJ+vyLiJw3vc6kQ3ZG4TnGkfe+pOay+c7l9TP6HOKLFo/B7W1Ifr3708v/+zvDrn7364QdPvp3WXb998vLHn66ff3hTt95ZuS8zzawpub8v6832yAPB6sZI01ivbTvG7U3ZVKPqyv3VOK/y7ZNdvOy2G+Y3ueZ4Fk/JN46/b9tGird0QNgxszlBhRoemqRrrDJLV1TqAR73x83FmidIkgiM60pcd9M89dUo179jX600Delg44eOSBKmgviPp95sskTM8hvHfHMzXT46P1wd1s/W8+vD+9PZ67SLF0P8avTnq5q495uOuCDB72nmClHWqG3jg/Xtl7eri7MxHYfYzYGkuuuPS3WFvku7efV4fbw/9P1Qr7Ze8+HusLnczJ6exZSmgXqlffVMm7E7fLUPF6t0e3ixO//66m6zIW2tuZ7K1TzcpNX5sCev5rvN43/r/kZ/2igpPpB1mS5y2vsawieepIIfRhZ3IDmMkm5e72dSIpDIyKNpITBOxNWx4CXcQaMmcq4VK2Sz2aKjQNR+lSu0k+/eMu1LEOek3KMbBSyFJWLNhTmKzvDPOck4P3SuUjMfzQ2Ky5hM4j42N6DekboO6t3BmTsEso7Y0z7RgiBIL7S6ntpuk2dp7ss2uaxPy3vLEmh4kG2c3KN76Np9zXby8bHLY/GuRXMLIKa9Ka1AH4vOn6tPxMQkCbHSk2l+CKezpNa46zX+xg8jNwlRkynNgGTGW6Q9jo9Nl0VUXAwwLlwi2sYroRxM3Mxff5SOK7X4bDJ1nWXC0rJtkVpWF3b9WMonP/6/xjf7f/PT/+33/pP/+qa///aLZ7F86/7+vjxZveoh2sHv8J4j8StZYP5i6tavSA6Xp7qTdkA8hovPy/QqhffT+WU8PnHHl7tDcvG871ktE9fWnJ36LcRAVDgewvqsG6lHmXLe1dDvd4fy0tWNeYBq5zjNNckuU011Dz/ZP0pDf5aIykCSbNWUhikf+po7V6tds/e162nioB8PpEyTGRAsnWeOvuOIF4AKzR+vp7T/0Xw+jN1c/FfjsK+ByPw4D5u76r7O3E0cp7AZwjiXejHd/tjRpKNynEL/xXRRHdRXpV4ZiVOQ3m1/d3dfw15CvH23O+y2Q9cNaU+FpbTdx9V52B/oKa4nf/ae/+rV7Wa1vnDzcAj5p/VeBtenbT2NE52uGr36Y+i787Kbh0zN5N07CDun/nxpFzKb+/GQRFEoFeW1zu485mNeP6u729GShbTmSQIUlMY8Hjlx0xYqVO4DvuD4NurZfhAQdf1DXri2WT20VmXhuE5+auGPpmbtXnU0lM3JBC5mgwhtWiSyUQbpEtzgPCa0pLaONmEGO9g+kv4KAVbJ8sLl1S5yvWakFsbLm43LC9JmC7hwBNS0tPzxQZq5sGEnnIb6zFgj0wASI0CocGZbvaUmn2fJc5mGg9TYaYDmmqmd53yytfiMkP1htKemkJZT+EVV9MTuLtcHnb2RGtT1OWZxAIslWxoCp17KO4GRH0Sg9aF/+fWPb15/7Xv3Z//hj+pZH47+LDy7fPJ8d/gMi6/v0N5N96U/vIik5kFZr/PP1/GrqbxKw5Qu3vj+zg2fpfdWZz9+fbtf7faPw+r5cPlsM5GOU+B5jyzCwxUqCiO7OI7H7Xq9+/Pby7ue9JJrYt2n1d4f74nfX8Z63Kv7H3aU3IaBCoOR9MQP85o4cNSGTGduruEDjRpd1WM/uakGPIcaKca+i6RlWvPe2b3hZ0DNQ1zHoPA55bXz52Goj6yGuWVXNuttDKUb+jTPLF1DRm5i4b9Cc7q2I+mU5hWVd33N8feH42boQB2v0eCTi+1u5JEfnjLQniein6HVbLMpVJGkCY6pBiW37jKvz3I31nXbro/E2shXYR7WNfuee+ptoHDAD2kk3WNSGOzekUi8K2aRVI47g7ilUuwCU0JyCWPu6m3lvitZOjCZWESkAC+AdBCsGhQk0I4ACT2wR4t/nMCKerBPThe9IjQjBU6jW4RXJ2ZXUzOja8PtZyhB8+6v6cYEOhUXiWuisrumsm+WFvksYoOL8ybdMDZdmZorA1fWHN8pX3m2y5XuGYW6qRNw6fm9lzyhge4Ly1ssstIDZKZwidPhfx4eUTuEtrxFMMSiMaDTftolHLb0IuYYBMjzQlBY+jkYNe9Orsqdmmynz2sZhS2ioeWzk+vh0y3R78mesZ+Wxe+ao11UtU6sYaGOkHsa1eBedq/rlfzg039XA55NWV+dXS9GLsiLF3GurZ6+Ye/dtwb3XilfTnlXtitqNqxxhUtus4tl59zV/OQYX9/tu/Mh3NfPoKCpn93qbKDm0K1b++7RX+VHx23dP9f7A/U1Ek1/M7r7wmMmCA7mexsiV0a77rji6Sox7tmg7DO1FtX3JCCl1BeR7HLH453nAnSDZLxrJshnWeJdTyrpkZL+la8XQTMXSpo24/y8fvPo2p0iricnVA1tdyxocanZ71U+xieBtFfoNYntYBl2uYYix6kuRTdShhTmekPTuFnPNG+4Wq49VWMnHzfn62ka04vui2o9Qq7n7LjyHEG7Vuv0AKno77/WONYijbYFNX6Gk6RZBHGWtIajVFQoHxRUKIIkSfBQaAYr9IOccgxtPjlmuqU0cjixVnZmWuFsGQ1Ih7syeXStYUML+MccGybtyXQ6NNBMId0dASjUV0RrlvP97ewPBQlR8Dr53Yt5gv0Va6VMdA6vRAdGzluAMfXNmOL6gxgRC8TsZCxL4MWdhI0LWyBRlySbhm0pnHcCutEFlfLW7D9IpwNiacf51OLTjSxGki8gOXUhD7aLPzFhS2P3IPIti4DIqyMCTJBFzllvR0vuZqCbGeW/mn33XlUQ2nLJoMLy8Hps9abzIxFT3dFS43YLQW1WaY/vIa44+PDt4TC7r3LiTXWMcchfjkTpHGN5OT91q23ujnOp2c2Rus+IWzXXfO1lHphYG9b90fG4k1Jj+Xk1lFuaEOKnCZadHGjhwXLUj0GdXqwL2GOc7vJyOPnlLYeOLhockogGTG1JnENQocyzeBRZoPn1OUl562nN/nYikgA128lWd7yTC9uM3MsZm0jI36OVQ7Z2oXk/hw1n087dEw0PS13vwd8DH0emz4OoHHh6pNFZk3SEzPJGcjryCV/kxGAhjHJagAPXBsQcfIHiAoSBeC2yGRcSvR+oOQMdrcxO4gFyJCfGCSDbr1YSXKDjDze3qdBqJKKTMvU4OCRDoqilfrUoyM1fspYV93kVlE6aBpti/3IxvrWVMz0y0OA5PXTV/8zjTMFvzd7VJAFl85zJmpHCF6B0L21KC0+8oVQO3ctOD1KRvg7fioqnoaIvDy2Ivqc/ibAW1HZJIYOSp2GYzA+0j5bjugi+ytuAV2lO4CSSOsnErNDg5EhrJFRMaVrQHH0bNZ5t3sGD9M3M9fJznWsey4yVObDMzQgn2MJbtltC1AfJRHvPhXldWES75ROKicHn0MCiwdsSAPsP+vBel75M/g2Nj6pnYCKpNeKpU1LNugc1SJlImGh14w+HzXh/QUeZfWq4L/msbOru7afMLT4ZR1JEtVArJ/UOzY6XqKdrF2zXz+o3lJPWQ8kqdfX4z8SUDuX29p4IzNBBJQvFiT9L8dHMlBgwgZj4Q+A5q0oE5Bp8g12Llb9KbhdwsnWxTbJ9XU5fcwLawM04uMwaWY7HWaIkLaYyOZCWgOUTlUCg9QwOmhzsOisLhNjLAebmZ80k9EgrAVPR4kV8cbKa3umZUO+1+BEsIwgp9iMs0SJ/8Rz40XPlR1gMaJM6bubACgTOLDQrKSfzcEZY4Ri2qObiMUzzfEbDFqPdTuDHhjZAImF1onjrmR1ezfoij/MwCthLuH72G2oAnPl8RZ+CPGYXLO9zbzO/5d303peVhBODEpCKSuyi9kJs3MK84JDLNx+EDuoJWtDE1pb+kbOaRd9ud5nPWp20LYhGTI1jyTfRwha5HayLb3V3O35elmiJDZLKVdbrlzUUG7pMt8tiPReVjGavT21W8RbzLd5BXmOn0Z7jae5sVxw/7OYP+y9rBDbO1VrwJLDA6RWwwdR34Srtp5WYbykGBoAd3DG6ctxgvXC6iUdRa4qjqY9mzEn4vWJMbVcEAJ+ewRx6ESHhNcAa/Oasl7OQ8L4L0RhVheQSmciZ4ix0hGZGDlBkHVn3AD6SWrnbHhb4wmKQhfUqp7749GE1AIR1Krr766MEFwidirzQy2cLE9JaRiiMigKZo0ub3bgZkKUBav/kRl51zyewQoElkp+E9uvLvMl+tNxP9jboMMgq5MgTW3XNi9P/2CJPWR4zP488SwGZR5k54bY4Sp2HjrRBitDEgl2TpLKCWknsU+0UFSI03rSTCVQFhNIQW9hepP54WtODAbKIDFVI+dHCBMD609XbdCKLE806CPit0668XVVRK6X5VIFRU9xMDACdhzaBwVr8PE9b1oqcehR7sgjojDdn6k5qN82A8Aer2VruUj555meXF1Ba9ORbMmkRojm/op+7xA3CSdxkMaDXTej0cSymHC9CllLMnzT3YZ5f70d3riIS5rmzhmRTL7fBNBLJWCkVpaa25iDmGZrxjvRAeWd6TfhBfZA4CyKo7aZkJASSxxNYUyPBYEUtNjjV1tScLPCIbDRpCDyycPCQDKE4IGHdMzQ2uJmX2/Spa7upPIPNB9i6TWaVzP/UkovIpa6coiVOi+lFrdwyqu2aMYZVQuDnvSU+USJDyW/f5jo2h6zpRqut6MNebPpTdNb5Jvf80Ei9ZWWXWaPEnGSVpmOeKUt1kFtseaugHj5rH4mHUBVYc4Ae4edsj3lf83matly/6kq/yf2ZDysHOSrms9HkSKxemtJxL9w85NstzsD+oKoCGdPAnQP0DnhNkd2TjYTVlCcZPw6AHhYWvAUXGo8hErHHvFgle9oWYWlYJ6cwaxpoXzsFskNQgokuSlttBb/FXFh4pWEInjLejbsF9SwV355mm6Iht1YWz5SMW3C5FShsZNGS6mEhdtt3LKwKc+bFRIr8opjpxb34FlTKevp8YnbRRerUd9tl8D0Gv7hivEzNuTNX0e63IDk1I6gUnuIEE1guMqniTZzQsqXAO4iQfCpL+160zaOIgrPsdgWULbYS447NWQrwJvld77QEmNJKgyY0NsBy5aSmk6elGdvOVFJLQhk8+0mkR7CxDRfyHIVJgBZOV0YCHbf0Wm/l6Lx7SvP03bDuDDkWk+QbwiqZ6kOAaeHQlv1TC5OytCzO7Nei5vXANvnTH+l3Guhjp3QJ/GK3KKzIMbNu2a5HexD5K8cDlxAbC1rE8MoCc9XtWu/9fGRjPXd4hKYHpwtNbdwHCqeC3atf7AxV+HaguqTqhMrMCnacNkqSqHq+Wn7xttftLHlLc+yjvcYFVtFf1Bkaq0BLoRrXsNmyGGf5nu1rPKCgSDasUvG6tx5cRjG/Z2ZXXoMZXCdmyLckbjH1p+2B037gXE5+sVkD7yx2gzVUfNNM52JfJHxnmS36lg82y7KIszSjdLpEils3LwSjsCjjFs0n7Z2hlrUM0nDv7cgV8wEnl0EfCh05wl5pgGjQijwkMZwJHwvcKUqexVo+krRqyMNiECOAo0NpB3/46tKP94U7JeXhsn3pyEYydBsKl17YmUFuG10cHGrJJ86jwNnqL9q2dEz5xtvStEKqUdLfjG5rXhKWpkI3j5M42lCJlqQt9l53/nh9YlZaVcu3NMS/bZga2mroxLLm8vBPQ53KO+1dKSdv66V01Up++hFmbB3QEMDnPKfbQ2jL0kNO1PWJygaT/xf1fq/+Mkg4GdRIMe64UJginZzCA1fywna45dJ6lYiBiltk+SO6DMLFAmJ7x0IFhoK3h0SRRWDyl9fgS82OrsPSpuPcsoDPMphq84qWVskZaCgImn7hGqIpuYwi/QigHvxZlA4kkiJbcCrG0joo7QJON09Z9KC9808Dhb5hvmFY9NY9KERIkIW0VN8Oyaleg33tNcmURcCaL6/ZGUJmHkJMV1EbxBebFbExc7/4LXMt+ibyD+W0iu2TyR2e9551btIsgEIyobBEbOyzytRIoMTiiJgUa7iVN8SGP6vrYr8S/fhuyJtnMU+ULcx5R6aflqCMxxkgBuALXCeRxQyG7/zAosYS5gM15khQZgs5iC9bJOhhaoERU54zS7r2INnC4cyutExQjxVjEIvtVyMsv8jveT3KEnR0xTUvsqghmYuwSLosAFGUwHJLR2UrlOZf1EGJfWz2SMo9rj3aJTrW3LVn8nNgpd2eVB9J6EfBODxLdOTi03AxiLnqN0iIqoMB8YomKm7ITyvPEmXj5MyTtcJrOpZaqI/yyiKsFE4/bT5Cyog62zGJNLOSFNiwUkEwsGnxdQl60dzhyfFRMVYtDE0TFw1cQS7SQoDBdqfHDKNcFFTK7WHRmG6hZbYjTRuRreHSZCxiARk+JundAoYXX2QFQ6/H0qp8QeyvGrhWZHm7NClE3KXZNfO6YKhZZORtIkNunFuxTaTjCHCtZbjydUenDvvRB9dw76AJicawzuJZ1/yoxVtOw9Wl2ZLWj5OGvlYhoRsUi+Pt0ctQNwIxCg2eoUo3cZwCV+3rpRI+E/mJzTnwdHnabDTGuDgBHxX2lZkgrtW+gh+cnALug04SQ2Q3T9ixgW/Ei2PA4nByF2Y/h1ZJY7kRCgkDDhLAfuI2qd3Rp29PByUv7GQ1BRq8hoUP04i1QYTFFtZ3EsYt8vWTfM6LCTRXs8SwbANZZG7O3HQ6JVl1GuEY30j5issPVMxPN43Xmpory+q73SSKu0AfGb1yMsptIR299MxMROARJlFYYCIFG7jeSbOsBZVnnFaSPtqUUY5lTiCeQPC/HR4m62PEvUrxqaC11SvYSkaZBKVYsh3IZH3gXjsWZayubO5yGihJxQXdFXIw2JI/CJqMj1C8gnp6UyfRSkGIF5RtkXNT9eYZlHIwLQzx7c3YyCopw4IUDhwye1Q1dthlLMPK3Fp97otNAO0TSayWhsl6BpoJk8ckRz345v+N3IVXRak2Fr14BbwgXi5Hy/B7hjj19gFZluXXTnJmff76jGA0DR9cRFtefrR0ISUVC9L1KSivhcEZknjVu5sxdgRGQUaQOLTcUju6dSl62Bpn1kcCrsgygCy2Q7rA1I1jNcFiAxAXnETNPrwAb0p3YDtF7+xlYZmALTs/EeC7RA/ESvDXdGQWtEqJxXSzWTiifmIJGbX174xCYp9j/+u4bu3arpBvt8eQF/VAUV/xFiUZBv8gPnL62a7Rcyxybg23Lbp2un3VluWlsJz2uCO4EqxdLSyyg7oaPY9+gBGxPl5YFoeJuzmzteKojc5S6TpFVfXo0hWw2pwZbt8Ijc08wcKCmQUoirSjpceoaG89VsbjzYkXbs3DC76ChJM4qPp9fYCNm2YJINycZJfL3Kd4W41WDsyAfs3uFWCXLfXWkSinXzsGermdUE0GD+lBS1MxBVHHq1GEA+F0sJW4IyUENqSiWYqFD1vUUmmhIEjbvFAWohks7yK5U415lFjkADRijT1Tr4EAdmCaYZpV1Jzme+cWREny7gWx1to3ZhRlhUexK3JeHE4h3WoglRsqrFtIDra6BEoCaiRe7RTpZLiw6oI0WrjQ88pTOsZPIUaENhyXabSGKIar+YRCJI6aWBOJvG/mH8F9SufZlPW8arzvvIJNNpheDHVRFiHvZic50eIhqhlRZFdQ47JMmtpjtNxC069lPgcsEotP+kXcS9+CeSszwgDApZj5swi5nVjDI9rQJr8M9xd+RmdMKhFBt4vdlIw5864lrpJEODHhQuGpL6B4GC6RpL81mPfVNCDWLIpN0DDy3lkwJQwDGtWXEZWgKYeYVetWv7fbk3rKaWYE5l4jH7HeproRhFSiNtMJp9/iDs8BS4sxxVjk0kKnVJy2VcuyZ827pHRVwkJsq+X01KhNsThbDUzKbKcEiYYwUSxidRqC8R8ayhKDWYEGNRR58wJ7QZ1soWiTAKyVM7IHYF9p+fZOmQx0Douh8XZoi+ZW+s/scEuwQSKfYnt7cVqQ5XHugWvLTj9B16eYFSO4TS/eI33iYpxF+tQEkHFfS6oHsVKKEwQAqy1bV+l1BPHPypbUc+MWf8xhwDXqc3d6CDUEowfE8EKQeJAS9hDW2wBYdjzMLLjGuRUNpHJDF9FVRlJrgwed3T5XBqkJiucg38aHxzVtW5pbF9zguvOA4zARdlbcgj1OU99JzY3VS/n6qbGxZ/IAHlmz5wvKngK77XqWEtjL3N+RDZVW+WZ/2tc4AvwpvuPCpGEJ2Epq6KRvplkdzVlwKQ/1SpopU607i5J4IxpuUJY0H7dwCF4LbfDcspN04yYeDodaSaJShc0c90igENl6kBei+BMEEaI7zuk34K2AA9Ohv1o8r0yLau7UQZpDYtWgrdH0nYJgTeI11h2VrFA1lLE1cwJCS9sa1CqvsCvOqSDlvn2yW6RCbBFoGDXi1oC6lRe4rYhJko0CI+JltU+ei2HPDIGaVyC7gJlOmSVhBWVcNPogVwpRgC0OJEMTjSg6gV3Gkbm8aFfXvQRbGaRQIE4ZyKZk6AnDtKjQUTgO42MVYBeEOZHFlHB2qPCZxJ1ydwXHPilpA0uaELMEYqUEmN0ojylrIZWtsOdnBMAZAK6cdkOjbP6V1KiXestZCG7Ww2DQJE+UgQFqVRoYU8SBIFgJxQdAMHYL7pE3x/qsJ1oyHdq6gXlcbSpwkJiuVLyOrlkeaHpzsr6EgBEEJk4yQXLDu2PG2ODGPwiDFyyMGDmsIFijuZSow4+B+dyRlYQp6Ho5WQ7UNA0V1UicJPXO0FJeTonfxBPbQppLs4foNep3nWg8uYUBklEvLSxaGibZKE5JiYojtp86wSybtoeX4lCDhDStxdMt+vhdcwjCnTGMNvGxn3kkcmKuCtPNi4ECxoGQHsYIdT2asoPeAgXR5KNIvt/LXhHksm6F2NIEHPmu7rOwmO5H2zrWJ1RY9svOnnpzwT5yc7kFQ65YTq6BVos0Gecf+KTWWRzKlCQJ4td+WMeJt1XapZCkUE1XPheLI4C8SwOwoZX8EdSaz0qKstpB6RcAzTM98QKdNqucFgQuTtHoFvNKFKZ+z5J6CzDtSLu2JYUqDW5JEPYdm78gAisCSqBTjkdvBbEXWCZttVE5DSGFkPSBeEGa78vmhmT7mOKb0ZlEvsSz0IjktjC+dOXeCQ21SPgjUTlhQ6URuA19hyx9KVZHYuBc6498YzSThrSsCtkOrZOADSf7jRwj7JA4J2PhCjUzFYXI+NflyunNVpseySCN8EA8WiOvY9IUlby4MHj0pPNNxSJoGA5XDUSJIUg/nXFlNJ8CWaG3Bp3gBUhsDRX8GisaoDstoH2HyKIIo5wHKu9lbwQpqZj30gx9AX1YhMD3CkrEYhR2URiQBkxr/61mhVkrX+10idVfdmCcpJohNIMloe+Clr2EWqzGaLucMZ3WySLb0TDpsPxIJ3II67ikI3EII/EXOK5W93XsUZEcmbppXYsOblTfRPuHGj9ba7HmJzVb0YwcVUUQESC3gE3jdcwErl8+XTPZ+rH7ebx4vpnux25LHbCrYVUOdEZpSId3qnTj85QP++l4M16+6reP/evrvf+VTXAyUdnAL8+DwBDEBadZnm4CmD8GLASKr5sZ04yUMi7OzDyEJ69Al422cDVhCK/IhiBpEoC2SEqLaJ8GduUWO2uOJ08vJWsvL5q9FnTp4ukoMfq0nwPpZJHRJAYkB4ST0fhldFw7BnrkpoLor0MESR8AYD7n9HnNrGxge0DMP1NkcKiyzjPHQkhSTH7RSawdwOGQpSdL19BihNWSFwsaUCSjdE5biNTrMatQSDZsoXitODaU4JHSahekjuE4NqJ5qynJDuyHamo7oU/zfwFD9ej8N5BBzCi7FssNC+sXAClLbnHvvFGKkrG9pDJuPs7FCck89kFShKBIGW8JVkWPy4+wgwwnbRUJ7xuPGtBUAxkXzbDdsuXFsgA5xl5wFoDcXuWADdNZtLAxddPMk2CPOPbFtoJzjXSnlRSvWJnTwEFsV9bsTGpzbYKxonlFInAsTSdot8tWQVuU4Rgv9BK2qj3FZauOApROm6EXu8OuRtCfoIgSbiFKV7xCSwLlFrF9OXM+SoeKrcF4SDRX/ct0/vXm+jCNYe6PedX1bpt2Ma/PurSf6ouP6Xjx9NHd6+v0Mg9f50eP4mYaLn5tdT/vwgU1bh3G43az2V/vz56f3766L6NAjd6Z0SFhfsNrcIUCTiurc2GdG9CDVlBOMQr8PwxdTllMnjBSObAwoWp9IphEaLaPkfWCkGSZVKIfM2tbpblZWI0YBZcUw0RBi6TVhemLUgGAJdTeI+E0Rq+mR+IxYmPW450kci+g4KuFLTyITIJZmpPkIWbvQyPi4HQhMs+zsD0Cs2qyFjK9NplJbKt5KwoFQLucIAkyMWARo4XmgaDPqmdnTlaJxFIvPGjgmV1ygiiwhROKRPSR00RTnebFXE2Dld0JWAETj0Ftfs3YRRLRcBRkZIcTwBdhBPFoSKQzgUdK4w7x5iIqhQILJ7PhQFOT6QphhXmOLssEBLlyZ8e6JdHFlrQNjkbGo6+2OobldZJvWChbSivwLRA1RMUL9Nd0+BDdiYFQCPaEkciZMGqLzth4Gh01NqNOVm7FTuQvCvcHeG95q0UhyTByPhty6zkjsAfdVLIAlHLcQsRWsq0ETjBY44yWaAyoSLfWoYOab1LmTcdx8jt3dt6ndT7fbq++uhm/Sumr6fGw7t381J/Fue4KmnbWjWfr/X28Dl1YJRfHQwmvxsuw/eJ2lzqCMurGOP+zXFPDN+Nd9aFnY1k9msevx/uP7/wQXCcZJ+88Cab6GLMaVgeQCDMEkQfxgljDfVD+J0pdbNNpZgzCTIRdaL6tmwwhQ5Hg35UFmMVQFPxT0fq6ONCuD1p7EmDIKpjYl+JssrI0uM7ntFCjIEjBnsZG57J6AMgICIZUTKdszi9ywMVWkm6TRAdVfktpt2zI6kMmkSYPM63bT/ZJXpAGomyboOUL3uxdSNzxTqaH3zYbx8KhXaEIdOiw1QW4lCRGQUDMQEO8lVkQPMRWZS8WKChBDKcMZWgsqUUGeBAkID4IYN9eoKDvTOYQQavT+gwhXI7R3hoW9esIiQg8nZoAUPxFtocm/xU+vNlLiCh6UzMz87228XkuIAkYEtHhSNo1HIVJvMYPLnJPtdFjYL5sCpmUYlG7t/qq6KkbH8JUUDQjUyMgPbpmEc0o5sZsMG6iLXRbd/HbTjKmRdTnG4ij8Rej4LLEEk7zG6VctMjcWI4IuxgU8x6uQ8+k5HhqhbP0afE/s9kfLWpFRF96zVpYwf4LykHHG2el2iJmqTHUeEz3n91vxtULP1xebu7u7rp++sivv7w5Jipvkidc92Uqcbta7Xb7GMbYDZ3L+9nFQq5q04e63zwNm/PurOz4fMxPXT7bENzg41jv8b2tX5QIka8ycTRxGJmNiyDpGLv9NOvVqmIEZFQDZMgDxSMzVWANAYMEGBlBDMhZ7BPhEKiJb00hghCJwwDjkV1DJ9g5n3ykQkgrxc+jWMFoSMBqA6ys3r6B6GxZEBUqIo74InMrL8AB+k3QfZFow5oj2WRDlsXh8cp4zlkwus3rjACyVnPhsSac9HEPAyyZTnL3GDhg1RNZagfeAL1iPmZbMXyxHLzSTpnGMkGKgx5lAcM3QpSKCjyuJJUKvQmbTA5XQGGKVpU/CEElreqCTADSDShUiKrs8WlDXoir4NcevqocahZDSnd8kqjXh3GrKFICvMjsEkz6JSEl5LC3LvgsvrNjISZkAIGoW7QtvVgx8Dnw3LHvDLCHuehagqDmRr4WMFKawCTAMZMWxAo0ct0Cbyql5Z8Wj2BDGKdDgYrFYvHDmBd8FYSswp/k/b9MazUAk0iqsaW8mpsggZjZXd6CevHONxKzljIlwlpw3Pke+OAxYJBSaRmWM+SNA3iXpznffHL9+LiNu/5sHedY4/ZjPQtnfZjq1ZUdY1o5bd1dTpuZwvqa4x2ntFqtDofpYj3c7dPZZnUcx7NNTNU1/cJq/zTsQ+EAybW+h4WiPB9Ra2uopzEC9tbg30tBp0g0Lp7WMPWGYdOtAAp0CjkxRzyI1bPzz4ek65E5yu2TAyQSk2sxeJaKG7R3lG2EcWcSf1hjtBwSJp3Nwm+C5prM0xZIKPEkZHfi/2BHqmXhFjy0+BZDnTCzWkgSMuVErRLPNMTmmQVswgezg5u02oDwRCkgEeFqaK1MqJxQuhoC7AhX/Fm0fsBoYSlHOCW+KRivD9QvXItU8ema57EgsQJjGcRDS/AlYbBq2qL6FE0bBP0MQZQtkFvId/TFPMqbqSGaWyTpeJMIoV78atObGgoTuArmwjgnAv9EbU08zTEq6l1aEGCBWHXUoGvwUWA4cZaIjMHEMjGcT3LE7CoM34YR7U4eoQHnQYcpFH0iRFxKSilCOKONZ04r5dIXUtDipudd/cai+0QJ8d42q0a28mAs65TqSRCqBJIR511YcPkl+LJkW/F12jEkbGPYHEfaiBAXfLJFJVV8mu4mQeLIIuD+agBSlEvttORfCo0fncv9p3f9GN4bN/XnR++nKW1WNICg6/rDsRqg1ZTy6v1NfhGuNrSAd1SagTRlvdqpbo/ru7F/EnYUJsW7Msb3No4LzPQSAilosLbscpTDI1asIDAx0ia2JmiNBD9FAQQb10kQQGc1VmxxMm1O8AHO/vIS5G6BMDnfoH6rxabYQpguBSoTP6Yi+BEatpL4QB6YXszVgSQFsD9EMbIekueKTzMFt/UqWa+FdNvxXaVZ7rKAXpP0zVlYOE+SluJw0rYFCEfTkoR1MUNriKslGLUp/4RNYAsYBNl0NsI6sS62rQ87tgInLQ7AKM1+QTth3xPUJbQtzVg4W0D+aVatSscCR0HZZCzapgIbymrLKgkJbytFAJhLBfvEGAmUpjUBrelrgOKVMgb3TzX0IeBBzzMmeHqoMwHzshgF4nqzpudaoONHzoB9YjeEGJcid7YPln7CuIPEq+2Nagr++3/6DyQqaUwI3dNqUhRpbtZKLYWRQgW0lhBNikEZqQSHbCcvK9rX1piNdp5gNNQetbJjElcjGV4ylKRduNPDZk+XCKIASkGs8NJLKLavFAtSlrG6sL2zssM0GHFajTKRkIlbJu4+uXm8W3elZnW02/vo+y4cyrx+sdkMnY89adOmvFvlchaXq2c3KExF1d2yyoY9BkvuGpCn4K4mSrJKXj2n1/Ya809LFEnjZae12WLMX2PqGqVT0vNZxqYiVKEsIygxQmiZDgianiW9HbZ3S/OHPFGi2wYwwOdZVU5r4erw9NMF6lEiYrFHhn1Tt/s0MlwSxaaIQQlAvjOqCmqs5ZmK5dVtADMh7++WVlWX3Sp3iQv8rv0hF9KJl6RrmLi4H4yjJFcL4gVycPyiQUyoVtlxQz6YhXPvtbKhZWuLA0Bi4Dey7hTZIV5zYS4gogNZ4uKUF87bMm4h/SJQ1dqrQJ9iFjUexfvDbOWsVCRoCuZiqrJuYUacawwP29IhynXzSC3M1hJzaXIyHbrqhNUZBFSQFEoNs6V4ZjhsdSzAecCHkhu2J7p8nuKv5HGKAeZgOGo7hS60lDPAHDDYyACvotQ+jY6Ar1EAguc9Q+0oK2nHHi0uUY3F4sgzD6WPORuJQ3eylcv5iR7yVE/F4Se7fOOelH4zhP001X2wHmp6nnbPuv79Ver9La3AqGluRF5mhkOEXwwQElxQThp/FjEJwmlLiqp9Fr/AdKPXdpwkrZtYPq2yC0PAaTccHjr0Y1ERrgkdJkcUln62JhXHXA1Cc/ogISeuPBWFhfQpccGLjSag7iC4MlctseR5URNksQchYRO9yzp4Wp2aZmpKyM/vDGGZ0Ic8Gz4l1CqwEWk1JtVH4s8EbIcYnC2BAzVPDifzrQDtQ10TWA+CTQb1CXYB+Tt2gnh3qzhNWUnClp/K3he8iZHQ+YiyEo/l5QZGaWeRjvUyZxu14E0We4lzYRmrnSFJPNQWOeYsCR+NB4QBMVIWUAS55KRmnTM+kjvnC4MEID/WLHQTzeWt6d+QEwltYAeBLRW/EFfw0hflZd4wd6SSz+h6kfZMPFO9PgiJocTMwQQoZAHbAioGVE8id49pxR+v6VJS9NrbrRbDNEpaWA2UlqIU8rB78OHGM3Je2w/VwElOXrRuKPPirDvEm/n2znrNhYWhHrqIybOupCKZv2RAYnTEnvHbFsPqWuzFRRwm9UhI1bSxNMxAEDeNM6ykoSHqG+k1Iyf4N39xc3nYnB+6gZKUbj/O2/VwTPP4xHUvtiuuzgg7RmNJ2sFStBI4w3OcGHrnVt4dimTNzA8oWrbDQgmlS4OmNBWcLnoKHC9k7aeJQwQMzLvQo5omPff43OIAPwHW5X40nNugTVplHgUQZB0luk6kUZk9AGUrYwrozPBKIRDLwV4vCBjKdyqGwCnwDKxX2L8Mh2dNslyx5hWHIp0Ua5NkMYl7hkU4jnsA8NSyymyi15qCrGPxilXX7wyrDtp41NQJ18AWzSMJNSiWcRivCj/YlmnMGqwU5Nd0AQmlLH4oXDREeEs1xGrRek8WjQd0ogjYiZFlshiYcQqfI6UFGx4vBkym6FUpHJySqaXSp9QQvVCT2O5PmmhHja04GdSNb/VK5uI4RWADsf8geYzqMGMIYnMF3VYdLkll+MpFX0CDiOX59UGAYCHlge3Jen716+NhhppmMd/PbBQt4AtahziXFDN51rrV9+il3/+dj1jcVHgTlqo44x/woxUBKV5QkY7WAgdcvdRcyindQTvMAAHwA+D5ySgBdCY47ASwYCTLQkZ9q2LJJqrgSoFFnFwMd3fKynVKNtIERKAoFktSKeTQ3Ff0Xtnb8kqQ0MTbWxrlXDVJ+zcHd+0uJhrPTiN5abYIdQcczsLwy6vwrHedOH7vm6xH0IJXQPe1rQzbka7E49X+4hfOp+PoJRyW37J3QPcGi3BnmABE+0kOMzyVgjv4PtolFUcXphXTmr0aCGQHlMIEUAG0eCQX4KWWHwXe8DwDiQ9McNoS6DVJw3QidSgO17ZIXqTnuSRJQlV3O85zss0AWjzzm5kJDGxLHSfoquiIko0h1TEPMAjDkKhWk+SclyKn1yQAW0ugE9JT10W2aPLOBmDJZ+lVIYrhIyNVLYQzWu+BKi+prEjtMlFk5LhFH7cAyBmyVkXTAq9TqRCZongXpY2cY1VdKMTaXjm0NOJXi+eQWjN8w4m9Lva51vpeXDOOrliRSXybBvrCSjFMACcCsD2HooC6RU0AmxDl5iDi6aepFZ+sjmBdAOTyiYLKafoP8NEH6biQGiXbU6re/ME/+w1j67TjvUiXDHLCuW1CEBoD2zXZj7xvP/LS/5EtiVtksAqHG9IRWoM0Ph0P1TLFFow5A+UXSgOqUy7IpsExwNfASG6UBYlI7TUNX1yI2BSpH0s3jNPuitvDfv7i+MHN5jDO7jL6j/pw1gFt1bqIyulZFobtrdUDnNj65uu9v/gi3BzGm8upf7H25sqYq2LVHPhhReAUdRS0FSGls9gNS40dL5QDjR+tbmvzBItrsarBQ06ZQ/AGwBfAM6JjHDUEVS1dYV1CDlQoJq16xTdiCaOEeI5lEb1qe3s+6hr20oi7mpsvHxZKgYZbcde6x7LUMEFoqwovkrlBF6fYNAY0wa6Iss3gLWx2g9NfRMQq4NecgceXhSSGxEQahQU1XFzXS6Y/JUwx5F+SYRXmbWXb1bZlnVKl7OhhCCYrw4Cv41lASatSCt7hd9tcBd8ed6vGamgvm5N/kNhJWE3GK7EDt5NN9ZSD/Mg0KLod65ZqfWYGcrVjFXzr9BZr5TUV1XzIe2OQGX4umawg10YM5oEJlCp+9x++sOIs8yQNUtFgaoGtGJIiGlUNA5JODlQrwdI0zSnjnZ8kboryQizBCcLg0mx8cwFuAb9IBNeENBfFeCfuSDsWmR3dSW0F/gqVdUHf9ZsSZJkZ0uQdNwZcv8lXZyARZXc47g6j/7wML/Oxi8PHg//W4IegdU88b7qKCM1SVIJkwgWN+a3/c7W761zki3Rxcuexv37hw6Mo6DXcfhYAAiZmnqRSIeKlpekOi4ETYFt+l8+w9QShkxjvKdAUlHC8V/Y5Hmy02j76MbnNkEMJPv/mFZRspXFBxHZXToDVsws31uC0m2BG0tZ8gHREKwXhi3mJyOwEqFBwAfo8Eq8VcfLq8IpywUUhB+QggBVS+CsCbGFEVdG8TxRaRHGI/D9oaJDfgFfnLEkk65wWEBWfkBgE0CRl1pwpz0jimBwPtjWSPmrMVn1OvD8wKcRfQfu6NLhDFMPjrSjTLxZIUl4/RDuauP5lWq35nVyGcie9QQcYkeVKIx7hyHtNZQTd5kX3Qba3RFj8JiItxwVNPKyov4KNjehFeBiakCk2JMaoSS2bdxSerfhXVHIkX6kL8p/+zkdBNq4F/LrFRRJawPilpA+l8Da2i0muXnx1EZkIhWPV+klXJEpvQSU6aV14TFBYiCJ6nYymthjVCqQATb1R9od1kOogRaRFKk7kzTkjo0Z7sMgSqKGGALx+royllN2pumX1YnfzcZry+NPj/Mlhc4jDZT/86sZvo4L6UoVI2h0J+67NwNgcrr7FIafx392fP9vAzM2h3G+rgRFPi31gCanuhoZGM+gQ5O64zQC/BWREgEJPvGRwA6m6zOdLQ+DSCN9z8wB47tzb7OEz+yEmFRjAevDFiHYNMCxxqCGYWxIOurbOmdm1WEN8AEe7Te23qNR1klPkFnRKiXo40leUKhZFXwFLmWQ+Mn0oZ8CnznMZjxPGjCNulYwPN+sa6J64sYFtFllVl3XmjYbbyJLYkUPvn94fisYylJN39bDuiJWmZo5TTm6/VxliSSQh45P4dniLIofFgSrijWg1IYGrUCAa7LNxF5T9w9EuHwp5OvwRaMUXBXAvUapX8oSss1KvhdTt0MWNnLGoiW8oEPqSsjL7xaMrKUofevGLPwL/cxspLg4iBTBnjUCj4ExoM34kY6Kn/6u/9SF2z7JYbtm+5iOyCaSol1GADKEZFy5YoSrECmGUeRFEmnUMO0MqSSvQRcB4I+YtTZtXAEWW1ct5wCpIxKQ4lA7qWK47YbGydl6yGOdaR3REWwCqSHwg5EgXBQ4VHgJXJfRhn8Zpznc/uNm+6jeHfu39uo9p3XXPO+vsYV8gY64dd8Tv8/joxXlyc7yI60erfTiU7G8+vZs+PT5Kfff+KnfVp9Ngy/p3PY8BQSUQXN4aggHl1hLgtTYKa8Uq3YSjQtpJZojwkeZQywNiB0zTnqaXYj9eY2P+0uxwzun4iRYN6rxmVpAxSrjNqy6IrAQCfcxJ9YrUM8HnmS1GdmnN/RjyiOgGkZIXN64nUOMRaSTmPr4FHAHxvMzflM5hAR8EcXdxl+/vjmEIXUf13yRDtETw0wAUVP0DdKMUb4AagV2Strhi9QL48kzRCAWDSYpr0CogxSD5B73MyvpsOCyNDdLpyQ+IjaZCaR5LiuK1NhhbJVViK1w2CFBasiilNK4psjdCPzlSVkuneZkWnSxh8mIHvCFoqGDI1vIAoDXcUxTGRBPViqH+JqvaKClaFecNpunLglmiOabogsF5Ix6iCKs1uHM8B7A26JxrAAFOoaKsjDWtI8qvSlmhuMH38ZE73uwvPriYx5m7R7g5uW86n/hPCBOaeDPkqUOKHLsFayouRgxxmqEpiIuOkAVdweuANvaBkoq2kDWIwVV/yDGLMvewUjEEzZ/JcNy82d381V3+sjw59h3PZ63vO6f5/HJIj4K0Ygh1WFbxwPOyDz+4Pf9yVW6O05spHvvyo33+q7TaxYtCejflaVyddeeX5+O094/cxZPt4XgIiUMDhMEwx+pC8IdMCWdtCcMIhImH2o0rOu4JG8VYWmAPKiQsbasL0MB1q4iyr0SaCPiNohiEOQkxDEV5Jagk6XHPDEklDRbNv9CKKCRAL2wyiPmIyqBymrCMSqQQQiYIzB333EraKGp8puyqWqNeywK80/a7MWiLFh2wVVht+37oLObCcY8x1iCL+xwd4CFYA/SXWE0A7zkeEthA2JCb8z5JpikZUL+KxjfWKpa3hwisnXNDsWsmEIpFA1NEtWUEahRQHGX4BdQrupJRjEuQyDF5mxnqPOeM4jrM/EVtKsIig3i6wH+FCse1SKGhGAKgzoOAIwBCWIqI2NlpDqixv/W644JQZHPGwmc3BsU6ujCogKjuBcxVEJco5AFakz/4Z79hqBgc44nCsY1RUTKb013FAHCx0y7EzuoQrkJ+nE10CdtrwdPz1h4Fc9PAY6fYySLvhcwYtrhXTFcLT63UhYwiLnoLkLOghQ3kXatww5Mb+wNp+Swkb++9LZDTxF7UV+hl93McHWfgOa5j2QScczwex7MLd/vj7s3BX4f35/6jR2eZ5hxMu+NcP2ic05v7qbr4VfWWv7oOk9t+6Uc3v553w8fb7ryXLF5Q5KyIodTdihU/kf01+y1lejwOUBaKBupeBQDgbMNiHAPCLnHLmo9nBsKKBA4etgNib2nKuuYgu5cZQweoFQHxPHXwIdHQFIP6bIcVNE8kMUHXBCAk7QRiEgD1FSG4LBo/BpIlcEVp9BKm0fr3gTr1VBUAzFLwrcfbsXrOYVWNlLwh+ge5rcROLOJ9pjh5gWbQIue9tOsjdfA6ODbxrVmLNVoLhFmiaqVQdHDKL60/GvnRY00S2feA/E4QSXZ1VlEJXtpjndIspETLi9lSMIV46iaphhLUf5j4oJZC2hu0oKR1GLJrYCfoARScGzRRbCoiJSRA2ExDm6hVoBmBzKKSScFyTeEZnUzyzlrNx3mXjM9pvXiRl2gpxuBKAYudMbQVnpvHHL/32x8a99po1lbjkIEZOhAFhtwrUxycGkTpcRM8y6TltVs2mtYPTQoWFh2CjdwEPRxBdXCEWYMbU+0R9EAhfomahOPXI2vXCkIsuIChXZrCWKQq3FzmfSUtlGqTzTzLTyWY50AaIQZOY7Da0xDcOsRt9KvgeoN1pP82cPi2Grrt+frsvbV/r3+zPl7e+Zu7Q8/u5XY3VjdPz7Er6Xlc+/h46tJ6mD70nrZdwUkARqtFBcn8xf9HARcYl20Ch/XPat0JOVupITUDkiy+NGJUlA6SRkDlpCNT/zXExbxsDrxYzB8HU3h2PPuHwWOmXxMenMFU9doGK8zAoCiVui/hDQk4IIVwY3+InULqQbKLpnlr9bss8tDZmFmkvh9gW9n5c+B2W+ZemKvIrImEzS6NuO8BhG8HQ+lsmo6G20xigpfiEmcq/arTcNSBcrksBfZ9dKqqKnI66NMsLATIvwe8DN/B2AgTvRDrnGxWtndWrEwSpBTuk+sJGitIrrteoHfGCnVeQRTiRetRV8F7bFGSm8liw3ISYX6xgAWlQ+j6ZudaWlfUKVoTldXTFK4RkF6gEcaIQV1y2ixpyB0460UrReKFtW9BTBEG9KWsvBMc1UIGSxLdLPWsYmOT9XXGWClajtGyIdA4+vry+ZbUJYayebJOeQ5ZWzwNG7a6Q5Yszys/EKsp1VhxPjZvQvjNDc8z32hYnTfVSsFldE0F05E6q46txm+R5BimFUQF/PTWkIjzlDCpIifRfhKnJwJhCszL+ckWBXD11+fR5dd/ef33L58cOOboh+FwHG/30+b5Kn9nqFlYnPx9nvcvmKiuAFXkABDQD3LzwETwujXBgMcMm/EwSxSpQXt9DXQyXWmpGf2iUcxEmyHD1gdFnWyWDAezSiLhZF5Kvbxi1MrbAcmmR4m5HoCZRf1Z8fXIcZYSDj2UUowNK/IGujFQ9MwLckld7fVZNx2k/QrkgxoraeiBJwtoQ9zbPKYaaNRwr76MVmMdtherGppFgfMky+a7EMo+DnF9wbDuIJcOHiZNip+LqpLKC2n63iTxlEODm7b41U88HiZOoiPjfRnWzZqKQONiqFszIeU1BXUtYMbVVUnJKLuQO6LHNE208gXf1NQLrQiQkYEz81q8hDFNVAeQ3FmQvQBqAi5ekRwn5iwqGG8hEufCUbljCISLk8nSkqMo4t7mEjjumhAD4cQ0e7eIVYvUIsWlae+MxLOYkACbSH4rOC0xU5hSDRajO1oL05DKK6nT0Aqh3qDoCMQuQ7ON3fufpX191KNPh+yTlieyEMBajQBkECk+0v+JILREc6rsz2eVxCwkkdHKiIzJKWbydECpFypgEcpP0BZZBR002MSDyaZbFovG3vRxwQUtupBYYucblp8UhuNjH1lxWAqyGYXwCD2TuoaHaXrzxe34Zn501fVdv133HTWau7F+6rf79KLH6o/1YV3EZUYTVM4NmVpPTUIFMIHXj5arNRCHf4QiN2TSMkMMoOchwak7vijDFigDX6r0oJBZFB5mQSEPDAavKnf1TI7HJE0VBUiwtmFzT0cEMaIXmkiecS/kw1GbKwodgDpYz3/9m6py9QuGwOALOy6WOXTPBLa2yorixg5lMNq4adSLspv2Myyv9gmixJnhw7EHUA4WNU7BR6QRpH4u9+LQe8Mo0+Izrtcqlb1SYYrxg3TAOP+LVXqkUlGEyeEVXvbVP9WbRQaGjY1fZ+UchpYAJjKybkUVRLh41krk8JQDMkseT4FuM0k0gCJvi3+5gowTgQdtdE2nonJaRtQg2HtFJxFrC4Oox2PiUC72Yh1CB56s5EbQyLdSGETS4epCs1YOoHNWhrOFJgJea7OBFXkaPB24SogT2kJZ4T1LbCIYcPRye8yyt7Yvp42px/O6R4KW56RpKHTeMDNheVgiIPCtoOleyUGo7FohXZ6WF3kgfJPKJeixhQPRYrZsZun1598VUUThfyuhKVk4Bjco9CXn7ZE4AzrYOpjhcKKWpWMm+DW4GmAN5JHY9p5tVqt67Y+68cN4vZ53T9z1Wdpdlv7JCkmKCdtzU7u48aKDHlD50g+lnSGyApGSNZPWkEjbYQCUx7ypfsAoAtPelCeFlEqxbVk9RlilyOCVqSwoBs9Ss3iNcxDaTNzXKrI2NIqKNSc8BhEl6WGAhhxHPUl6IXlnU+JpdGr0qGpGKNr2qrFV0x9jABnC+bAFGt50yvPdHDax2j5F+jkFQ+2YfTjHI/RNpGNOmclIZ6iCUSSuRxyHEe11qfFaOq5ObLeVF2VleAuREUmwRF4BHQ+HCspCDeIWzDVAyE77MV1DrItyWcVxO1AC0Q7lpQRMn8uNew5dTTzQlDfqEBufgJwo7QckuXiyRXlkSqGQ0yGObUxsgp02fgvXHAmvWhAFUjWF1wajIIVh5LPGLHPSwwzzipWXiT7qbh3rEoJfxV5H6iLIVaPeMkVW3/utFxzeFdRcxVdw4OekHIfksBEiENDSytbA+/l6SuPmg3Wit9DuIi/7AAI6OCeaTgo0QyySJFPtEsN7zMfnZVXVfSv+wcYhaXdFjZpKNuPIeZtGx1Uww240T9TSLCamLqoeoEdSqKiy2XhaIgHMzoe6/5X9ihRDWibFzDmrRegcJFri/rIrK+Z1sEpyZlOLMp9rTZ31m16Jf6S7KLVzb6VuamYiCdqiHFH+rPkoMsLVTMCsGxYpgRI3eUmc7wVtleCcbVm/jkzLdsFyFIp4JVBnUptQDSJxK3kxMWe8hiFDmI6pnhnh/XJYp8eAn+kszGyxbjqfZmYLCCLVMuIjn+FZvTxIoIHmFTgkE3vB6QV4jLNHTIWpTF+N4VEndpmxTrI42jaIyCsB3goEOdWTOaw6chJjzhqI1etEBxyDJBlxAeBYoONyIkoRsRCEsXyWeraVSXU7JWRm6U6ud9Mr6+dCXNCaw3htMfamBCGdY+nEmNbrBGORnBk2AHuySPJbHEMBZguAED26HeEkNJURvFJ0coLmOl6MLwB4bDw9VvSfNkUFLCl3tsswvdBpxUaEQ9W6ZWeSHih0QsoWj4yJr5KB2jwup3M9VO3Da/6uwKVxmlFV/P7vfBSUIVlEYlkqZNLWVLQ0UNoDg1hHf+23t/72610JrkvR2zg2k+62Hj1o3cOCBN6WOm4TomJey/OwESxNKamfRDo8L97QPgk9YNpDkHLYgt2AukPH8j0A5GgTQL1fDQGehNEy+x7czRIXNC7EQR1ZQB2+oHqy9XProTUkjibTeEnogDXwbhCoG9hEVDhJcT1h5OPWEMxHkZqUoadBlHx9J4QmKWOzUaaE2kpXkul00tAju3+Ce9SCcWgeHiiJTUKjAhxX2RgulYIdWfMOtymSNfVDB4omTEOmCDEoyKSimbesBBe91PslzVCqkYO6PFE6pXsm83BjHBs8BR4PEYAkSjyixVAMm/BaTnD1kr+Y5jM/bDuOBCMAb452KbSRpe6FsCZWhj0fzbgFiOl5Ayg3GiAJeR1OhymcYRAT64lNDu+N9ZyOWevpAFslJ3LcXo7NEySwdVhSZWWLh6hrNXEiDHCmsBbewKUY+O9OOag204GHc/D8G/YE/RCSHRnObwibiwC/5LwUnf7ZGLyKxip7nzVLtYxrKJ5VkzGtHrcj4yl9G15fRDBWwTo+7CADYMKj1gRVWYyxQpEtlR9r9Gz0zNIi0/h9YFhB/JjgPuAE2zwomWAsnTdOKiD12ecpZn/RuSwxfyeD7ZQuIN0MXuXWxFJm7rxGs4XGULx1EGh0Ekaara33i6bceZRcL+ikZIVsnTItjBBIQQzrWhTtQRHKD0rWQCYs5bQlqx+khk/CnBC0CmMdG9hSvKSAjRQmd0q29FbKqaGQSpswLUA1oK2kgLMHqjp04HBTXoUQsZtFTwo0fe68maeCz3WLpr8YpBYjdN8YGH0QhqGMpaMKQERqicQH+SCCSjKCCaOo2Ojw9UDNnbNT0oqgFWQaURQKLxoecCPSALzadi6rSVpoHgUlr+KyCRBkswhNG4YR6K1W6248zjTYysn4a61SZSDrYAhmLvOFr+Z5XcIq8jOlvI+Jk0W47N6KaFgErjyAtyWq3JivF4+EvntUTqVsF1y1GmL1uPCK5h4v0LXkLLK8vOczuRCuG84kYlcvviNPkDl8c6KqrFIDkvgk8XNeMgsBdwLT9KHQHVR1q8aGUFv3AcG6g2F1rnG/uUme8XWOZBFXI2OF20ANCnkGwljOB5FqOOP3zzPU5QP0dkpe2BInlbRsk4SCwH/sofOS6e5cM7heShZCQlhWNjtqXANTJEpbmzIoYbwowkJPgFlmPtlO+cetC0yKsryPBRvq3OwU4i9CNBU4k9+dpslLwVWpbkGtuSZ61pSDPWxJVlaGjhQsQKEaYjP56gCx51BQsD4SnQTH6QlHyPMsxF+nIl8o52FLSZ+JV05TNinbNmFU+sDZafAqBkiUFLAxslnqYEhtZiZ6fTx9H7QWI02aqChHLQbzZSj5iGeIjwcM/qKnw5ZaC9VcoGFOg/Kx2YgPazxsYVHhnckwTQozRwi6ym9RYstAj9BH2Pd2rLDMO4+Wns4qxxeWV2amEUCEANIRaI5blEEKRFqsSohSJm6ThTRFrBIt0FhSxJgZYREjVx0lUEr0VwxOQxLpggic6K1WMX1Rw3KXVqUaOAQgXHdzQKPmUUZVQ5iFwSCP/RkhGM9HXQNJgbiKHgeAXPUp1qtZbTqUVhiSZ1FN1WIGLt4TO4T6ivE0O+48q285DFKNxfbv+44JE9mmPc2MsgGxoHR76HDcIIBRf6t+E1CDfqh2M0p5WWDElkBBoodTOaVcCPmWY17+RC9nEOwQZEXFtB84iPPIDXU2JQ8P9gifU3aq4yI9gLOE1TwnMRUL5wsY6QI6AkA00j9jMtYXHdqMmAWdQEuZ3/2ND+Cb4T9Bs8xSZZAcT88qA0ln3faD1TxO/Yd9dx7TNIUcldobwJuYVc9E6noKhyF9JfciE7OFA11EbhxNqhr7KfIlI1HFomt1s9MxCUWJrFkyQcH+tLmtOHBVJL+DIbbk3HMnGm2RKWHXyaBmBom8tSUqvIp9kBivIfBeI2FjwamDhIa3Y6CkQCaNu0+CMLw1JPKqEVx/ROVwxaFwkfUpwJ1ih2VNmQGyEETSafWHaz0AL5CSAGNmIqVok0O+Tiigc4mi7M61+VXUCLyAC+IRLCTxqNLelEVOU1NCh/DBHorirKCAkZVnHimd22p/pXLEeFDHGRBOnQWePWIZDvllqor19GID1GWvyRTndICHax5H13kz532eLykEFhfCCQuyh6iqA4ZhccxI6FK18kAYZE4HK2eNHGuABiWVqKDkAy/NLKbN4kUKUWZeodvGSUwUlDdAIYNOKtXKBsd6zCwVyMnawgdGl4yCg3ql9yjPOfhdYK+Sg/PVzvXgJZmoNmKVeLfATLC5FHIpugsbjKT0TqDyKTXshf6KNVkOEOELQouHLQ5GP5QUAdGMjin1igVJqqiV6AJeOd+FZEtMG0a2YYwcLLJ3LaAjl/n93/0IDs1LV7SscrEJBQ6QakY0GO+K/3Q+1CN4W8rBsSygtBAra6MR6qqR7jn5N3Jdo1lruGg9Olm5f95kTj0ObTG5DzITtMtFO1HqDnD+nTcAS/ywbnR9ukRNwDtYBITLLrp1GMcR1QfKDTlyRg7SRZYhZVDZaIoE+hyzPIYifEhy1KFl5hK6w+2DFS3y3mxp9ZDU352OM77LZOiC4ZTM9Y9F5l/RXdDUX6iqK5u3XmH9Zr2vavKkgFg4lUDtHAwm0ZYErVn4mU7pdTLQSfevIDXF1X3Pv475oCxmxEJ0CKIRd9P3O0owyfFKCkYAP8yTIrs8WUBLz0R817iVzsMqonhHHpFjuiKsfSlESt2ZZ+3V66m2r97peJhw/XUz5GP2N3nauM3lCuVIKb0TgSug1qnZilAcpPNWFB8ZGeyk5TsKh0DwGj14tFA9+w/wP0HIqGtSjWwnNA5pPrI6NbYKVFmKisMw0d9hY4fOJNtbhxkcG5Bir+Mz6F7MygdxrpldmrQ3sxERNgan3lqLp5UELaMsGFXm6viCmQBo4ZIrxdgb2vmbG1GDN4lqn1nPCWfK4r1AqNQOeRkNbbwHr7I2FjjLeYhAXTwY/1LkKegYJxQofv+3P3IKdjjV1YTtFxyOv8OD3RWPPwt+HYsKdDUZCikVOwyL51qVa2GwoueNGu4kKeMmLPaKHQ6AQE5QqrNuA6daJc4Vc4BaISA/k5NwPrmFuCBV0f7B0hgSlNpE6Pk7lUYEcUaaeBfCUgCJMFxaek01J8ffkTmN8FcgvLFyPJmJkpTJzemGEwhAilxULwNsnEAy0ptlSKXYNA0nrQxk9Fdklevx+O4v/fqUx3k+IjcJrEiLjA/5l5WNKW6fUH71IHMJ2qICeDJ7ivO4yO3BVJHMooXkWMLU5QWbURsDUfSpdkorRJCaCtw2QLESs/ZkxZQYTHgQW0POKQJUa6RvQ/vmtCMalEvlBhG3oA+GPFq2C3Z+v+3KyxrLufgIpjPUkFnlIoQUXT+3xlMwE46TuzQWp5IpTLLzAHoEITIWRZHOpHpV4OviCVoTNeLToOOOiVqoYgFRO4eIU8Ycq3rZE7kWGTqI+i8SEjLHnEJiIrwoGjGKxLs9t4EU8Mpww8zflokPQfIGgrq4hgtVQhOZ4fcP6IsGHRfMXqs8eCeKekDri0me5WLd0TZgQfInVK6x0jrdh0kqgjLB3aIgIJgX+lWleoDpJMKItmgjSAxR7Kyx4iiD7iAvgNEjXAlGNqRxL9OqSY7my7QQLYMPAXDjdQAkebwsu7Co7ppTGW+ngoSihJ9BvNQpLEW0cb0AQ6hrEBMKPkipw7KmSAYFCNCZd/NUQPJkhAJoloLcXJKT7IZRJ9RrMDtX0jHt7vZavqR63BAwjgyJqMmlZpsOsBB7Xm16EcNU/K7+OjMb5TvczlKk/MFvWG+qfnM6JBFW1knaaAuPIFIk/91f/I1//k/+p//m9/+H//J3/rHL3X/44R/X1QMWw35MhgwScAOJEoL5Av864ziIvJykzwwbOcbXinAUhCgbQAe3ATbog1lve655kbuObNqc0vEyczWdbPFGAkhMeTeyMUF1FHnlqGLtCI0z52ggfAK5WJ8NNZIynyTAOQSa52IdjpzPdmEV5y+nMPvjtkYcPUWCPNyhGuusKkX1RgbuXgJjYDxKOQrxFzNjBYXMNvqMnR2AziB6flyFFIU14MSBA+0E4yXTG7nMV22i5JU6l6G+7fEwb856fkPyQnSpKr9jeB9wydW686rrgnFhdTODaFafzvEw0RQlL0kWJhYkHsPlnLZemEym/A0mcIHDCCJoJYPvI1PqxCqJHhlKIgpB6okTQLOLckg1akEDQzC5CA6U0J1T2KwD3yyLjAQ1ZWlLzEqk4rpE/bt6HaJAlqKcXh+/+5svBGUsIh0HJD9r6yP8SYfamSjeNZED3prSqD2BYeSlRqA3JiQLiSCcpHsQG4g9oCiPbl4L1w3c6RTAS9KkIoigjIHyJuSIrnHPo24deCKCz0I5N4MLE2USdea6QRYGOUUoXJYGjI1LlbFmStBHV63JPxCQD01Lry1vjEn3HJ+ThyymFSdkKJAhoDSShaqq8iBFvkk2pT7adYfcBDgRKwhXkx2+/0v/+T/5x//jxdnjaqT++I//5N//27/4h7/xuz/67E9r2EPn3HHnLY+H4jKfQxnLLKmX7NjkHwQ3gb2rW4e7bQifWp/19QRm5aOBl0jFweIE/cnobSRjFzSGMngOLyCLxuVFqUjqsC8rttCbMIkX8NZ0oJrguJ+xkjVBRtQA/0H8eBKS99j0sfNaYxEWaNnncp2nc1o90CwpTesCOBCiUiDUSdpvPTFjfbUpx/1UDbGAhrR0YHsE3OzAz4K7prlOqmgL+gdiAGFNEAxwpMFfz9o/IHPYtE9WOuyQhXGRL4jucKmXcdzPUqvpJBhk8kpESg7tCgjOSO2bjapDdsJoHR0ltqGoFcCQBUbK4FFgQ61PQBjtXqhzbFBwI8VZz2aUYdcW/MJz5FIUSZC0g1179CIGJz/BaTWSBAAZCkHUabXCMccxHBxkTo05iKa6GcYgFmK6Sw4JdrXisqx77c2teZU3bV0Cqlmjqh1yPiGxpE3nnDwjeIaKCDdAMUkkWH2BfTIX1zmkBDIF/1/3hBhpJzx9AeBtbisxHsjH1vNpFAFVsA15tgBVWyg5KKWTichaWo44jFedMLA6tPWELFdU9R8KHqUHnWAmbCysFRzdPMrw7p7JAWDVoziwLETURwKpNtxmByBDEnhn6uzZ6oY9GZT3Lz924/rq6uoP//AP/+RP/uTjjz/+vd/5/d/8z/6Lvut++tUn8zwz75wrWYwoQQJcOTjMzmU4XBhtwYH2wayxNvoJcQTmc9bLINSfmz8GelvKWVBJ5Qo0/ZSi1MOscRDEUkRXCzgUUgAsSD2TeZYcCuMY6q9szgfkO1L4Q+kgU4hxPM71FyPjREmYFmRrqo3rOO8zB1bqkb5Oo8/xrMO9MA+r4BgjVATNGCFz0kiTAlueqSHAcPEaL/w/VZ1pj27XcZ3PPuM79HAHzpQi2ZJNJVRsC5JjO3IM5EN+g3+pPxsGDCTI4MAIDDuWYYoURVLicG8P73TGVK2n9mlGIKjLvt1vn2Hv2lWr1lolAC7nTVOeGyQQbbR/A/Db171ZlOEYy5Gz2sw/YoipOWn1sSmEYSEtcqSvWOH8bECmLv6UycB4QggoyAaNSYCDCG7Om4sxPCuRJUG7TYF4VE/Y4jphQGu9bYVIZo+DYnXf58alqSTvXtmXuUZRd1WhJHa7Mj9QWvRYuRXu8YlaPg9MmQHd6V34phDJZs40TLTxGkRQ0ZFnR3sJYtmo0xrmJY9mWBu04T8ZjIEn88CoJqt1IBd9x2L1nCqY17TiPHA6HLRWTycF6TzTTKqnD0U1RnLlSza8GZKey5p4sceys2A+Ljwhf7IbXHUkxTrrnAuiTuRRMv5nfprRVqy9DMbehmgr88Wy2taTc3jDDkmUWQNQROHAYwU7WBEHEm+3GaliHataCeYx3CJBVFKWFTnoa3XqtwQz64Pf+cP/9Cf/5YsvvrCv/OVf/uWHH3642Wzauvvwhz/9d7/7x1+//vKrV58HBi9UG1esRsUs/XhvfZThEGB/axmNpy1lSTbnx/sctn/kvxpoHEQqS3mAiv0hT1E8+oYRB5uTE3mpjgTHzpnG3HZxANjqt++HX+I4EW4BRVrRmSjJ6zBKBcVYu1olUzmqFTUvSbs4StvrZv7NkKZiep5E2kurbobVS2t/PVbJ1vG9AUxQGyeU57bGlHyNAUFPjnVSPIJ7MvcM1VstRjuEHkAf9uF4mTj8dBwmuCxkzfYIGcdAesvFWCAYxyUjj4HWE4mmPB44vPBVMVGeZ2hiwUvHC0aRgZXF09cpAY4j0x+fRsZRPzZyzpqz9A82smCBKmANrXOP0cK8MPAgXwJcE2ztSVyd10xOz6nsZgguYT2UvRPWpJsuYZGVSfaPrZkom5pIFQkn1Yd/9r4yrnl9u3NMiIvi2X93KArBa5YQUtTZP58CuA4NWmzr7ABTZPkR/KBcvkVoKLOhGm0LOwoyJK+/KtbWQ8KZTvBB1utWKfRiKRrVfDKxG+GVnW8Ee7kUFQANdRxcXomhGV75ChxBPq+5QpwRCY6nnLkTvGKAa4xTFKvmlYES8pckBeJMuZTHLkR8Jkn240spW8qOz85g0IHv3yk/OLsFsnH7ubeff+/9N3/wve997yc/+cmLFy/s3i+XS13XTdPcXD3/6Yd/cb154x9/+d+LFCWn1ybD1GovsVY8CqSUAVTxUbPKNzcNfKOCSiA2XnUntX7csh7CEFWPh3vnhTlNNMx5y5hmBtEp2qYFI/liM8M/ouayp0TO4nJl3T7fZmWpbezLeajCqwRov6DPgC7aj406trTPN7ubylMabhcR36oy5phZguyMUIBMhAHn0xhJxJJxyUDWyrVDGogvDXuhkCzXpisthXNQXzdYZviZptRm21zc6g+2bRXmLZktCbBAPU7/frOtl7wC+Sh7Gn6R/z+tmrBSphA2s5/FQcW0UeXIeWJPjeRE2T1xzsxxGuurq12RlR7r4ZrbG8DhBamco5Dqk2imSXwzFUmRdcEecKfsThHQWBD3anZTuOnHMsiu8/gCKetXPydSEH8valVnJ7hCYKs/Q3hYSOfLLA2n0K3CmzWBN02RyOHNFOUS9gog2YvAIy4CmyFCWBX9xwQ2UeKalPJ4H6R/5dNw40xv5XEzJSkLVvTF1vdMlekIKYYghaCkJBElTvF5+F5isC1OI4VIyKElRonDJ/KvcV49vKir0ZqG8CrRu3VbQUQnmRMQnGNZRIVJUMo2DFOeSrDZtauHAWNBhXpwLrlHSrTMsLsrOSE917PPeb59vytvDofD1dXVdrt9eHgYdHhZ2Prkk0/+6q/+6u///v/cDZ+uLBiQRNiVPHbl3r6YLLeid+k9ivEJrfOSbVq85FFZEX51Ez5TIbfIWUaIWrhNDc4smXKISNhihOUveHLBroLTdBFWFe7+aibYTmO6Z6U2XKXVT6uHqRCV7ID0qKdu1/jvqgMMdZLHwklWzP0y3099MZf7GqDHQ1vvC9HiWifhjn3+7qpF4jeOMamYdN6bd20M9svyoDlQ6xTOM6Uc35d86AKQ2SUFJltBXpmrPPTUor+Ln4Frv9VcfiJP5LOBlj+HwSppsqstg2FfEobABNnGQIGYN6xOBOlbM/5I4qDC4VJvT2PK+kFH8S0nokcf2m8Sg1BKWRi0sgC53mqpUjNmmDJ5itRJsvyw6FqtEJ+o/JNXvnUdLQWUkhhzplw6rXKUpP5mphNGZkCL07fSh3/6XriUqe2qfRvoGuETqCKc/xs60dJY1lm8llKmbs7kZRopsE58IQ1Z/JoVy+eA0oOHksK/ETpAsfJQSgY35cRHB04qoQWKiinYJWWJ8oy1+Ur8JRGquzB5UAEfgB9yMxo30JosHYO4MGdhbVAZ0tqLKBD0r2p+sjzRnWaCMhXuolJi/JYXSgzs0ZbzzelTWhlDW8JFiBM3TMES/id2MdtdkxU/lLrFuy+//94bv2t//eWXX97d3XG733zzzd/+7d/+zd/8zevXry0pO5SfdV19Pg6iXARhkiiQa4FIwjMtK1u246ItqieYQllGWdo0MCcmwrdcQPNQFDXmq0DZGetAuVRRmK+yXiq4lXCE6TCVWtWWa1HjWeEl+Jpx3qiojMGrddWfRqXHifSKihVufdGk8itLWYv6zQagY3SRczUJ5fE/bwRNSOcIslGHu3E9CZHRuFPPu0eJNOz2PSCm4nwYtletc0ouU7CLg08bF5CtMuKy4QlSK1xOgydcQjmo7JQCQ9CLxy7wmNYX5D7MfMJqjfZuzFW2pyE+Bzz1lNuaLq5uo8bk20AwRafIpUxmt1T5K6x2PoUaC4XcJNkWps+4SoCTlGLV4Kg1fEt9Ad3a45dQuap+CprRauRNxeyPZRWxRJs4V/dY4KfoBmR6ar0yxovqx3/2foztVpsgy9CWMlOrsHFZsp0mKZiWYxE0k9DTeCu0yq0iyH5arOElqKaMsjaBeSmtmJS/SD/qM7VyAeLRuRp9/T5A4iKmAEQUSPl4IalWtzGb5z9N6MrGhnoK9jpt5YXIQIkS696DdVuuuzRzslPEOL3XVmkOxknQuKC8e2zNhugAZDRcuHcYehSkKzBHz0H7s4wPzOJ+138oVNGnC3KAYsrbz7//3bd/T3vbws30m9/85p//+Z//+q//2v6gpoftzPFh/oz+QNtGq25Qe6iUW4DXceOyTuJBa5IXbqTSpMz5HyGpQ5i2pXU8uB6s7X9/caQDorN1G0/cLIEa3BcYHckkKCpHxlwGDrIkhM5e5z7jemH0GZ1FIecsW4OebpyiUes82znILjk6KF+2v72by7447+xnaxZtu61JD5XV+luYhBlnryFPhxXLal5W8Ncwk4isu1CrwYPLdt/ioGA/u7/uen9HYkvgVeDWpr4mLALaFy+n0X57ypbia11GaaYj1t97L02FfY7do0VGe6ore3O18UEhj6w90tis9kdYKpuHOWQ6alDaDm1aFWvy6knKbcucxayW1q5yZwUKME15UmeVW+0QtkW/CLlezuOy/rEE2/XFsL1uvRoblux5GcYhvW/wRA9aRg6Zyof8aPTUrw5Zbgw0ACNGTMab8lr1Rz97J+SDORzaowyWfSbdp2ycSG88JHWBXpVFzhfKMpOGczWEBo18dQ7VblTjcxbK4p1WhDggojiUpWmao9uSwl2A0ibl8a7+II4jyfO3Td8V2minZJMD5ZlwTMBoIfhgIAc7YVknnWSKf6MzbS0Zwr6iCFa9nDQSOXy2gguBcVliRBkoT6ZEeoSyRVxmD3gRIByuUsbqZ3t/CWbTk8t1ZnjZ9b/74vtvXH/Hqqy+75umsXrw448/Ph6PS57Qsdtv7qZP5pwMZjprRXRecgu10wajN8pRT6qyu27tUbB7bWd6mjaHwALcYXfVAKgVwgRorslpN1k0oe0AgyYeL0UZpOdUsqZd+6IwR83iDLW67E8DFV8QVsonx04ZNuTHu4QBdBUvInjVxD4LcNNlSY/T1C0Y5Lvw5TyOGTnKzfsSe7UW4+OyIK0gOgN10QLa7BsnlHhGExfGyUp3lYLAIr6+mCjeK0TUx9HiTvWsap5Vk62vcWpumrIr52auOgtn3oucxyfXKvjuZKDhKbREjxinWdZ2t6nId6A6ElvH3GClAY0LRZFrKKJY9lDLrTKht9GGzqBq+a05RpjMOKrYT6GRSkFDo96SgG+9/myXUjwNNCzzE0b9UqzWV0BK2fBLifboOvnMHeP6gZjGPF4gJGUWQ37vJ2+nbFvOqTUo24Stiz4gstO5WGE2YrMfdEVk18B4iNhA3VYhQngMZk5z05TRSVztiwO0DqsAHhbxKGZza3e13tJaedUFvYIWzDLg3rAFIjepsvGxRCrJhS/Cy7JJnp88yi+eyBBljjW0KiZ/FNPKKhAlwnsu9oHwD/TahNQqHRCzJgpbBIBFNqW0b9ts69UaIUwXligVueb1WIMEZ3djUUDnR1iD/vabT9954/u3Vy/HkfxlsdzKakPH79v25z//+U9/+rN//OX/uIwnuzxANy36yNFSNkQsRH3yteKNP7h1MfvTXo3fyBC6CqI8gcZWVe+wVIN1geJdzUJXlWHp2xiMgSkYuVvxubIbtbhsMvVv9YHJJW9jWrQwQrXjwdQfu7PSa85RCdnCs4kek0CfiXNiDNKcN0ZB4sevJncrvbZVUXgIHqNnKheKedW9O17mnK+wbHSDvcyVwbcgvDSENpB1Ktcr6K4C/G/2nr71yrmUQUMiDUTfkpL9fjfa8fLr81SMb/3Oy+vb/auvXo1XU70080XA4jxnVTzRvFKrfaJKwGBnDlISJsvR7PbcDSGdPkTFs2wVgi4vitlxsFUXDUF9TuY2JxTgddjkJ5YK7DCeABpPkLXQvZRx6vs51EbPJOggjG7T0vLN0j+VtHST5HNp0byK4kOz1ISfzhnhFT0t64VbkelkVBX2HmGu98FP3+EQ47+Bzebs0Bw1qhbZFBBsKDa8ih7CArHIAulUhDvaUxNQ2a9SLUFbYo2kaKuvUy0zAyrlNqISJcdK9ETWibgqBtfhgwnDaXwO6ASTbXoGMc04YzxVu7pUy4qbps5ei35SjUMuAwXfuJ4Gy4EiQIowz2yrlhImYzdVAwXEE4cyBGLr4PsShgdbHdMlqx9HnJWSb8sB0wK1Pzx+aVcgN5lkjuz4txO7prVX5JXgPH7njd+3JMvSK/vy559/fjqd7NM/+OCDH//4x/Z7P/78F1+++qxkVMQSQ4kA4WdxqVx810+2mnuZ2MGuRKVxOQ0aUEoNmzPlPBM7E8f8fVGJw1FmBkRIkV0VOIv/6aWNJ4YiB7DgGv06rJ8dp8/2AzRhYCo5JL9pMkEP6JCenZN7OeqqrHUFspQKolCG2M2WN3wxLJe5f2O5fn9X2P6yf6o5WTg4u1FLvfH3dX4YtCw9AAEY5XkZajjmOU+oVYhBNLLt0W2uWntQMi9V+6wM2rOyOX+wS07n2k1z/+lj8dnY/Gqa7sbDV6fh1Vz903n61dhWzdyGK9EkKajkOJ5ol8VK4i+A7RsBKQBtOatdcq/NL3WzayWHCFp1kZFK5DWIIWm/erNFORG0MlY586hB6+1KLLPeXndBOwDlGDFcDpphyu7nK/aKhozG8WonGd8gp8DVQSTA0AWsKQioRaKNjlYPmceSKfvzKkSxeOee7qt7gQw0oDKXVCiBmbWh/yKQsYJCAR8sypj1aj8LrwR3JwiKyAWqFfZPROga18qok0schVI2zQm0NeX4VWRPy9wUJhAV4iimTnRENCX8vEjtyYfcqNVIagrxN2Newd6wtN9x3GwSFo5imZr/5BRTLBcdyFWeITS67DkIDRzdTRc9JvsDod+fwAqrF08efiRuc8wKRd2GZ3wqYhJ1JJJ+lNEFF4Z9uhz+7Xf/ZLu1I96qlfHrr7+2kvD58+c/+MEPbm9vLXj98rN/+uru1wDqtrx8woKqGMrLQaXN6rQjjHYeIEz5kIWSarfKlu2oF1dTcBYGvQV4AM5d8BmMWVmm1e/rdcpFh2pD1U0zDGaEAbT/hO7PHqE8//LXVKr3j7aR80Bchzp71PiqhQRPsu2H0GlsBKrS3q1O03yauxdtl+r92/v+1/bXU7lPb33v5bAdhnaYu7nsfYEEDKKzUrlD4aIZL4L8VaKFsP8cM42oVOOCGg0Cj6cM6AryGGT7WXBSUTrdbLaY0+6c2rHcHMvqsd2X5S419Yv2VOTeQsgzmZSj0RJTyKFIDlwJgDyjDiEXCX67rdfkC4SB2a5CnUpofc6eP0/ikYbTCwa/5Dv8uhWlWgvSUGKklHKTSnhrgvGvEC12MVTSb9n7tbIVwXf3CaJSBCCJQw8ftukhf4p2HLkIfRtsdmgDrpimsz2cOJrt5XCSVQfdO9+hq6Q8DnFfeIAwfoP8Hz6U7F/D+xxqbJEdbbxcl3NQoGhK83wdjHmAh72SfsytpafBVZwPtZDpcJ6OBvOyDoYkSF9OU+5axpkzStYv0+fQuLHf8GkLZlOJWFfUpNzRJzq1qMCUpNAi0OC2YrtrzsexzG3E0XsiBX33Oo+l43C2RaZaL2a7Ex24EvHrKk6zOlipJZNmEIVNQ4BKFBrK7BzDcgZwMabD+PjJR1W363ZXlmF99dVX2xfLWy/e70+Pn/3f//UvH//vY3EqJa4GUA8YKENCvH7oIDhAoUMK+6oqnbX/6eWDXyzhugVnZ6IiYKUhiANDXG9KZVTJqMdViw8Z7XIO1/DcJx3L7L2Vsjkahbk0MbGHg0GW83G7HIsscIYtV7Ws4fQ4rCi1a5Ie5uL12Dxclb+6P1rZ+gtp8O7n7rP08Kv78l+ncV9btstmBgqYYq6UvybHGaSfp9fuKJskX/b9g/LoFc3s5cxBkWh/OB8G50yoAUqnwg+JNKe2fKvc2k9958X2cOl3m+a8K5adr9+2Q8BUZd374gRjMelClihhNo3LSIjEOUAbTxNwkN6bczRlTzTPKIunOSzB/5xj1WEAn0TSXoqVpZQ4UWDSA3hj8To4QTcUThUSgtrzDPtOhwLLSMCVwaScxAT466jleZT+yd+gOrAhtREWESaIpETZYyG4U4guaH264ceP/+P7KTuLBu9ePYi16YZWqM6AS8qDfbpNBcFktRItA3siAwzfRdAxdjtpf/i9yopPNGvqHRkYaJyB9wu0sVes1DLwIjhWc1jW5QGoczYUJK1r5Ja3fMv0B8Vy7psswT1pmcgUlYh9s62zYAAFYzAsKGnE0qtajdYwjRLGIDjfsdvFMggywUy/8isfmB+VqVj2bbRLaLqpYzU/RfZs8y54gg60r6G8KxYItPen3+4ebb+d9y/f/bu/+7u786df9v+SXt+9+ugX8/nRHsOr6rVFcK/I0LJMs0qwAASXPOyryPMbFX8rufeV2HJZzsIwLsn3/Jvt+YSsqgiEe8p5Jat8FbVmgogSNOgjSpY9kz1PEFBFf6/RA9XSUTucFCZTgBoM75NXp1Iz8noaLILY/K/o3kjXnZT9+dlWbarpN+NVZ0do/8bVvnxol2N/+ayvvpqGQ/NyqLupelUOzbbqpBMkyCIXE2zkeJaHgNaxc5YNCnkyL9xQITA0mV0F+SjTj0tI86scoryuXh/O+7G6P/ZvP99/c3+6XBWnZcrQWBn7C2F8XW6v2yUb1wkTKEJNGSqxtNnWgE37245MJzR3KBAsWg3eoM9K7NXBaZmza/MSBRB9tGL1mRB9d4lpRtLYMmGM1VjLVtCCrC/dgE3kJUcPoXLgLCBm6GZKbvzp1dEqreoyD91xs8Mn4MhVUAvNrpFutUt2amf8OtbcUN5ZhvVukR1Ha3/fNQ1B7KtWuD1C5rIaMEWFmSJpjHqwzNaaT7xQxeM8wKqAHFjRjdbx7hpxCd/sD46bokcfMQMKI6SKKUzZsYuaMA90ie1HEZFdLMIPBMMzx9G9aU18DESolpywLIOzezoMtQSiIBFlGcNpkK0U2YrUHkWr8sRpBz2StyWLLej011Sdu32MHV5dyYPSpe+xgBI2L6I1QPC1BWGXEVzH/D+qRXsy2VM3WaC4Gq+Wy/mjX3780S/+sXjzrt4s8+l8m66vr29e3z1+evwNx+mgVC5MuKZMVbc0Qag5BJxliRFhhbwM1wl0aq4vO+/cjyWM39IbOlCQ6gwb2Y/Y7h1zTs0FuwDb85f2dOjbbM9EYUVWstk2SkDwSCjwNkDpki1Y/aOun28sn2VTUWaWedAe5hmaJ5h6pR4MiPbkdFONX4+bVF1tm9v9xm6vSfMP3nthu+Ptm9byiedXm68eDvXLNi3hQsGZBI3WeXnDHB6Qer+NkjhKfk0tmpjDWK7Gbdm26fpZBwPOUX+P8h04nQuPX7Rvddv+wUvZafviMT1a0Rpu16p2gcl4irK4iCbXRlWqQ/KY96cY5ihCGU6KT5ZNFi84yO0TnJ27hC8+RtUO221rW2O2hoF0YqDk8sSI5IDHte3bxpkYRvYuGODIryNGR14cQT+MlYQOh0OR4oiFnjAXmpaVZZ1J6WhUlrbVnKTsLITFm7p/OhKY0vLDP3ybDguZJHj5mB0gscSA/qfEuIpJuWXAHFRkYP5Lnv64ktAKQjtkhSp8C4gvVOyCTmbCmbSpYQ6NwxS1AHtjCg+/gOEd2d00oXGJBsqidD16opAwcD6SOjcDq1lB6nZ3GpSkeSSK911dZiopgJp7LE5LtmGL+QW4etqPiyA6U9KSyOyvO3JXVCZ0vi30y7IqYgFK+hmJ/yTKVcxG9tc5Zw4eDLrx4gvXIoKVPCJDaAR8sXz+6lV/ml999fV9utu/4wK9YZpPX84P4/HL8su+7AslmN22ApIAmRoEabGF4qTxDlolZsNELU+zeRxiFCBaELdJmQPU09adW9HNg8+9yLx0Scj3r242VhkBJ9vd2fZAdbzENBrBQzobUqB1y1mcBh4m64HQxkAgxKceiZRbKdt1TeAgBTLgqcCvgGI9CbrMxcNsKcLrx/PpdLx7OB9736VHef5dxqk/TceruXEKkpctj68vmy00COiLMbWAhWTf4ymnDv9MUlmQ9DuV5KrBW8KTCx3J8xDuQwh35EHoG/V8XUz343Sc3rupj9tlbO2Y7OEHIJFZI3WTJ4wU2a9tzI7+tJ7UEp2kzRwxcsDp0J4qfGxoZVkuU9LCIhd2F8DQaSb4TX4qd1FMWKprtRueTmCClG+eVZ1t5VTo9mMsk57Jajrm3XkSt8CCtJjmZQXUgWWgR2CYA50YdzDWj3dIlyIrYaOLVcp8yXOXD//0vTl3xDym1lVWWkwxIDdBGvAtukIeZKEpZjSEwQDgCLoBu5pGstLogunQUNcvnIZy4yncplCHiGNdU7kgNqbYlqVGuVINcBMvNO9XB2DU28QFF/TqgFrC2z90BhYcT4+9/W0J/Kil0fsAzhh14wTrObtK9DNkgkr9ZhEUFyCwKU+dLGPcpljIwhrtqMfuFk9RYitoGuzNJeseCNwVkx3o5VHrqhR11Hbf8kgpcpWHThRc/ta36VSepqu+eyts/6ttOlSH34xfXorLEqOzMZbR7Q/+cim6vXEeyqqizmNZEb7aNxCbas+bbDuHey+t2K1VzfpPSj+EnIvQQCimK99dsGOVwiYl/EbAuWLGT5FgtOMi4nlBVV4Ow+6mq+XEgAFB5Nd2GccxUgPv6yWlqAMWsqR1Upurvp2iwd89FFYUWjL1zP653h765d1n+/vj+e03nlvSdng8n+sxbTxrsyVht8ZigF0PLQZRJyHe1phApmKK2fGhSrGz5PjQW96xLGGRPo+BWlDiNauI11ZSXV52xfWpstjw2kJc6WsMC+wsYRH+6wWW1R/jnEdAfjuFl8aocZBEN277JY8vC+NZdGmwixiGuLrHQJwUn65dlOqSRjQQcXW6c9dQQ8Hy7TdaNE+5xvLyHOGU1oAEeV4b2XOwE6VzO9wE0kf4pv+TzfsjlU556oK6k2J0D8AjC/g61w8+wG9UnVRVP/yjt/LOsYDiYbsRuBuySZa+CpqwWBCq3bbBA4aSruZrQ4blurASlocnTNHZyS6XeJyjnKKWJDzFBhY8PEq8It1/PG2pAXComAnMqwsCAjGdURW0Uibl2R/cUlIZu79j8UeKPA8S12NboP4InOswCf8qxR4aOe3FilBGPUYYktnbHMzVJWgf8C2dnTiEr0i7xTEoBuSGhdMSk9rWcbgBl15iS9DW5LCyFckKq9twd9ONe0xsPc+X/HVX4emuokmLdV/BSrfvdNbCZVpyMRiUQnXljo+DEthEA1f+OdnpUepCdXVn8aomHrs3VUQ0h6hpl0fRikY/NC7q1dQ68OxgsFuzFZzlx1HggPsRv3j4zuSa1ifgof9yHL3nK4aNfeDVs87iFJ3TjQwnYvRDEa479oOe2A7zCrP6adqk6hsnhdk7bMV6sM8Yx/7x2I/DYAH77jT0D+P4YtlvN6wK7Xy1esUO399sVP86uk+z2GLEEo7jBaBeL2jV35GKAHoONC9dsofkcPa4YG/NTUfUGjtulodzf6imdt9Ak8ZEENalZTd2U1ZX7m86cgU62hLZiF+mQYr2n96IvExF2JNkGzwVg72wUTJ99ZSitiWLhNYUA6JV91EquQ/azquwzVXrp+OEhiuGv00TuvHwbg8jDTH11oMwfOiLkFUjZS/Vx7PXzR4vMk0ScVgx56FnkfGVy9MoCYkH5uAhh0jjj/7iu8HZzbbuudOI88ZCixEX+kyJXELDkVJwAqf4hLXulbxGoUoODavgK/wSlGoVMXQs1v0gdM3rcN+uuFxVomLPfHImlT1pkZS0h2YqVeGbYXdot7K7iZoFCXfVwNtIoCEwM6mT+6xci0ZM4ZFus28LrzHnKAYVOKewqU6n49C1WcSgrzuYIna+o+/4ZC5h5EYZOKuyYzSe/V7vN/WTu8tXWLwviHLor9uPWw0oKsCIXJEmKUsQgydaNpTVqmc9Y0doQhtBSyHhr0Cqsr/tmPp1OY+ywZuzuH3CPEQJha2w7DEgf7SYh57fbHx9msMETTi9FZT4QGmeSszXdC5CGfNvvNzWMRZDKMSqvZymwKcU14LEFFBYQRQjV3FH/dJ/C/berVAze4ZgjrC0YieoeW1BZztV7Zh2XfPZ14d+GG63zX7TPhwvb9zur3btl68e7Vlcqmn3fAMepAFfJdx3uy9X1ei5oYVcsnqfm7Jvs+U6KOuchwjr/kIvU9DfxbazZ2I5Y4hqRwd6Hbazvb8r26vGD9Qxhtn4apcSkDkXaqNTwYhAoEPI899NA9RlCTjIlACNaKjZB57FvKkbCWU8iNSUGvgdAWsuOZUj3/HtXfv+2l3b85yB7T0d1hlDn0dpfsrCgDRnm2yttCKm/OrcssObmQaIXsjdSOXsEzR4Mcbc0ny0xJlxMb5Bdg3DwVjz1GfdvnE1y1JsXLqQHHQPjLx88pzPkpogtS950vKSx39531pIhJ02Xs1hOabHSltQljp4X0SwhHfnK8OO1q5a7Qdp2wHG0/63g4tG5BJjx2MQSBXdirJqwrKHImvO4qPMoPU/kEfge6s8aLIYrzjoWW7rF+/f5mJ07WGPXOphkcOT3MFyvLrd0It1UEbda1IwVD6afzlZerS9bh/vLvbQkRzCnocNuKhcdaRJRisupj0OMU45iyGgBXRCfGE8Q1ayAIRwUhDJYj8oeh7ygyTITHo9YaeAjDJdC0sTaXcT7McYt6N8m++5fr6xQgwRFQsAbuRq16vNX4u0GQ/H/gBOB+Rk11PL9B3vICAP+rnYvzg07llktc6LU6iFqlZpsQV709auElga8wFdkR1YFqmIPHLYcB64Vi7oFLHPWyn4ZklWx7aYNmm8KdNVVb58cyhOhzRuOo90v717DIvEsbzsHclyaf0c1oCDlIYpm/GfDqP7r55HZjrE8PrM7SYcr7mevSPI/VfPNlMxb9/tRl8ic2o9sXFFsQoLKwuc4XEaeX2u1tIOV5/H96qKgznMo3258p8lJWpEmWzp5We8FNrw1yW0DJqkU3az/7prrQ69/Tu4QUugEHAjArEaYsI5XXW/niIou7V6pjigNBKry1xE82Wlfl397BjCGAYSID95MttmX8u3dkEJx4nux7YYEovuNGWLQbtTCqNaE445iqof/ezdmNuRXWtXLXF0fOBMFz4QKaednrbQzwhuUUwwe3KVcp2qkmQhfBNe90pixyLmgC8c46v710VJI0wCjKhiY0gAMVxmRJKWK9ECZ1pJ+I1hL7XFP8SOsiI8QjNhChydirXFJ2+Rxa2bMS4h2cdnPY/bFHkd0vaUFTbRMy2zC6Inht7zqsP01tXq0T8tGc+Tkp0MlMnBABbiGJ1N+SjQgZrz5Ks5Q1czKrBhgh/PJ5NOIh6ST54TYrW2ptWSbNVvhlPQvDgGZBH5NOIPzOqEvxeTmUFnZFxrP+yJw2zLfVAQ8T2AMoklpWau3VHZWu25a473ffRAtXgqNRNtx3pQloyRPlf03ccw/7HVH8348FCHyON5dMhTlJMCAkr2NMHLXYEhZzD5x3rRwGm0tm69jWX1Y1sMbXGqpqE7n7fLZVccr4rD7VK82y5fDK5RnefTftruHI6m5+PCeKEz9i521x0GfkhZw80uO2J7+qDajczFQ2obLNygzqhMvn65swd++uKY3k3P3rvZPGvH/XCpLkM5tqlZpuLbjEL7pRtZKiox8XBj7zfLAL2AaJWUbTy9Gi0bWrtPvaoT+jMgmIpoYPbVStBZljyrFWw6WzDbQrI4e3wYMDuDzRBJhniwCDDwKEd6VdZPMngwIxnXzJR7npUDL6rRCe8PTFkgVyGDoBIlCSqfug1ihxBM34Ye9QrlhkLM3QC9qz3Dwh9yzHoa4itawkanH+blnLH05v22qxB/hK1KnmwqK+t14kUM50hhgiHWX25hrABt48t3YC3COQKis/TSKj63zSbKhgoqhMHeKmaA+BQkY8uqouNeptX8f1VyAHzQhp/lm055RSo0yMuYyggaiGpYmVJpI60euzg6WW7Ce3KMX0Rw2zl2fKHnRDNI0KTcKCLfqeaMdm808lPONvQ8ArX1zsOmcgBI6W23bSGsKWuTR4qsiqM9HJz7STPqfKPubtqwXSoL23LjZeRBUcT52Shz51Y1WjS/7ITw9mQRvi5FjBok3PCKfSm3VaR1FyK4RqKWntvDWYEC7sIO+WF0Ejl79nQGiaF1MwVvQHk3cFVQhKTvEaN4pj2EdUfW6CaAAmnCgtyID0+oi7TK1Msv7CF4j6gfwz6lAG2cRDdb6E0vj7OPIE9Lum2Slgf8xj5TrkJrVYQ7iPj0pb9iPTdXzHgb3iuMPHU5QezaSdfib3xM54+P434eP+77fzg377S7clN8Mh+LczoUde8JJLU2lHRvmD72Kes6adF6Cu/90KAsOax2RZ4SJg2lAAHHnlRS+ezbUCwziCDpoAof906D4FYPYdWhMb2lZUhEeA0mBjuJZVrR9aYPzsIbNcJjVgyCZ0tlDb25zHPS6HcJMClZpVrHudkqMNc+dqOpHApB/mlqEE/hmituLSZXDqd8+CfvEYlysj2XeRAbJnmki/bD3oBXD8sfZU7K1DJb5qzLoR7MprqZxKFPo5a2RQb0UGbGPbxRun6yapXzf1thWSeAqeB5OcS+6ifU8Aban5j9HeT4dDl7XhAGXiorNOOAIV1Oq4VLAhUTQ0NY1zQfkDGqNJsYG0PLT0wOJ8S2QtbsoTl1q61Oh14+MwvrmNrZDgehGCEpt6dHFgnLLITv0ivotPMNj1cvnuubXQ2YKgofaYjyzTLtbzqLZfvbDZ4n0d8IdloY6QmeZHxRgG6YtxCpJWCuWCj2GxmE03kzpOj2DaREu067F/fq1EhOiwLHxz6PWig0O0AScbmSU9njBsPGQ8kQ2glV3HaGbXbemmCmg/0K4YOoCGLKlpdUXe3L4zxhur2oEcybIprbmYTE0l1DjwMGcDjM+G9XUa8kqyhWTwJB2hbCijy82tNGu7qvBjtkl2Hub4tt2zAEzH61kzb1g34Xa+jU/rcrOVg6GZF3Jqmp6mC69RcvHkFnuFP7kKu6Of23h+dLVwzLw0ePx1/Py5dp++kwfzIuN9VYzDQBiQ6zJftdCF2hfWIaI5FmaYc62db5IMC0WMf6+vpBDGRxBFQRxjm4hyYYeJ7LkWBr4HwYMHovUtiTyu7Rk9ZOrjiV1P6lMBDBiyPjc+wH6fE53qQxHzWmtcouNSXIUxmPpx6qGBdS7q7a00MvFQ324gtDsugar25/dISp6rD6QQQEo3VQH6P6wR++RV0DLJryoOqJz1rg1Kk1k8fViaMQy9EVRm0NkIz9prfP22iczzEwvQyh3BIdjSUcMArMfewB+QGSW2Yx3009Y/L/IFKm0IjAtOI41dOZCTfKyGYSjTz53XvVNM5tyzluIspYymavdAZEnp6EMc2EbFscMETgyMDTDfvacdbjqhgNkKRY5LBaGwtubHQaokQfmZ05Q322N20hnpFK1EGCybqLgMla+XbKmDppS7erL15xVDxkwF1OBPp3o8RrtohPD74Qnf2LVgFzsSH09+QXq9H+nJk7jec1/hfEsoKx3MEQLrZqgXN38N0tYeQ6wVlpuYhN4ugP7QKBdN4SorGtqF1ljU64u9gD8Rs/jjEtRhm0AK+aeMex37npsDNd7ZudknYYgviTfcdGOYXil+SZo8w5Uxw2AVzY7UPpVBQuLbEqH6ZkAWNIl3YsWlvTxe2LLVvgZNFZZR3JnXNlFA3pcbebIJFmDqf35ke9PrsSZ8ypX4nT6WmxxbAtH8a3n+9vmm6v+Ldtq5e3u+lZNXcOq2PwbVdoNxgpc1ZKuebUnu2mOh3F80qIZmZMEGP+hXQX9gDtBh1u61cryuDu2P/vbzsLtRyT5BwYFknM5LhHJX3+OkIRwhQZTKAZsnvbXjmxjjJ2wi7pHMYMcGgckeRQa0OnBVRfh0sqOExwkgoRRBQWa6ccOf7rNW+McVgCzk/ZW8Iv4w/+/Lsc7EQl5uiG3aij+p7uNmLuIJK0YwQuFcC8hwYGPSK7Q/YlPIVNLvCIULpOcygZUkaag6jN6dQYxRVhFp7c5nHEsKHTh1B70z2xNWd5lo7ognSv0UBg3pM9nd1V55OBF+fLbeVqJPVAcBpWlcNGHXpYBfayqzL8Lphm6EbjOkDU4i1YxCnTGjDfINw76BOm8vIwot5WHzel0Cuo/ioQ8TQtg8vDiXDWp4lq77dM/QK4AzmD4Quh3Sn8fGPasO388+MAgRhSAm8XyNxThtNo12Yr0hc3YjRYS5q7NfgIZTdpuHq2KeawbwwJcR3j1C2UOzysdoH3py8jA5znPCwSpnvnPhCezG6uPEVqxHu2BG+rrM1tecTj5/nHuaIqgOlw3J33KKWptPfi4JfdewaD/VDpZ8YcLDG11NOKRaC+bUgqF0sBWMb29iVW9XpqK82gZmGUjgqJZlFapvDKvmfsH6b5WdpuOiiLhQpVXPpYdZZzWaXmGMVNxyl70Upz+tUUc72cGnZ08+VS+pWw8RG9pq/GZkhnS82K4s2bXSPdYtvUx9vi4g6QMXmoCoWcbv/KkSwYlWryFpjk6Gz2U8QBozmGfezV7bHFYA9BJy7Gc3g/av6m2vrOCL1qiiWsRxin5jXaEAHOaRxYPLXlal+h1M+boWRS7rW/azGNWAdb0N2iqWqb0dHJ7JJgt2BJ8Zin3unHG/r+TE3e7Fu0UI2AUaj2GnxZsQgx2nMPicNg76X64R+8NQuIYQRYWNm2IbyA4DMxBElsiKbj8U00yFMMAYMvXjDBKfQo4eg45VntCadwDDxDhKzOCBqaMjfpyzLP+C2DwpcnGnhksdNGLFNPHJjCEvLaJZTPbmVbFJAM5zyJGx2msx+v29nJPkPThr0nYubQA8k90nedPRAd2kAtWPHjby2POv/mrbvZURSUgP0xRklQJTCzXbpi4sS3ocSmmFJaKt5gzMgoc9ci4faVhV2zpdO27bGLRBIgJcfk/K/LDJUsBiMqzaRigp+NlJ2SPGXduCxuPDuzFbxRpW/Ll0J+DCms39d23x7uLwLmpPmoqHmDuNBGsjky7gk31zIPjvWW0K7mi7UPHAuOgl1tVkwWmbZWg4thhWoFb5WVT5CnO5l2sjIxp415MxePxaNaOvYJKmRCWtiox3r9bGPfg1kwrvl9zDpU031TDp9fbBN1ZXOupuu3dkB7clKaaCXJ2D4PD8cns3AlkLcCJS9FzHT1rDse+mpTbm/a4SQhhK/bYh00O96U1d3cpPIyeL5v+emrx2N/nap9jcX2krWWnp4r7cXmUP2rkZFcKcSz88YrCa/TnW2nrU4hzOwZTOXnMUYcOCd28e3w4u29080nX8aY1nu2IVazUmM/qvd2/az5IuTokNQ86zwOTKNgCaWcu4Er28WjTKjVkQO9oosFhuj9brW2JLkfgxUhhOQiSBRRgfr10mBW4ceyESdRD8RXcvWT//xvVjg5QRqoy3Uah70YXATk+qrTSc+FQkZEp4SfVNuGa220zKd5neZmv1jGrzVNh9Ur1rOJwBHDUQ+wpmHUnQBgEp8iG/vBOcS0SFrCJ8ocqQeKOQwtww4lvMf8feyuXdtVaAxn0i04nrLHq8v5vv1pYKPSARljsgBddmj3jgWQUcuSPCI1nko0dNGy4gmBQRq8OAore+UWIlEUNWLAI3vyh1nFeZLyWAoppaAgYAMiY3jFPmadSpfnwh1ODpJ527oAFu4/JaIcI0hVxfj19yqZN7t6HQ2J8tnley82fnprN9pVuR5QyYXucYSoETwacflsX+H9Is/ySq/V4YVJzCywXqVpMcyOfrafT3qR0KkA2r0X3LvNIWwPpy8OtoU6iBQM2hvUSieV9nzqOFKmRaCPHmj0WPVX0d71PD1EeaXaxOPV8+1wGJszHgnVsA1KsAUIh/DVwGUN22+pM1XQK3pN6IPmip1GLZCufrOud1XaF/3dJb2XNs86+8+ls8i9tPvyvJ2vD7vbbXX3eH7x8sVQNIf20lw3TlsRXtNIDR6m+HM0eZ2hqhMIMoFFcwfR/ejypeJV3pKpOR2eLFixFXhOdJvGCehNeJzxCpxExog5/ZQH37NHrpfvXeEu2asWdiaQvUH5cCHfSZogSXYMqcVTsyU0D57bMq1myCOT52WlZZBAsY8wOxLW3mLP6QVpLbPmUL/NY3Y04swrYpRMUX3ws3fCzauO8TM4gVU073yNSkVchQsofjq2hewKmEnn7ottfRZ5isbWIMSRFrXmo2RiapkH3tWikFWllTNV1tyMIvs6PwX5aJVtBscQtXaO5j6J150TLJAeiK5TlKS8wiobr5uV7V2pgYUipKyjLCXuqH3uR7SFKrYiZPSWeSRYdF5GZAfqB2NOEFPLNVXUQ8lGwkBPvy9ztj3DbWbJNEhP1qQlWqrVBlo7zXFo5yJOQx8z2kSkdsSU7AyIYWXA4WCRyb2qrJXv1k50wBfYNn+jJZ5HzNrJcXR7PIpiguOYJbVcm8gHC5PyfIoMDAb9zxuF/tJHPEOE1jMUcqTtwHHiDNXrNiZWzN6pxFVqHQ7mTO7DUFarYDBwishPBaP0MgNoNOmTnAibBEiCThbRoJqdZQSWlQyBfxcz89BnihF7gM5KuUSPBV/QWdkra7K10/vr2ZIGS24Pbd9tW4J4EX6+sT8tu2nlg4xMDxxwnQjfqkz2lf8wb+v2MvaH//pQvazt3X7n/XdsT77+5m7czGVXlr/0Y/x4HtIydeV8uFrG5Pj3SJ9EKzY0PWolLf70WoCIZoMrgT8ZuBc4dLvRCK6q8tHvhZcP8sxZpsLSIkyEbMmB4fjpu7B9artyW12H+wF5//mAK1wBtQL5XlK5c1GhY4kkwn6SZctDNVfYUc7ToSc/inKyDE0Prx5SAsgyEaaM8WIh/NJUt1aZl78Z0buSGIVNjr++0aymqT74ydv4yfTiSaOJx0SxxkehKRH9hZGL97AaK1NZXjUq5excTgrXKw9nAsooMBu6PKFXEcF/N4QgsPkyk7MA492ZX+OYwubYwd0KlTy3B9Uepq8MuVP2gfacy+UUZchB62yGJZZ5wjlTGZCf52LA+88e73s7zC2bgG+BS4wl0vZFOpL7645shFDYSJHA7BZ0uegSglBKxwCptlLOVjOEF4gqSMb0whwx8QTKcSJLZ7x4UWAiaVcZn0i1BmavKoOw51+txBGdCoWwP5HpPdnxPPG6Y24YHCKmE5JvywxgiTiimYBhMJKdJxrReTwsHgeaEvZOcW4gZGRG8gIkLA7q1m7Ntt/+tuNe/OBJ4ckBeMGPewhTexaCFeO2EMrB0T9pRA32jW4skanLVH/2dauO+ZEQz8dM48T00zI7LmTJ1Bw+F9mpTqho4+/oun784tJY4WWJYT1t3tws/VL5CTFtJbewtQSboZW9hD1klKo4fLCf/cwAorad9st+ej02j2n6dBjfKC6/Ps+P0/I/T57mfDr97s2t3ePpMr55u2ub+n4zTpUXOxYIhAc9jQvUEV1oPNp8lu590OJHtQ5GKVSr0mTcBKDJlI3CmQENKoXSL7JG364aU+ytskDrpwx9hjBsgebq1tb/wPDgWSKhUuflkKcoDeewe4JYQ1cKu12pXyYLOlhcDeGf4UwINYgbKEeUWauVMZkEgAlZJKn9PORSmtmXmlVuEcOx5h//+fsxc9w2WJ0kd9L3OYXd8ZFRhSs2uEUe3TNngwFUQhyVOylINV64ZICiirI6+65U4XUpTxX7yuGuJz/E5J+BK43zJ5xSINx0hFw69PMq9XaGnuBVf2rD4rwSJUejzGodWPFUNhSOKsHCsdb9f91/o/E3pBKy3TqOOwrQDWhGZA4lbuFlaFGfCsu2IkQtWGAW2uz1kI07QizLZhLaTqQKcjeU9x4j8uxSVCm+o7ST4bnQa0PYwbIA9aegs2V0/WzjcUQxl2l9echSWo2eeTvSkYEyFJgr4Wmj4rdBkuagj04OwDsh3CG9xHYuCHEMQM/jS/lAtxJUZrp8i7lCpylME8kRqrBA0Wua2Qwy8xX1YducT+NqRmbZveW2sB+dR6ZXj+21Z3DZO6SQl4QtADs8FK28FVsopwa4oZVpZw/iu5RH1WEaTFfUfkriYT8OZblVTt/43PCyL4YXFrkSqjelyYTaSPN72Rnh5CUpe+39WQTz2QNu3Kabb9qX2+7u4dR/1Jdfz5evtzf1Ut+n7VxXz5vHU28XbxXt/f35rh7bm8b2IcpKjrFR/RCaqhiBAfbPQySPzJ7xGxyjOXiRgF856YS0UzBfqYK6hbWTEaJaggjfZbzQ0PAq8VRNs1h89OQU+qviQHhsNOXNy+1R4EOZx+sCSa9zp87HIZtbyYJcPaXAAeTisCWi6ezxTE0qdxh/ts7O2mjIaQImUiI2ORtekcsW7O//5J1Y1ksYNjvR6aoRDTom9K0j16NGmwA1cb9NHETQKxBqsnMmQe9eSe1aDFKcXiQes5zPKhrD6qd6GAoWnFMKRhl3LDSYCkUxi0T+astIxGS+7rgb9Ta1gP0KDY8ruW1yMTuisaYBP0JGx3hRsVF8OTvjoa0ETgX/wEsJK9A0TYD0Fa2Wu1kUMfLLPspCkh3jXnapvTDKJ/v00NsKC5tdWkUVU6CjCHWfE9FS1k+e8sAe+1tZsnnH1j5ZopkGsHOSSz0cDn/fkr9iXooZZqRlqxZKbZNVe8xKYjAnMppSA6jsYx1hzObOjiI5ojwz00mwhWNeO7lHjBcRaKfgu/hhQCN89AXdS54avHYvUuqVBcp4Hq8yGN3mq8XxL25he+UKZy/J1WEki5Ex0cIkt0YxohQNzV037PBQiyWbRqSg4zbV/Tdne0207QqJGehgkBrbF+1d26+2WIAscUpze7d4mVuU56tpe9OkOWFkKqO+CgXYt0dhs+QsN7caKoTlwrztzjwL3tyUr063++73vvPGtmve3JWnfrA/vPfmzadvDcPL6vIive7G5c26cNrXiOrL1Q5L5l521cb96uxlDftnGwKuEnNS45iAR67QBDewFk3BlsqUQi0vvmHy/pJ3pcV9WVt7c5bFWAQpZsSqOsK7hpnnjT4QFymn5u1C6lDIk5IDjDhOhYSvw04UtmGMcesQ6BmkhIjF9fNNTHJr8qRbpOMoLidNXQTxn741LswioN2jbfDqR3/8rgVdWyt5KtciocMEHoRYd34auJJYTHgbRCMjJRGpQ7TqPVqHq90OEKFjDyNJkC3/VrXV60ITktpO5zDwduugGBbvBWypFMMaF1ttPHEvp7E/VvcB30WXK6voGKCM4Qe0iIT1cNH+L3cua5jyoHNMZieOd6BoLulwdxEjzMEggGrZbviLpzXTh1ZWfAI3ho9Olh81FjplOcKDxfuJQ8+JTq1nslTpEBRhe3WiayoBmeW+ViONFgNwyYWMs/PP7qzix12e4DThmU3BaBdw0W9pJH8lnHXbaslj6ThsL+eJMhlGm6CEUm3QcNanH2f/toTFc0Z5DeHBBKoI4snsDzvJlYkvdefIdB5XIYwv8/U4vVsNv3B0xoGPATgcIxEmYgS5SWmvqktvZnsTU4ZTq28H6EFwtS1hH6Ntis/1KK8SdcSmMs8xsoz4JETv6maDuNJn9th7OC+NNsbl3F+asSqq7U3nKbyYN0zQIO3FEezKjRwmBjqM6qtYWLx6tgklWXm+KZqvvny0x3gZHa84ORHEW5xfdUOI+yzfH9yE024QTNpjrysc6iZLzX0nV844QfUCL1Tk6iAu0fS4fr4h8/Xi9xIjuRAk7JXVYs3EdFuvXfy0pviah2wp4WWvGjtwfUjeV8Ubqh0kB7I5duGOUyhkweRh3U+IMNFsupK0QFYCMVYz1CkSKth7t2UgULsE2+WBoAxxQPA8gVipYcJwpiqGnlhw/tF/eNd+vS1o58XposP7Vxo9Cb7UIJN5Jh6PaT1tlA16RLPw1MVUVbEtSm3vkdE95GVWGwKl8z8moWMqojWB75cvdItK6rU7+4nIimfApLl4SmsdcQNAwaDSV5uqA7tyWzpEN8QN+2cdhRs0aKcgVnQUi4hl9z2z5HYqNGiC0OUc5XBgu8XW/UU3bj9yeH2Ro0iJ6bs0KyWt343ku3riJcmwmB/B/8Ag0HamfSAOxf6Squpwf6G/6aiEXgFWYqGYly8qU21s9Qu0dswOOwGwbbmITM/e3FnwgofJk5fJSZirkd9h+oGsBHzdqw/B8E4IVDiDIgBzPWbcTzE5uazC3ayVjbJ3Ko4eUIKiWTylIbjZMVnr+sXWMmhbOZZAYc2OkyUDQ9aqwcqNbtPYSYbPFAV1yHHllouSQbinR3bqGs8W5aZEEiFvstq99mVLFXzmMllK60iiIr6V84T4pIxyLpfim8EbBGM53xQvf3zbXjWX1A++u+f2pm6slPZtt9RbS97r84NVYZ7LUxM5eDJ4aim3e182d0W/PRSXy3i93dwfz+++uDpenC3yeOMhw34vZHq4RXCUZoEGdv3Uwmq5jO220lE6MRojinpZesKVLaVhpAnulp5KdpRzpSpmoEygPStaxMg7Iu/tG7v+GC+aNly291zwZdKYO0exnfqjriVjnxdR+YnCbu9z00F/W2JeWYmQtpMCj4lteWaw0iWHRAGn1GqrgvWJ7q0TF+986OsWD84COzlKb5/8zPxe0lrGMdCJ80xSaduEijrGboRcMwTZURIudAxBpYkg4SVQQJVGAymUTtkWxptJ6odMIK7perSCgZ0f0LqpGxZ0eAw64Vusk0ANsozTrsoOeXhu3uwA8BLMHLOYtM1g9Gi0ekkNOM8xKde1vschz+/1N2+7S+hAha0ddsDwrJBcISh1ak8fHA72OUAJRSgYKgT3SjdrcXOjnkAewVJa/YjQ117k5TDKMKeE8GKfPELmVkMaCi5m7XXwNiqkZ+4mfBgxdZEIEpfLiS6PXfCVH4kezrbqJXtBobY9T2CSRqdSssBYB/6WvgqTEYiqyoYKkapbOLqFqAx5PISo25oXa2sF1nuhNLbILmAebq461Nf8XmkMxjp0UX4ybcSbB99d1MA5HnrIUCT4niAoU7aEbuMNnBKMhvkLaMjURbF42qLZgNYnk8iK/owTF3d1e9v2v+0r2xjyY7h+udtVm2pTjr/q+7t+em7Pdv/8jeth20/tdFyO1d72E6NPRrhOTHgMf/qmvHlz1zX16fL8g7c3D8eLBavtm//mdLx/2I376xYd3+U0bfMysDqOBn8pPDRqqxgi63XcxSl+MZh9it6LFyuWIPs9HgbCk7fVZIVml2ElQpXprApojhDR9GSXcWwLy5+vn3UaAVPim5JHlnjUs4rk4dXZO0h5CnKgNA0d9lGanpkBBZ0O7CHE225lFRaghbc77aRf1umwGmPBKEPkMaVqxpZER98w9aRsFdVJjCP59z//zuGuZwPYSesbQw/dElRLLlSxjzi0qpDGz1uyr50niugtkBlaiaO+OCanS7d3SqtE/2EvW4qnznwt1UqOyJJzAfeIRjTFMDh1RrbXHdFks6nRc9Bdtl0BoZZ2oT0yOzbt+t2nQkC+XOtnpNEObJW4U4XIUbHDD2EdaAWd1G2eQ9HpKHayqIhtcsCY6OD0snACH7FMkNahgHy/NdjbXCRuswOD5ES8cB2WEP3otXUVR6V9g0VbRi4D2QjFdJQQeD7GbTkpYXAPqSpcNHo1y2gLYlYTXV3pz6naZEA4W0yE6BBmxxitkd3IHmd/u7HnaS9lrwdO3e3hXu2OOcukRGusMCZmfi/Vn9SaNGQ8Klk6c3XTMYXFn4YMFcrwp1W78DgcHnp8BSCdVsFp4GADkanBImwzS7gD6ry04cWYVswYgN+Z0HkGIhIfQFWvu/UYGZpJgkCrx3bRyfnT7XAY2770Lu79mB6a/vPh/uv7uSmmL8bxH87tD7absm3uq9f/+ipdVfPH07wrd9uOOVLoN+tI0ls7clyfVM7daT68OtiNnC7DvrSbnQ63/kTEY5h4fbwyz+hnr2wYPQve5y4gYLjgp863KBRhPZYx7JZezezMO4tZFcAOOlBKe3uzty+3dv6dZXw8KZo7VUKcpkHYmX2+I8hVuNeDT1WyNqN3DBfBd3rmP8KNghuwvWlHJ8qN3hdCzjUXq7h69BvxgSZ0VGxHWFQZ+xiUS8SPwcmSYR0cYdQU4aRWNRQldXag11Qf/un74FPKoQreOp7Q0PnTOjjeOX5hXiGsdCxCp7YA2lk4Ez7lqK0tWSFwGIqqIK+VB04SfEEitVr3OKh7HQ5kvZRA9vRrRRwQHOYIef/LJYcVUvJJzOB1Uo7yCK8I4HbT0fNAKbH+8f4izS3oaQpzfvU9Ny7BgxZQrI4R2AHbZSj6+Dn84u29451RZltoa6aYJj3pB8dlnXAnbbYjdFUws4LQWAbxAnAQgiIuZQzEIeAm5Q5JTqoMrXGnzX1LsYB/I1M85N0s974iBrT0Z0QFNLy93MCPmIip9DCR42DPAlqnQwwzcseYJTdbMlqURBqccASjMbpSpWIKdwq2sCVu9g3kCHnbDNJFxHygBC+hqx5eXTBvWccQkOQ6eu1zdOz2fB2ufglP03aLBauGrbjEfhq79VCDRK7UQtXcdpnkFHY7DdJX+36L9d5b2DWPd2e0HKfH0Al519J23W9tC1ZdU16l4kVbvyg205fj7eKDKu4+ur//6OHycXv1ehw+6XeH5jF5PekHwK6xij4rEBZan1E3tdM7U+drrKuvd1Y/1l91sKIsJWzJMrKLid91L7GUvabTYWQpkrcCYMuEEiKl859dSyxqsfCpmEGM8Qk5OD0irJDACrFgsU1h64SOJ0xjR+Vc0yM/ghTzaPZ+3hRqg7Thy3QZWQx+tp0GhC54csUsGFGa5TARTAX/7XoplnbQW9io2AquX431ma83KzvguFF1Wlq3ZG8rqj0xGXyp/D8M+FzzwOyExwAAAABJRU5ErkJggg==\"></a>"}
{"code": "public void ifPresent(IntConsumer consumer){\n  if (isPresent)   consumer.accept(value);\n}\n", "nl": "Have the specified consumer accept the value if a value is present, otherwise do nothing."}
{"code": "private static boolean contains(String value,int start,int length,String criteria1,String criteria2,String criteria3,String criteria4){\n  return contains(value,start,length,new String[]{criteria1,criteria2,criteria3,criteria4});\n}\n", "nl": "Shortcut method with 4 criteria"}
{"code": "private void writeTreeLikelihood(String tag,String id,int num,PartitionData partition,XMLWriter writer){\n  PartitionSubstitutionModel substModel=partition.getPartitionSubstitutionModel();\n  PartitionTreeModel treeModel=partition.getPartitionTreeModel();\n  PartitionClockModel clockModel=partition.getPartitionClockModel();\n  writer.writeComment(\"Likelihood for tree given sequence data\");\n  String prefix;\n  if (num > 0) {\n    prefix=partition.getPrefix() + substModel.getPrefixCodon(num);\n  }\n else {\n    prefix=partition.getPrefix();\n  }\n  String idString=prefix + id;\n  Attribute[] attributes;\n  if (tag.equals(MarkovJumpsTreeLikelihoodParser.MARKOV_JUMP_TREE_LIKELIHOOD)) {\n    AncestralStatesComponentOptions ancestralStatesOptions=(AncestralStatesComponentOptions)options.getComponentOptions(AncestralStatesComponentOptions.class);\n    boolean saveCompleteHistory=ancestralStatesOptions.isCompleteHistoryLogging(partition);\n    attributes=new Attribute[]{new Attribute.Default<String>(XMLParser.ID,idString),new Attribute.Default<Boolean>(TreeLikelihoodParser.USE_AMBIGUITIES,substModel.isUseAmbiguitiesTreeLikelihood()),new Attribute.Default<Boolean>(MarkovJumpsTreeLikelihoodParser.USE_UNIFORMIZATION,true),new Attribute.Default<Integer>(MarkovJumpsTreeLikelihoodParser.NUMBER_OF_SIMULANTS,1),new Attribute.Default<String>(AncestralStateTreeLikelihoodParser.RECONSTRUCTION_TAG_NAME,prefix + AncestralStateTreeLikelihoodParser.RECONSTRUCTION_TAG),new Attribute.Default<String>(MarkovJumpsTreeLikelihoodParser.SAVE_HISTORY,saveCompleteHistory ? \"true\" : \"false\")};\n  }\n else   if (tag.equals(TreeLikelihoodParser.ANCESTRAL_TREE_LIKELIHOOD)) {\n    attributes=new Attribute[]{new Attribute.Default<String>(XMLParser.ID,idString),new Attribute.Default<Boolean>(TreeLikelihoodParser.USE_AMBIGUITIES,substModel.isUseAmbiguitiesTreeLikelihood()),new Attribute.Default<String>(AncestralStateTreeLikelihoodParser.RECONSTRUCTION_TAG_NAME,prefix + AncestralStateTreeLikelihoodParser.RECONSTRUCTION_TAG)};\n  }\n else {\n    attributes=new Attribute[]{new Attribute.Default<String>(XMLParser.ID,idString),new Attribute.Default<Boolean>(TreeLikelihoodParser.USE_AMBIGUITIES,substModel.isUseAmbiguitiesTreeLikelihood())};\n  }\n  writer.writeOpenTag(tag,attributes);\n  if (!options.samplePriorOnly) {\n    if (num > 0) {\n      writeCodonPatternsRef(prefix,num,substModel.getCodonPartitionCount(),writer);\n    }\n else {\n      writer.writeIDref(SitePatternsParser.PATTERNS,prefix + SitePatternsParser.PATTERNS);\n    }\n  }\n else {\n    writer.writeIDref(AlignmentParser.ALIGNMENT,partition.getAlignment().getId());\n  }\n  writer.writeIDref(TreeModel.TREE_MODEL,treeModel.getPrefix() + TreeModel.TREE_MODEL);\n  if (num > 0) {\n    writer.writeIDref(GammaSiteModel.SITE_MODEL,substModel.getPrefix(num) + SiteModel.SITE_MODEL);\n  }\n else {\n    writer.writeIDref(GammaSiteModel.SITE_MODEL,substModel.getPrefix() + SiteModel.SITE_MODEL);\n  }\n  ClockModelGenerator.writeBranchRatesModelRef(clockModel,writer);\n  generateInsertionPoint(ComponentGenerator.InsertionPoint.IN_TREE_LIKELIHOOD,partition,prefix,writer);\n  writer.writeCloseTag(tag);\n}\n", "nl": "Write the tree likelihood XML block."}
{"code": "private static void sift(final int[] primary,final int[] names,final int left,final int right){\n  int currentLeft;\n  final int primaryTMP;\n  final int namesTMP;\n  int childL;\n  currentLeft=left;\n  primaryTMP=primary[currentLeft];\n  namesTMP=names[currentLeft];\n  childL=2 * left + 1;\n  if ((childL < right) && (primary[childL] < primary[childL + 1])) {\n    childL+=1;\n  }\n  while ((childL <= right) && (primaryTMP < primary[childL])) {\n    primary[currentLeft]=primary[childL];\n    names[currentLeft]=names[childL];\n    currentLeft=childL;\n    childL=2 * childL + 1;\n    if ((childL < right) && (primary[childL] < primary[childL + 1])) {\n      childL+=1;\n    }\n  }\n  primary[currentLeft]=primaryTMP;\n  names[currentLeft]=namesTMP;\n}\n", "nl": "quick sort list on 1 value with names as int primary is sorted into ascending order and names is joined to primary. so if primary[i] is moved to primary[j], then names[i] is moved to names[j]"}
{"code": "public static cuComplex cuCmul(cuComplex x,cuComplex y){\n  cuComplex prod;\n  prod=cuCmplx((cuCreal(x) * cuCreal(y)) - (cuCimag(x) * cuCimag(y)),(cuCreal(x) * cuCimag(y)) + (cuCimag(x) * cuCreal(y)));\n  return prod;\n}\n", "nl": "Returns the product of the given complex numbers.<br /> <br /> Original comment:<br /> <br /> This implementation could suffer from intermediate overflow even though the final result would be in range. However, various implementations do not guard against this (presumably to avoid losing performance), so we don't do it either to stay competitive."}
{"code": "public View onContentViewCreated(View contentView){\n  ViewGroup mainView=(ViewGroup)activity.getLayoutInflater().inflate(layoutId,null);\n  mainView.addView(contentView,0);\n  return mainView;\n}\n", "nl": "This event is fired when root content view is created"}
{"code": "public static KeyPair load(File certificateFile,File privateKeyFile,String privateKeyPassword) throws IOException, UnrecoverableKeyException, NoSuchAlgorithmException, CertificateException, KeyStoreException {\n  Cert cert=Cert.load(certificateFile);\n  PrivKey privKey=PrivKey.loadFromKeyStore(privateKeyFile,privateKeyPassword);\n  return new KeyPair(cert,privKey);\n}\n", "nl": "Load Certificate & Private key pair from X.509 and keystore file"}
{"code": "public void addPrivilegedService(Class<? extends Service> serviceType){\n  super.addPrivilegedService(serviceType);\n}\n", "nl": "Adds a service to a privileged list, allowing it to operate on authorization. context"}
{"code": "protected byte[] engineDoFinal(byte[] input,int inputOffset,int inputLen) throws IllegalBlockSizeException, BadPaddingException {\n  return core.doFinal(input,inputOffset,inputLen);\n}\n", "nl": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. <p>The first <code>inputLen</code> bytes in the <code>input</code> buffer, starting at <code>inputOffset</code>, and any input bytes that may have been buffered during a previous <code>update</code> operation, are processed, with padding (if requested) being applied. The result is stored in a new buffer. <p>The cipher is reset to its initial state (uninitialized) after this call."}
{"code": "public void startTransition(long durationMillis){\n  mFrom=0;\n  mTo=255;\n  mAlpha=0;\n  mDuration=mOriginalDuration=durationMillis;\n  mReverse=false;\n  mTransitionState=TRANSITION_STARTING;\n  invalidateSelf();\n}\n", "nl": "Begin the second layer on top of the first layer."}
{"code": "private void drawXTickMarks(Graphics g){\n  Rectangle plotRect=getPlotRect();\n  int yPos=plotRect.y + plotRect.height;\n  NumberFormat nf=NumberFormatUtil.getInstance().getNumberFormat();\n  for (double d=0.0; d <= 1.0; d+=0.1) {\n    int xPos=getXPos(d);\n    g.setColor(boundaryColor);\n    g.drawLine(xPos,yPos,xPos,yPos - 10);\n    g.drawString(nf.format(d),xPos - 3,yPos + 12);\n  }\n}\n", "nl": "This method draws tick marks for the x axis.  The x axis represents pi_e, the true probability of effect in treatment, and ranges in value from pi_c to 1.0."}
{"code": "private static String buildToolTip(final ZyLabelContent content){\n  return HtmlGenerator.getHtml(content,MONOSPACE_FONT,true);\n}\n", "nl": "Builds the tooltip text of a table row from the content of a node."}
{"code": "public static double convertFeetToMeters(double feet){\n  return (feet / METERS_TO_FEET);\n}\n", "nl": "Converts distance in feet to distance in meters."}
{"code": "public static void appendUnpaddedInteger(StringBuffer buf,int value){\n  if (value < 0) {\n    buf.append('-');\n    if (value != Integer.MIN_VALUE) {\n      value=-value;\n    }\n else {\n      buf.append(\"\" + -(long)Integer.MIN_VALUE);\n      return;\n    }\n  }\n  if (value < 10) {\n    buf.append((char)(value + '0'));\n  }\n else   if (value < 100) {\n    int d=((value + 1) * 13421772) >> 27;\n    buf.append((char)(d + '0'));\n    buf.append((char)(value - (d << 3) - (d << 1) + '0'));\n  }\n else {\n    buf.append(Integer.toString(value));\n  }\n}\n", "nl": "Converts an integer to a string, and appends it to the given buffer. <p>This method is optimized for converting small values to strings."}
{"code": "public boolean isConstant(){\n  return constant;\n}\n", "nl": "tells if arg we are poxying for is dynamic or constant."}
{"code": "public void write(byte[] buf) throws IOException {\n  write(buf,0,buf.length);\n}\n", "nl": "Write a byte array to the output stream."}
{"code": "public static _Fields findByThriftIdOrThrow(int fieldId){\n  _Fields fields=findByThriftId(fieldId);\n  if (fields == null)   throw new IllegalArgumentException(\"Field \" + fieldId + \" doesn't exist!\");\n  return fields;\n}\n", "nl": "Find the _Fields constant that matches fieldId, throwing an exception if it is not found."}
{"code": "private static byte[] encode3to4(byte[] b4,byte[] threeBytes,int numSigBytes){\n  encode3to4(threeBytes,0,numSigBytes,b4,0);\n  return b4;\n}\n", "nl": "Encodes up to the first three bytes of array <var>threeBytes</var> and returns a four-byte array in Base64 notation. The actual number of significant bytes in your array is given by <var>numSigBytes</var>. The array <var>threeBytes</var> needs only be as big as <var>numSigBytes</var>. Code can reuse a byte array by passing a four-byte array as <var>b4</var>."}
{"code": "public void closeFile(){\n  closeFile(true);\n}\n", "nl": "closes the current tab"}
{"code": "public void updateStatus(JobContext jobContext){\n  try {\n    if (_status == JobStatus.SUCCESS) {\n      s_logger.debug(\"Calling task completer for successful job\");\n      _taskCompleter.ready(jobContext.getDbClient());\n    }\n else     if (_status == JobStatus.FAILED) {\n      s_logger.debug(\"Calling task completer for failed job\");\n      ServiceError error=DeviceControllerErrors.vplex.cacheInvalidateJobFailed(_errorDescription);\n      _taskCompleter.error(jobContext.getDbClient(),error);\n    }\n  }\n catch (  Exception e) {\n    s_logger.error(\"Problem while trying to update status\",e);\n  }\n}\n", "nl": "Update the status after a poll."}
{"code": "private void cancelScrollFeedback(){\n  removeMessages(SCROLL_FEEDBACK);\n}\n", "nl": "Removes any pending scroll position feedback. Call this for every event."}
{"code": "public final void actionDelete() throws BasicException {\n  saveData();\n  if (canDeleteData()) {\n    Object obj=getCurrentElement();\n    int iIndex=getIndex();\n    int iCount=m_bd.getSize();\n    if (iIndex >= 0 && iIndex < iCount) {\n      m_iState=ST_DELETE;\n      m_editorrecord.writeValueDelete(obj);\n      m_Dirty.setDirty(true);\n      fireStateUpdate();\n    }\n  }\n}\n", "nl": "Delete data"}
{"code": "public QueryInvalidException(String msg){\n  super(msg);\n}\n", "nl": "Construct an instance of QueryInvalidException"}
{"code": "public static Timestamp toTimestamp(String string){\n  if (string == null)   return null;\n else   try {\n    return Timestamp.valueOf(string);\n  }\n catch (  Throwable t) {\n    return null;\n  }\n}\n", "nl": "Return Timestamp value using a String. Null or conversion error returns null."}
{"code": "public boolean hasNext(){\n  return (current != null);\n}\n", "nl": "Determine if there are more Nodes in the list to be reported."}
{"code": "@Override public long skip(long n) throws IOException {\n  if (n <= 0) {\n    return n;\n  }\n  long skipLen=0;\n  while (n > 0) {\n    long sublen=Math.min(n,_readLength - _readOffset);\n    if (sublen > 0) {\n      _readOffset+=sublen;\n      skipLen+=sublen;\n      n-=sublen;\n    }\n else {\n      if (_source.hasSkip()) {\n        _readOffset=_readLength=0;\n        long sourceSkipped=_source.skip(n);\n        if (sourceSkipped <= 0) {\n          return skipLen;\n        }\n else {\n          _position+=sourceSkipped;\n          skipLen+=sourceSkipped;\n          n-=sourceSkipped;\n        }\n      }\n else       if (!readBuffer()) {\n        return skipLen;\n      }\n    }\n  }\n  return skipLen;\n}\n", "nl": "Skips the next <code>n</code> bytes."}
{"code": "@Override public double op(double z){\n  z=(z - average) / sigma;\n  double result=0.5 * (1.0 + errorFunction.op(z * Constants.M_SQRT_2));\n  if (result <= 1e-8) {\n    double sum=1.0;\n    final double zsqr=z * z;\n    double i=1.0, g=1.0, x, y, a=Constants.QL_MAX_REAL, lasta;\n    do {\n      lasta=a;\n      x=(4.0 * i - 3.0) / zsqr;\n      y=x * ((4.0 * i - 1) / zsqr);\n      a=g * (x - y);\n      sum-=a;\n      g*=y;\n      ++i;\n      a=Math.abs(a);\n    }\n while (lasta > a && a >= Math.abs(sum * Constants.QL_EPSILON));\n    result=-gaussian.op(z) / z * sum;\n  }\n  return result;\n}\n", "nl": "Computes the cumulative normal distribution. <p> Asymptotic expansion for very negative z as references on M. Abramowitz book."}
{"code": "public boolean isZoomXEnabled(){\n  return mZoomXEnabled;\n}\n", "nl": "Returns the enabled state of the zoom on X axis."}
{"code": "protected void connectToAnyPeer() throws PeerDiscoveryException {\n  final State state=state();\n  if (!(state == State.STARTING || state == State.RUNNING))   return;\n  PeerAddress addr=null;\n  long nowMillis=Utils.currentTimeMillis();\n  long retryTime=0;\n  lock.lock();\n  try {\n    if (!haveReadyInactivePeer(nowMillis)) {\n      discoverPeers();\n      groupBackoff.trackSuccess();\n      nowMillis=Utils.currentTimeMillis();\n    }\n    if (inactives.size() == 0) {\n      log.debug(\"Peer discovery didn't provide us any more peers, not trying to build new connection.\");\n      return;\n    }\n    addr=inactives.poll();\n    retryTime=backoffMap.get(addr).getRetryTime();\n  }\n  finally {\n    retryTime=Math.max(retryTime,groupBackoff.getRetryTime());\n    lock.unlock();\n    if (retryTime > nowMillis) {\n      final long millis=retryTime - nowMillis;\n      log.info(\"Waiting {} msec before next connect attempt {}\",millis,addr == null ? \"\" : \" to \" + addr);\n      Utils.sleep(millis);\n    }\n  }\n  checkNotNull(addr);\n  connectTo(addr,false);\n}\n", "nl": "Picks a peer from discovery and connects to it. If connection fails, picks another and tries again."}
{"code": "public int read(char buff[],int off,int len) throws IOException {\n  int b=read();\n  if (b == -1)   return -1;\n else {\n    buff[off]=(char)b;\n    return 1;\n  }\n}\n", "nl": "This is a degenerate implementation. I don't know how to keep this from blocking if we try to read more than one char...  There is no available() for Readers ??"}
{"code": "public InputStream read(int size,boolean extraCRLF) throws DecodingException {\n  nextSeen=false;\n  nextChar=0;\n  FixedLengthInputStream fin=new FixedLengthInputStream(this.in,size);\n  if (extraCRLF) {\n    return new EolInputStream(this,fin);\n  }\n else {\n    return fin;\n  }\n}\n", "nl": "Reads and consumes a number of characters from the underlying reader, filling the char array provided. TODO: remove unnecessary copying of bits; line reader should maintain an internal ByteBuffer;"}
{"code": "public static void registerTurtleUpgrade(ITurtleUpgrade upgrade){\n  if (upgrade != null) {\n    findCC();\n    if (computerCraft_registerTurtleUpgrade != null) {\n      try {\n        computerCraft_registerTurtleUpgrade.invoke(null,upgrade);\n      }\n catch (      Exception e) {\n      }\n    }\n  }\n}\n", "nl": "Registers a new turtle turtle for use in ComputerCraft. After calling this, users should be able to craft Turtles with your new turtle. It is recommended to call this during the load() method of your mod."}
{"code": "private void showFeedback(String feedback){\n  if (myHost != null) {\n    myHost.showFeedback(feedback);\n  }\n else {\n    System.out.println(feedback);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "public void println(long x){\n  out.println(x);\n}\n", "nl": "Print a long and then terminate the line."}
{"code": "public static String[] warningOptionNames(){\n  String[] result={OPTION_ReportAnnotationSuperInterface,OPTION_ReportAssertIdentifier,OPTION_ReportAutoboxing,OPTION_ReportComparingIdentical,OPTION_ReportDeadCode,OPTION_ReportDeadCodeInTrivialIfStatement,OPTION_ReportDeprecation,OPTION_ReportDeprecationInDeprecatedCode,OPTION_ReportDeprecationWhenOverridingDeprecatedMethod,OPTION_ReportDiscouragedReference,OPTION_ReportEmptyStatement,OPTION_ReportEnumIdentifier,OPTION_ReportFallthroughCase,OPTION_ReportFieldHiding,OPTION_ReportFinallyBlockNotCompletingNormally,OPTION_ReportFinalParameterBound,OPTION_ReportForbiddenReference,OPTION_ReportHiddenCatchBlock,OPTION_ReportIncompatibleNonInheritedInterfaceMethod,OPTION_ReportIncompleteEnumSwitch,OPTION_ReportIndirectStaticAccess,OPTION_ReportInvalidJavadoc,OPTION_ReportInvalidJavadocTags,OPTION_ReportInvalidJavadocTagsDeprecatedRef,OPTION_ReportInvalidJavadocTagsNotVisibleRef,OPTION_ReportInvalidJavadocTagsVisibility,OPTION_ReportLocalVariableHiding,OPTION_ReportMethodCanBePotentiallyStatic,OPTION_ReportMethodCanBeStatic,OPTION_ReportMethodWithConstructorName,OPTION_ReportMissingDeprecatedAnnotation,OPTION_ReportMissingHashCodeMethod,OPTION_ReportMissingJavadocComments,OPTION_ReportMissingJavadocCommentsOverriding,OPTION_ReportMissingJavadocCommentsVisibility,OPTION_ReportMissingJavadocTagDescription,OPTION_ReportMissingJavadocTags,OPTION_ReportMissingJavadocTagsMethodTypeParameters,OPTION_ReportMissingJavadocTagsOverriding,OPTION_ReportMissingJavadocTagsVisibility,OPTION_ReportMissingOverrideAnnotation,OPTION_ReportMissingOverrideAnnotationForInterfaceMethodImplementation,OPTION_ReportMissingSerialVersion,OPTION_ReportMissingSynchronizedOnInheritedMethod,OPTION_ReportNoEffectAssignment,OPTION_ReportNoImplicitStringConversion,OPTION_ReportNonExternalizedStringLiteral,OPTION_ReportNonStaticAccessToStatic,OPTION_ReportNullReference,OPTION_ReportOverridingMethodWithoutSuperInvocation,OPTION_ReportOverridingPackageDefaultMethod,OPTION_ReportParameterAssignment,OPTION_ReportPossibleAccidentalBooleanAssignment,OPTION_ReportPotentialNullReference,OPTION_ReportRawTypeReference,OPTION_ReportRedundantNullCheck,OPTION_ReportRedundantSuperinterface,OPTION_ReportRedundantSpecificationOfTypeArguments,OPTION_ReportSpecialParameterHidingField,OPTION_ReportSyntheticAccessEmulation,OPTION_ReportTasks,OPTION_ReportTypeParameterHiding,OPTION_ReportUnavoidableGenericTypeProblems,OPTION_ReportUncheckedTypeOperation,OPTION_ReportUndocumentedEmptyBlock,OPTION_ReportUnhandledWarningToken,OPTION_ReportUnnecessaryElse,OPTION_ReportUnnecessaryTypeCheck,OPTION_ReportUnqualifiedFieldAccess,OPTION_ReportUnusedDeclaredThrownException,OPTION_ReportUnusedDeclaredThrownExceptionExemptExceptionAndThrowable,OPTION_ReportUnusedDeclaredThrownExceptionIncludeDocCommentReference,OPTION_ReportUnusedDeclaredThrownExceptionWhenOverriding,OPTION_ReportUnusedImport,OPTION_ReportUnusedLabel,OPTION_ReportUnusedLocal,OPTION_ReportUnusedObjectAllocation,OPTION_ReportUnusedParameter,OPTION_ReportUnusedParameterIncludeDocCommentReference,OPTION_ReportUnusedParameterWhenImplementingAbstract,OPTION_ReportUnusedParameterWhenOverridingConcrete,OPTION_ReportUnusedPrivateMember,OPTION_ReportUnusedTypeArgumentsForMethodInvocation,OPTION_ReportUnusedWarningToken,OPTION_ReportVarargsArgumentNeedCast};\n  return result;\n}\n", "nl": "Return all warning option names for use as keys in compiler options maps."}
{"code": "public AnchorUpdateControl(Layout[] layout,String action){\n  this(layout,action,true);\n}\n", "nl": "Create a new AnchorUpdateControl."}
{"code": "public static Data convertInputType(String parameterName,Object parameterValue,Metadata metadata){\n  String name=parameterName;\n  Object value=parameterValue;\n  boolean hasMetadata=(metadata != null) ? true : false;\n  boolean hasMatrixMetadata=hasMetadata && (metadata instanceof MatrixMetadata) ? true : false;\n  boolean hasFrameMetadata=hasMetadata && (metadata instanceof FrameMetadata) ? true : false;\n  if (name == null) {\n    throw new MLContextException(\"Input parameter name is null\");\n  }\n else   if (value == null) {\n    throw new MLContextException(\"Input parameter value is null for: \" + parameterName);\n  }\n else   if (value instanceof JavaRDD<?>) {\n    @SuppressWarnings(\"unchecked\") JavaRDD<String> javaRDD=(JavaRDD<String>)value;\n    if (hasMatrixMetadata) {\n      MatrixMetadata matrixMetadata=(MatrixMetadata)metadata;\n      if (matrixMetadata.getMatrixFormat() == MatrixFormat.IJV) {\n        return MLContextConversionUtil.javaRDDStringIJVToMatrixObject(name,javaRDD,matrixMetadata);\n      }\n else {\n        return MLContextConversionUtil.javaRDDStringCSVToMatrixObject(name,javaRDD,matrixMetadata);\n      }\n    }\n else     if (hasFrameMetadata) {\n      FrameMetadata frameMetadata=(FrameMetadata)metadata;\n      if (frameMetadata.getFrameFormat() == FrameFormat.IJV) {\n        return MLContextConversionUtil.javaRDDStringIJVToFrameObject(name,javaRDD,frameMetadata);\n      }\n else {\n        return MLContextConversionUtil.javaRDDStringCSVToFrameObject(name,javaRDD,frameMetadata);\n      }\n    }\n else     if (!hasMetadata) {\n      String firstLine=javaRDD.first();\n      boolean isAllNumbers=isCSVLineAllNumbers(firstLine);\n      if (isAllNumbers) {\n        return MLContextConversionUtil.javaRDDStringCSVToMatrixObject(name,javaRDD);\n      }\n else {\n        return MLContextConversionUtil.javaRDDStringCSVToFrameObject(name,javaRDD);\n      }\n    }\n  }\n else   if (value instanceof RDD<?>) {\n    @SuppressWarnings(\"unchecked\") RDD<String> rdd=(RDD<String>)value;\n    if (hasMatrixMetadata) {\n      MatrixMetadata matrixMetadata=(MatrixMetadata)metadata;\n      if (matrixMetadata.getMatrixFormat() == MatrixFormat.IJV) {\n        return MLContextConversionUtil.rddStringIJVToMatrixObject(name,rdd,matrixMetadata);\n      }\n else {\n        return MLContextConversionUtil.rddStringCSVToMatrixObject(name,rdd,matrixMetadata);\n      }\n    }\n else     if (hasFrameMetadata) {\n      FrameMetadata frameMetadata=(FrameMetadata)metadata;\n      if (frameMetadata.getFrameFormat() == FrameFormat.IJV) {\n        return MLContextConversionUtil.rddStringIJVToFrameObject(name,rdd,frameMetadata);\n      }\n else {\n        return MLContextConversionUtil.rddStringCSVToFrameObject(name,rdd,frameMetadata);\n      }\n    }\n else     if (!hasMetadata) {\n      String firstLine=rdd.first();\n      boolean isAllNumbers=isCSVLineAllNumbers(firstLine);\n      if (isAllNumbers) {\n        return MLContextConversionUtil.rddStringCSVToMatrixObject(name,rdd);\n      }\n else {\n        return MLContextConversionUtil.rddStringCSVToFrameObject(name,rdd);\n      }\n    }\n  }\n else   if (value instanceof MatrixBlock) {\n    MatrixBlock matrixBlock=(MatrixBlock)value;\n    return MLContextConversionUtil.matrixBlockToMatrixObject(name,matrixBlock,(MatrixMetadata)metadata);\n  }\n else   if (value instanceof FrameBlock) {\n    FrameBlock frameBlock=(FrameBlock)value;\n    return MLContextConversionUtil.frameBlockToFrameObject(name,frameBlock,(FrameMetadata)metadata);\n  }\n else   if (value instanceof DataFrame) {\n    DataFrame dataFrame=(DataFrame)value;\n    if (hasMatrixMetadata) {\n      return MLContextConversionUtil.dataFrameToMatrixObject(name,dataFrame,(MatrixMetadata)metadata);\n    }\n else     if (hasFrameMetadata) {\n      return MLContextConversionUtil.dataFrameToFrameObject(name,dataFrame,(FrameMetadata)metadata);\n    }\n else     if (!hasMetadata) {\n      boolean looksLikeMatrix=doesDataFrameLookLikeMatrix(dataFrame);\n      if (looksLikeMatrix) {\n        return MLContextConversionUtil.dataFrameToMatrixObject(name,dataFrame);\n      }\n else {\n        return MLContextConversionUtil.dataFrameToFrameObject(name,dataFrame);\n      }\n    }\n  }\n else   if (value instanceof BinaryBlockMatrix) {\n    BinaryBlockMatrix binaryBlockMatrix=(BinaryBlockMatrix)value;\n    if (metadata == null) {\n      metadata=binaryBlockMatrix.getMatrixMetadata();\n    }\n    JavaPairRDD<MatrixIndexes,MatrixBlock> binaryBlocks=binaryBlockMatrix.getBinaryBlocks();\n    return MLContextConversionUtil.binaryBlocksToMatrixObject(name,binaryBlocks,(MatrixMetadata)metadata);\n  }\n else   if (value instanceof BinaryBlockFrame) {\n    BinaryBlockFrame binaryBlockFrame=(BinaryBlockFrame)value;\n    if (metadata == null) {\n      metadata=binaryBlockFrame.getFrameMetadata();\n    }\n    JavaPairRDD<Long,FrameBlock> binaryBlocks=binaryBlockFrame.getBinaryBlocks();\n    return MLContextConversionUtil.binaryBlocksToFrameObject(name,binaryBlocks,(FrameMetadata)metadata);\n  }\n else   if (value instanceof Matrix) {\n    Matrix matrix=(Matrix)value;\n    return matrix.toMatrixObject();\n  }\n else   if (value instanceof Frame) {\n    Frame frame=(Frame)value;\n    return frame.toFrameObject();\n  }\n else   if (value instanceof double[][]) {\n    double[][] doubleMatrix=(double[][])value;\n    return MLContextConversionUtil.doubleMatrixToMatrixObject(name,doubleMatrix,(MatrixMetadata)metadata);\n  }\n else   if (value instanceof URL) {\n    URL url=(URL)value;\n    return MLContextConversionUtil.urlToMatrixObject(name,url,(MatrixMetadata)metadata);\n  }\n else   if (value instanceof Integer) {\n    return new IntObject((Integer)value);\n  }\n else   if (value instanceof Double) {\n    return new DoubleObject((Double)value);\n  }\n else   if (value instanceof String) {\n    return new StringObject((String)value);\n  }\n else   if (value instanceof Boolean) {\n    return new BooleanObject((Boolean)value);\n  }\n  return null;\n}\n", "nl": "Convert input types to internal SystemML representations"}
{"code": "@Override public List<ExampleSetBasedIndividual> operate(ExampleSetBasedIndividual individual) throws Exception {\n  List<ExampleSetBasedIndividual> l=new LinkedList<ExampleSetBasedIndividual>();\n  AttributeWeightedExampleSet clone=(AttributeWeightedExampleSet)individual.getExampleSet().clone();\n  double p=prob < 0 ? 1.0d / clone.getAttributes().size() : prob;\n  p/=4.0d;\n  try {\n    if ((maxNumberOfAttributes < 0) || (clone.getAttributes().size() < maxNumberOfAttributes)) {\n      addOriginalAttribute(clone,p);\n    }\n    boolean generationPossible=false;\n    if ((maxNumberOfAttributes < 0) || (clone.getAttributes().size() <= maxNumberOfAttributes)) {\n      generationPossible=addGeneratedAttribute(clone,p);\n    }\n    deselect(clone,generationPossible ? 2 : 1,p);\n  }\n catch (  GenerationException e) {\n    individual.getExampleSet().getLog().logWarning(\"GeneratingMutation: Exception occured during generation of attributes, using only original example set instead.\");\n  }\n  if (clone.getNumberOfUsedAttributes() > 0) {\n    l.add(new ExampleSetBasedIndividual(clone));\n  }\n  l.add(individual);\n  return l;\n}\n", "nl": "Performs one of the following three mutations: <ul> <li>add a newly generated attribute</li> <li>add an original attribute</li> <li>remove an attribute</li> </ul>"}
{"code": "public int findPeakElement(int[] num){\n  if (num == null || num.length == 0)   return 0;\n  int n=num.length;\n  if (n <= 1)   return 0;\n  if (num[0] > num[1])   return 0;\n  if (num[n - 1] > num[n - 2])   return n - 1;\n  int left=1, right=n - 2;\n  while (left < right) {\n    int mid=(right - left) / 2 + left;\n    if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1])     return mid;\n else     if (num[mid] > num[mid + 1])     right=mid - 1;\n else     left=mid + 1;\n  }\n  return left;\n}\n", "nl": "Binary search for a peak. Other peaks can be ignored."}
{"code": "public static void serializeTrace(Model model){\n  try {\n    List<TLCState> trace=getErrorOfOriginalTrace(model).getStates(Length.ALL);\n    Assert.isNotNull(trace);\n    Iterator<TLCState> it=trace.iterator();\n    IFile traceSourceFile=model.getTraceSourceFile();\n    ModelHelper.createOrClearFiles(new IFile[]{traceSourceFile},new NullProgressMonitor());\n    while (it.hasNext()) {\n      traceSourceFile.appendContents(new ByteArrayInputStream((MP.DELIM + MP.STARTMSG + \"0000\"+ MP.COLON+ MP.STATE+ \" \"+ MP.DELIM+ \"\\n\").getBytes()),IResource.FORCE | IWorkspace.AVOID_UPDATE,new NullProgressMonitor());\n      TLCState state=(TLCState)it.next();\n      StringBuffer toAppend=new StringBuffer();\n      toAppend.append(state.getStateNumber()).append(\": \").append(state.getLabel()).append(\"\\n\").append(state.toString());\n      traceSourceFile.appendContents(new ByteArrayInputStream(toAppend.toString().getBytes()),IResource.FORCE | IWorkspace.AVOID_UPDATE,new NullProgressMonitor());\n      traceSourceFile.appendContents(new ByteArrayInputStream((MP.DELIM + MP.ENDMSG + \"0000\"+ \" \"+ MP.DELIM+ \"\\n\").getBytes()),IResource.FORCE | IWorkspace.AVOID_UPDATE,new NullProgressMonitor());\n    }\n  }\n catch (  CoreException e) {\n    TLCUIActivator.getDefault().logError(\"Error writing trace contents to file\",e);\n  }\n}\n", "nl": "Writes the trace to MC_TE.out."}
{"code": "public AmqpSender createSender(final String address) throws Exception {\n  return createSender(address,false);\n}\n", "nl": "Create a sender instance using the given address"}
{"code": "@Override public void prepareAccessibilityDrop(){\n  if (mReorderAlarm.alarmPending()) {\n    mReorderAlarm.cancelAlarm();\n    mReorderAlarmListener.onAlarm(mReorderAlarm);\n  }\n}\n", "nl": "When performing an accessibility drop, onDrop is sent immediately after onDragEnter. So we need to complete all transient states based on timers."}
{"code": "@RequestMapping(value=\"/{id}\",params=\"action=delete\",method=POST) public Callable<String> deleteTodo(@PathVariable(\"id\") Long id){\n  return null;\n}\n", "nl": "Delete a to-do item."}
{"code": "public WitboxFaces(int face,int[] type){\n  mType=face;\n  generatePlaneCoords(face,type);\n  int vertexShader=ViewerRenderer.loadShader(GLES20.GL_VERTEX_SHADER,vertexShaderCode);\n  int fragmentShader=ViewerRenderer.loadShader(GLES20.GL_FRAGMENT_SHADER,fragmentShaderCode);\n  mProgram=GLES20.glCreateProgram();\n  GLES20.glAttachShader(mProgram,vertexShader);\n  GLES20.glAttachShader(mProgram,fragmentShader);\n  GLES20.glLinkProgram(mProgram);\n}\n", "nl": "Sets up the drawing object data for use in an OpenGL ES context. Alberto: change alpha according to face"}
{"code": "public <T extends ServiceDocument>Iterable<T> selectedDocuments(Class<T> type){\n  if (this.results == null || this.results.selectedDocuments == null) {\n    return Collections.emptyList();\n  }\n  Stream<T> stream=this.results.selectedDocuments.values().stream().map(null);\n  return null;\n}\n", "nl": "Iterate over all selected documents converted to the desired type. The returned iterable is not reusable."}
{"code": "public static PlatformDecoder buildPlatformDecoder(PoolFactory poolFactory,boolean decodeMemoryFileEnabled){\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    return new ArtDecoder(poolFactory.getBitmapPool(),poolFactory.getFlexByteArrayPoolMaxNumThreads());\n  }\n else {\n    if (decodeMemoryFileEnabled && Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {\n      return new GingerbreadPurgeableDecoder();\n    }\n else {\n      return new KitKatPurgeableDecoder(poolFactory.getFlexByteArrayPool());\n    }\n  }\n}\n", "nl": "Provide the implementation of the PlatformDecoder for the current platform using the provided PoolFactory"}
{"code": "protected void uninstallListeners(){\n  frame.removePropertyChangeListener(this);\n  removePropertyChangeListener(this);\n}\n", "nl": "Uninstall the listeners from the title pane."}
{"code": "protected void paintData(Graphics2D g2,Variate.N xData,Variate.N yData){\n  g2.setPaint(linePaint);\n  g2.setStroke(lineStroke);\n  if (getSelectedPoints() != null && getSelectedPoints().size() > 0) {\n    for (    int i : getSelectedPoints()) {\n      double x=((Number)xTipData.get(i)).doubleValue();\n      double y=((Number)yTipData.get(i)).doubleValue();\n      double x1=transformX(x);\n      double y1=transformY(y);\n      double x2=transformX(((Number)xData.get(0)).doubleValue());\n      double y2=transformY(((Number)yData.get(0)).doubleValue());\n      GeneralPath path=new GeneralPath();\n      path.moveTo((float)x1,(float)y1);\n      path.lineTo((float)x2,(float)y2);\n      g2.draw(path);\n    }\n  }\n else {\n    for (int i=0; i < xData.getCount(); i++) {\n      double x1=transformX(((Number)xTipData.get(i)).doubleValue());\n      double y1=transformY(((Number)yTipData.get(i)).doubleValue());\n      double x2=transformX(((Number)xData.get(i)).doubleValue());\n      double y2=transformY(((Number)yData.get(i)).doubleValue());\n      GeneralPath path=new GeneralPath();\n      path.moveTo((float)x1,(float)y1);\n      path.lineTo((float)x2,(float)y2);\n      g2.draw(path);\n    }\n  }\n}\n", "nl": "Paint data series"}
{"code": "public MessageBuilder appendQuote(String content){\n  return appendCode(\"\",content);\n}\n", "nl": "Adds a multiline code block with no language highlighting."}
{"code": "@Override public boolean isAscending(){\n  return false;\n}\n", "nl": "Ascending is set to false as we are looking for Bottom N"}
{"code": "private DebugProtocolHelper(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public String name(){\n  return name;\n}\n", "nl": "Returns bucket name."}
{"code": "public MergePolicyWrapper(MergePolicy in){\n  this.in=in;\n}\n", "nl": "Creates a new merge policy instance."}
{"code": "public void pop(){\n  mv.visitInsn(Opcodes.POP);\n}\n", "nl": "Generates a POP instruction."}
{"code": "public static String ssx(String shpFileName){\n  String ret=null;\n  if (shpFileName != null) {\n    ret=shpFileName.substring(0,shpFileName.indexOf(\".shp\")) + \".ssx\";\n  }\n  return ret;\n}\n", "nl": "Figures out the ssx file name from the shp file name."}
{"code": "@Nullable public GeoPoint center(){\n  return center;\n}\n", "nl": "Query for the center of the map"}
{"code": "public static boolean running(){\n  return running;\n}\n", "nl": "Check if the simulation is still running. This method should be used by entities to check if they should continue executing."}
{"code": "public CheckItemProvider(AdapterFactory adapterFactory){\n  super(adapterFactory);\n}\n", "nl": "This constructs an instance from a factory and a notifier. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "private boolean sendEmail(MRequest request,String AD_Message){\n  String subject=Msg.getMsg(m_client.getAD_Language(),AD_Message,new String[]{request.getDocumentNo()});\n  return m_client.sendEMail(request.getSalesRep_ID(),subject,request.getSummary(),request.createPDF());\n}\n", "nl": "Send Alert EMail"}
{"code": "public static <T extends ServiceDocument>boolean documentEquals(Class<T> type,T document1,T document2) throws IllegalAccessException {\n  ServiceDocumentDescription documentDescription=ServiceDocumentDescription.Builder.create().buildDescription(type,EnumSet.noneOf(Service.ServiceOption.class));\n  return ServiceDocument.equals(documentDescription,document1,document2);\n}\n", "nl": "Compare the hash of two documents."}
{"code": "public Map<String,String> find(String userId,String keyFilter) throws ServerException {\n  requireNonNull(userId,\"Required non-null user id\");\n  return preferenceDao.getPreferences(userId,keyFilter);\n}\n", "nl": "Finds user's preferences."}
{"code": "private void checkField(final boolean invalid,final String failLabel,final String fieldLabel) throws RequestProcessAdviceException {\n  if (invalid) {\n    throw new RequestProcessAdviceException(new JSONObject().put(Keys.MSG,langPropsService.get(failLabel) + \" - \" + langPropsService.get(fieldLabel)));\n  }\n}\n", "nl": "Checks field."}
{"code": "public void addSuperClass(ClassType type){\n  addSuperClassNoBidirectionalUpdate(type);\n  type.addSubclassNoBidirectionalUpdate(this);\n}\n", "nl": "Adds a superclass of this class and ensures that the back-reference on the referred entity is set as well."}
{"code": "public GivenName(){\n  super(KEY);\n}\n", "nl": "Constructs an instance using the default key."}
{"code": "public void removeGrid(String gridName){\n  gridNames.remove(gridName);\n}\n", "nl": "Remove grid name."}
{"code": "protected void engineInit(int opmode,Key key,AlgorithmParameterSpec params,SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {\n  core.init(opmode,key,params,random);\n}\n", "nl": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. <p>The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of <code>opmode</code>. <p>If this cipher (including its underlying feedback or padding scheme) requires any random bytes, it will get them from <code>random</code>."}
{"code": "public ResultSet monitor(ResultSet rs){\n  return (ResultSet)monitorJDBC(rs);\n}\n", "nl": "Monitor a resultSets methods.  Note the version that takes an explicit class is used for when the class is a proxy"}
{"code": "public CharClassInterval(int start,int end,int charClass){\n  this.start=start;\n  this.end=end;\n  this.charClass=charClass;\n}\n", "nl": "Creates a new CharClassInterval from <CODE>start</code> to <CODE>end</code> that belongs to character class <CODE>charClass</code>."}
{"code": "public static void removeMonitor(DependencyMonitor monitor){\n  monitors.remove(monitor);\n}\n", "nl": "Unregister a dependency monitor."}
{"code": "private byte readAndCheckByte() throws IOException, EOFException {\n  int b1=in.read();\n  if (-1 == b1) {\n    throw new EOFException();\n  }\n  return (byte)b1;\n}\n", "nl": "Reads a byte from the input stream checking that the end of file (EOF) has not been encountered."}
{"code": "@Override public void configureHyperlinkLabelProvider(com.google.inject.Binder binder){\n  binder.bind(org.eclipse.jface.viewers.ILabelProvider.class).annotatedWith(org.eclipse.xtext.ui.editor.hyperlinking.HyperlinkLabelProvider.class).to(N4JSHyperlinkLabelProvider.class);\n}\n", "nl": "Binds a specific label provider for the hyper linking use case."}
{"code": "private synchronized long waitForAtLeastOneAvailableConnection(long waitTime) throws PoolExhaustedException {\n  while (availableSize() == 0) {\n    if (waitTime <= 0)     throw new PoolExhaustedException(\"ConnectionPool: pool is empty - increase either maxPoolSize or borrowConnectionTimeout\");\n    long before=System.currentTimeMillis();\n    try {\n      if (LOGGER.isTraceEnabled())       LOGGER.logTrace(this + \": about to wait for connection during \" + waitTime+ \"ms...\");\n      this.wait(waitTime);\n    }\n catch (    InterruptedException ex) {\n      InterruptedExceptionHelper.handleInterruptedException(ex);\n      if (LOGGER.isTraceEnabled())       LOGGER.logTrace(this + \": interrupted during wait\",ex);\n    }\n    if (LOGGER.isTraceEnabled())     LOGGER.logTrace(this + \": done waiting.\");\n    long now=System.currentTimeMillis();\n    waitTime-=(now - before);\n  }\n  return waitTime;\n}\n", "nl": "Wait until the connection pool contains an available connection or a timeout happens. Returns immediately if the pool already contains a connection in state available."}
{"code": "protected void sendFunctionGroup1(){\n  byte[] result=jmri.NmraPacket.function0Through4Packet(address.getNumber(),address.isLongAddress(),getF0(),getF1(),getF2(),getF3(),getF4());\n  station.sendPacket(result,1);\n}\n", "nl": "Send the message to set the state of functions F0, F1, F2, F3, F4."}
{"code": "TaskProgress(String stageName,int taskId){\n  this.stageName=stageName;\n  this.taskId=taskId;\n}\n", "nl": "Defines a new task progress tracker for the given task ID."}
{"code": "public static final LoginManager acquireLoginManager(LoginType loginType,Map<String,?> configs) throws IOException, LoginException {\nsynchronized (LoginManager.class) {\n    LoginManager loginManager=CACHED_INSTANCES.get(loginType);\n    if (loginManager == null) {\n      loginManager=new LoginManager(loginType,configs);\n      CACHED_INSTANCES.put(loginType,loginManager);\n    }\n    return loginManager.acquire();\n  }\n}\n", "nl": "Returns an instance of `LoginManager` and increases its reference count. `release()` should be invoked when the `LoginManager` is no longer needed. This method will try to reuse an existing `LoginManager` for the provided `mode` if available. However, it expects `configs` to be the same for every invocation and it will ignore them in the case where it's returning a cached instance of `LoginManager`. This is a bit ugly and it would be nicer if we could pass the `LoginManager` to `ChannelBuilders.create` and shut it down when the broker or clients are closed. It's straightforward to do the former, but it's more complicated to do the latter without making the consumer API more complex."}
{"code": "public String current(){\n  return this.currentState;\n}\n", "nl": "Get the current group name of the callback."}
{"code": "public static boolean lineLocationContainment(Location loc1,Location loc2){\n  return (loc1.beginLine() >= loc2.beginLine()) && (loc2.endLine() >= loc1.endLine());\n}\n", "nl": "True iff the range of lines specified by loc1 is a subset of the range of lines specified by loc2."}
{"code": "public File makeLargeGzipFile(int kbytes) throws IOException {\n  final byte[] line=new byte[1024];\n  final File file=File.createTempFile(\"test\",\"GzipAsynch.gz\");\n  try (GZIPOutputStream out=new GZIPOutputStream(new FileOutputStream(file))){\n    for (int i=0; i < kbytes; i++) {\n      for (int pos=0; pos < 1024; pos++) {\n        line[pos]=(byte)('!' + (pos * (long)i) % 91);\n      }\n      line[1023]=(byte)'\\n';\n      out.write(line);\n    }\n  }\n   return file;\n}\n", "nl": "Creates a largish gzipped file containing <code>numCopies</code> of <code>line</code>."}
{"code": "@Override public void clear(){\n}\n", "nl": "Clears any cached information."}
{"code": "@Override public RabbitGroup saveGroup(RabbitGroup group){\n  return groupRepository.save(group);\n}\n", "nl": "Save rabbit group to repository"}
{"code": "public void dispose(){\n  if (glHandle == 0)   return;\n  delete();\n  if (data.isManaged())   if (managedTextures.get(Gdx.app) != null)   managedTextures.get(Gdx.app).removeValue(this,true);\n}\n", "nl": "Disposes all resources associated with the texture"}
{"code": "public static String toString(InputStream input) throws IOException {\n  return toString(input,null);\n}\n", "nl": "Get the contents of an <code>InputStream</code> as a String using the default character encoding of the platform. <p> This method buffers the input internally, so there is no need to use a <code>BufferedInputStream</code>."}
{"code": "public final static VersionInfo loadVersionInfo(final String pckg,ClassLoader clsldr){\n  if (pckg == null) {\n    throw new IllegalArgumentException(\"Package identifier must not be null.\");\n  }\n  if (clsldr == null)   clsldr=Thread.currentThread().getContextClassLoader();\n  Properties vip=null;\n  try {\n    InputStream is=clsldr.getResourceAsStream(pckg.replace('.','/') + \"/\" + VERSION_PROPERTY_FILE);\n    if (is != null) {\n      try {\n        Properties props=new Properties();\n        props.load(is);\n        vip=props;\n      }\n  finally {\n        is.close();\n      }\n    }\n  }\n catch (  IOException ex) {\n  }\n  VersionInfo result=null;\n  if (vip != null)   result=fromMap(pckg,vip,clsldr);\n  return result;\n}\n", "nl": "Loads version information for a package."}
{"code": "public DgKSNetwork convertNetworkLanesAndSignals(Network network,Lanes lanes,SignalsData signals,Envelope signalsBoundingBox,double startTime,double endTime){\n  log.info(\"Checking cycle time...\");\n  this.cycle=readCycle(signals);\n  log.info(\"cycle set to \" + this.cycle);\n  signalizedLinks=this.getSignalizedLinkIds(signals.getSignalSystemsData());\n  log.info(\"Converting network ...\");\n  this.timeInterval=endTime - startTime;\n  this.signalsBoundingBox=signalsBoundingBox;\n  this.dgNetwork=this.convertNetwork(network,lanes,signals);\n  log.info(\"Network converted.\");\n  return this.dgNetwork;\n}\n", "nl": "converts the given matsim network into a ks-model network with crossings and streets and returns it"}
{"code": "private static String formatNumberCroreFormat(final BigDecimal num){\n  final double absAmount=num.abs().doubleValue();\n  final long numLakhs=(long)(absAmount / 100000);\n  final double numThousands=absAmount - (numLakhs * 100000);\n  final DecimalFormat formatter=new DecimalFormat(\"#,##\");\n  final String firstPart=(num.doubleValue() < 0 ? \"-\" : \"\") + (numLakhs > 0 ? formatter.format(numLakhs) + \",\" : \"\");\n  formatter.applyPattern(\"00,000.00\");\n  return (firstPart + formatter.format(numThousands));\n}\n", "nl": "Formats given number in Indian format (CRORE format). e.g. 1234567890.5 will be formatted as 1,23,45,67,890.50"}
{"code": "public static int ELIBSCN(){\n  return 81;\n}\n", "nl": ".lib section in a.out corrupted"}
{"code": "public void run(){\n  while (this.stop) {\n    System.out.print(\"\\b \");\n  }\n}\n", "nl": "Implementation of <code>run</code> method"}
{"code": "public static synchronized int pollId(final Class<?> clazz){\n  Class<?> matchClass=null;\n  if (COUNTERS.containsKey(clazz)) {\n    matchClass=clazz;\n  }\n else   if (!NO_COUNTERS.contains(clazz)) {\n    for (    Class<?> key : COUNTERS.keySet()) {\n      if (key.isAssignableFrom(clazz)) {\n        matchClass=key;\n        break;\n      }\n    }\n  }\n  int result=-1;\n  if (matchClass == null) {\n    NO_COUNTERS.add(clazz);\n    result=pollGlobalId();\n  }\n else {\n    result=COUNTERS.get(matchClass);\n    COUNTERS.put(matchClass,result + 1);\n  }\n  if (result < 0) {\n    throw new IllegalStateException(\"The generated id for class:\" + clazz.getName() + \" is negative. Possible integer overflow.\");\n  }\n  return result;\n}\n", "nl": "Returns a valid id for the specified class."}
{"code": "public boolean isSupportedLookAndFeel(){\n  return true;\n}\n", "nl": "Returns <code>true</code>; every platform permits this look and feel."}
{"code": "public String toGnuStepASCIIPropertyList(){\n  StringBuilder ascii=new StringBuilder();\n  toASCIIGnuStep(ascii,0);\n  ascii.append(NEWLINE);\n  return ascii.toString();\n}\n", "nl": "Generates a valid ASCII property list in GnuStep format which has this NSDictionary as its root object. The generated property list complies with the format as described in <a href=\"http://www.gnustep.org/resources/documentation/Developer/Base/Reference/NSPropertyList.html\"> GnuStep - NSPropertyListSerialization class documentation </a>"}
{"code": "public SafeTimeTracker(long delay,long random){\n  internalDelay=delay;\n  randomRange=random;\n}\n", "nl": "In many situations, it is a bad idea to have all objects of the same kind to be waiting for the exact same amount of time, as that can lead to some situation where they're all synchronized and got to work all at the same time. When created with a random range, the mark that is set when reaching the expect delay will be added with a random number between [0, range[, meaning that the event will take between 0 and range more tick to run."}
{"code": "private static void scrapeLink(String episodeURL,int episodeNum,Series series){\n  StringBuilder episodeTextBuffer=new StringBuilder(\"Episode Number: \" + episodeNum + \"<br>\");\n  String episodeText;\n  URL url;\n  InputStream is=null;\n  BufferedReader br;\n  String line;\n  try {\n    url=new URL(episodeURL);\n    is=url.openStream();\n    br=new BufferedReader(new InputStreamReader(is));\n    while ((line=br.readLine()) != null) {\n      episodeTextBuffer.append(line);\n      episodeTextBuffer.append(\" \");\n    }\n  }\n catch (  IOException ioe) {\n    ioe.printStackTrace();\n  }\n finally {\n    try {\n      if (is != null)       is.close();\n    }\n catch (    IOException ioe) {\n    }\n  }\n  episodeText=episodeTextBuffer.toString();\n  episodeText=episodeText.replaceAll(\"\\\\n\",\"\");\n  episodeText=episodeText.replaceAll(\"<br>\",\"\\n\");\n  episodeText=episodeText.replaceAll(\"</div>(.*\\n)*.*\",\"\\n\");\n  episodeText=episodeText.replaceAll(\"<[^>]*>\",\"\\n\");\n  episodeText=episodeText.replace(\"&nbsp\",\"\");\n  episodeText=episodeText.replaceAll(\"\\\\n+\\\\s*\",\"\\n\");\n  episodeText=episodeText.replaceAll(\"\\\\n{2,}\",\"\\n\");\n  episodeText=episodeText.replaceAll(\":;\",\": \");\n  saveEpisode(episodeText,episodeNum,series);\n}\n", "nl": "Scrape the given episode using the provided information"}
{"code": "public static boolean isConfigFileKeyword(String name){\n  return CONFIG_KEYWORDS.contains(name);\n}\n", "nl": "Checks if name is a configuration file keyword"}
{"code": "public void replaceAnnFile(Reader readerAnnFile){\n  m_pathAnnFile=null;\n  m_readerAnnFile=readerAnnFile;\n  m_isUpdateAnnFile=true;\n  if (!isModified())   setEditFlag(FolderEditFlag.UPDATE);\n}\n", "nl": "Reemplaza el fichero de anotaciones asociado al documento"}
{"code": "public IntStack(int blocksize){\n  super(blocksize);\n}\n", "nl": "Construct a IntVector, using the given block size."}
{"code": "private GrantorRequestProcessor(InternalDistributedSystem system,InternalDistributedMember elder){\n  super(system,elder);\n}\n", "nl": "Creates a new instance of GrantorRequestProcessor"}
{"code": "public static SecureConnectionMode parse(String value,String defaultValue){\n  SecureConnectionMode mode=parse(value);\n  if (mode == null && defaultValue != null)   mode=parse(defaultValue);\n  return mode;\n}\n", "nl": "Determine if the supplied value is one of the predefined options."}
{"code": "public void testServerResponseRetransmissions() throws Exception {\n  String oldRetransValue=System.getProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n  System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS,\"2\");\n  System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER,\"100\");\n  System.setProperty(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\"true\");\n  stunStack.addRequestListener(serverAddress,requestCollector);\n  stunStack.sendRequest(bindingRequest,serverAddress,clientAddress,responseCollector);\n  requestCollector.waitForRequest();\n  Vector<StunMessageEvent> reqs=requestCollector.getRequestsForTransaction(bindingRequest.getTransactionID());\n  StunMessageEvent evt=reqs.get(0);\n  byte[] tid=evt.getMessage().getTransactionID();\n  stunStack.sendResponse(tid,bindingResponse,serverAddress,clientAddress);\n  Thread.sleep(500);\n  assertTrue(\"There were too few retransmissions of a binding response: \" + responseCollector.receivedResponses.size(),responseCollector.receivedResponses.size() < 3);\n  if (oldRetransValue != null)   System.getProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS,oldRetransValue);\n else   System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n  System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n}\n", "nl": "Makes sure that once a request has been answered by the server, retransmissions of this request are not propagated to the UA and are automatically handled with a retransmission of the last seen response"}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 13:01:21.661 -0500\",hash_original_method=\"9928E14A90ED22F7792AF824C555C38E\",hash_generated_method=\"FD09E15A05B5DCDBEE2328F70AACD50E\") private TextImpl firstTextNodeInCurrentRun(){\n  TextImpl firstTextInCurrentRun=this;\n  for (Node p=getPreviousSibling(); p != null; p=p.getPreviousSibling()) {\n    short nodeType=p.getNodeType();\n    if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n      firstTextInCurrentRun=(TextImpl)p;\n    }\n else {\n      break;\n    }\n  }\n  return firstTextInCurrentRun;\n}\n", "nl": "Returns the first text or CDATA node in the current sequence of text and CDATA nodes."}
{"code": "private static void addDefaultProfile(SpringApplication app,SimpleCommandLinePropertySource source){\n  if (!source.containsProperty(\"spring.profiles.active\") && !System.getenv().containsKey(\"SPRING_PROFILES_ACTIVE\")) {\n    app.setAdditionalProfiles(Constants.SPRING_PROFILE_DEVELOPMENT);\n  }\n}\n", "nl": "If no profile has been configured, set by default the \"dev\" profile."}
{"code": "public ApproximationSetPlot(DiagnosticTool frame,String metric){\n  super(frame,metric);\n  setLayout(new BorderLayout());\n}\n", "nl": "Constructs a new plot do display the Pareto approximation set."}
{"code": "public static void assertNotNull(Object object){\n  assertTrue(object != null);\n}\n", "nl": "Assert that a value is not null."}
{"code": "private static boolean oRule(String s){\n  int pos=s.length() - 1;\n  if (pos < 2)   return false;\n  if (!isVowel(s,pos) && isVowel(s,pos - 1) && !isVowel(s,pos - 2)) {\nswitch (s.charAt(pos)) {\ncase 'w':\ncase 'x':\ncase 'y':\n      return false;\ndefault :\n    return true;\n}\n}\nreturn false;\n}\n", "nl": "*o  - the stem ends cvc, where the second c is not W, X or Y (e.g. -WIL, -HOP)."}
{"code": "void refreshAccessPoints(){\n  if (mWifiManager.isWifiEnabled()) {\n    mScanner.resume();\n  }\n  getPreferenceScreen().removeAll();\n}\n", "nl": "Refreshes acccess points and ask Wifi module to scan networks again."}
{"code": "public boolean isDefaultButton(){\n  JRootPane root=SwingUtilities.getRootPane(this);\n  if (root != null) {\n    return root.getDefaultButton() == this;\n  }\n  return false;\n}\n", "nl": "Gets the value of the <code>defaultButton</code> property, which if <code>true</code> means that this button is the current default button for its <code>JRootPane</code>. Most look and feels render the default button differently, and may potentially provide bindings to access the default button."}
{"code": "public void testCase16(){\n  byte aBytes[]={-127,100,56,7,98,-1,39,-128,127};\n  byte bBytes[]={-127,100,56,7,98,-1,39,-128,127};\n  int aSign=1;\n  int bSign=1;\n  byte rBytes[]={0};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.remainder(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",0,result.signum());\n}\n", "nl": "Remainder of division of equal numbers"}
{"code": "public EditableOMRect(OMRect omc){\n  setGraphic(omc);\n}\n", "nl": "Create the EditableOMRect with an OMRect already defined, ready for editing."}
{"code": "protected Node export(Node n,AbstractDocument d){\n  super.export(n,d);\n  AbstractElement ae=(AbstractElement)n;\n  if (attributes != null) {\n    NamedNodeMap map=attributes;\n    for (int i=map.getLength() - 1; i >= 0; i--) {\n      AbstractAttr aa=(AbstractAttr)map.item(i);\n      if (aa.getSpecified()) {\n        Attr attr=(Attr)aa.deepExport(aa.cloneNode(false),d);\n        if (aa instanceof AbstractAttrNS) {\n          ae.setAttributeNodeNS(attr);\n        }\n else {\n          ae.setAttributeNode(attr);\n        }\n      }\n    }\n  }\n  return n;\n}\n", "nl": "Exports this node to the given document."}
{"code": "public static void main(String[] args) throws IOException {\n  long t1=Util.getTimestamp(2003,4,1);\n  long t2=Util.getTimestamp(2003,5,1);\n  System.out.println(\"t1 = \" + t1);\n  System.out.println(\"t2 = \" + t2);\n  String rrdPath=Util.getRrd4jDemoPath(\"demo.rrd\");\n  DataProcessor dp=new DataProcessor(t1,t2);\n  dp.addDatasource(\"X\",rrdPath,\"sun\",ConsolFun.AVERAGE);\n  dp.addDatasource(\"Y\",rrdPath,\"shade\",ConsolFun.AVERAGE);\n  dp.addDatasource(\"Z\",\"X,Y,+,2,/\");\n  dp.addDatasource(\"DERIVE[Z]\",\"Z,PREV(Z),-,STEP,/\");\n  dp.addDatasource(\"TREND[Z]\",\"DERIVE[Z],SIGN\");\n  dp.addDatasource(\"AVG[Z]\",\"Z\",ConsolFun.AVERAGE);\n  dp.addDatasource(\"DELTA\",\"Z,AVG[Z],-\");\n  long laptime=System.currentTimeMillis();\n  dp.processData();\n  System.out.println(\"Data processed in \" + (System.currentTimeMillis() - laptime) + \" milliseconds\\n---\");\n  System.out.println(dp.dump());\n  System.out.println(\"\\nAggregates for X\");\n  Aggregates agg=dp.getAggregates(\"X\");\n  System.out.println(agg.dump());\n  System.out.println(\"\\nAggregates for Y\");\n  agg=dp.getAggregates(\"Y\");\n  System.out.println(agg.dump());\n  System.out.println(\"\\n95-percentile for X: \" + Util.formatDouble(dp.get95Percentile(\"X\")));\n  System.out.println(\"95-percentile for Y: \" + Util.formatDouble(dp.get95Percentile(\"Y\")));\n  System.out.println(\"\\nLast archive update time was: \" + dp.getLastRrdArchiveUpdateTime());\n}\n", "nl": "Cute little demo. Uses demo.rrd file previously created by basic Rrd4j demo."}
{"code": "private void afterServerCommit(TXCommitMessage txcm){\n  if (this.internalAfterSendCommit != null) {\n    this.internalAfterSendCommit.run();\n  }\n  GemFireCacheImpl cache=GemFireCacheImpl.getInstance();\n  if (cache == null) {\n    return;\n  }\n  cache.getCancelCriterion().checkCancelInProgress(null);\n  InternalDistributedSystem ds=cache.getDistributedSystem();\n  DM dm=ds.getDistributionManager();\n  txcm.setDM(dm);\n  txcm.setAckRequired(false);\n  txcm.setDisableListeners(true);\n  cache.getTxManager().setTXState(null);\n  txcm.hookupRegions(dm);\n  txcm.basicProcess();\n}\n", "nl": "perform local cache modifications using the server's TXCommitMessage"}
{"code": "private boolean conditionCH1(String value,int index){\n  return ((contains(value,0,4,\"VAN \",\"VON \") || contains(value,0,3,\"SCH\")) || contains(value,index - 2,6,\"ORCHES\",\"ARCHIT\",\"ORCHID\") || contains(value,index + 2,1,\"T\",\"S\")|| ((contains(value,index - 1,1,\"A\",\"O\",\"U\",\"E\") || index == 0) && (contains(value,index + 2,1,L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n}\n", "nl": "Complex condition 1 for 'CH'"}
{"code": "public static void toggleBreakpointStatus(final BreakpointManager manager,final INaviModule module,final UnrelocatedAddress unrelocatedAddress){\n  Preconditions.checkNotNull(manager,\"IE01723: Manager argument can not be null\");\n  Preconditions.checkNotNull(module,\"IE01724: Module argument can not be null\");\n  Preconditions.checkNotNull(unrelocatedAddress,\"IE01725: Address argument can not be null\");\n  final BreakpointAddress address=new BreakpointAddress(module,unrelocatedAddress);\n  toggleBreakpoint(manager,address);\n}\n", "nl": "Disables or enables a breakpoint at a given address."}
{"code": "@Override public String toString(){\n  return getClass().getName() + \"[data=\" + data+ \"]\";\n}\n", "nl": "Returns a String representation of this RootNotification."}
{"code": "public static PcRunner serializableInstance(){\n  return PcRunner.serializableInstance();\n}\n", "nl": "Generates a simple exemplar of this class to test serialization."}
{"code": "@Override public boolean visitTree(VisitContext visitContext,VisitCallback callback){\n  if (!isVisitable(visitContext)) {\n    return false;\n  }\n  FacesContext facesContext=visitContext.getFacesContext();\n  boolean visitRows=requiresRowIteration(visitContext);\n  Integer oldRowKey=null;\n  if (visitRows) {\n    oldRowKey=getRowKey();\n    setRowKey(facesContext,null);\n  }\n  pushComponentToEL(facesContext,null);\n  try {\n    VisitResult result=visitContext.invokeVisitCallback(this,callback);\n    if (result == VisitResult.COMPLETE) {\n      return true;\n    }\n    if ((result == VisitResult.ACCEPT)) {\n      if (visitDataChildren(visitContext,callback,visitRows)) {\n        return true;\n      }\n    }\n  }\n catch (  IOException e) {\n    LOG.log(Level.SEVERE,e.getMessage(),e);\n  }\n finally {\n    popComponentFromEL(facesContext);\n    if (visitRows) {\n      try {\n        setRowKey(facesContext,oldRowKey);\n        restoreOrigValue(facesContext);\n      }\n catch (      Exception e) {\n        LOG.log(Level.SEVERE,e.getMessage(),e);\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Copied from Richfaces UIDataAdapter#visitTree."}
{"code": "public TestBase(String name){\n  testName=name;\n}\n", "nl": "Creates a new instance of StreamReader"}
{"code": "private LRAction searchSingleReduction(){\n  Reduce act=null;\n  for (  Terminal t : table.getActionTable().getColumns()) {\n    LRAction act2=table.getActionTable().get(rdState,t);\n    if (act2 instanceof Reduce) {\n      if (act == null)       act=(Reduce)act2;\n else       if (((Reduce)act2).getProduction() != act.getProduction())       return null;\n    }\n else     if (act2 instanceof Shift)     return null;\n  }\n  return act;\n}\n", "nl": "If in the current state only one single reduction is possible, this function returns it. Otherwise returns null."}
{"code": "public static String joinSizeTagToKey(String key,String tag){\n  return new StringBuilder(key).append(SIZE_SP).append(tag).toString();\n}\n", "nl": "Join the tag with the key."}
{"code": "public PriceListProduct(int M_Product_ID,String value,String name,String description,String help,String documentNote,String imageURL,String descriptionURL,BigDecimal price,String uomName,String uomSymbol){\n  m_Product_ID=M_Product_ID;\n  m_value=value;\n  m_name=name;\n  m_description=description;\n  m_help=help;\n  m_documentNote=documentNote;\n  m_imageURL=imageURL;\n  m_descriptionURL=descriptionURL;\n  m_price=price;\n  m_uomName=uomName;\n  m_uomSymbol=uomSymbol;\n}\n", "nl": "Price List Product."}
{"code": "private void prepareNativeDaemon(){\n  mBandwidthControlEnabled=false;\n  final boolean hasKernelSupport=new File(\"/proc/net/xt_qtaguid/ctrl\").exists();\n  if (hasKernelSupport) {\n    Slog.d(TAG,\"enabling bandwidth control\");\n    try {\n      mConnector.execute(\"bandwidth\",\"enable\");\n      mBandwidthControlEnabled=true;\n    }\n catch (    NativeDaemonConnectorException e) {\n      Log.wtf(TAG,\"problem enabling bandwidth controls\",e);\n    }\n  }\n else {\n    Slog.d(TAG,\"not enabling bandwidth control\");\n  }\n  SystemProperties.set(PROP_QTAGUID_ENABLED,mBandwidthControlEnabled ? \"1\" : \"0\");\nsynchronized (mQuotaLock) {\n    int size=mActiveQuotas.size();\n    if (size > 0) {\n      Slog.d(TAG,\"pushing \" + size + \" active quota rules\");\n      final HashMap<String,Long> activeQuotas=mActiveQuotas;\n      mActiveQuotas=Maps.newHashMap();\n      for (      Map.Entry<String,Long> entry : activeQuotas.entrySet()) {\n        setInterfaceQuota(entry.getKey(),entry.getValue());\n      }\n    }\n    size=mActiveAlerts.size();\n    if (size > 0) {\n      Slog.d(TAG,\"pushing \" + size + \" active alert rules\");\n      final HashMap<String,Long> activeAlerts=mActiveAlerts;\n      mActiveAlerts=Maps.newHashMap();\n      for (      Map.Entry<String,Long> entry : activeAlerts.entrySet()) {\n        setInterfaceAlert(entry.getKey(),entry.getValue());\n      }\n    }\n    size=mUidRejectOnQuota.size();\n    if (size > 0) {\n      Slog.d(TAG,\"pushing \" + size + \" active uid rules\");\n      final SparseBooleanArray uidRejectOnQuota=mUidRejectOnQuota;\n      mUidRejectOnQuota=new SparseBooleanArray();\n      for (int i=0; i < uidRejectOnQuota.size(); i++) {\n        setUidNetworkRules(uidRejectOnQuota.keyAt(i),uidRejectOnQuota.valueAt(i));\n      }\n    }\n  }\n  setFirewallEnabled(mFirewallEnabled || LockdownVpnTracker.isEnabled());\n}\n", "nl": "Prepare native daemon once connected, enabling modules and pushing any existing in-memory rules."}
{"code": "public static final int signedToInt(byte b){\n  return ((int)b & 0xff);\n}\n", "nl": "Converts a byte in the range of -128 to 127 to an int in the range 0 - 255."}
{"code": "public SamlCodeEvent(Object source,String code){\n  super(source,code);\n}\n", "nl": "Create a new SamlCodeEvent"}
{"code": "public Set<String> addContent(String variable,double value){\n  if (!paused) {\n    curState.addToState(new Assignment(variable,value));\n    return update();\n  }\n else {\n    log.info(\"system is paused, ignoring \" + variable + \"=\"+ value);\n    return Collections.emptySet();\n  }\n}\n", "nl": "Adds the content (expressed as a pair of variable=value) to the current dialogue state, and subsequently updates the dialogue state."}
{"code": "public float interpolate(float x){\n  final int n=mX.length;\n  if (Float.isNaN(x)) {\n    return x;\n  }\n  if (x <= mX[0]) {\n    return mY[0];\n  }\n  if (x >= mX[n - 1]) {\n    return mY[n - 1];\n  }\n  int i=0;\n  while (x >= mX[i + 1]) {\n    i+=1;\n    if (x == mX[i]) {\n      return mY[i];\n    }\n  }\n  float h=mX[i + 1] - mX[i];\n  float t=(x - mX[i]) / h;\n  return (mY[i] * (1 + 2 * t) + h * mM[i] * t) * (1 - t) * (1 - t) + (mY[i + 1] * (3 - 2 * t) + h * mM[i + 1] * (t - 1)) * t * t;\n}\n", "nl": "Interpolates the value of Y = f(X) for given X. Clamps X to the domain of the spline."}
{"code": "public static void showToast(Context context,int resourceId){\n  Toast.makeText(context,context.getString(resourceId),Toast.LENGTH_LONG).show();\n}\n", "nl": "Shows a (long) toast."}
{"code": "private static final PublicKey constructPublicKey(byte[] encodedKey,String encodedKeyAlgorithm) throws InvalidKeyException, NoSuchAlgorithmException {\n  try {\n    KeyFactory keyFactory=KeyFactory.getInstance(encodedKeyAlgorithm);\n    X509EncodedKeySpec keySpec=new X509EncodedKeySpec(encodedKey);\n    return keyFactory.generatePublic(keySpec);\n  }\n catch (  NoSuchAlgorithmException nsae) {\n    throw new NoSuchAlgorithmException(\"No installed providers \" + \"can create keys for the \" + encodedKeyAlgorithm + \"algorithm\",nsae);\n  }\ncatch (  InvalidKeySpecException ike) {\n    throw new InvalidKeyException(\"Cannot construct public key\",ike);\n  }\n}\n", "nl": "Construct a public key from its encoding."}
{"code": "public <T>T mapTo(final Class<T> mappingClass,final JBBPMapperCustomFieldProcessor customFieldProcessor,final int flags){\n  return JBBPMapper.map(this,mappingClass,customFieldProcessor,flags);\n}\n", "nl": "Map the structure fields to a class fields."}
{"code": "public static void unregisterSemanticNodes(){\n  semanticNodes=new LinkedList();\n}\n", "nl": "Deletes the information about semantic nodes used with tool-specific information"}
{"code": "public boolean doWindowDeActivated(){\n  return true;\n}\n", "nl": "Method doWindowDeActivated."}
{"code": "public TrieIterator(TrieNode node){\n  super();\n  m_Root=node;\n  m_CurrentLeaf=(TrieNode)m_Root.getFirstLeaf();\n  m_LastLeaf=(TrieNode)m_Root.getLastLeaf();\n}\n", "nl": "initializes the iterator"}
{"code": "public static JavacNode injectField(JavacNode typeNode,JCVariableDecl field){\n  return injectField(typeNode,field,false);\n}\n", "nl": "Adds the given new field declaration to the provided type AST Node. Also takes care of updating the JavacAST."}
{"code": "private static boolean checkAppSignature(String facetId,Context context){\n  try {\n    PackageInfo packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),PackageManager.GET_SIGNATURES);\n    for (    Signature sign : packageInfo.signatures) {\n      byte[] sB=sign.toByteArray();\n      MessageDigest messageDigest=MessageDigest.getInstance(\"SHA1\");\n      messageDigest.update(sign.toByteArray());\n      String currentSignature=Base64.encodeToString(messageDigest.digest(),Base64.DEFAULT);\n      if (currentSignature.toLowerCase().contains(facetId.split(\":\")[2].toLowerCase())) {\n        return true;\n      }\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    e.printStackTrace();\n  }\ncatch (  NoSuchAlgorithmException e) {\n    e.printStackTrace();\n  }\n  return false;\n}\n", "nl": "A double check about app signature that was passed by MainActivity as facetID."}
{"code": "public static RemoveHealthListenerRequest create(int id){\n  RemoveHealthListenerRequest m=new RemoveHealthListenerRequest();\n  m.id=id;\n  return m;\n}\n", "nl": "Returns a <code>RemoveHealthListenerRequest</code> to be sent to the specified recipient."}
{"code": "public void close(){\n  if (getParentInternalFrame() != null) {\n    getParentInternalFrame().doDefaultCloseAction();\n  }\n else   if (getParentFrame() != null) {\n    ((Window)getParentFrame()).dispatchEvent(new WindowEvent(getParentFrame(),WindowEvent.WINDOW_CLOSING));\n  }\n}\n", "nl": "closes the window, i.e., if the parent is not null and implements the WindowListener interface it calls the windowClosing method"}
{"code": "public static SRegResponse createSRegResponse(SRegRequest req,Map userData) throws MessageException {\n  SRegResponse resp=new SRegResponse();\n  List attributes=req.getAttributes();\n  Iterator iter=attributes.iterator();\n  while (iter.hasNext()) {\n    String attr=(String)iter.next();\n    String value=(String)userData.get(attr);\n    if (value != null)     resp.addAttribute(attr,value);\n  }\n  return resp;\n}\n", "nl": "Creates a SRegResponse from a SRegRequest message and the data released by the user."}
{"code": "@Override public int size(){\n  final Segment<V>[] segments=this.segments;\n  long sum=0;\n  long check=0;\n  int[] mc=new int[segments.length];\n  for (int k=0; k < RETRIES_BEFORE_LOCK; ++k) {\n    check=0;\n    sum=0;\n    int mcsum=0;\n    for (int i=0; i < segments.length; ++i) {\n      sum+=segments[i].count;\n      mcsum+=mc[i]=segments[i].modCount;\n    }\n    if (mcsum != 0) {\n      for (int i=0; i < segments.length; ++i) {\n        check+=segments[i].count;\n        if (mc[i] != segments[i].modCount) {\n          check=-1;\n          break;\n        }\n      }\n    }\n    if (check == sum)     break;\n  }\n  if (check != sum) {\n    sum=0;\n    for (int i=0; i < segments.length; ++i)     segments[i].lock();\n    for (int i=0; i < segments.length; ++i)     sum+=segments[i].count;\n    for (int i=0; i < segments.length; ++i)     segments[i].unlock();\n  }\n  if (sum > Integer.MAX_VALUE)   return Integer.MAX_VALUE;\n  return (int)sum;\n}\n", "nl": "Returns the number of key-value mappings in this map.  If the map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns <tt>Integer.MAX_VALUE</tt>."}
{"code": "public void testParallelExhausted() throws Exception {\n  String algLines[]={\"# ----- properties \",\"content.source=org.apache.lucene.benchmark.byTask.feeds.LineDocSource\",\"docs.file=\" + getReuters20LinesFile(),\"content.source.log.step=3\",\"doc.term.vector=false\",\"content.source.forever=false\",\"directory=RAMDirectory\",\"doc.stored=false\",\"doc.tokenized=false\",\"task.max.depth.log=1\",\"# ----- alg \",\"CreateIndex\",\"{ [ AddDoc]: 4} : * \",\"ResetInputs \",\"{ [ AddDoc]: 4} : * \",\"CloseIndex\"};\n  Benchmark benchmark=execBenchmark(algLines);\n  IndexReader ir=DirectoryReader.open(benchmark.getRunData().getDirectory());\n  int ndocsExpected=2 * 20;\n  assertEquals(\"wrong number of docs in the index!\",ndocsExpected,ir.numDocs());\n  ir.close();\n}\n", "nl": "Test that \" {[AddDoc(4000)]: 4} : * \" works corrcetly (for LUCENE-941)"}
{"code": "protected void verifyMatch(Object target,Object deserialized){\n  CronExpression targetCronExpression=(CronExpression)target;\n  CronExpression deserializedCronExpression=(CronExpression)deserialized;\n  assertNotNull(deserializedCronExpression);\n  assertEquals(targetCronExpression.getCronExpression(),deserializedCronExpression.getCronExpression());\n  assertEquals(targetCronExpression.getTimeZone(),deserializedCronExpression.getTimeZone());\n}\n", "nl": "Verify that the target object and the object we just deserialized match."}
{"code": "public static boolean ISK(int x){\n  return 0 != ((x) & BITRK);\n}\n", "nl": "test whether value is a constant"}
{"code": "public boolean isDependentEntities(){\n  Object oo=get_Value(COLUMNNAME_IsDependentEntities);\n  if (oo != null) {\n    if (oo instanceof Boolean)     return ((Boolean)oo).booleanValue();\n    return \"Y\".equals(oo);\n  }\n  return false;\n}\n", "nl": "Get Dependent Entities."}
{"code": "private void removeWaiter(WaitNode node){\n  if (node != null) {\n    node.thread=null;\n    retry:     for (; ; ) {\n      for (WaitNode pred=null, q=waiters, s; q != null; q=s) {\n        s=q.next;\n        if (q.thread != null)         pred=q;\n else         if (pred != null) {\n          pred.next=s;\n          if (pred.thread == null)           continue retry;\n        }\n else         if (!UNSAFE.compareAndSwapObject(this,waitersOffset,q,s))         continue retry;\n      }\n      break;\n    }\n  }\n}\n", "nl": "Tries to unlink a timed-out or interrupted wait node to avoid accumulating garbage.  Internal nodes are simply unspliced without CAS since it is harmless if they are traversed anyway by releasers.  To avoid effects of unsplicing from already removed nodes, the list is retraversed in case of an apparent race.  This is slow when there are a lot of nodes, but we don't expect lists to be long enough to outweigh higher-overhead schemes."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:27:51.378 -0500\",hash_original_method=\"212FDF834FF8F6725237F29A41B6704B\",hash_generated_method=\"46C0413BA03B9DE945DBF06FA8B5E0CE\") public static String convertPreDial(String phoneNumber){\n  if (phoneNumber == null) {\n    return null;\n  }\n  int len=phoneNumber.length();\n  StringBuilder ret=new StringBuilder(len);\n  for (int i=0; i < len; i++) {\n    char c=phoneNumber.charAt(i);\n    if (isPause(c)) {\n      c=PAUSE;\n    }\n else     if (isToneWait(c)) {\n      c=WAIT;\n    }\n    ret.append(c);\n  }\n  return ret.toString();\n}\n", "nl": "Converts pause and tonewait pause characters to Android representation. RFC 3601 says pause is 'p' and tonewait is 'w'."}
{"code": "@Override public boolean execute(String sql,String[] columnNames) throws SQLException {\n  try {\n    if (isDebugEnabled()) {\n      debugCode(\"execute(\" + quote(sql) + \", \"+ quoteArray(columnNames)+ \");\");\n    }\n    throw DbException.get(ErrorCode.METHOD_NOT_ALLOWED_FOR_PREPARED_STATEMENT);\n  }\n catch (  Exception e) {\n    throw logAndConvert(e);\n  }\n}\n", "nl": "Calling this method is not legal on a PreparedStatement."}
{"code": "@Override public void increment(double coord,float value){\n  if (cachefill >= 0) {\n    if (cachefill < cachec.length) {\n      cachec[cachefill]=coord;\n      cachev[cachefill]=value;\n      cachefill++;\n      return;\n    }\n else {\n      materialize();\n    }\n  }\n  testResample(coord);\n  super.increment(coord,value);\n}\n", "nl": "Put fresh data into the histogram (or into the cache)"}
{"code": "public WPAttributeDialog(int M_AttributeSetInstance_ID,int M_Product_ID,int C_BPartner_ID,boolean productWindow,int AD_Column_ID,int WindowNo){\n  super();\n  this.setTitle(Msg.translate(Env.getCtx(),\"M_AttributeSetInstance_ID\"));\n  this.setAttribute(\"modal\",Boolean.TRUE);\n  this.setBorder(\"normal\");\n  this.setWidth(\"500px\");\n  this.setHeight(\"600px\");\n  this.setSizable(true);\n  log.config(\"M_AttributeSetInstance_ID=\" + M_AttributeSetInstance_ID + \", M_Product_ID=\"+ M_Product_ID+ \", C_BPartner_ID=\"+ C_BPartner_ID+ \", ProductW=\"+ productWindow+ \", Column=\"+ AD_Column_ID);\n  m_WindowNo=SessionManager.getAppDesktop().registerWindow(this);\n  m_M_AttributeSetInstance_ID=M_AttributeSetInstance_ID;\n  m_M_Product_ID=M_Product_ID;\n  m_C_BPartner_ID=C_BPartner_ID;\n  m_productWindow=productWindow;\n  m_AD_Column_ID=AD_Column_ID;\n  m_WindowNoParent=WindowNo;\n  m_columnName=MColumn.getColumnName(Env.getCtx(),AD_Column_ID);\n  if (m_columnName == null || m_columnName.trim().length() == 0) {\n    m_columnName=\"M_AttributeSetInstance_ID\";\n  }\n  try {\n    init();\n  }\n catch (  Exception ex) {\n    log.log(Level.SEVERE,\"VPAttributeDialog\" + ex);\n  }\n  if (!initAttributes()) {\n    dispose();\n    return;\n  }\n  AEnv.showCenterScreen(this);\n}\n", "nl": "Product Attribute Instance Dialog"}
{"code": "public Vector multiply(double n){\n  return new Vector(this.x * n,this.y * n,this.z * n);\n}\n", "nl": "Perform scalar multiplication and return a new vector."}
{"code": "public static String date2String_yyyy_MM_dd_HH_mm_ss(Date date){\n  return getSimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(date);\n}\n", "nl": "format date to yyyy-MM-dd HH:mm:ss string"}
{"code": "public void init(java.net.URL url){\n  init(null,url);\n}\n", "nl": "Initialize the LayerHandler by having it construct it's layers from a URL containing an openmap.properties file."}
{"code": "@Override public boolean isValidCombination(int weeklyMinutes,DatePattern datePattern,TimePattern timePattern){\n  if (timePattern.getType() != null && timePattern.getType() == TimePattern.sTypeExactTime)   return true;\n  if (datePattern == null)   return false;\n  if (datePattern.getType() != null && datePattern.getType() == DatePattern.sTypePatternSet) {\n    for (    DatePattern child : datePattern.findChildren())     if (isValidCombination(weeklyMinutes,child,timePattern))     return true;\n    return false;\n  }\n else {\n    return weeklyMinutes == datePattern.getEffectiveNumberOfWeeks() * timePattern.getNrMeetings() * timePattern.getMinPerMtg() / getSemesterWeeks(datePattern);\n  }\n}\n", "nl": "A combination is valid when the number of semester minutes matches the number of meetings times number of minutes per week of the time pattern, multiplied by the number of weeks of the date pattern.<br> <code>weekly minutes == number of meetings x number of minutes per meeting x number of weeks / semester weeks</code><br> Semester weeks are provided with the given parameter or (if not set) taken from the default date pattern."}
{"code": "private void calcNextPos(int dx,int minX,int maxX,int dy,int minY,int maxY){\n  if (dx != 0) {\n    leadColumn+=dx;\n    if (leadColumn > maxX) {\n      leadColumn=minX;\n      leadRow++;\n      if (leadRow > maxY) {\n        leadRow=minY;\n      }\n    }\n else     if (leadColumn < minX) {\n      leadColumn=maxX;\n      leadRow--;\n      if (leadRow < minY) {\n        leadRow=maxY;\n      }\n    }\n  }\n else {\n    leadRow+=dy;\n    if (leadRow > maxY) {\n      leadRow=minY;\n      leadColumn++;\n      if (leadColumn > maxX) {\n        leadColumn=minX;\n      }\n    }\n else     if (leadRow < minY) {\n      leadRow=maxY;\n      leadColumn--;\n      if (leadColumn < minX) {\n        leadColumn=maxX;\n      }\n    }\n  }\n}\n", "nl": "Find the next lead row and column based on the given dx/dy and max/min values."}
{"code": "@Override public void exportGroupDelete(URI export,String opId) throws ControllerException {\n  ExportTaskCompleter taskCompleter=new ExportDeleteCompleter(export,false,opId);\n  Workflow workflow=null;\n  try {\n    ExportGroup exportGroup=_dbClient.queryObject(ExportGroup.class,export);\n    if (exportGroup != null && exportGroup.getExportMasks() != null) {\n      workflow=_wfUtils.newWorkflow(\"exportGroupDelete\",false,opId);\n      Set<URI> storageSystemURIs=new HashSet<URI>();\n      List<ExportMask> tempExportMasks=ExportMaskUtils.getExportMasks(_dbClient,exportGroup);\n      for (      ExportMask tempExportMask : tempExportMasks) {\n        List<String> lockKeys=ControllerLockingUtil.getHostStorageLockKeys(_dbClient,ExportGroup.ExportGroupType.valueOf(exportGroup.getType()),StringSetUtil.stringSetToUriList(exportGroup.getInitiators()),tempExportMask.getStorageDevice());\n        boolean acquiredLocks=_wfUtils.getWorkflowService().acquireWorkflowLocks(workflow,lockKeys,LockTimeoutValue.get(LockType.EXPORT_GROUP_OPS));\n        if (!acquiredLocks) {\n          throw DeviceControllerException.exceptions.failedToAcquireLock(lockKeys.toString(),\"ExportGroupDelete: \" + exportGroup.getLabel());\n        }\n        if (tempExportMask != null && tempExportMask.getVolumes() != null) {\n          List<URI> uriList=getExportRemovableObjects(exportGroup,tempExportMask);\n          Map<URI,List<URI>> storageToVolumes=getStorageToVolumes(uriList);\n          for (          URI storageURI : storageToVolumes.keySet()) {\n            if (!storageSystemURIs.contains(storageURI)) {\n              storageSystemURIs.add(storageURI);\n              _wfUtils.generateExportGroupDeleteWorkflow(workflow,null,null,storageURI,export);\n            }\n          }\n        }\n else {\n          exportGroup.removeExportMask(tempExportMask.getId());\n          _dbClient.persistObject(exportGroup);\n        }\n      }\n      workflow.executePlan(taskCompleter,\"Removed export from all devices.\");\n    }\n else {\n      taskCompleter.ready(_dbClient);\n    }\n  }\n catch (  Exception ex) {\n    String message=\"exportGroupDelete caught an exception.\";\n    _log.error(message,ex);\n    if (workflow != null) {\n      _wfUtils.getWorkflowService().releaseAllWorkflowLocks(workflow);\n    }\n    ServiceError serviceError=DeviceControllerException.errors.jobFailed(ex);\n    taskCompleter.error(_dbClient,serviceError);\n  }\n}\n", "nl": "Delete the export."}
{"code": "public NoInitialContextException(String explanation){\n  super(explanation);\n}\n", "nl": "Constructs an instance of NoInitialContextException with an explanation. All other fields are initialized to null."}
{"code": "protected void animateToNearestState(){\n  final PanelState nearestState=findNearestPanelStateFromHeight(getHeight());\n  final float displacement=getPanelHeightFromState(nearestState) - getHeight();\n  final long duration=calculateAnimationDuration(INITIAL_ANIMATION_VELOCITY_DP_PER_SECOND,displacement);\n  animatePanelToState(nearestState,StateChangeReason.SWIPE,duration);\n}\n", "nl": "Animates the Panel to its nearest state."}
{"code": "synchronized void checkThreshold(){\n  Ratio successRatio=circuit.getSuccessThreshold();\n  Ratio failureRatio=circuit.getFailureThreshold();\n  if (successRatio != null) {\n    if (bitSet.occupiedBits() == successRatio.denominator || (successRatio.ratio == 1.0 && bitSet.positiveRatio() < 1.0))     if (bitSet.positiveRatio() >= successRatio.ratio)     circuit.close();\n else     circuit.open();\n  }\n else   if (failureRatio != null) {\n    if (bitSet.occupiedBits() == failureRatio.denominator || (failureRatio.ratio == 1.0 && bitSet.negativeRatio() < 1.0))     if (bitSet.negativeRatio() >= failureRatio.ratio)     circuit.open();\n else     circuit.close();\n  }\n else {\n    if (bitSet.positiveRatio() == 1)     circuit.close();\n else     circuit.open();\n  }\n}\n", "nl": "Checks to determine if a threshold has been met and the circuit should be opened or closed. <p> If a success ratio is configured, the circuit is opened or closed after the expected number of executions based on whether the ratio was exceeded. <p> Else if a failure ratio is configured, the circuit is opened or closed after the expected number of executions based on whether the ratio was not exceeded. <p> Else when no thresholds are configured, the circuit opens or closes on a single failure or success."}
{"code": "public synchronized void channelDone(int channel){\n  if (!chBusy[channel])   throw new IllegalStateException(\"channel \" + channel + \" is not busy\");\n  chBusy[channel]=false;\n  gate.release();\n}\n", "nl": "Signal that the channel is done processing the splitter supplied tuple."}
{"code": "protected void sequence_SimpleQuantifier(ISerializationContext context,SimpleQuantifier semanticObject){\n  genericSequencer.createSequence(context,semanticObject);\n}\n", "nl": "Contexts: Quantifier returns SimpleQuantifier SimpleQuantifier returns SimpleQuantifier Constraint: ((quantifier='+' | quantifier='*' | quantifier='?') nonGreedy?='?'?)"}
{"code": "public void testBaselineParameters() throws Exception {\n  SweetSpotSimilarity sim=getSimilarity(\"text_baseline\",SweetSpotSimilarity.class);\n  ClassicSimilarity d=new ClassicSimilarity();\n  for (int i=1; i <= 6; i++) {\n    assertEquals(\"tf i=\" + i,1.5F,sim.tf(i),0.0F);\n  }\n  for (int i=6; i <= 1000; i++) {\n    assertTrue(\"tf: i=\" + i + \" : s=\"+ sim.tf(i)+ \" < d=\"+ d.tf(i),sim.tf(i) < d.tf(i));\n  }\n  assertEquals(\"norm 1 == 7\",sim.computeLengthNorm(1),sim.computeLengthNorm(7),0.0F);\n  assertEquals(\"norm 2 == 6\",sim.computeLengthNorm(1),sim.computeLengthNorm(7),0.0F);\n  assertEquals(\"norm 3\",1.00F,sim.computeLengthNorm(3),0.0F);\n  assertEquals(\"norm 4\",1.00F,sim.computeLengthNorm(4),0.0F);\n  assertEquals(\"norm 5\",1.00F,sim.computeLengthNorm(5),0.0F);\n  assertTrue(\"norm 6 too high: \" + sim.computeLengthNorm(6),sim.computeLengthNorm(6) < 1.0F);\n  assertTrue(\"norm 7 higher then norm 6\",sim.computeLengthNorm(7) < sim.computeLengthNorm(6));\n  assertEquals(\"norm 20\",0.25F,sim.computeLengthNorm(20),0.0F);\n}\n", "nl": "baseline with parameters"}
{"code": "private void dumpComplexTypeAttribute(XSComplexType type){\n  Iterator itr;\n  itr=type.iterateAttGroups();\n  while (itr.hasNext()) {\n    dumpRef((XSAttGroupDecl)itr.next());\n  }\n  itr=type.iterateDeclaredAttributeUses();\n  while (itr.hasNext()) {\n    attributeUse((XSAttributeUse)itr.next());\n  }\n}\n", "nl": "Creates node for complex type."}
{"code": "public static double computePerspectiveNearDistance(Angle fieldOfView,double distanceToObject){\n  if (fieldOfView == null) {\n    String msg=Logging.getMessage(\"nullValue.FOVIsNull\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  if (distanceToObject < 0) {\n    String msg=Logging.getMessage(\"generic.DistanceLessThanZero\");\n    Logging.logger().severe(msg);\n    throw new IllegalArgumentException(msg);\n  }\n  double tanHalfFov=fieldOfView.tanHalfAngle();\n  return distanceToObject / (2 * Math.sqrt(2 * tanHalfFov * tanHalfFov + 1));\n}\n", "nl": "Computes the maximum near clip distance for a perspective projection that avoids clipping an object at a given distance from the eye point. The given distance should specify the smallest distance between the eye and the object being viewed, but may be an approximation if an exact clip distance is not required."}
{"code": "public double worldToView(Axis axis,Number value,boolean extrapolate){\n  checkAxisBounds(axis);\n  double min=axis.getMin().doubleValue();\n  double max=axis.getMax().doubleValue();\n  double val=value.doubleValue();\n  if (!extrapolate) {\n    if (val <= min) {\n      return 0.0;\n    }\n    if (val >= max) {\n      return getShapeLength();\n    }\n  }\n  double minLog=(min > 0.0) ? Math.log10(min) : 0.0;\n  double maxLog=(max > 0.0) ? Math.log10(max) : 1.0;\n  return (Math.log10(val) - minLog) * getShapeLength() / (maxLog - minLog);\n}\n", "nl": "Converts a world (axis) coordinate value to a view (screen) coordinate value."}
{"code": "@SuppressWarnings(\"unchecked\") public Continuation(Name top,Hashtable<?,?> environment){\n  super();\n  starter=top;\n  this.environment=(Hashtable<?,?>)((environment == null) ? null : environment.clone());\n}\n", "nl": "Constructs a new instance of Continuation."}
{"code": "private void testProbability(double probability){\n  Replace replace=new Replace(probability);\n  int count=0;\n  for (int i=0; i < TestThresholds.SAMPLES; i++) {\n    Solution original=new Solution(1,0);\n    original.setVariable(0,new Subset(50,100));\n    Solution mutated=replace.evolve(new Solution[]{original})[0];\n    if (testSubset((Subset)original.getVariable(0),(Subset)mutated.getVariable(0))) {\n      count++;\n    }\n  }\n  Assert.assertEquals((double)count / TestThresholds.SAMPLES,probability,TestThresholds.VARIATION_EPS);\n}\n", "nl": "Tests if the replace mutation occurs with the specified probability."}
{"code": "private void LINK(BasicBlock block1,BasicBlock block2){\n  if (DEBUG) {\n    System.out.println(\"  Linking \" + block1 + \" with \"+ block2);\n  }\n  BasicBlock s=block2;\n  while (getSemi(getLabel(block2)) < getSemi(getLabel(getChild(s)))) {\n    if (getSize(s) + getSize(getChild(getChild(s))) >= 2 * getSize(getChild(s))) {\n      LTDominatorInfo.getInfo(getChild(s),ir).setAncestor(s);\n      LTDominatorInfo.getInfo(s,ir).setChild(getChild(getChild(s)));\n    }\n else {\n      LTDominatorInfo.getInfo(getChild(s),ir).setSize(getSize(s));\n      LTDominatorInfo.getInfo(s,ir).setAncestor(getChild(s));\n      s=getChild(s);\n    }\n  }\n  LTDominatorInfo.getInfo(s,ir).setLabel(getLabel(block2));\n  LTDominatorInfo.getInfo(block1,ir).setSize(getSize(block1) + getSize(block2));\n  if (getSize(block1) < 2 * getSize(block2)) {\n    BasicBlock tmp=s;\n    s=getChild(block1);\n    LTDominatorInfo.getInfo(block1,ir).setChild(tmp);\n  }\n  while (s != null) {\n    LTDominatorInfo.getInfo(s,ir).setAncestor(block1);\n    s=getChild(s);\n  }\n  if (DEBUG) {\n    System.out.println(\"  .... done\");\n  }\n}\n", "nl": "Adds edge (block1, block2) to the forest maintained as an auxiliary data structure.  This implementation uses path compression and results in a O(e * alpha(e,n)) complexity, where e is the number of edges in the CFG and n is the number of nodes."}
{"code": "public boolean contains(Object value,Object filter,Locale locale){\n  String filterText=(filter == null) ? null : filter.toString().trim();\n  if (StringUtils.isBlank(filterText)) {\n    return true;\n  }\n  if (value == null) {\n    return false;\n  }\n  return StringUtils.containsIgnoreCase(value.toString(),filterText);\n}\n", "nl": "Filters by contains"}
{"code": "@Override public DPState compute(Rule rule,List<HGNode> tailNodes,int i,int j,SourcePath sourcePath,Sentence sentence,Accumulator acc){\n  if (rule != null && rule.getOwner().equals(ownerID)) {\n    if (rule.getPrecomputableCost() <= Float.NEGATIVE_INFINITY) {\n      rule.setPrecomputableCost(phrase_weights,weights);\n    }\n    for (int k=0; k < phrase_weights.length; k++) {\n      acc.add(k + denseFeatureIndex,rule.getDenseFeature(k));\n    }\n    for (    String key : rule.getFeatureVector().keySet())     acc.add(key,rule.getFeatureVector().getSparse(key));\n  }\n  return null;\n}\n", "nl": "Just chain to computeFeatures(rule), since this feature doesn't use the sourcePath or sentID."}
{"code": "public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {\n  super.reset(componentManager);\n  fDoctypeName=null;\n  fDoctypePublicId=null;\n  fDoctypeSystemId=null;\n  fSeenDoctypeDecl=false;\n  fScanningDTD=false;\n  fExternalSubsetSource=null;\n  if (!fParserSettings) {\n    fNamespaceContext.reset();\n    setScannerState(SCANNER_STATE_XML_DECL);\n    setDispatcher(fXMLDeclDispatcher);\n    return;\n  }\n  try {\n    fLoadExternalDTD=componentManager.getFeature(LOAD_EXTERNAL_DTD);\n  }\n catch (  XMLConfigurationException e) {\n    fLoadExternalDTD=true;\n  }\n  try {\n    fDisallowDoctype=componentManager.getFeature(DISALLOW_DOCTYPE_DECL_FEATURE);\n  }\n catch (  XMLConfigurationException e) {\n    fDisallowDoctype=false;\n  }\n  fDTDScanner=(XMLDTDScanner)componentManager.getProperty(DTD_SCANNER);\n  try {\n    fValidationManager=(ValidationManager)componentManager.getProperty(VALIDATION_MANAGER);\n  }\n catch (  XMLConfigurationException e) {\n    fValidationManager=null;\n  }\n  try {\n    fNamespaceContext=(NamespaceContext)componentManager.getProperty(NAMESPACE_CONTEXT);\n  }\n catch (  XMLConfigurationException e) {\n  }\n  if (fNamespaceContext == null) {\n    fNamespaceContext=new NamespaceSupport();\n  }\n  fNamespaceContext.reset();\n  setScannerState(SCANNER_STATE_XML_DECL);\n  setDispatcher(fXMLDeclDispatcher);\n}\n", "nl": "Resets the component. The component can query the component manager about any features and properties that affect the operation of the component."}
{"code": "public boolean optBoolean(int index){\n  return this.optBoolean(index,false);\n}\n", "nl": "Get the optional boolean value associated with an index. It returns false if there is no value at that index, or if the value is not Boolean.TRUE or the String \"true\"."}
{"code": "@PostConstruct @Override public void init() throws ConfigException {\n  try {\n    _codeSource=new CodeSource(new URL(_path.getURL()),(Certificate[])null);\n  }\n catch (  Exception e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n  super.init();\n  getClassLoader().addURL(_path,_isScanned);\n}\n", "nl": "Initializes the loader."}
{"code": "public noscript addElement(String hashcode,String element){\n  addElementToRegistry(hashcode,element);\n  return (this);\n}\n", "nl": "Adds an Element to the element."}
{"code": "protected void parseC() throws ParseException, IOException {\n  current=reader.read();\n  skipSpaces();\n  boolean expectNumber=true;\n  for (; ; ) {\nswitch (current) {\ndefault :\n      if (expectNumber)       reportUnexpected(current);\n    return;\ncase '+':\ncase '-':\ncase '.':\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n  break;\n}\nfloat x1=parseFloat();\nskipCommaSpaces();\nfloat y1=parseFloat();\nskipCommaSpaces();\nfloat x2=parseFloat();\nskipCommaSpaces();\nfloat y2=parseFloat();\nskipCommaSpaces();\nfloat x=parseFloat();\nskipCommaSpaces();\nfloat y=parseFloat();\npathHandler.curvetoCubicAbs(x1,y1,x2,y2,x,y);\nexpectNumber=skipCommaSpaces2();\n}\n}\n", "nl": "Parses a 'C' command."}
{"code": "public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException {\n  String name=m_arg0.execute(xctxt).str();\n  int context=xctxt.getCurrentNode();\n  DTM dtm=xctxt.getDTM(context);\n  int doc=dtm.getDocument();\n  String uri=dtm.getUnparsedEntityURI(name);\n  return new XString(uri);\n}\n", "nl": "Execute the function.  The function must return a valid object."}
{"code": "public void revokeModerator(String nickname) throws XMPPException {\n  changeRole(nickname,\"participant\",null);\n}\n", "nl": "Revokes moderator privileges from another user. The occupant that loses moderator privileges will become a participant. Room administrators may revoke moderator privileges only to occupants whose affiliation is member or none. This means that an administrator is not allowed to revoke moderator privileges from other room administrators or owners."}
{"code": "public static void saveData(final AbstractSQLProvider provider,final INaviModule module,final byte[] data) throws CouldntSaveDataException {\n  Preconditions.checkNotNull(provider,\"IE01267: Provider argument can not be null\");\n  Preconditions.checkNotNull(module,\"IE01268: Module argument can not be null\");\n  Preconditions.checkNotNull(data,\"IE01269: Data argument can not be null\");\n  final CConnection connection=provider.getConnection();\n  try {\n    connection.executeUpdate(\"DELETE FROM \" + CTableNames.DATA_PARTS_TABLE + \" WHERE module_id = \"+ module.getConfiguration().getId(),true);\n  }\n catch (  final SQLException exception) {\n    throw new CouldntSaveDataException(exception);\n  }\n  final String preparedStatement=\"INSERT INTO \" + CTableNames.DATA_PARTS_TABLE + \"(module_id, part_id, data) VALUES(?, ?, ?)\";\n  try (PreparedStatement statement=provider.getConnection().getConnection().prepareStatement(preparedStatement)){\n    statement.setInt(1,module.getConfiguration().getId());\n    statement.setInt(2,0);\n    statement.setBinaryStream(3,new ByteArrayInputStream(data,0,data.length),data.length);\n    statement.execute();\n  }\n catch (  final SQLException exception) {\n    throw new CouldntSaveDataException(exception);\n  }\n}\n", "nl": "Saves the data of a module to the database."}
{"code": "public void addSource(ITLAPMOutputSource source){\n  ITLAPMOutputSource existingSource=(ITLAPMOutputSource)sources.get(source.getFullModulePath());\n  if (existingSource != null) {\n    ITLAPMOutputSourceListener[] existingListeners=existingSource.getListeners();\n    for (int i=0; i < existingListeners.length; i++) {\n      source.addListener(existingListeners[i]);\n      existingSource.removeListener(existingListeners[i]);\n    }\n  }\n else {\n    List list=(List)listenerLists.get(source.getFullModulePath());\n    if (list != null) {\n      for (Iterator it=list.iterator(); it.hasNext(); ) {\n        source.addListener((ITLAPMOutputSourceListener)it.next());\n        it.remove();\n      }\n    }\n  }\n  sources.put(source.getFullModulePath(),source);\n}\n", "nl": "Adds a source to this registry. This source will replace the most recently added source such that existingSource.getFullModulePath().equals(newSource.getFullModulePath())."}
{"code": "public NoBilingSharesDataAvailableException(){\n}\n", "nl": "Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized."}
{"code": "private CollectorUtil(){\n  instanceNotAllowed(getClass());\n}\n", "nl": "Utility classes should not be instantiated."}
{"code": "public String toString(){\n  StringBuffer sb=new StringBuffer(m_apps_host);\n  sb.append(\"{\").append(m_db_host).append(\"-\").append(m_db_name).append(\"-\").append(m_db_uid).append(\"}\");\n  return sb.toString();\n}\n", "nl": "Short String representation"}
{"code": "public boolean match(URI uri){\n  return matchNormalized(uri.normalize());\n}\n", "nl": "Returns true if the given uri matches the pattern"}
{"code": "private static void writeOp(byte[] inBuffer,int inOffset,int count,byte[] outBuffer,int write_pos,int buff_len){\n  if ((write_pos + count) <= buff_len) {\n    System.arraycopy(inBuffer,inOffset,outBuffer,write_pos,count);\n  }\n else {\n    int tillEndCount;\n    int fromStartCount;\n    tillEndCount=buff_len - write_pos;\n    fromStartCount=count - tillEndCount;\n    System.arraycopy(inBuffer,inOffset,outBuffer,write_pos,tillEndCount);\n    System.arraycopy(inBuffer,inOffset + tillEndCount,outBuffer,0,fromStartCount);\n  }\n}\n", "nl": "Utility method for write operations"}
{"code": "public Builder addJavadoc(String javadoc){\n  javadocs.add(javadoc);\n  return this;\n}\n", "nl": "Adds class level javadoc."}
{"code": "private void updateProducerDescription(){\n  StringBuffer sb=new StringBuffer();\n  sb.append(getFilter().getDescription());\n  sb.append(\" at (\");\n  sb.append(receptiveField.getCenterX());\n  sb.append(\", \");\n  sb.append(receptiveField.getCenterY());\n  sb.append(\")\");\n  description=sb.toString();\n}\n", "nl": "Update producer description."}
{"code": "synchronized public void close(){\n  this.valid=false;\n  for (  DBConnectionWrapper conn : this.connections) {\n    logger.fine(\"Closing connection to (\" + conn.getAppUser() + \", \"+ conn.getDb()+ \")\");\n    try {\n      if (conn.isInuse() && conn.getCurrentStatement() != null) {\n        logger.fine(\"Cancel pending query, connection  (\" + conn.getAppUser() + \", \"+ conn.getDb()+ \")\");\n        conn.getCurrentStatement().cancel();\n      }\n    }\n catch (    Exception ex) {\n      logger.log(Level.SEVERE,\"Exception\",ex);\n    }\n    conn.close();\n    logger.fine(\"Closed connection to (\" + conn.getAppUser() + \", \"+ conn.getDb()+ \")\");\n  }\n  this.connections.clear();\n}\n", "nl": "Close all connections"}
{"code": "public java.sql.Statement createStatement() throws SQLException {\n  checkClosed();\n  try {\n    return StatementWrapper.getInstance(this,this.pooledConnection,this.mc.createStatement());\n  }\n catch (  SQLException sqlException) {\n    checkAndFireConnectionError(sqlException);\n  }\n  return null;\n}\n", "nl": "Passes call to method on physical connection instance. Notifies listeners of any caught exceptions before re-throwing to client."}
{"code": "public CodeItem(CstMethodRef ref,DalvCode code,boolean isStatic,TypeList throwsList){\n  super(ALIGNMENT,-1);\n  if (ref == null) {\n    throw new NullPointerException(\"ref == null\");\n  }\n  if (code == null) {\n    throw new NullPointerException(\"code == null\");\n  }\n  if (throwsList == null) {\n    throw new NullPointerException(\"throwsList == null\");\n  }\n  this.ref=ref;\n  this.code=code;\n  this.isStatic=isStatic;\n  this.throwsList=throwsList;\n  this.catches=null;\n  this.debugInfo=null;\n}\n", "nl": "Constructs an instance."}
{"code": "public static Transformer<Duo<Object,Object>,Boolean> ne(){\n  return FunctionalTools.compose(eq(),not());\n}\n", "nl": "ne, not equals."}
{"code": "@Override public boolean exists(){\n  ClassLoader loader=Thread.currentThread().getContextClassLoader();\n  return loader.getResource(getTrimPath()) != null;\n}\n", "nl": "Returns true if the file exists."}
{"code": "public static boolean isTrue(boolean expression,String message){\n  if (!expression)   throw new AssertionFailedException(\"assertion failed: \" + message);\n  return expression;\n}\n", "nl": "Asserts that the given boolean is <code>true</code>. If this is not the case, some kind of unchecked exception is thrown. The given message is included in that exception, to aid debugging."}
{"code": "public static Matrix centerCorpImageview(DragImageView imageView,Bitmap bitmap){\n  float height, width;\n  int x1=0, y1=0;\n  float scale=1;\n  if (imageView.imageViewHeight / bitmap.getHeight() > imageView.imageViewWidth / bitmap.getWidth()) {\n    height=bitmap.getHeight();\n    scale=imageView.imageViewHeight / height;\n    width=imageView.imageViewWidth / scale;\n    x1=(int)((bitmap.getWidth() - width) / 2);\n    y1=0;\n  }\n else {\n    width=bitmap.getWidth();\n    scale=imageView.imageViewWidth / width;\n    height=imageView.imageViewHeight / scale;\n    y1=(int)((bitmap.getHeight() - height) / 2);\n    x1=0;\n  }\n  Bitmap cutBitmap=Bitmap.createBitmap(bitmap,x1,y1,(int)width,(int)height);\n  imageView.setImageBitmap(cutBitmap);\n  return imageView.resetMatrix();\n}\n", "nl": "help DragImageView to CENTER_CORP"}
{"code": "public static void initialize_update_sources(Context ctx){\n  if (_SOURCES != null) {\n    return;\n  }\n  _SOURCES=new ArrayList<UpdateSource>();\n  Log.v(MainActivity.TAG,\"Reading update sources...\");\n  try {\n    InputStream is=ctx.getAssets().open(\"sources.json\");\n    StringBuilder buffer=new StringBuilder();\n    BufferedReader br=new BufferedReader(new InputStreamReader(is,\"UTF-8\"));\n    String s;\n    while ((s=br.readLine()) != null) {\n      buffer.append(s);\n    }\n    JSONArray sources=new JSONArray(buffer.toString());\n    for (int i=0; i < sources.length(); ++i) {\n      String name=sources.getJSONObject(i).getString(\"name\");\n      Log.v(MainActivity.TAG,\"Reading \" + name);\n      String url=sources.getJSONObject(i).getString(\"url\");\n      JSONObject packages=sources.getJSONObject(i).optJSONObject(\"packages\");\n      if (packages == null || packages.length() == 0) {\n        throw new JSONException(\"packages missing or empty for \" + name);\n      }\n      ArrayList<UpdateSourceEntry> entries=new ArrayList<UpdateSourceEntry>();\n      Iterator<String> it=packages.keys();\n      while (it.hasNext()) {\n        String applicable_packages=it.next();\n        JSONObject entry=packages.getJSONObject(applicable_packages);\n        UpdateSourceEntry use=new UpdateSourceEntry(applicable_packages);\n        use.set_version_regexp(entry.getString(\"version\"));\n        try {\n          use.set_download_regexp(entry.getString(\"download_regexp\"));\n        }\n catch (        JSONException ignored) {\n        }\n        try {\n          use.set_download_url(entry.getString(\"download\"));\n        }\n catch (        JSONException ignored) {\n        }\n        try {\n          use.set_changelog_regexp(entry.getString(\"changelog\"));\n        }\n catch (        JSONException ignored) {\n        }\n        entries.add(use);\n      }\n      UpdateSource us=new UpdateSource(name,url,entries);\n      JSONArray conditions=sources.getJSONObject(i).optJSONArray(\"autoselect_if\");\n      if (conditions != null) {\n        List<String> autoselect_conditions=new ArrayList<String>();\n        for (int j=0; j < conditions.length(); ++j) {\n          autoselect_conditions.add(conditions.getString(j));\n        }\n        if (autoselect_conditions.size() > 0) {\n          us.set_autoselect_conditions(autoselect_conditions);\n        }\n      }\n      int delay=sources.getJSONObject(i).optInt(\"request_delay\",0);\n      if (delay > 0) {\n        us.set_request_delay(delay);\n      }\n      _SOURCES.add(us);\n    }\n  }\n catch (  IOException e) {\n    Log.e(MainActivity.TAG,\"Could not open sources.json!\",e);\n  }\ncatch (  JSONException e) {\n    Log.e(MainActivity.TAG,\"sources.json seems to be malformed!\",e);\n  }\n}\n", "nl": "Initializes the update sources by reading the ones available in sources.json. They are kept in memory in order to avoid looking them up in the assets every time."}
{"code": "private IRuntimeClasspathEntry[] resolveClasspathEntries(List<IClasspathEntry> classpathEntries) throws CoreException {\n  LinkedHashSet<IRuntimeClasspathEntry> runtimeClasspathEntries=new LinkedHashSet<IRuntimeClasspathEntry>();\n  for (  IClasspathEntry classpathEntry : classpathEntries) {\n    if (classpathEntry.getEntryKind() == IClasspathEntry.CPE_PROJECT) {\n      String projectName=classpathEntry.getPath().lastSegment();\n      IJavaProject theproject=JavaProjectUtilities.findJavaProject(projectName);\n      IRuntimeClasspathEntry projectEntry=JavaRuntime.newProjectRuntimeClasspathEntry(theproject);\n      runtimeClasspathEntries.add(projectEntry);\n      runtimeClasspathEntries.addAll(dependenciesForProject(theproject));\n    }\n else {\n      runtimeClasspathEntries.add(JavaRuntime.newArchiveRuntimeClasspathEntry(classpathEntry.getPath()));\n    }\n  }\n  return runtimeClasspathEntries.toArray(NO_ENTRIES);\n}\n", "nl": "Given a list of IClasspathEntry, produce an array of IRuntimeClasspathEntry based on that list."}
{"code": "public void redraw(){\n  if (Double.parseDouble(tfRectangle1X.getText()) != rectangle1.getX()) {\n    rectangle1.setX(Double.parseDouble(tfRectangle1X.getText()));\n  }\n  if (Double.parseDouble(tfRectangle1Y.getText()) != rectangle1.getY()) {\n    rectangle1.setY(Double.parseDouble(tfRectangle1Y.getText()));\n  }\n  if (Double.parseDouble(tfRectangle1Width.getText()) != rectangle1.getWidth()) {\n    rectangle1.setWidth(Double.parseDouble(tfRectangle1Width.getText()));\n  }\n  if (Double.parseDouble(tfRectangle1Height.getText()) != rectangle1.getHeight()) {\n    rectangle1.setHeight(Double.parseDouble(tfRectangle1Height.getText()));\n  }\n  if (Double.parseDouble(tfRectangle2X.getText()) != rectangle2.getX()) {\n    rectangle2.setX(Double.parseDouble(tfRectangle2X.getText()));\n  }\n  if (Double.parseDouble(tfRectangle2Y.getText()) != rectangle2.getY()) {\n    rectangle2.setY(Double.parseDouble(tfRectangle2Y.getText()));\n  }\n  if (Double.parseDouble(tfRectangle2Width.getText()) != rectangle2.getWidth()) {\n    rectangle2.setWidth(Double.parseDouble(tfRectangle2Width.getText()));\n  }\n  if (Double.parseDouble(tfRectangle2Height.getText()) != rectangle2.getHeight()) {\n    rectangle2.setHeight(Double.parseDouble(tfRectangle2Height.getText()));\n  }\n}\n", "nl": "Set retangles to text field data"}
{"code": "public static void addSaslMech(String mech){\n  if (!defaultMechs.contains(mech)) {\n    defaultMechs.add(mech);\n  }\n}\n", "nl": "Add a SASL mechanism to the list to be used."}
{"code": "public void enable() throws IOException {\nsynchronized (optOutLock) {\n    if (isOptOut()) {\n      config.getNode(\"mcstats.opt-out\").setValue(false);\n      configurationLoader.save(config);\n    }\n    if (task == null) {\n      start();\n    }\n  }\n}\n", "nl": "Enables metrics for the server by setting \"opt-out\" to false in the config file and starting the metrics task."}
{"code": "public void testGetFormat(){\n  byte[] key=new byte[]{1,2,3,4,5};\n  String algorithm=\"Algorithm\";\n  SecretKeySpec ks=new SecretKeySpec(key,algorithm);\n  assertTrue(\"The returned value is not \\\"RAW\\\".\",ks.getFormat() == \"RAW\");\n}\n", "nl": "getFormat() method testing. Tests that returned value is \"RAW\"."}
{"code": "public static void notEmpty(Object[] arr,String name){\n  notNull(arr,name);\n  if (arr.length == 0)   throw new IllegalArgumentException(INVALID_ARG_MSG_PREFIX + name + NOT_EMPTY_SUFFIX);\n}\n", "nl": "Checks that given array is not empty."}
{"code": "public void invokeStatic(final Type owner,final Method method){\n  invokeInsn(Opcodes.INVOKESTATIC,owner,method,false);\n}\n", "nl": "Generates the instruction to invoke a static method."}
{"code": "public CommentedLineReader(Reader in){\n  super(in);\n}\n", "nl": "Constructs a buffered reader that ignores lines starting with the #  character."}
{"code": "public IssueCollector(IssueFilter issueFilter){\n  this.issueFilter=Objects.requireNonNull(issueFilter);\n  this.collectedIssues=new LinkedList<>();\n}\n", "nl": "Creates a new issue collector instance that accepts only those issues that match the given issue filter."}
{"code": "public static int[] copyOfRange(int[] original,int start,int end){\n  if (start <= end) {\n    if (original.length >= start && 0 <= start) {\n      int length=end - start;\n      int copyLength=Math.min(length,original.length - start);\n      int[] copy=new int[length];\n      System.arraycopy(original,start,copy,0,copyLength);\n      return copy;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  throw new IllegalArgumentException();\n}\n", "nl": "Copies elements in original array to a new array, from index start(inclusive) to end(exclusive). The first element (if any) in the new array is original[from], and other elements in the new array are in the original order. The padding value whose index is bigger than or equal to original.length - start is 0."}
{"code": "public void loadAndPopulateStaticAspects(NBTTagCompound nbt,long aspectSeed){\n  if (nbt != null && nbt.hasKey(\"entries\")) {\n    this.loadStaticAspects(nbt);\n    this.updateAspects(aspectSeed);\n  }\n else {\n    this.generateStaticAspects(aspectSeed);\n  }\n}\n", "nl": "Loads all static aspects from an NBT and complements any missing data"}
{"code": "private void upgradeLeaf(TableEntry10 table,TableUpgrade upgradeTable,Page10 page) throws IOException {\n  try (ReadStream is=openRead(page.segment().address(),page.segment().length())){\n    is.position(page.address());\n    byte[] minKey=new byte[table.keyLength()];\n    byte[] maxKey=new byte[table.keyLength()];\n    is.read(minKey,0,minKey.length);\n    is.read(maxKey,0,maxKey.length);\n    int blocks=BitsUtil.readInt16(is);\n    for (int i=0; i < blocks; i++) {\n      upgradeLeafBlock(is,table,upgradeTable,page);\n    }\n  }\n }\n", "nl": "Upgrade a table page."}
{"code": "private static double[] reparameterize(ArrayList<Point2D.Double> d,int first,int last,double[] u,Point2D.Double[] bezCurve){\n  int nPts=last - first + 1;\n  int i;\n  double[] uPrime;\n  uPrime=new double[nPts];\n  for (i=first; i <= last; i++) {\n    uPrime[i - first]=newtonRaphsonRootFind(bezCurve,d.get(i),u[i - first]);\n  }\n  return (uPrime);\n}\n", "nl": "Given set of points and their parameterization, try to find a better parameterization."}
{"code": "@Override public void send(DatagramPacket p) throws IOException {\n  socketDelegate.send(p);\n}\n", "nl": "Sends a datagram packet from this socket. The <tt>DatagramPacket</tt> includes information indicating the data to be sent, its length, the IP address of the remote host, and the port number on the remote host."}
{"code": "public CryptoException(){\n  super();\n}\n", "nl": "Creates a new CryptoException."}
{"code": "@POST @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Path(\"/{id}/protection/snapshot-sessions/{sid}/restore\") @CheckPermission(roles={Role.TENANT_ADMIN},acls={ACL.ANY}) public TaskResourceRep restoreConsistencyGroupSnapshotSession(@PathParam(\"id\") final URI consistencyGroupId,@PathParam(\"sid\") final URI snapSessionId){\n  final BlockConsistencyGroup consistencyGroup=(BlockConsistencyGroup)queryResource(consistencyGroupId);\n  final BlockSnapshotSession snapSession=(BlockSnapshotSession)queryResource(snapSessionId);\n  verifySnapshotSessionIsForConsistencyGroup(snapSession,consistencyGroup);\n  return getSnapshotSessionManager().restoreSnapshotSession(snapSessionId);\n}\n", "nl": "Restores the data on the array snapshot point-in-time copy represented by the BlockSnapshotSession instance with the passed id, to the snapshot session source object."}
{"code": "public void initializeLogging(){\n  LogWrapper logWrapper=new LogWrapper();\n  Log.setLogNode(logWrapper);\n  MessageOnlyLogFilter msgFilter=new MessageOnlyLogFilter();\n  logWrapper.setNext(msgFilter);\n  LogFragment logFragment=(LogFragment)getSupportFragmentManager().findFragmentById(R.id.log_fragment);\n  msgFilter.setNext(logFragment.getLogView());\n}\n", "nl": "Set up targets to receive log data"}
{"code": "public Vertex synthesize(Vertex source){\n  log(\"synthesize\",Level.FINE);\n  return synthesizeResponse(null,null,null,false,null,source.getNetwork());\n}\n", "nl": "Self API for synthesizing a new response."}
{"code": "public AEADBadTagException(){\n  super();\n}\n", "nl": "Constructs a AEADBadTagException with no detail message."}
{"code": "public EntryStream<K,V> filterKeyValue(BiPredicate<? super K,? super V> predicate){\n  return filter(null);\n}\n", "nl": "Returns a stream consisting of the elements of this stream which elements match the given predicate. <p> This is an <a href=\"package-summary.html#StreamOps\">intermediate</a> operation."}
{"code": "void draw(Graphics2D g,int x,int y){\n  sprite.draw(g,x + xOffset,y + yOffset);\n}\n", "nl": "Draw the sprite at the EntityView's location."}
{"code": "public ConfigSetter(Class<?> configInterface,Method method){\n  super(configInterface,method);\n  Method getMethod=ConfigUtil.getGetMethod(configInterface,method);\n  Preconditions.checkNotNullArgument(getMethod,String.format(\"Cannot find getter for config \\\"%s\\\" property \\\"%s\\\"\",configInterface.getSimpleName(),getPropertyName()));\n  sourceType=ConfigUtil.getSourceType(configInterface,method);\n  if (!String.class.equals(ConfigUtil.getMethodType(method)))   stringifier=TypeStringify.getInstance(configInterface,method);\n}\n", "nl": "Create a new ConfigSetter instance."}
{"code": "public ServiceStateException(String message,ApplicationExceptionBean bean){\n  super(message,bean);\n}\n", "nl": "Constructs a new exception with the specified detail message and bean for JAX-WS exception serialization."}
{"code": "public CpcRunner(Graph graph,Parameters params,KnowledgeBoxModel knowledgeBoxModel){\n  super(graph,params,knowledgeBoxModel);\n}\n", "nl": "Constucts a wrapper for the given EdgeListGraph."}
{"code": "static Instruction makeMoveInstruction(IR ir,Register r1,ConstantOperand c){\n  Operator mv=IRTools.getMoveOp(c.getType());\n  RegisterOperand o1=new RegisterOperand(r1,c.getType());\n  Operand o2=c.copy();\n  Instruction s=Move.create(mv,o1,o2);\n  s.setSourcePosition(SSA_SYNTH_BCI,ir.getGc().getInlineSequence());\n  return s;\n}\n", "nl": "Create a move instruction r1 := c.<p> !!TODO: put this functionality elsewhere."}
{"code": "public void test_munge03(){\n  assertEquals(\"test_context\",GangliaMunge.munge(\"test context\"));\n}\n", "nl": "Note: The ganglia UI messes up when there is whitespace in a metric name."}
{"code": "public Uniform(RandomEngine randomGenerator){\n  this(0,1,randomGenerator);\n}\n", "nl": "Constructs a uniform distribution with <tt>min=0.0</tt> and <tt>max=1.0</tt>."}
{"code": "public void testGeneratingJsonSchema() throws Exception {\n  ObjectMapper mapper=new ObjectMapper();\n  JsonSchema jsonSchema=mapper.generateJsonSchema(SimpleBean.class);\n  assertNotNull(jsonSchema);\n  assertTrue(jsonSchema.equals(jsonSchema));\n  assertFalse(jsonSchema.equals(null));\n  assertFalse(jsonSchema.equals(\"foo\"));\n  assertNotNull(jsonSchema.toString());\n  assertNotNull(JsonSchema.getDefaultSchemaNode());\n  ObjectNode root=jsonSchema.getSchemaNode();\n  assertEquals(\"object\",root.get(\"type\").asText());\n  assertEquals(false,root.path(\"required\").getBooleanValue());\n  JsonNode propertiesSchema=root.get(\"properties\");\n  assertNotNull(propertiesSchema);\n  JsonNode property1Schema=propertiesSchema.get(\"property1\");\n  assertNotNull(property1Schema);\n  assertEquals(\"integer\",property1Schema.get(\"type\").asText());\n  assertEquals(false,property1Schema.path(\"required\").getBooleanValue());\n  JsonNode property2Schema=propertiesSchema.get(\"property2\");\n  assertNotNull(property2Schema);\n  assertEquals(\"string\",property2Schema.get(\"type\").asText());\n  assertEquals(false,property2Schema.path(\"required\").getBooleanValue());\n  JsonNode property3Schema=propertiesSchema.get(\"property3\");\n  assertNotNull(property3Schema);\n  assertEquals(\"array\",property3Schema.get(\"type\").asText());\n  assertEquals(false,property3Schema.path(\"required\").getBooleanValue());\n  assertEquals(\"string\",property3Schema.get(\"items\").get(\"type\").asText());\n  JsonNode property4Schema=propertiesSchema.get(\"property4\");\n  assertNotNull(property4Schema);\n  assertEquals(\"array\",property4Schema.get(\"type\").asText());\n  assertEquals(false,property4Schema.path(\"required\").getBooleanValue());\n  assertEquals(\"number\",property4Schema.get(\"items\").get(\"type\").asText());\n}\n", "nl": "tests generating json-schema stuff."}
{"code": "private void init(DerValue encoding) throws Asn1Exception, KrbApErrException, IOException {\n  if (((encoding.getTag() & (byte)(0x1F)) != Krb5.KRB_AP_REP) || (encoding.isApplication() != true) || (encoding.isConstructed() != true)) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  DerValue der=encoding.getData().getDerValue();\n  if (der.getTag() != DerValue.tag_Sequence) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  DerValue subDer=der.getData().getDerValue();\n  if ((subDer.getTag() & (byte)0x1F) != (byte)0x00) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  pvno=subDer.getData().getBigInteger().intValue();\n  if (pvno != Krb5.PVNO) {\n    throw new KrbApErrException(Krb5.KRB_AP_ERR_BADVERSION);\n  }\n  subDer=der.getData().getDerValue();\n  if ((subDer.getTag() & (byte)0x1F) != (byte)0x01) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n  msgType=subDer.getData().getBigInteger().intValue();\n  if (msgType != Krb5.KRB_AP_REP) {\n    throw new KrbApErrException(Krb5.KRB_AP_ERR_MSG_TYPE);\n  }\n  encPart=EncryptedData.parse(der.getData(),(byte)0x02,false);\n  if (der.getData().available() > 0) {\n    throw new Asn1Exception(Krb5.ASN1_BAD_ID);\n  }\n}\n", "nl": "Initializes an APRep object."}
{"code": "static public void assertEquals(String message,boolean expected,boolean actual){\n  assertEquals(message,new Boolean(expected),new Boolean(actual));\n}\n", "nl": "Asserts that two booleans are equal. If they are not an AssertionFailedError is thrown with the given message."}
{"code": "public void testFilteredClassifier(){\n  try {\n    Instances data=getFilteredClassifierData();\n    for (int i=0; i < data.numAttributes(); i++) {\n      if (data.classIndex() == i)       continue;\n      if (data.attribute(i).isNominal()) {\n        ((MakeIndicator)m_FilteredClassifier.getFilter()).setAttributeIndex(\"\" + (i + 1));\n        break;\n      }\n    }\n  }\n catch (  Exception e) {\n    fail(\"Problem setting up test for FilteredClassifier: \" + e.toString());\n  }\n  super.testFilteredClassifier();\n}\n", "nl": "tests the filter in conjunction with the FilteredClassifier"}
{"code": "public synchronized boolean hasSectionToday(){\n  try {\n    final Query query=new Query().addSort(Keys.OBJECT_ID,SortDirection.DESCENDING).setCurrentPageNum(1).setPageSize(1);\n    query.setFilter(new PropertyFilter(Article.ARTICLE_TYPE,FilterOperator.EQUAL,Article.ARTICLE_TYPE_C_JOURNAL_SECTION));\n    final JSONObject result=articleRepository.get(query);\n    final List<JSONObject> journals=CollectionUtils.<JSONObject>jsonArrayToList(result.optJSONArray(Keys.RESULTS));\n    if (journals.isEmpty()) {\n      return false;\n    }\n    final JSONObject maybeToday=journals.get(0);\n    final long created=maybeToday.optLong(Article.ARTICLE_CREATE_TIME);\n    return DateUtils.isSameDay(new Date(created),new Date());\n  }\n catch (  final RepositoryException e) {\n    LOGGER.log(Level.ERROR,\"Check section generated failed\",e);\n    return false;\n  }\n}\n", "nl": "Section generated today?"}
{"code": "public List<NamedRelatedResourceRep> listByConsistencyGroup(URI consistencyGroupId){\n  return getList(getByConsistencyGroupUrl(),consistencyGroupId);\n}\n", "nl": "Lists the block snapshots for a consistency group by ID. <p> API Call: <tt>GET /block/consistency-groups/{consistencyGroupId}/protection/snapshots</tt>"}
{"code": "private void returnData(Object ret){\n  if (myHost != null) {\n    myHost.returnData(ret);\n  }\n}\n", "nl": "Used to communicate a return object from a plugin tool to the main Whitebox user-interface."}
{"code": "protected void countProximityPosition(int i){\n  if (i < m_proximityPositions.length)   m_proximityPositions[i]--;\n}\n", "nl": "Count backwards one proximity position."}
{"code": "public final int read(byte b[],int off,int len){\n  if (len > buf.length - position) {\n    len=buf.length - position;\n  }\n  for (int i=0; i < len; i++) {\n    b[off + i]=buf[position++];\n  }\n  return len;\n}\n", "nl": "Reads up to <code>len</code> bytes of data from the contained input stream into an array of bytes.  An attempt is made to read as many as <code>len</code> bytes, but a smaller number may be read, possibly zero. The number of bytes actually read is returned as an integer. <p> This method blocks until input data is available, end of file is detected, or an exception is thrown. <p> If <code>len</code> is zero, then no bytes are read and <code>0</code> is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value <code>-1</code> is returned; otherwise, at least one byte is read and stored into <code>b</code>. <p> The first byte read is stored into element <code>b[off]</code>, the next one into <code>b[off+1]</code>, and so on. The number of bytes read is, at most, equal to <code>len</code>. Let <i>k</i> be the number of bytes actually read; these bytes will be stored in elements <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>, leaving elements <code>b[off+</code><i>k</i><code>]</code> through <code>b[off+len-1]</code> unaffected. <p> In every case, elements <code>b[0]</code> through <code>b[off]</code> and elements <code>b[off+len]</code> through <code>b[b.length-1]</code> are unaffected."}
{"code": "protected void startNode(Node node) throws org.xml.sax.SAXException {\n  if (node instanceof Locator) {\n    Locator loc=(Locator)node;\n    fLocator.setColumnNumber(loc.getColumnNumber());\n    fLocator.setLineNumber(loc.getLineNumber());\n    fLocator.setPublicId(loc.getPublicId());\n    fLocator.setSystemId(loc.getSystemId());\n  }\n else {\n    fLocator.setColumnNumber(0);\n    fLocator.setLineNumber(0);\n  }\nswitch (node.getNodeType()) {\ncase Node.DOCUMENT_TYPE_NODE:\n    serializeDocType((DocumentType)node,true);\n  break;\ncase Node.COMMENT_NODE:\nserializeComment((Comment)node);\nbreak;\ncase Node.DOCUMENT_FRAGMENT_NODE:\nbreak;\ncase Node.DOCUMENT_NODE:\nbreak;\ncase Node.ELEMENT_NODE:\nserializeElement((Element)node,true);\nbreak;\ncase Node.PROCESSING_INSTRUCTION_NODE:\nserializePI((ProcessingInstruction)node);\nbreak;\ncase Node.CDATA_SECTION_NODE:\nserializeCDATASection((CDATASection)node);\nbreak;\ncase Node.TEXT_NODE:\nserializeText((Text)node);\nbreak;\ncase Node.ENTITY_REFERENCE_NODE:\nserializeEntityReference((EntityReference)node,true);\nbreak;\ndefault :\n}\n}\n", "nl": "Start processing given node"}
{"code": "protected ExpandedItem(Parcel parcel){\n  ParcelInfo parcelInfo=Concierge.receiveParcel(parcel);\n  int parcelableVersion=parcelInfo.getParcelVersion();\n  if (parcelableVersion >= Build.CM_VERSION_CODES.APRICOT) {\n    if (parcel.readInt() != 0) {\n      onClickPendingIntent=PendingIntent.CREATOR.createFromParcel(parcel);\n    }\n    if (parcel.readInt() != 0) {\n      itemTitle=parcel.readString();\n    }\n    if (parcel.readInt() != 0) {\n      itemSummary=parcel.readString();\n    }\n    itemDrawableResourceId=parcel.readInt();\n  }\n  if (parcelableVersion >= Build.CM_VERSION_CODES.BOYSENBERRY) {\n    if (parcel.readInt() != 0) {\n      itemBitmapResource=Bitmap.CREATOR.createFromParcel(parcel);\n    }\n  }\n  parcelInfo.complete();\n}\n", "nl": "Unflatten the ExpandedItem from a parcel."}
{"code": "public void addObserveRelation(ObserveRelation relation){\n  relations.add(relation);\n}\n", "nl": "Adds the specified observe relation."}
{"code": "public StateContext<S,E> postTransition(StateContext<S,E> stateContext){\n  for (  StateMachineInterceptor<S,E> interceptor : interceptors) {\n    if ((stateContext=interceptor.postTransition(stateContext)) == null) {\n      break;\n    }\n  }\n  return stateContext;\n}\n", "nl": "Post transition."}
{"code": "public void clear(){\n  while (this.positions.size() > 0 || this.controlPoints.size() > 0) {\n    this.removeControlPoint();\n  }\n  this.shapeCenterPosition=null;\n  this.shapeOrientation=null;\n  this.shapeRectangle=null;\n}\n", "nl": "Removes all positions from the shape, clear attributes."}
{"code": "protected String valueToString(ValueType value){\n  if (value == null) {\n    return \"null\";\n  }\n  return value.toString();\n}\n", "nl": "Subclasses may override this if they want to do something special to convert Value objects to Strings. By default, we just call toString() on the values."}
{"code": "Vset checkBlockStatement(Environment env,Context ctx,Vset vset,Hashtable exp){\n  return check(env,ctx,vset,exp);\n}\n", "nl": "This is called in contexts where declarations are valid."}
{"code": "private void postPlugin(boolean isPing) throws IOException {\n  PluginDescriptionFile description=plugin.getDescription();\n  String pluginName=description.getName();\n  boolean onlineMode=Bukkit.getServer().getOnlineMode();\n  String pluginVersion=description.getVersion();\n  String serverVersion=Bukkit.getVersion();\n  int playersOnline=this.getOnlinePlayers();\n  StringBuilder json=new StringBuilder(1024);\n  json.append('{');\n  appendJSONPair(json,\"guid\",guid);\n  appendJSONPair(json,\"plugin_version\",pluginVersion);\n  appendJSONPair(json,\"server_version\",serverVersion);\n  appendJSONPair(json,\"players_online\",Integer.toString(playersOnline));\n  String osname=System.getProperty(\"os.name\");\n  String osarch=System.getProperty(\"os.arch\");\n  String osversion=System.getProperty(\"os.version\");\n  String java_version=System.getProperty(\"java.version\");\n  int coreCount=Runtime.getRuntime().availableProcessors();\n  if (osarch.equals(\"amd64\")) {\n    osarch=\"x86_64\";\n  }\n  appendJSONPair(json,\"osname\",osname);\n  appendJSONPair(json,\"osarch\",osarch);\n  appendJSONPair(json,\"osversion\",osversion);\n  appendJSONPair(json,\"cores\",Integer.toString(coreCount));\n  appendJSONPair(json,\"auth_mode\",onlineMode ? \"1\" : \"0\");\n  appendJSONPair(json,\"java_version\",java_version);\n  if (isPing) {\n    appendJSONPair(json,\"ping\",\"1\");\n  }\n  json.append('}');\n  URL url=new URL(BASE_URL + String.format(REPORT_URL,urlEncode(pluginName)));\n  URLConnection connection;\n  if (isMineshafterPresent()) {\n    connection=url.openConnection(Proxy.NO_PROXY);\n  }\n else {\n    connection=url.openConnection();\n  }\n  byte[] uncompressed=json.toString().getBytes();\n  byte[] compressed=gzip(json.toString());\n  connection.addRequestProperty(\"User-Agent\",\"MCStats/\" + REVISION);\n  connection.addRequestProperty(\"Content-Type\",\"application/json\");\n  connection.addRequestProperty(\"Content-Encoding\",\"gzip\");\n  connection.addRequestProperty(\"Content-Length\",Integer.toString(compressed.length));\n  connection.addRequestProperty(\"Accept\",\"application/json\");\n  connection.addRequestProperty(\"Connection\",\"close\");\n  connection.setDoOutput(true);\n  if (debug) {\n    System.out.println(\"[Metrics] Prepared request for \" + pluginName + \" uncompressed=\"+ uncompressed.length+ \" compressed=\"+ compressed.length);\n  }\n  OutputStream os=connection.getOutputStream();\n  os.write(compressed);\n  os.flush();\n  final BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));\n  String response=reader.readLine();\n  os.close();\n  reader.close();\n  if (response == null || response.startsWith(\"ERR\") || response.startsWith(\"7\")) {\n    if (response == null) {\n      response=\"null\";\n    }\n else     if (response.startsWith(\"7\")) {\n      response=response.substring(response.startsWith(\"7,\") ? 2 : 1);\n    }\n    throw new IOException(response);\n  }\n}\n", "nl": "Generic method that posts a plugin to the metrics website"}
{"code": "private void debugReflection(String msg){\n  if (debug) {\n    checker.message(javax.tools.Diagnostic.Kind.NOTE,MSG_PREFEX_REFLECTION + msg);\n  }\n}\n", "nl": "Reports debug information about the reflection resolution iff the corresponding debug flag is set"}
{"code": "public String serialize(){\n  return serialize(CUR_VERSION);\n}\n", "nl": "Serialize the DLSN into base64 encoded string."}
{"code": "public void write(CDATA cdata) throws SAXException {\n  String text=cdata.getText();\n  if (lexicalHandler != null) {\n    lexicalHandler.startCDATA();\n    write(text);\n    lexicalHandler.endCDATA();\n  }\n else {\n    write(text);\n  }\n}\n", "nl": "Generates SAX events for the given CDATA"}
{"code": "public Builder deleteMembers(){\n  deleteFields.add(\"members\");\n  return this;\n}\n", "nl": "deletes all group members of a existing group"}
{"code": "public void removeModel(ModelRenderer model){\n  models.remove(model);\n  modelBaseRot.remove(model);\n}\n", "nl": "Removes the given model from the Bone. Always detach the model before adding it to another Bone. The best thing however is to just keep the model to one bone."}
{"code": "public void update(){\n  checkPermission(Permission.MANAGE_ROLES);\n  checkPosition();\n  JSONObject frame=getFrame();\n  if (name != null)   frame.put(\"name\",name);\n  if (color >= 0)   frame.put(\"color\",color);\n  if (grouped != null)   frame.put(\"hoist\",grouped.booleanValue());\n  if (mentionable != null)   frame.put(\"mentionable\",mentionable.booleanValue());\n  update(frame);\n}\n", "nl": "This method will apply all accumulated changes received by setters"}
{"code": "Vector processSIMPLEPATTERNLIST(StylesheetHandler handler,String uri,String name,String rawName,String value,ElemTemplateElement owner) throws org.xml.sax.SAXException {\n  try {\n    StringTokenizer tokenizer=new StringTokenizer(value,\" \\t\\n\\r\\f\");\n    int nPatterns=tokenizer.countTokens();\n    Vector patterns=new Vector(nPatterns);\n    for (int i=0; i < nPatterns; i++) {\n      XPath pattern=handler.createMatchPatternXPath(tokenizer.nextToken(),owner);\n      patterns.addElement(pattern);\n    }\n    return patterns;\n  }\n catch (  TransformerException te) {\n    throw new org.xml.sax.SAXException(te);\n  }\n}\n", "nl": "Process an attribute string of type T_SIMPLEPATTERNLIST into a vector of XPath match patterns."}
{"code": "public Deck subdeck(int low,int high){\n  Deck sub=new Deck(high - low + 1);\n  for (int i=0; i < sub.cards.length; i++) {\n    sub.cards[i]=this.cards[low + i];\n  }\n  return sub;\n}\n", "nl": "Returns a subset of the cards in the deck."}
{"code": "public void readBinary(BinaryRawReader reader){\n  items=new TreeMap<>();\n  int count=reader.readInt();\n  for (int i=0; i < count; i++)   items.put(reader.readString(),reader.readByteArray());\n  staticObjects=reader.readByteArray();\n  timeout=reader.readInt();\n  lockNodeId=reader.readUuid();\n  lockId=reader.readLong();\n  lockTime=reader.readTimestamp();\n}\n", "nl": "Reads from a binary reader."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:55:28.977 -0500\",hash_original_method=\"C99C4952C168074F3FBA7AB2C1372665\",hash_generated_method=\"F33ED7C3E1DB2DC82243B965350B6674\") public boolean isMessagePartOfTransaction(SIPMessage messageToTest){\n  ViaList viaHeaders=messageToTest.getViaHeaders();\n  boolean transactionMatches;\n  String messageBranch=((Via)viaHeaders.getFirst()).getBranch();\n  boolean rfc3261Compliant=getBranch() != null && messageBranch != null && getBranch().toLowerCase().startsWith(SIPConstants.BRANCH_MAGIC_COOKIE_LOWER_CASE) && messageBranch.toLowerCase().startsWith(SIPConstants.BRANCH_MAGIC_COOKIE_LOWER_CASE);\n  transactionMatches=false;\n  if (TransactionState.COMPLETED == this.getState()) {\n    if (rfc3261Compliant) {\n      transactionMatches=getBranch().equalsIgnoreCase(((Via)viaHeaders.getFirst()).getBranch()) && getMethod().equals(messageToTest.getCSeq().getMethod());\n    }\n else {\n      transactionMatches=getBranch().equals(messageToTest.getTransactionId());\n    }\n  }\n else   if (!isTerminated()) {\n    if (rfc3261Compliant) {\n      if (viaHeaders != null) {\n        if (getBranch().equalsIgnoreCase(((Via)viaHeaders.getFirst()).getBranch())) {\n          transactionMatches=getOriginalRequest().getCSeq().getMethod().equals(messageToTest.getCSeq().getMethod());\n        }\n      }\n    }\n else {\n      if (getBranch() != null) {\n        transactionMatches=getBranch().equalsIgnoreCase(messageToTest.getTransactionId());\n      }\n else {\n        transactionMatches=getOriginalRequest().getTransactionId().equalsIgnoreCase(messageToTest.getTransactionId());\n      }\n    }\n  }\n  return transactionMatches;\n}\n", "nl": "Deterines if the message is a part of this transaction."}
{"code": "public ParameterRef newParameterRef(Type paramType,int number){\n  return new ParameterRef(paramType,number);\n}\n", "nl": "Constructs a ParameterRef(SootMethod, int) grammar chunk."}
{"code": "public void storeKnownDevices(){\n  StringBuffer listKnownDevices=new StringBuffer();\n  boolean first=true;\n  for (  String id : knownDevices) {\n    if (id.length() > 0) {\n      if (!first)       listKnownDevices=listKnownDevices.append(\",\");\n else       first=false;\n      listKnownDevices=listKnownDevices.append(id);\n    }\n  }\n  SharedPreferences.Editor editor=settings.edit();\n  editor.putString(\"knownDevices\",listKnownDevices.toString());\n  editor.commit();\n}\n", "nl": "method to store the current status of my known devices. this info will be used to restore status."}
{"code": "private static int decode4to3(final byte[] source,final int srcOffset,final byte[] destination,final int destOffset,final int options){\n  byte[] DECODABET=Base64.getDecodabet(options);\n  if (source[srcOffset + 2] == Base64.EQUALS_SIGN) {\n    int outBuff=(DECODABET[source[srcOffset]] & 0xFF) << 18 | (DECODABET[source[srcOffset + 1]] & 0xFF) << 12;\n    destination[destOffset]=(byte)(outBuff >>> 16);\n    return 1;\n  }\n else   if (source[srcOffset + 3] == Base64.EQUALS_SIGN) {\n    int outBuff=(DECODABET[source[srcOffset]] & 0xFF) << 18 | (DECODABET[source[srcOffset + 1]] & 0xFF) << 12 | (DECODABET[source[srcOffset + 2]] & 0xFF) << 6;\n    destination[destOffset]=(byte)(outBuff >>> 16);\n    destination[destOffset + 1]=(byte)(outBuff >>> 8);\n    return 2;\n  }\n else {\n    try {\n      int outBuff=(DECODABET[source[srcOffset]] & 0xFF) << 18 | (DECODABET[source[srcOffset + 1]] & 0xFF) << 12 | (DECODABET[source[srcOffset + 2]] & 0xFF) << 6 | DECODABET[source[srcOffset + 3]] & 0xFF;\n      destination[destOffset]=(byte)(outBuff >> 16);\n      destination[destOffset + 1]=(byte)(outBuff >> 8);\n      destination[destOffset + 2]=(byte)outBuff;\n      return 3;\n    }\n catch (    Exception e) {\n      System.out.println(\"\" + source[srcOffset] + \": \"+ DECODABET[source[srcOffset]]);\n      System.out.println(\"\" + source[srcOffset + 1] + \": \"+ DECODABET[source[srcOffset + 1]]);\n      System.out.println(\"\" + source[srcOffset + 2] + \": \"+ DECODABET[source[srcOffset + 2]]);\n      System.out.println(\"\" + source[srcOffset + 3] + \": \"+ DECODABET[source[srcOffset + 3]]);\n      return -1;\n    }\n  }\n}\n", "nl": "Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to accommodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var> + 3 for the <var>destination</var> array. This method returns the actual number of bytes that were converted from the Base64 encoding. <p>This is the lowest level of the decoding methods with all possible parameters.</p>"}
{"code": "private static String generateSPNativeGuidFromIndication(Hashtable<String,String> cimIndication,String poolNativeId_IndicationAttribute){\n  String serialNumber=null;\n  String deviceType=null;\n  String poolNativeId=null;\n  String spInstanceId=null;\n  try {\n    spInstanceId=cimIndication.get(poolNativeId_IndicationAttribute);\n    String[] individualIds=spInstanceId.split(Constants.PATH_DELIMITER_REGEX);\n    try {\n      serialNumber=individualIds[1];\n      poolNativeId=spInstanceId.substring(spInstanceId.indexOf(serialNumber) + serialNumber.length() + 1,spInstanceId.length());\n    }\n catch (    Exception e) {\n      _logger.error(\"Format of SourceInstanceModelPathSPInstanceID is not correct {}\",spInstanceId);\n      return null;\n    }\n    String modelPathCompositeId=cimIndication.get(CIMConstants.SOURCE_INSTANCE_MODEL_PATH_COMPOSITE_ID);\n    if (modelPathCompositeId != null && modelPathCompositeId.indexOf(CIMConstants.CLARIION_PREFIX) != -1) {\n      deviceType=_deviceTypeMap.get(StorageSystem.Type.vnxblock.name());\n    }\n else     if (modelPathCompositeId != null && modelPathCompositeId.indexOf(CIMConstants.SYMMETRIX_PREFIX) != -1) {\n      deviceType=_deviceTypeMap.get(StorageSystem.Type.vmax.name());\n    }\n    _logger.debug(\"Using serialNumber - {}, deviceType - {} poolNativeId - {} to compute NativeGuid \",new Object[]{serialNumber,deviceType,poolNativeId});\n    if (serialNumber == null || (serialNumber != null && serialNumber.length() <= 0) || deviceType == null || (deviceType != null && deviceType.length() <= 0) || poolNativeId == null || (poolNativeId != null && poolNativeId.length() <= 0)) {\n      return null;\n    }\n    String nativeGuid=getNativeGuidforPool(deviceType,serialNumber,poolNativeId);\n    _logger.debug(\"Required format of NativeGuid computed : {}\",nativeGuid);\n    return nativeGuid;\n  }\n catch (  Exception e) {\n    _logger.error(\"Unable to compute native guid using indication's SourceInstanceModelPathSPInstanceID {} - {}\",spInstanceId,e.getMessage());\n    return null;\n  }\n}\n", "nl": "Generates the native guid for provider triggered indications of type VNX and VMAX StoragePool and VolumeView Indications Example Values for reference : SourceInstanceModelPathInstanceID : SYMMETRIX+000195900704+TP+GopiTest SourceInstanceModelPathCompositeID : SYMMETRIX+000195900704+TP+GopiTest"}
{"code": "public boolean isNegative(){\n  return signum() == -1;\n}\n", "nl": "Returns true if and only if this instance represents a monetary value less than zero, otherwise false."}
{"code": "@Override public void writeCData(String data) throws XMLStreamException {\n  log.log(Level.FINE,\"writeCData({0})\",data);\n  writeCharsInternal(data,false);\n}\n", "nl": "Writes a CData section. In delegates to writeCharsInternal."}
{"code": "private boolean isAVL(Node x){\n  if (x == null)   return true;\n  int bf=balanceFactor(x);\n  if (bf > 1 || bf < -1)   return false;\n  return isAVL(x.left) && isAVL(x.right);\n}\n", "nl": "Checks if AVL property is consistent in the subtree."}
{"code": "private void showFeedback(String feedback){\n  if (myHost != null) {\n    myHost.showFeedback(feedback);\n  }\n else {\n    System.out.println(feedback);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "private void closeDatabases(){\n  s_logger.log(Level.INFO,\"\");\n  s_logger.log(Level.INFO,\"migrateCloseDatabases\");\n  m_source.close();\n  m_target.close();\n  m_source.reset();\n  m_source=null;\n  m_target.reset();\n  m_target=null;\n  m_direction=null;\n  m_objectType=null;\n  m_objectTypes=null;\n  m_sourceMap=null;\n  m_targetMap=null;\n  m_objectList=new ArrayList<String>();\n  m_trackingList=new ArrayList<String>();\n  m_tempIndexes=null;\n  m_counterPrg=null;\n  m_counterDrp=null;\n  m_counterUpd=null;\n  m_counterAdd=null;\n  m_totalPrg=null;\n  m_totalDrp=null;\n  m_totalUpd=null;\n  m_totalAdd=null;\n  m_detailType=null;\n  m_detailTypes=null;\n  m_detailCounterDrp=null;\n  m_detailCounterUpd=null;\n  m_detailCounterAdd=null;\n  System.gc();\n}\n", "nl": "closes target and source databases"}
{"code": "public boolean contains(CharSequence cs){\n  return map.containsKey(cs);\n}\n", "nl": "true if the <code>CharSequence</code> is in the set"}
{"code": "public JSONObject makeReferralInfoProps(final String utmSource,final String utmCampaign,final String utmMedium,final String utmContent,final String utmTerm){\n  JSONObject props;\n  try {\n    props=new JSONObject();\n    props.put(\"Referral Source\",utmSource);\n    props.put(\"Referral Campaign\",utmCampaign);\n    props.put(\"Referral Medium\",utmMedium);\n    props.put(\"Referral Campaign Content\",utmContent);\n    props.put(\"Referral Term\",utmTerm);\n  }\n catch (  JSONException e) {\n    Logger.e(TAG,\"Error building Mixpanel Props\",e);\n    props=null;\n  }\n  return props;\n}\n", "nl": "Create a JsonObject props for the referral info"}
{"code": "private void applyForegroundColor(Color color,Control control,List exclusions){\n  if (exclusions.contains(control))   return;\n  control.setForeground(color);\n  if (control instanceof Composite) {\n    Control[] children=((Composite)control).getChildren();\n    for (int i=0; i < children.length; i++) {\n      applyForegroundColor(color,children[i],exclusions);\n    }\n  }\n}\n", "nl": "Set the specified foreground color for the specified control and all of its children, except for those specified in the list of exclusions."}
{"code": "public void tagFreeCharacter(int charId) throws IOException {\n  startTag(TAG_FREECHARACTER,false);\n  out.writeUI16(charId);\n  completeTag();\n}\n", "nl": "SWFTagTypes interface"}
{"code": "public boolean isPlayable(){\n  return mPlayable;\n}\n", "nl": "Is a playable content"}
{"code": "public AuthenticationFailedSynchronizer(final IDebugger debugger,final ListenerProvider<IDebugEventListener> listeners){\n  super(debugger,listeners);\n}\n", "nl": "Creates a new Authentication Failed synchronizer."}
{"code": "public boolean put(Object object) throws CacheException, InterruptedException {\n  boolean putDone=super.put(object);\n  if (takeFirst) {\n    this.take();\n    this.takeFirst=false;\n  }\nsynchronized (forWaiting) {\n    forWaiting.notifyAll();\n  }\n  return putDone;\n}\n", "nl": "Does a put and a notifyAll() multiple threads can possibly be waiting on this queue to put"}
{"code": "public JFXSpinner(){\n  super();\n  getStyleClass().add(DEFAULT_STYLE_CLASS);\n  initialize();\n}\n", "nl": "creates a spinner node"}
{"code": "public static PlatformUser createAdmin(DataService mgr,String userId,Organization org) throws NonUniqueBusinessKeyException {\n  PlatformUser user=Organizations.createUserForOrg(mgr,org,true,userId);\n  return user;\n}\n", "nl": "Creates a new platform user with the given user id. The user is assigned the administrator role."}
{"code": "public static DirichletBayesImWrapper serializableInstance(){\n  return new DirichletBayesImWrapper(BayesPmWrapper.serializableInstance(),new Parameters());\n}\n", "nl": "Generates a simple exemplar of this class to test serialization."}
{"code": "public String applyMask(String value){\n  return formatter.applyMask(displayHints.getMask(),value);\n}\n", "nl": "Applies mask on a given string"}
{"code": "private static boolean hasMatchingAncestor(Context context,AccessibilityNodeInfoCompat node,NodeFilter filter){\n  if (node == null) {\n    return false;\n  }\n  final AccessibilityNodeInfoCompat result=getMatchingAncestor(context,node,filter);\n  if (result == null) {\n    return false;\n  }\n  result.recycle();\n  return true;\n}\n", "nl": "Check whether a given node has a scrollable ancestor."}
{"code": "private boolean doesUserNotHavePasswordAndNeedsIt(final User editedUser){\n  return !editedUser.getIsSingleUser() && editedUser.getPassword() == null;\n}\n", "nl": "Returns true if the user does not have a password and needs it."}
{"code": "public SwingTerminal(TerminalSize initialTerminalSize,TerminalEmulatorDeviceConfiguration deviceConfiguration,SwingTerminalFontConfiguration fontConfiguration,TerminalEmulatorColorConfiguration colorConfiguration,TerminalScrollController scrollController){\n  if (deviceConfiguration == null) {\n    deviceConfiguration=TerminalEmulatorDeviceConfiguration.getDefault();\n  }\n  if (fontConfiguration == null) {\n    fontConfiguration=SwingTerminalFontConfiguration.getDefault();\n  }\n  if (colorConfiguration == null) {\n    colorConfiguration=TerminalEmulatorColorConfiguration.getDefault();\n  }\n  terminalImplementation=new SwingTerminalImplementation(this,fontConfiguration,initialTerminalSize,deviceConfiguration,colorConfiguration,scrollController);\n}\n", "nl": "Creates a new SwingTerminal component using custom settings and a custom scroll controller. The scrolling controller will be notified when the terminal's history size grows and will be called when this class needs to figure out the current scrolling position."}
{"code": "public Double2D tv(final Double2D d1,final Double2D d2){\n  return new Double2D(tdx(d1.x,d2.x),tdy(d1.y,d2.y));\n}\n", "nl": "Minimum Toroidal difference vector between two points.  This subtracts the second point from the first and produces the minimum-length such subtractive vector, considering wrap-around possibilities as well"}
{"code": "static public String normalizeToEncoding(String origString_,Charset encoding_){\n  String normString=origString_;\n  CharsetEncoder encoder=encoding_.newEncoder();\n  if (!encoder.canEncode(origString_)) {\n    final int length=origString_.length();\n    char[] normSeq=new char[(origString_.length())];\n    int charNum=0;\n    for (int offset=0; offset < length; ) {\n      Pair<Character,Integer> replacement=normalizeCodepoint(origString_,encoding_,offset);\n      Character replacedChar=replacement.getFirst();\n      int codepoint=replacement.getSecond();\n      if (null != replacedChar) {\n        normSeq[charNum]=replacedChar;\n        charNum++;\n      }\n      offset+=Character.charCount(codepoint);\n    }\n    normString=new String(normSeq);\n  }\n  return normString;\n}\n", "nl": "tries to normalize string to specified encoding. The number of characters returned should be the same, and tokens should remain contiguous in the output; non-recognized characters will be substituted for *something*."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-03-24 16:07:26.282 -0400\",hash_original_method=\"3DD1F54AED9C9361A6A54B10F128DAE9\",hash_generated_method=\"3FB8B09BDF3878CD331AF8E6EEE97886\") public boolean isTetheringOn(){\n  mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM,\"Need BLUETOOTH permission\");\nsynchronized (mBluetoothPanProfileHandler) {\n    return mBluetoothPanProfileHandler.isTetheringOn();\n  }\n}\n", "nl": "Handlers for PAN  Profile"}
{"code": "@Override public final void release(final K ctx){\n  if (ctx.usage == USAGE_CLQ) {\n    ctxQueue.offer(getOrCreateReference(ctx));\n  }\n}\n", "nl": "Restore the given ReentrantContext instance for reuse"}
{"code": "@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n  int widthMode=MeasureSpec.getMode(widthMeasureSpec);\n  int widthSize=MeasureSpec.getSize(widthMeasureSpec);\n  int heightMode=MeasureSpec.getMode(heightMeasureSpec);\n  int heightSize=MeasureSpec.getSize(heightMeasureSpec);\n  if (widthMode == MeasureSpec.AT_MOST && heightMode == MeasureSpec.AT_MOST) {\n    setMeasuredDimension(defaultWidth,defaultWidth);\n  }\n else   if (widthMode == MeasureSpec.AT_MOST) {\n    setMeasuredDimension(defaultWidth,heightSize);\n  }\n else   if (heightMode == MeasureSpec.AT_MOST) {\n    setMeasuredDimension(widthSize,defaultWidth);\n  }\n}\n", "nl": "ColorButton is not support self-define padding"}
{"code": "public ZoneRulesBuilder addWindow(ZoneOffset standardOffset,LocalDateTime until,TimeDefinition untilDefinition){\n  Objects.requireNonNull(standardOffset,\"standardOffset\");\n  Objects.requireNonNull(until,\"until\");\n  Objects.requireNonNull(untilDefinition,\"untilDefinition\");\n  TZWindow window=new TZWindow(standardOffset,until,untilDefinition);\n  if (windowList.size() > 0) {\n    TZWindow previous=windowList.get(windowList.size() - 1);\n    window.validateWindowOrder(previous);\n  }\n  windowList.add(window);\n  return this;\n}\n", "nl": "Adds a window to the builder that can be used to filter a set of rules. <p> This method defines and adds a window to the zone where the standard offset is specified. The window limits the effect of subsequent additions of transition rules or fixed savings. If neither rules or fixed savings are added to the window then the window will default to no savings. <p> Each window must be added sequentially, as the start instant of the window is derived from the until instant of the previous window."}
{"code": "public void storePersistentState(Editor editor,String prefix){\n  editor.putString(prefix + \".hash\",String.valueOf(mEditText.getText().toString().hashCode()));\n  editor.putInt(prefix + \".maxSize\",mEditHistory.mmMaxHistorySize);\n  editor.putInt(prefix + \".position\",mEditHistory.mmPosition);\n  editor.putInt(prefix + \".size\",mEditHistory.mmHistory.size());\n  int i=0;\n  for (  EditItem ei : mEditHistory.mmHistory) {\n    String pre=prefix + \".\" + i;\n    editor.putInt(pre + \".start\",ei.mmStart);\n    editor.putString(pre + \".before\",ei.mmBefore.toString());\n    editor.putString(pre + \".after\",ei.mmAfter.toString());\n    i++;\n  }\n}\n", "nl": "Store preferences."}
{"code": "public CoordinateSystem(double minX,double maxX,double minY,double maxY){\n  this(minX,maxX,minY,maxY,AxisDirection.EAST,AxisDirection.SOUTH);\n}\n", "nl": "Uses Java graphics default axis orientation: x increases to the right, y increases to the bottom."}
{"code": "public static ErThrowableInformation fromThrowableProxy(ThrowableProxy tp){\n  ErThrowableInformation ert=new ErThrowableInformation();\n  ert.setThrowable(ErThrowable.fromThrowableProxy(tp));\n  String[] rep=new String[tp.getExtendedStackTrace().length + 1];\n  rep[0]=tp.toString();\n  for (int i=0; i < rep.length - 1; i++) {\n    rep[i + 1]=tp.getExtendedStackTrace()[i].toString();\n  }\n  ert.setRep(rep);\n  return ert;\n}\n", "nl": "Make from org.apache.logging.log4j.core.impl.ThrowableProxy (Log4j 2.x)"}
{"code": "public static boolean isNotEmpty(final short[] array){\n  return array != null && array.length != 0;\n}\n", "nl": "<p>Checks if an array of primitive shorts is not empty or not <code>null</code>.</p>"}
{"code": "public TextDrawable(TextView tv,boolean bindToViewsText,boolean bindToViewsPaint){\n  this(tv,tv.getText().toString(),false,false);\n}\n", "nl": "Create a TextDrawable. This uses the given TextView to initialize paint and the text that will be drawn."}
{"code": "@Override public boolean equals(Object itemSet){\n  if ((itemSet == null) || !(itemSet.getClass().equals(this.getClass()))) {\n    return false;\n  }\n  if (m_items.length != ((ItemSet)itemSet).m_items.length) {\n    return false;\n  }\n  for (int i=0; i < m_items.length; i++) {\n    if (m_items[i] != ((ItemSet)itemSet).m_items[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n", "nl": "Tests if two item sets are equal."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(textsplittextnomodificationallowederr.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "private void assertResultSet(boolean ordered,ResultSet rs,String[][] data) throws SQLException {\n  int len=rs.getMetaData().getColumnCount();\n  int rows=data.length;\n  if (rows == 0) {\n    if (rs.next()) {\n      fail(\"testResultSet expected rowCount:\" + rows + \" got:0\");\n    }\n  }\n  int len2=data[0].length;\n  if (len < len2) {\n    fail(\"testResultSet expected columnCount:\" + len2 + \" got:\"+ len);\n  }\n  for (int i=0; i < rows; i++) {\n    if (!rs.next()) {\n      fail(\"testResultSet expected rowCount:\" + rows + \" got:\"+ i);\n    }\n    String[] row=getData(rs,len);\n    if (ordered) {\n      String[] good=data[i];\n      if (!testRow(good,row,good.length)) {\n        fail(\"testResultSet row not equal, got:\\n\" + formatRow(row) + \"\\n\"+ formatRow(good));\n      }\n    }\n else {\n      boolean found=false;\n      for (int j=0; j < rows; j++) {\n        String[] good=data[i];\n        if (testRow(good,row,good.length)) {\n          found=true;\n          break;\n        }\n      }\n      if (!found) {\n        fail(\"testResultSet no match for row:\" + formatRow(row));\n      }\n    }\n  }\n  if (rs.next()) {\n    String[] row=getData(rs,len);\n    fail(\"testResultSet expected rowcount:\" + rows + \" got:>=\"+ (rows + 1)+ \" data:\"+ formatRow(row));\n  }\n}\n", "nl": "Check if a result set contains the expected data."}
{"code": "public static String convertSystemNameToAlternate(String systemName){\n  if (!validSystemNameFormat(systemName,systemName.charAt(1))) {\n    return \"\";\n  }\n  Matcher matcher=getAllPattern().matcher(systemName);\n  matcher.matches();\n  if (matcher.group(7) != null) {\n    int num=Integer.valueOf(matcher.group(7)).intValue();\n    return matcher.group(1) + matcher.group(2) + (num / 1000)+ \"B\"+ (num % 1000);\n  }\n else {\n    int node=Integer.valueOf(matcher.group(4)).intValue();\n    int bit=Integer.valueOf(matcher.group(6)).intValue();\n    return matcher.group(1) + matcher.group(2) + node+ \"B\"+ bit;\n  }\n}\n", "nl": "Public static method to convert any format system name for the alternate format (nnBnn) If the supplied system name does not have a valid format, or if there is no representation in the alternate naming scheme, an empty string is returned."}
{"code": "@Override public void run(){\n  amIActive=true;\n  String inputFile;\n  String outputHeader;\n  String fieldName;\n  int fieldNum=0;\n  String assignmentType;\n  String baseFileHeader=\"not specified\";\n  double backgroundValue=0;\n  int row, col;\n  double xCoord, yCoord, value, z;\n  int progress;\n  double cellSize=-1.0;\n  int rows;\n  int cols;\n  double noData=-32768.0;\n  double east;\n  double west;\n  double north;\n  double south;\n  DataType dataType=WhiteboxRasterBase.DataType.INTEGER;\n  Object[] data;\n  boolean useRecID=false;\n  if (args.length <= 0) {\n    showFeedback(\"Plugin parameters have not been set.\");\n    return;\n  }\n  inputFile=args[0];\n  outputHeader=args[1];\n  fieldName=args[2];\n  assignmentType=args[3].toLowerCase();\n  if (args[4].toLowerCase().contains(\"nodata\")) {\n    backgroundValue=noData;\n  }\n else {\n    backgroundValue=Double.parseDouble(args[4]);\n  }\n  if (!args[5].toLowerCase().contains(\"not specified\")) {\n    cellSize=Double.parseDouble(args[5]);\n  }\n  baseFileHeader=args[6];\n  if ((inputFile == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    ShapeFile input=new ShapeFile(inputFile);\n    if (input.getShapeType() != ShapeType.POINT && input.getShapeType() != ShapeType.POINTZ && input.getShapeType() != ShapeType.POINTM && input.getShapeType() != ShapeType.MULTIPOINT && input.getShapeType() != ShapeType.MULTIPOINTZ && input.getShapeType() != ShapeType.MULTIPOINTM) {\n      showFeedback(\"The input shapefile must be of a 'point' data type.\");\n      return;\n    }\n    AttributeTable reader=input.getAttributeTable();\n    int numberOfFields=reader.getFieldCount();\n    for (int i=0; i < numberOfFields; i++) {\n      DBFField field=reader.getField(i);\n      if (field.getName().equals(fieldName)) {\n        fieldNum=i;\n        if (field.getDataType() == DBFField.DBFDataType.NUMERIC || field.getDataType() == DBFField.DBFDataType.FLOAT) {\n          if (field.getDecimalCount() == 0) {\n            dataType=WhiteboxRasterBase.DataType.INTEGER;\n          }\n else {\n            dataType=WhiteboxRasterBase.DataType.FLOAT;\n          }\n        }\n else {\n          useRecID=true;\n        }\n      }\n    }\n    if (fieldNum < 0) {\n      useRecID=true;\n    }\n    WhiteboxRaster output;\n    if ((cellSize > 0) || ((cellSize < 0) & (baseFileHeader.toLowerCase().contains(\"not specified\")))) {\n      if ((cellSize < 0) & (baseFileHeader.toLowerCase().contains(\"not specified\"))) {\n        cellSize=Math.min((input.getyMax() - input.getyMin()) / 500.0,(input.getxMax() - input.getxMin()) / 500.0);\n      }\n      north=input.getyMax() + cellSize / 2.0;\n      south=input.getyMin() - cellSize / 2.0;\n      east=input.getxMax() + cellSize / 2.0;\n      west=input.getxMin() - cellSize / 2.0;\n      rows=(int)(Math.ceil((north - south) / cellSize));\n      cols=(int)(Math.ceil((east - west) / cellSize));\n      east=west + cols * cellSize;\n      south=north - rows * cellSize;\n      output=new WhiteboxRaster(outputHeader,north,south,east,west,rows,cols,WhiteboxRasterBase.DataScale.CONTINUOUS,dataType,backgroundValue,noData);\n    }\n else {\n      output=new WhiteboxRaster(outputHeader,\"rw\",baseFileHeader,dataType,backgroundValue);\n      rows=output.getNumberRows();\n      cols=output.getNumberColumns();\n    }\n    double[][] geometry;\n    if (assignmentType.equals(\"minimum\")) {\n      for (      ShapeFileRecord record : input.records) {\n        data=reader.nextRecord();\n        geometry=getXYFromShapefileRecord(record);\n        for (int i=0; i < geometry.length; i++) {\n          xCoord=geometry[i][0];\n          yCoord=geometry[i][1];\n          row=output.getRowFromYCoordinate(yCoord);\n          col=output.getColumnFromXCoordinate(xCoord);\n          if (row < rows && row >= 0 && col < cols && col >= 0) {\n            row=output.getRowFromYCoordinate(yCoord);\n            col=output.getColumnFromXCoordinate(xCoord);\n            value=Double.valueOf(data[fieldNum].toString());\n            z=output.getValue(row,col);\n            if (z == backgroundValue || z < value) {\n              output.setValue(row,col,value);\n            }\n          }\n        }\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress=(int)((100.0 * record.getRecordNumber()) / input.getNumberOfRecords());\n        updateProgress(progress);\n      }\n    }\n else     if (assignmentType.equals(\"maximum\")) {\n      for (      ShapeFileRecord record : input.records) {\n        data=reader.nextRecord();\n        geometry=getXYFromShapefileRecord(record);\n        for (int i=0; i < geometry.length; i++) {\n          xCoord=geometry[i][0];\n          yCoord=geometry[i][1];\n          row=output.getRowFromYCoordinate(yCoord);\n          col=output.getColumnFromXCoordinate(xCoord);\n          if (row < rows && row >= 0 && col < cols && col >= 0) {\n            row=output.getRowFromYCoordinate(yCoord);\n            col=output.getColumnFromXCoordinate(xCoord);\n            if (!useRecID) {\n              value=Double.valueOf(data[fieldNum].toString());\n            }\n else {\n              value=record.getRecordNumber();\n            }\n            z=output.getValue(row,col);\n            if (z == backgroundValue || z > value) {\n              output.setValue(row,col,value);\n            }\n          }\n        }\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress=(int)((100.0 * record.getRecordNumber()) / input.getNumberOfRecords());\n        updateProgress(progress);\n      }\n    }\n else     if (assignmentType.equals(\"sum\")) {\n      for (      ShapeFileRecord record : input.records) {\n        data=reader.nextRecord();\n        geometry=getXYFromShapefileRecord(record);\n        for (int i=0; i < geometry.length; i++) {\n          xCoord=geometry[i][0];\n          yCoord=geometry[i][1];\n          row=output.getRowFromYCoordinate(yCoord);\n          col=output.getColumnFromXCoordinate(xCoord);\n          if (row < rows && row >= 0 && col < cols && col >= 0) {\n            row=output.getRowFromYCoordinate(yCoord);\n            col=output.getColumnFromXCoordinate(xCoord);\n            if (!useRecID) {\n              value=Double.valueOf(data[fieldNum].toString());\n            }\n else {\n              value=record.getRecordNumber();\n            }\n            z=output.getValue(row,col);\n            if (z == backgroundValue) {\n              output.setValue(row,col,value);\n            }\n else {\n              output.setValue(row,col,value + z);\n            }\n          }\n        }\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress=(int)((100.0 * record.getRecordNumber()) / input.getNumberOfRecords());\n        updateProgress(progress);\n      }\n    }\n else     if (assignmentType.equals(\"first\")) {\n      for (      ShapeFileRecord record : input.records) {\n        data=reader.nextRecord();\n        geometry=getXYFromShapefileRecord(record);\n        for (int i=0; i < geometry.length; i++) {\n          xCoord=geometry[i][0];\n          yCoord=geometry[i][1];\n          row=output.getRowFromYCoordinate(yCoord);\n          col=output.getColumnFromXCoordinate(xCoord);\n          if (row < rows && row >= 0 && col < cols && col >= 0) {\n            row=output.getRowFromYCoordinate(yCoord);\n            col=output.getColumnFromXCoordinate(xCoord);\n            if (!useRecID) {\n              value=Double.valueOf(data[fieldNum].toString());\n            }\n else {\n              value=record.getRecordNumber();\n            }\n            z=output.getValue(row,col);\n            if (z == backgroundValue) {\n              output.setValue(row,col,value);\n            }\n          }\n        }\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress=(int)((100.0 * record.getRecordNumber()) / input.getNumberOfRecords());\n        updateProgress(progress);\n      }\n    }\n else     if (assignmentType.equals(\"last\")) {\n      for (      ShapeFileRecord record : input.records) {\n        data=reader.nextRecord();\n        geometry=getXYFromShapefileRecord(record);\n        for (int i=0; i < geometry.length; i++) {\n          xCoord=geometry[i][0];\n          yCoord=geometry[i][1];\n          row=output.getRowFromYCoordinate(yCoord);\n          col=output.getColumnFromXCoordinate(xCoord);\n          if (row < rows && row >= 0 && col < cols && col >= 0) {\n            row=output.getRowFromYCoordinate(yCoord);\n            col=output.getColumnFromXCoordinate(xCoord);\n            if (!useRecID) {\n              value=Double.valueOf(data[fieldNum].toString());\n            }\n else {\n              value=record.getRecordNumber();\n            }\n            output.setValue(row,col,value);\n          }\n        }\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n        progress=(int)((100.0 * record.getRecordNumber()) / input.getNumberOfRecords());\n        updateProgress(progress);\n      }\n    }\n else     if (assignmentType.equals(\"mean\")) {\n    }\n else     if (assignmentType.equals(\"range\")) {\n    }\n    output.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    output.addMetadataEntry(\"Created on \" + new Date());\n    output.flush();\n    output.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "static protected void runWatchDog(){\n  boolean warned=false;\n  logFine(WATCHDOG_NAME,\"Starting\");\n  try {\n    basicLoadEmergencyClasses();\n  }\n catch (  ExceptionInInitializerError e) {\n    boolean noSurprise=false;\n    Throwable cause=e.getCause();\n    if (cause != null) {\n      if (cause instanceof IllegalStateException) {\n        String msg=cause.getMessage();\n        if (msg.indexOf(\"Shutdown in progress\") >= 0) {\n          noSurprise=true;\n        }\n      }\n    }\n    if (!noSurprise) {\n      logWarning(WATCHDOG_NAME,\"Unable to load GemFire classes: \",e);\n    }\n    return;\n  }\ncatch (  CancelException e) {\n  }\ncatch (  Throwable t) {\n    logWarning(WATCHDOG_NAME,\"Unable to initialize watchdog\",t);\n    return;\n  }\n  for (; ; ) {\n    if (stopping) {\n      return;\n    }\n    try {\n      if (isCacheClosing) {\n        break;\n      }\nsynchronized (failureSync) {\n        if (stopping) {\n          return;\n        }\n        logFine(WATCHDOG_NAME,\"Waiting for disaster\");\n        try {\n          failureSync.wait(WATCHDOG_WAIT * 1000);\n        }\n catch (        InterruptedException e) {\n        }\n        if (stopping) {\n          return;\n        }\n      }\n      if (failureActionCompleted) {\n        logInfo(WATCHDOG_NAME,\"all actions completed; exiting\");\n      }\n      if (failure == null) {\n        logFine(WATCHDOG_NAME,\"no failure detected\");\n        continue;\n      }\n      if (!warned) {\n        warned=logWarning(WATCHDOG_NAME,\"failure detected\",failure);\n      }\n      if (!gemfireCloseCompleted) {\n        logInfo(WATCHDOG_NAME,\"closing GemFire\");\n        try {\n          emergencyClose();\n        }\n catch (        Throwable t) {\n          logWarning(WATCHDOG_NAME,\"trouble closing GemFire\",t);\n          continue;\n        }\n        gemfireCloseCompleted=true;\n      }\n      if (!failureActionCompleted) {\n        Runnable r=failureAction;\n        if (r != null) {\n          logInfo(WATCHDOG_NAME,\"running user's runnable\");\n          try {\n            r.run();\n          }\n catch (          Throwable t) {\n            logWarning(WATCHDOG_NAME,\"trouble running user's runnable\",t);\n            continue;\n          }\n        }\n        failureActionCompleted=true;\n      }\n      stopping=true;\n      stopProctor();\n      if (exitOK) {\n        logWarning(WATCHDOG_NAME,CALLING_SYSTEM_EXIT,exitExcuse);\n        System.exit(1);\n      }\n      logInfo(WATCHDOG_NAME,\"exiting\");\n      return;\n    }\n catch (    Throwable t) {\n      logWarning(WATCHDOG_NAME,\"thread encountered a problem: \" + t,t);\n    }\n  }\n}\n", "nl": "This is the run loop for the watchdog thread."}
{"code": "public PotentialProducer createPotentialProducer(final Object baseObject,final AttributeType type){\n  String methodName=type.getMethodName();\n  Class<?> dataType=type.getDataType();\n  PotentialProducer producer=createPotentialProducer(baseObject,methodName,dataType);\n  String description=type.getBaseDescription();\n  producer.setCustomDescription(description);\n  return producer;\n}\n", "nl": "Create a potential producer using an attribute type."}
{"code": "public boolean isTextureInitializationFailed(){\n  return this.textureInitializationFailed;\n}\n", "nl": "Indicates whether an attempt was made to retrieve and read the texture but it failed. If this flag is true, this texture should not be used."}
{"code": "@Override public boolean stopSelfResultForPlugin(int startId){\n  if (mPluginHostService != null) {\n    return mPluginHostService.stopSelfResult(startId);\n  }\n  return false;\n}\n", "nl": "ApiLevel: 27"}
{"code": "public QuickAdapter(Context context,int layoutResId){\n  super(context,layoutResId);\n}\n", "nl": "Create a QuickAdapter."}
{"code": "public int numSquares2(int n){\n  int[] res=new int[n + 1];\n  Arrays.fill(res,Integer.MAX_VALUE);\n  res[0]=0;\n  for (int i=0; i <= n; i++) {\n    for (int j=1; j * j <= i; j++) {\n      res[i]=Math.min(res[i],res[i - j * j] + 1);\n    }\n  }\n  return res[n];\n}\n", "nl": "DP, bottom-up"}
{"code": "private void fetchStats(NetworkTemplate template){\n  INetworkStatsSession session=null;\n  try {\n    mStatsService.forceUpdate();\n    session=mStatsService.openSession();\n    final NetworkStats stats=session.getSummaryForAllUid(template,Long.MIN_VALUE,Long.MAX_VALUE,false);\n    reportStats(stats);\n  }\n catch (  RemoteException e) {\n    Log.w(LOG_TAG,\"Failed to fetch network stats.\");\n  }\n finally {\n    TrafficStats.closeQuietly(session);\n  }\n}\n", "nl": "Helper method that fetches all the network stats available and reports it to instrumentation out."}
{"code": "public int readVarInt() throws IOException {\n  int b=readByte();\n  if (b >= 0) {\n    return b;\n  }\n  int x=b & 0x7f;\n  b=readByte();\n  if (b >= 0) {\n    return x | (b << 7);\n  }\n  x|=(b & 0x7f) << 7;\n  b=readByte();\n  if (b >= 0) {\n    return x | (b << 14);\n  }\n  x|=(b & 0x7f) << 14;\n  b=readByte();\n  if (b >= 0) {\n    return x | b << 21;\n  }\n  return x | ((b & 0x7f) << 21) | (readByte() << 28);\n}\n", "nl": "Read a variable size integer."}
{"code": "public TsFciRunner(GraphSource graphWrapper,Parameters params,KnowledgeBoxModel knowledgeBoxModel){\n  super(graphWrapper.getGraph(),params,knowledgeBoxModel);\n}\n", "nl": "Constucts a wrapper for the given EdgeListGraph."}
{"code": "@LargeTest public void testCameraPairwiseScenario16() throws Exception {\n  genericPairwiseTestCase(Flash.AUTO,Exposure.MIN,WhiteBalance.AUTO,SceneMode.PARTY,PictureSize.SMALL,Geotagging.OFF);\n}\n", "nl": "Flash: Auto / Exposure: Min / WB: Auto Scene: Party / Pic: Small / Geo: off"}
{"code": "public void runButtonActionPerformed(java.awt.event.ActionEvent e){\n  if (!mRunButton.isSelected()) {\n    return;\n  }\n  boolean ok=false;\n  for (int i=0; i < MAXSEQUENCE; i++) {\n    if (mUseField[i].isSelected()) {\n      ok=true;\n    }\n  }\n  if (!ok) {\n    mRunButton.setSelected(false);\n    return;\n  }\n  mNextSequenceElement=0;\n  sendNextItem();\n}\n", "nl": "Run button pressed down, start the sequence operation"}
{"code": "public RoundedBitmapBuilder cornerRadiusDp(int corner,float radius){\n  return cornerRadius(corner,TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,radius,mDisplayMetrics));\n}\n", "nl": "Set corner radius for a specific corner in density independent pixels."}
{"code": "private static String linkToHtml(Link l){\n  if (l == null) {\n    return \"null\";\n  }\n  StringBuilder result=new StringBuilder();\n  result.append(\"<div class=\\\"Link\\\"><b class=\\\"Link\\\">Link:</b>\" + l.getType() + \": \\\"\"+ convertTags(l.getText())+ \"\\\" -> \\\"\"+ convertTags(l.getTarget())+ \"\\\"\");\n  if (l.getParameters().size() != 0) {\n    for (    String parameter : l.getParameters()) {\n      result.append(\"<br/>\\nPARAMETER: \\\"\" + convertTags(parameter) + \"\\\"\");\n    }\n  }\n  result.append(\"</div>\\n\");\n  return result.toString();\n}\n", "nl": "Generates HTML Output for a Link."}
{"code": "public X509Ext(ASN1ObjectIdentifier oid,byte[] value,boolean critical){\n  this.oid=oid;\n  this.value=new byte[value.length];\n  System.arraycopy(value,0,this.value,0,this.value.length);\n  this.critical=critical;\n  name=lookupFriendlyName();\n}\n", "nl": "Construct a new immutable X509Ext."}
{"code": "@SmallTest public void testCreateSpeechRules_metadata() throws Exception {\n  final String strategy=\"<ss:rule>\" + \"  <ss:metadata>\" + \"    <ss:queuing>UNINTERRUPTIBLE</ss:queuing>\"+ \"  </ss:metadata>\"+ \"</ss:rule>\";\n  final AccessibilityEvent event=AccessibilityEvent.obtain();\n  final EventSpeechRuleProcessor processor=createProcessorWithStrategy(strategy,1);\n  final Utterance utterance=new Utterance();\n  final boolean processed=processor.processEvent(event,utterance);\n  assertTrue(\"The event must match the filter\",processed);\n  assertEquals(\"The meta-data must have its queuing poperty set\",2,utterance.getMetadata().get(Utterance.KEY_METADATA_QUEUING));\n}\n", "nl": "Test that the meta-data of a speech rule is properly parsed and passed to a formatted utterance."}
{"code": "public boolean isServiceRegistered(){\n  return ServerApiUtils.isImsConnected();\n}\n", "nl": "Returns true if the service is registered to the platform, else returns false"}
{"code": "public Builder mutable(){\n  return new Builder(this);\n}\n", "nl": "Gets a mutable Builder instance."}
{"code": "public void afterQuadrantMove(Quadrant newQuadrant){\n  Raptor.getInstance().getPreferences().setValue(service.getConnector().getShortName() + \"-\" + PreferenceKeys.BUG_WHO_QUADRANT,newQuadrant);\n}\n", "nl": "Invoked after this control is moved to a new quadrant."}
{"code": "public void appendToLog(String s){\n  append(\"\\n\" + s);\n}\n", "nl": "Outputs the string as a new line of log data in the LogView."}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  String qual=getString(stack);\n  return new Long(MMC.getInstance().getQualityOverallBitrate(qual));\n}\n", "nl": "Gets the estimated overall bitrate for a given recording quality. The returned value is in Megabits per second."}
{"code": "public int capacity(){\n  return value.length;\n}\n", "nl": "Returns the number of characters that can be held without growing."}
{"code": "public static String toUnitbytes(long bytes){\n  if (bytes < 0) {\n    return \"? \" + GENERAL_UNIT_KILOBYTES;\n  }\n  long unitValue;\n  String unitName;\n  if (bytes < 0xA00000) {\n    unitValue=0x400;\n    unitName=GENERAL_UNIT_KILOBYTES;\n  }\n else   if (bytes < 0x280000000L) {\n    unitValue=0x100000;\n    unitName=GENERAL_UNIT_MEGABYTES;\n  }\n else   if (bytes < 0xA0000000000L) {\n    unitValue=0x40000000;\n    unitName=GENERAL_UNIT_GIGABYTES;\n  }\n else {\n    unitValue=0x10000000000L;\n    unitName=GENERAL_UNIT_TERABYTES;\n  }\n  NumberFormat numberFormat;\n  if ((double)bytes * 100 / unitValue < 99995)   numberFormat=NUMBER_FORMAT1;\n else   numberFormat=NUMBER_FORMAT0;\n  try {\n    return numberFormat.format((double)bytes / unitValue) + \" \" + unitName;\n  }\n catch (  ArithmeticException ae) {\n    return \"0 \" + unitName;\n  }\n}\n", "nl": "Converts the passed in number of bytes into a byte-size string. Group digits with locale-dependant thousand separator if needed, but with \"KB\", or \"MB\" or \"GB\" or \"TB\" locale-dependant unit at the end, and a limited precision of 4 significant digits."}
{"code": "public void testAllSystem(String trainnameNRC,String trainnameGUMLTLT,String trainnameKLUE) throws Exception {\n  SentimentSystemNRC nrcSystem=new SentimentSystemNRC(tweetList);\n  Map<String,ClassificationResult> nrcResult=nrcSystem.test(trainnameNRC);\n  SentimentSystemGUMLTLT gumltltSystem=new SentimentSystemGUMLTLT(tweetList);\n  Map<String,ClassificationResult> gumltltResult=gumltltSystem.test(trainnameGUMLTLT);\n  SentimentSystemKLUE klueSystem=new SentimentSystemKLUE(tweetList);\n  Map<String,ClassificationResult> klueResult=klueSystem.test(trainnameKLUE);\n  this.evalAllModels(nrcResult,gumltltResult,klueResult);\n}\n", "nl": "Tests and evaluate all 3 systems"}
{"code": "public boolean observed(String form){\n  return table.containsKey(form);\n}\n", "nl": "Indicates whether the input word was observed while training this learner."}
{"code": "private void showFeedback(String feedback){\n  if (myHost != null) {\n    myHost.showFeedback(feedback);\n  }\n else {\n    System.out.println(feedback);\n  }\n}\n", "nl": "Used to communicate feedback pop-up messages between a plugin tool and the main Whitebox user-interface."}
{"code": "private boolean startProcess(){\n  log.fine(m_pi.toString());\n  boolean started=false;\n  if (DB.isRemoteProcess()) {\n    Server server=CConnection.get().getServer();\n    try {\n      if (server != null) {\n        m_pi=server.process(m_wscctx,m_pi);\n        log.finest(\"server => \" + m_pi);\n        started=true;\n      }\n    }\n catch (    UndeclaredThrowableException ex) {\n      Throwable cause=ex.getCause();\n      if (cause != null) {\n        if (cause instanceof InvalidClassException)         log.log(Level.SEVERE,\"Version Server <> Client: \" + cause.toString() + \" - \"+ m_pi,ex);\n else         log.log(Level.SEVERE,\"AppsServer error(1b): \" + cause.toString() + \" - \"+ m_pi,ex);\n      }\n else       log.log(Level.SEVERE,\" AppsServer error(1) - \" + m_pi,ex);\n      started=false;\n    }\ncatch (    Exception ex) {\n      Throwable cause=ex.getCause();\n      if (cause == null)       cause=ex;\n      log.log(Level.SEVERE,\"AppsServer error - \" + m_pi,cause);\n      started=false;\n    }\n  }\n  if (!started && !m_IsServerProcess) {\n    ProcessCall myObject=null;\n    try {\n      Class myClass=Class.forName(m_pi.getClassName());\n      myObject=(ProcessCall)myClass.newInstance();\n      if (myObject == null)       m_pi.setSummary(\"No Instance for \" + m_pi.getClassName(),true);\n else       myObject.startProcess(m_wscctx,m_pi,m_trx);\n      if (m_trx != null) {\n        m_trx.commit();\n        m_trx.close();\n      }\n    }\n catch (    Exception e) {\n      if (m_trx != null) {\n        m_trx.rollback();\n        m_trx.close();\n      }\n      m_pi.setSummary(\"Error starting Class \" + m_pi.getClassName(),true);\n      log.log(Level.SEVERE,m_pi.getClassName(),e);\n    }\n  }\n  return !m_pi.isError();\n}\n", "nl": "Start Java Process Class. instanciate the class implementing the interface ProcessCall. The class can be a Server/Client class (when in Package org compiere.process or org.compiere.model) or a client only class (e.g. in org.compiere.report)"}
{"code": "public static Set notifyListeners(Set cacheOpReceivers,Set adjunctRecipients,FilterRoutingInfo filterInfo,PartitionedRegion r,EntryEventImpl event,boolean ifNew,boolean ifOld,DirectReplyProcessor processor,boolean sendDeltaWithFullValue){\n  PutMessage msg=new PutMessage(Collections.EMPTY_SET,true,r.getPRId(),processor,event,0,ifNew,ifOld,null,false);\n  msg.setInternalDs(r.getSystem());\n  msg.versionTag=event.getVersionTag();\n  msg.setSendDeltaWithFullValue(sendDeltaWithFullValue);\n  return msg.relayToListeners(cacheOpReceivers,adjunctRecipients,filterInfo,event,r,processor);\n}\n", "nl": "send a notification-only message to a set of listeners. The processor id is passed with the message for reply message processing. This method does not wait on the processor."}
{"code": "public void clearCache(){\n  if (cumulative) {\n    for (    Map.Entry<K,SumEntry> e : sums.entrySet()) {\n      SumEntry val=e.getValue();\n      val.changed=false;\n    }\n  }\n else {\n    sums.clear();\n  }\n}\n", "nl": "Clears the cache making this operator stateless on window boundary"}
{"code": "private static void arcToBezier(Path p,double cx,double cy,double a,double b,double e1x,double e1y,double theta,double start,double sweep){\n  int numSegments=Math.abs((int)Math.ceil(sweep * 4 / Math.PI));\n  double eta1=start;\n  double cosTheta=Math.cos(theta);\n  double sinTheta=Math.sin(theta);\n  double cosEta1=Math.cos(eta1);\n  double sinEta1=Math.sin(eta1);\n  double ep1x=(-a * cosTheta * sinEta1) - (b * sinTheta * cosEta1);\n  double ep1y=(-a * sinTheta * sinEta1) + (b * cosTheta * cosEta1);\n  double anglePerSegment=sweep / numSegments;\n  for (int i=0; i < numSegments; i++) {\n    double eta2=eta1 + anglePerSegment;\n    double sinEta2=Math.sin(eta2);\n    double cosEta2=Math.cos(eta2);\n    double e2x=cx + (a * cosTheta * cosEta2) - (b * sinTheta * sinEta2);\n    double e2y=cy + (a * sinTheta * cosEta2) + (b * cosTheta * sinEta2);\n    double ep2x=-a * cosTheta * sinEta2 - b * sinTheta * cosEta2;\n    double ep2y=-a * sinTheta * sinEta2 + b * cosTheta * cosEta2;\n    double tanDiff2=Math.tan((eta2 - eta1) / 2);\n    double alpha=Math.sin(eta2 - eta1) * (Math.sqrt(4 + (3 * tanDiff2 * tanDiff2)) - 1) / 3;\n    double q1x=e1x + alpha * ep1x;\n    double q1y=e1y + alpha * ep1y;\n    double q2x=e2x - alpha * ep2x;\n    double q2y=e2y - alpha * ep2y;\n    p.cubicTo((float)q1x,(float)q1y,(float)q2x,(float)q2y,(float)e2x,(float)e2y);\n    eta1=eta2;\n    e1x=e2x;\n    e1y=e2y;\n    ep1x=ep2x;\n    ep1y=ep2y;\n  }\n}\n", "nl": "Converts an arc to cubic Bezier segments and records them in p."}
{"code": "private String shortFQN(String fqn,String method,int size){\n  String line=fqn + \".\" + method;\n  if (line.length() > size) {\n    line=\"...\" + line.substring(3,size);\n  }\n  return line;\n}\n", "nl": "Shortens a full qualified class name if it exceeds the size. TODO: improve method to shorten middle packages first, maybe abbreviating the package by its first character."}
{"code": "private byte adviseOp(byte requestedOpCode,EntryEventImpl event){\n{\n    Object oldVal;\n    if (this.op == OP_NULL) {\n      oldVal=getOriginalValue();\n    }\n else {\n      oldVal=getNearSidePendingValue();\n    }\n    Region region=event.getRegion();\n    boolean needOldValue=region instanceof HARegion || region instanceof BucketRegion;\n    event.setTXEntryOldValue(oldVal,needOldValue);\n  }\n  byte advisedOpCode=OP_NULL;\nswitch (requestedOpCode) {\ncase OP_L_DESTROY:\nswitch (this.op) {\ncase OP_NULL:\n      advisedOpCode=requestedOpCode;\n    break;\ncase OP_L_DESTROY:\ncase OP_CREATE_LD:\ncase OP_LLOAD_CREATE_LD:\ncase OP_NLOAD_CREATE_LD:\ncase OP_PUT_LD:\ncase OP_LLOAD_PUT_LD:\ncase OP_NLOAD_PUT_LD:\ncase OP_D_INVALIDATE_LD:\ncase OP_D_DESTROY:\n  throw new IllegalStateException(LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1.toLocalizedString(new Object[]{opToString(),opToString(requestedOpCode)}));\ncase OP_L_INVALIDATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_PUT_LI:\nadvisedOpCode=OP_PUT_LD;\nbreak;\ncase OP_LLOAD_PUT_LI:\nadvisedOpCode=OP_LLOAD_PUT_LD;\nbreak;\ncase OP_NLOAD_PUT_LI:\nadvisedOpCode=OP_NLOAD_PUT_LD;\nbreak;\ncase OP_D_INVALIDATE:\nadvisedOpCode=OP_D_INVALIDATE_LD;\nbreak;\ncase OP_CREATE_LI:\nadvisedOpCode=OP_CREATE_LD;\nbreak;\ncase OP_LLOAD_CREATE_LI:\nadvisedOpCode=OP_LLOAD_CREATE_LD;\nbreak;\ncase OP_NLOAD_CREATE_LI:\nadvisedOpCode=OP_NLOAD_CREATE_LD;\nbreak;\ncase OP_CREATE:\nadvisedOpCode=OP_CREATE_LD;\nbreak;\ncase OP_SEARCH_CREATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_LLOAD_CREATE:\nadvisedOpCode=OP_LLOAD_CREATE_LD;\nbreak;\ncase OP_NLOAD_CREATE:\nadvisedOpCode=OP_NLOAD_CREATE_LD;\nbreak;\ncase OP_LOCAL_CREATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_PUT:\nadvisedOpCode=OP_PUT_LD;\nbreak;\ncase OP_SEARCH_PUT:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_LLOAD_PUT:\nadvisedOpCode=OP_LLOAD_PUT_LD;\nbreak;\ncase OP_NLOAD_PUT:\nadvisedOpCode=OP_NLOAD_PUT_LD;\nbreak;\ndefault :\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));\n}\nbreak;\ncase OP_D_DESTROY:\nAssert.assertTrue(!isOpDestroy(),\"Transactional destroy assertion op=\" + this.op);\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_L_INVALIDATE:\nswitch (this.op) {\ncase OP_NULL:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_L_DESTROY:\ncase OP_CREATE_LD:\ncase OP_LLOAD_CREATE_LD:\ncase OP_NLOAD_CREATE_LD:\ncase OP_PUT_LD:\ncase OP_LLOAD_PUT_LD:\ncase OP_NLOAD_PUT_LD:\ncase OP_D_DESTROY:\ncase OP_D_INVALIDATE_LD:\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1.toLocalizedString(new Object[]{opToString(),opToString(requestedOpCode)}));\ncase OP_L_INVALIDATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_LLOAD_PUT_LI:\ncase OP_NLOAD_PUT_LI:\ncase OP_LLOAD_CREATE_LI:\ncase OP_NLOAD_CREATE_LI:\nadvisedOpCode=this.op;\nbreak;\ncase OP_PUT_LI:\nadvisedOpCode=OP_PUT_LI;\nbreak;\ncase OP_CREATE_LI:\nadvisedOpCode=OP_CREATE_LI;\nbreak;\ncase OP_D_INVALIDATE:\nadvisedOpCode=OP_D_INVALIDATE;\nbreak;\ncase OP_CREATE:\nadvisedOpCode=OP_CREATE_LI;\nbreak;\ncase OP_SEARCH_CREATE:\nadvisedOpCode=OP_LOCAL_CREATE;\nbreak;\ncase OP_LLOAD_CREATE:\nadvisedOpCode=OP_LLOAD_CREATE_LI;\nbreak;\ncase OP_NLOAD_CREATE:\nadvisedOpCode=OP_NLOAD_CREATE_LI;\nbreak;\ncase OP_LOCAL_CREATE:\nadvisedOpCode=OP_LOCAL_CREATE;\nbreak;\ncase OP_PUT:\nadvisedOpCode=OP_PUT_LI;\nbreak;\ncase OP_SEARCH_PUT:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_LLOAD_PUT:\nadvisedOpCode=OP_LLOAD_PUT_LI;\nbreak;\ncase OP_NLOAD_PUT:\nadvisedOpCode=OP_NLOAD_PUT_LI;\nbreak;\ndefault :\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));\n}\nbreak;\ncase OP_D_INVALIDATE:\nswitch (this.op) {\ncase OP_NULL:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_L_DESTROY:\ncase OP_CREATE_LD:\ncase OP_LLOAD_CREATE_LD:\ncase OP_NLOAD_CREATE_LD:\ncase OP_PUT_LD:\ncase OP_LLOAD_PUT_LD:\ncase OP_NLOAD_PUT_LD:\ncase OP_D_INVALIDATE_LD:\ncase OP_D_DESTROY:\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_UNEXPECTED_CURRENT_OP_0_FOR_REQUESTED_OP_1.toLocalizedString(new Object[]{opToString(),opToString(requestedOpCode)}));\ncase OP_D_INVALIDATE:\ncase OP_L_INVALIDATE:\nadvisedOpCode=OP_D_INVALIDATE;\nbreak;\ncase OP_PUT_LI:\ncase OP_LLOAD_PUT_LI:\ncase OP_NLOAD_PUT_LI:\ncase OP_CREATE_LI:\ncase OP_LLOAD_CREATE_LI:\ncase OP_NLOAD_CREATE_LI:\nadvisedOpCode=this.op;\nbreak;\ncase OP_CREATE:\nadvisedOpCode=OP_CREATE;\nbreak;\ncase OP_SEARCH_CREATE:\nadvisedOpCode=OP_LOCAL_CREATE;\nbreak;\ncase OP_LLOAD_CREATE:\nadvisedOpCode=OP_CREATE;\nbreak;\ncase OP_NLOAD_CREATE:\nadvisedOpCode=OP_CREATE;\nbreak;\ncase OP_LOCAL_CREATE:\nadvisedOpCode=OP_LOCAL_CREATE;\nbreak;\ncase OP_PUT:\ncase OP_SEARCH_PUT:\ncase OP_LLOAD_PUT:\ncase OP_NLOAD_PUT:\nadvisedOpCode=requestedOpCode;\nbreak;\ndefault :\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_UNHANDLED_0.toLocalizedString(opToString()));\n}\nbreak;\ncase OP_CREATE:\ncase OP_SEARCH_CREATE:\ncase OP_LLOAD_CREATE:\ncase OP_NLOAD_CREATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_PUT:\nswitch (this.op) {\ncase OP_CREATE:\ncase OP_SEARCH_CREATE:\ncase OP_LLOAD_CREATE:\ncase OP_NLOAD_CREATE:\ncase OP_LOCAL_CREATE:\ncase OP_CREATE_LI:\ncase OP_LLOAD_CREATE_LI:\ncase OP_NLOAD_CREATE_LI:\ncase OP_CREATE_LD:\ncase OP_LLOAD_CREATE_LD:\ncase OP_NLOAD_CREATE_LD:\ncase OP_PUT_LD:\ncase OP_LLOAD_PUT_LD:\ncase OP_NLOAD_PUT_LD:\ncase OP_D_INVALIDATE_LD:\ncase OP_L_DESTROY:\ncase OP_D_DESTROY:\nadvisedOpCode=OP_CREATE;\nbreak;\ndefault :\nadvisedOpCode=requestedOpCode;\nbreak;\n}\nbreak;\ncase OP_SEARCH_PUT:\nswitch (this.op) {\ncase OP_NULL:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_L_INVALIDATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_PUT_LI:\nadvisedOpCode=OP_PUT;\nbreak;\ncase OP_LLOAD_PUT_LI:\nadvisedOpCode=OP_LLOAD_PUT;\nbreak;\ncase OP_NLOAD_PUT_LI:\nadvisedOpCode=OP_NLOAD_PUT;\nbreak;\ncase OP_CREATE_LI:\nadvisedOpCode=OP_CREATE;\nbreak;\ncase OP_LLOAD_CREATE_LI:\nadvisedOpCode=OP_LLOAD_CREATE;\nbreak;\ncase OP_NLOAD_CREATE_LI:\nadvisedOpCode=OP_NLOAD_CREATE;\nbreak;\ndefault :\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_PREVIOUS_OP_0_UNEXPECTED_FOR_REQUESTED_OP_1.toLocalizedString(new Object[]{opToString(),opToString(requestedOpCode)}));\n}\nbreak;\ncase OP_LLOAD_PUT:\ncase OP_NLOAD_PUT:\nswitch (this.op) {\ncase OP_NULL:\ncase OP_L_INVALIDATE:\ncase OP_PUT_LI:\ncase OP_LLOAD_PUT_LI:\ncase OP_NLOAD_PUT_LI:\ncase OP_D_INVALIDATE:\nadvisedOpCode=requestedOpCode;\nbreak;\ncase OP_CREATE:\ncase OP_LOCAL_CREATE:\ncase OP_CREATE_LI:\ncase OP_LLOAD_CREATE_LI:\ncase OP_NLOAD_CREATE_LI:\nif (requestedOpCode == OP_LLOAD_PUT) {\nadvisedOpCode=OP_LLOAD_CREATE;\n}\n else {\nadvisedOpCode=OP_NLOAD_CREATE;\n}\nbreak;\ndefault :\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_PREVIOUS_OP_0_UNEXPECTED_FOR_REQUESTED_OP_1.toLocalizedString(new Object[]{opToString(),opToString(requestedOpCode)}));\n}\nbreak;\ndefault :\nthrow new IllegalStateException(LocalizedStrings.TXEntryState_OPCODE_0_SHOULD_NEVER_BE_REQUESTED.toLocalizedString(opToString(requestedOpCode)));\n}\nreturn advisedOpCode;\n}\n", "nl": "Perform operation algebra"}
{"code": "protected void computeOffsets(DrawContext dc){\n  if (dc.getFrameTimeStamp() != this.frameNumber) {\n    final BasicWWTexture texture=this.getTexture();\n    final int viewportWidth=dc.getView().getViewport().width;\n    final int viewportHeight=dc.getView().getViewport().height;\n    if (texture != null) {\n      this.originalImageWidth=texture.getWidth(dc);\n      this.originalImageHeight=texture.getHeight(dc);\n    }\n else     if (this.getImageSource() == null) {\n      this.originalImageWidth=1;\n      this.originalImageHeight=1;\n    }\n else {\n      this.frameNumber=dc.getFrameTimeStamp();\n      return;\n    }\n    if (this.size != null) {\n      Dimension d=this.size.compute(this.originalImageWidth,this.originalImageHeight,viewportWidth,viewportHeight);\n      this.width=d.width;\n      this.height=d.height;\n    }\n else {\n      this.width=this.originalImageWidth;\n      this.height=this.originalImageHeight;\n    }\n    Offset rotationOffset=this.getRotationOffset();\n    if (rotationOffset != null) {\n      Point.Double pointD=rotationOffset.computeOffset(this.width,this.height,null,null);\n      rotationPoint=new Point((int)pointD.x,(int)pointD.y);\n    }\n else {\n      this.rotationPoint=new Point(this.width,this.height);\n    }\n    if (this.screenOffset != null) {\n      Point.Double pointD=this.screenOffset.computeOffset(viewportWidth,viewportHeight,null,null);\n      this.screenLocation=new Point((int)pointD.x,(int)(pointD.y));\n    }\n else {\n      this.screenLocation=new Point(viewportWidth / 2,viewportHeight / 2);\n    }\n    this.awtScreenLocation=new Point(this.screenLocation.x,viewportHeight - this.screenLocation.y);\n    Point.Double overlayPoint;\n    if (this.imageOffset != null)     overlayPoint=this.imageOffset.computeOffset(this.width,this.height,null,null);\n else     overlayPoint=new Point.Double(this.originalImageWidth / 2.0,this.originalImageHeight / 2.0);\n    this.dx=-overlayPoint.x;\n    this.dy=-overlayPoint.y;\n    this.frameNumber=dc.getFrameTimeStamp();\n  }\n}\n", "nl": "Compute the image size, rotation, and position based on the current viewport size. This method updates the calculated values for screen point, rotation point, width, and height. The calculation is not performed if the values have already been calculated for this frame."}
{"code": "public int encode(byte[] data,int off,int length,OutputStream out) throws IOException {\n  for (int i=off; i < (off + length); i++) {\n    int v=data[i] & 0xff;\n    out.write(encodingTable[(v >>> 4)]);\n    out.write(encodingTable[v & 0xf]);\n  }\n  return length * 2;\n}\n", "nl": "encode the input data producing a Hex output stream."}
{"code": "synchronized void markRemoved(){\n  if (!(!removed)) {\n    throw new AssertionError();\n  }\n  removed=true;\n  if (!permanent && callCount == 0) {\n    ObjectTable.decrementKeepAliveCount();\n  }\n  if (exportedTransport != null) {\n    exportedTransport.targetUnexported();\n  }\n}\n", "nl": "Mark this target as having been removed from the object table."}
{"code": "public static AnimGameItem process(MD5Model md5Model,MD5AnimModel animModel,Vector3f defaultColour) throws Exception {\n  List<Matrix4f> invJointMatrices=calcInJointMatrices(md5Model);\n  List<AnimatedFrame> animatedFrames=processAnimationFrames(md5Model,animModel,invJointMatrices);\n  List<Mesh> list=new ArrayList<>();\n  for (  MD5Mesh md5Mesh : md5Model.getMeshes()) {\n    Mesh mesh=generateMesh(md5Model,md5Mesh);\n    handleTexture(mesh,md5Mesh,defaultColour);\n    list.add(mesh);\n  }\n  Mesh[] meshes=new Mesh[list.size()];\n  meshes=list.toArray(meshes);\n  AnimGameItem result=new AnimGameItem(meshes,animatedFrames,invJointMatrices);\n  return result;\n}\n", "nl": "Constructs and AnimGameItem instace based on a MD5 Model an MD5 Animation"}
{"code": "public ServiceChannel createServiceChannel(ApplicationDescription applicationDescription) throws ServiceResultException {\n  return new ServiceChannel(createSecureChannel(applicationDescription));\n}\n", "nl": "Create a service channel <p> Note this implementation is unsecure as the dialog with discover endpoint is not encrypted."}
{"code": "public void close(){\n  this._stats.close();\n}\n", "nl": "Closes the <code>FunctionServiceStats</code>."}
{"code": "public WebSocket disconnect(int closeCode,String reason,long closeDelay){\nsynchronized (mStateManager) {\nswitch (mStateManager.getState()) {\ncase CREATED:\n      finishAsynchronously();\n    return this;\ncase OPEN:\n  break;\ndefault :\nreturn this;\n}\nmStateManager.changeToClosing(CloseInitiator.CLIENT);\nWebSocketFrame frame=WebSocketFrame.createCloseFrame(closeCode,reason);\nsendFrame(frame);\n}\nmListenerManager.callOnStateChanged(CLOSING);\nif (closeDelay < 0) {\ncloseDelay=DEFAULT_CLOSE_DELAY;\n}\nstopThreads(closeDelay);\nreturn this;\n}\n", "nl": "Disconnect the WebSocket."}
{"code": "@Override protected void doPreRender(KMLTraversalContext tc,DrawContext dc){\n  if (this.getRenderable() == null)   this.initializeRenderable(tc);\n  KMLRenderable r=this.getRenderable();\n  if (r != null) {\n    r.preRender(tc,dc);\n  }\n}\n", "nl": "Pre-renders the ground overlay geometry represented by this <code>KMLGroundOverlay</code>. This initializes the ground overlay geometry if necessary, prior to pre-rendering."}
{"code": "public static boolean containsHTML(String text){\n  if ((text == null) || text.isEmpty()) {\n    return false;\n  }\n  return (text.indexOf('<') != -1) || (text.indexOf('>') != -1);\n}\n", "nl": "Check if the text contains HTML tags."}
{"code": "private CResultFilter(){\n}\n", "nl": "You are not supposed to instantiate this class."}
{"code": "public void transformValues(TDoubleFunction function){\n  byte[] states=_states;\n  double[] values=_values;\n  for (int i=values.length; i-- > 0; ) {\n    if (states[i] == FULL) {\n      values[i]=function.execute(values[i]);\n    }\n  }\n}\n", "nl": "Transform the values in this map using <tt>function</tt>."}
{"code": "@Override public int read() throws IOException {\n  return in.read();\n}\n", "nl": "Reads the next byte of data from the input stream. The value byte is returned as an <code>int</code> in the range <code>0</code> to <code>255</code>. If no byte is available because the end of the stream has been reached, the value <code>-1</code> is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown. <p> <p> A subclass must provide an implementation of this method."}
{"code": "private void readEntityDeclaration() throws IOException, XmlPullParserException {\n  read(START_ENTITY);\n  boolean generalEntity=true;\n  skip();\n  if (peekCharacter() == '%') {\n    generalEntity=false;\n    position++;\n    skip();\n  }\n  String name=readName();\n  skip();\n  int quote=peekCharacter();\n  String entityValue;\n  if (quote == '\"' || quote == '\\'') {\n    position++;\n    entityValue=readValue((char)quote,true,false,ValueContext.ENTITY_DECLARATION);\n    if (peekCharacter() == quote) {\n      position++;\n    }\n  }\n else   if (readExternalId(true,false)) {\n    entityValue=\"\";\n    skip();\n    if (peekCharacter() == NDATA[0]) {\n      read(NDATA);\n      skip();\n      readName();\n    }\n  }\n else {\n    throw new XmlPullParserException(\"Expected entity value or external ID\",this,null);\n  }\n  if (generalEntity && processDocDecl) {\n    if (documentEntities == null) {\n      documentEntities=new HashMap<String,char[]>();\n    }\n    documentEntities.put(name,entityValue.toCharArray());\n  }\n  skip();\n  read('>');\n}\n", "nl": "Read an entity declaration. The value of internal entities are inline: <!ENTITY foo \"bar\"> The values of external entities must be retrieved by URL or path: <!ENTITY foo SYSTEM \"http://host/file\"> <!ENTITY foo PUBLIC \"-//Android//Foo//EN\" \"http://host/file\"> <!ENTITY foo SYSTEM \"../file.png\" NDATA png> Entities may be general or parameterized. Parameterized entities are marked by a percent sign. Such entities may only be used in the DTD: <!ENTITY % foo \"bar\">"}
{"code": "public static double recall(double truePositive,double falseNegative){\n  final double totalPositive=truePositive + falseNegative;\n  if (totalPositive == 0) {\n    throw new IllegalArgumentException();\n  }\n  return truePositive / totalPositive;\n}\n", "nl": "Compute the fraction of positive instances that were correctly classified."}
{"code": "public static List<String> readFileToList(String filePath,String charsetName){\n  File file=new File(filePath);\n  List<String> fileContent=new ArrayList<String>();\n  if (file == null || !file.isFile()) {\n    return null;\n  }\n  BufferedReader reader=null;\n  try {\n    InputStreamReader is=new InputStreamReader(new FileInputStream(file),charsetName);\n    reader=new BufferedReader(is);\n    String line=null;\n    while ((line=reader.readLine()) != null) {\n      fileContent.add(line);\n    }\n    reader.close();\n    return fileContent;\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"IOException occurred. \",e);\n  }\n finally {\n    if (reader != null) {\n      try {\n        reader.close();\n      }\n catch (      IOException e) {\n        throw new RuntimeException(\"IOException occurred. \",e);\n      }\n    }\n  }\n}\n", "nl": "read file to string list, a element of list is a line"}
{"code": "public IndexSegment(final IndexSegmentStore fileStore){\n  super(fileStore,ImmutableNodeFactory.INSTANCE,true,fileStore.getIndexMetadata(),fileStore.getIndexMetadata().getIndexSegmentRecordCompressorFactory());\n  this.fileStore=(IndexSegmentStore)fileStore;\n  _reopen();\n}\n", "nl": "Open a read-only index segment."}
{"code": "public QueryResultHandlerException(String msg){\n  super(msg);\n}\n", "nl": "Creates a new QueryResultHandlerException."}
{"code": "public static CSVFormat newFormat(final char delimiter){\n  return new CSVFormat(delimiter,null,null,null,null,false,false,null,null,null,false);\n}\n", "nl": "Creates a new CSV format with the specified delimiter."}
{"code": "public static EntropyRateCalculatorDiscrete newInstance(int base,int history){\n  return new EntropyRateCalculatorDiscrete(base,history);\n}\n", "nl": "User was formerly forced to create new instances through this factory method. Retained for backwards compatibility."}
{"code": "public StrTokenizer(final String input,final char delim){\n  this(input);\n  setDelimiterChar(delim);\n}\n", "nl": "Constructs a tokenizer splitting on the specified delimiter character."}
{"code": "private void updatePturb(){\n  double xj=0;\n  double yj=0;\n  for (int j=0; j < m_plots.size(); j++) {\n    PlotData2D temp_plot=(m_plots.get(j));\n    for (int i=0; i < temp_plot.m_plotInstances.numInstances(); i++) {\n      if (temp_plot.m_plotInstances.instance(i).isMissing(m_xIndex) || temp_plot.m_plotInstances.instance(i).isMissing(m_yIndex)) {\n      }\n else {\n        if (m_JitterVal > 0) {\n          xj=m_JRand.nextGaussian();\n          yj=m_JRand.nextGaussian();\n        }\n        temp_plot.m_pointLookup[i][2]=pturbX(temp_plot.m_pointLookup[i][0],xj);\n        temp_plot.m_pointLookup[i][3]=pturbY(temp_plot.m_pointLookup[i][1],yj);\n      }\n    }\n  }\n}\n", "nl": "Updates the perturbed values for the plots when the jitter value is changed"}
{"code": "@Override public void writeTo(OutputStream out) throws IOException {\n  out.write(buf,0,count);\n}\n", "nl": "Writes the complete contents of this byte array output stream to the specified output stream argument, as if by calling the output stream's write method using <code>out.write(buf, 0, count)</code>."}
{"code": "public GeneratorModel createGeneratorModel(){\n  GeneratorModelImpl generatorModel=new GeneratorModelImpl();\n  return generatorModel;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public final V remove(int index){\n  if (GWT.isScript()) {\n    V ret=jsArray.get(index);\n    jsArray.remove(index);\n    return ret;\n  }\n else {\n    return javaArray.remove(index);\n  }\n}\n", "nl": "Remove the element at the given position."}
{"code": "public void createDefaultState(final String fileContentDescription,final EditorType editorType,final Keymap keymap,final int numberOfLines,final int tabSize){\n  setCharPosition(null);\n  setLineNumber(numberOfLines);\n  setFileType(fileContentDescription);\n  setEditorTypeFromInstance(editorType);\n  setKeybindingsFromInstance(keymap);\n  setTabSize(tabSize);\n}\n", "nl": "Creates an initial state, before actual data is available."}
{"code": "static CipherSuite valueOf(int id1,int id2){\n  id1&=0xff;\n  id2&=0xff;\n  int id=(id1 << 8) | id2;\n  CipherSuite c=idMap.get(id);\n  if (c == null) {\n    String h1=Integer.toString(id1,16);\n    String h2=Integer.toString(id2,16);\n    c=new CipherSuite(\"Unknown 0x\" + h1 + \":0x\"+ h2,id);\n  }\n  return c;\n}\n", "nl": "Return a CipherSuite with the given ID. A temporary object is constructed if the ID is unknown. Use isAvailable() to verify that the CipherSuite can actually be used."}
{"code": "protected synchronized WebBackForwardList clone(){\n  throw new MustOverrideException();\n}\n", "nl": "Clone the entire object to be used in the UI thread by clients of WebView. This creates a copy that should never be modified by any of the webkit package classes."}
{"code": "public boolean isRevoked(Certificate cert){\n  if (!cert.getType().equals(\"X.509\")) {\n    throw new RuntimeException(\"X.509 CRL used with non X.509 Cert\");\n  }\n  TBSCertList.CRLEntry[] certs=c.getRevokedCertificates();\n  X500Name caName=c.getIssuer();\n  if (certs != null) {\n    BigInteger serial=((X509Certificate)cert).getSerialNumber();\n    for (int i=0; i < certs.length; i++) {\n      if (isIndirect && certs[i].hasExtensions()) {\n        Extension currentCaName=certs[i].getExtensions().getExtension(Extension.certificateIssuer);\n        if (currentCaName != null) {\n          caName=X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName());\n        }\n      }\n      if (certs[i].getUserCertificate().getValue().equals(serial)) {\n        X500Name issuer;\n        if (cert instanceof X509Certificate) {\n          issuer=X500Name.getInstance(((X509Certificate)cert).getIssuerX500Principal().getEncoded());\n        }\n else {\n          try {\n            issuer=org.bouncycastle.asn1.x509.Certificate.getInstance(cert.getEncoded()).getIssuer();\n          }\n catch (          CertificateEncodingException e) {\n            throw new RuntimeException(\"Cannot process certificate\");\n          }\n        }\n        if (!caName.equals(issuer)) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "nl": "Checks whether the given certificate is on this CRL."}
{"code": "public final boolean isOperationRunning(final int id){\n  return mChronosListener.isRunning(id);\n}\n", "nl": "Checks if an operation with given launch id is running."}
{"code": "@CanIgnoreReturnValue @Override public boolean put(@Nullable K key,@Nullable V value){\n  addNode(key,value,null);\n  return true;\n}\n", "nl": "Stores a key-value pair in the multimap."}
{"code": "protected Key engineUnwrap(byte[] wrappedKey,String wrappedKeyAlgorithm,int wrappedKeyType) throws InvalidKeyException, NoSuchAlgorithmException {\n  if (wrappedKey.length == 0) {\n    throw new InvalidKeyException(\"The wrapped key is empty\");\n  }\n  byte[] buffer=new byte[wrappedKey.length];\n  cipher.decrypt(wrappedKey,0,wrappedKey.length,buffer,0);\n  for (int i=0; i < buffer.length / 2; i++) {\n    byte temp=buffer[i];\n    buffer[i]=buffer[buffer.length - 1 - i];\n    buffer[buffer.length - 1 - i]=temp;\n  }\n  iv=new byte[IV_LEN];\n  System.arraycopy(buffer,0,iv,0,iv.length);\n  cipher.init(true,cipherKey.getAlgorithm(),cipherKey.getEncoded(),iv);\n  byte[] buffer2=new byte[buffer.length - iv.length];\n  cipher.decrypt(buffer,iv.length,buffer2.length,buffer2,0);\n  int keyValLen=buffer2.length - CHECKSUM_LEN;\n  byte[] cks=getChecksum(buffer2,0,keyValLen);\n  int offset=keyValLen;\n  for (int i=0; i < CHECKSUM_LEN; i++) {\n    if (buffer2[offset + i] != cks[i]) {\n      throw new InvalidKeyException(\"Checksum comparison failed\");\n    }\n  }\n  cipher.init(decrypting,cipherKey.getAlgorithm(),cipherKey.getEncoded(),IV2);\n  byte[] out=new byte[keyValLen];\n  System.arraycopy(buffer2,0,out,0,keyValLen);\n  return ConstructKeys.constructKey(out,wrappedKeyAlgorithm,wrappedKeyType);\n}\n", "nl": "Unwrap a previously wrapped key."}
{"code": "public byte[] toByteArray() throws IOException {\n  return text == null ? new byte[0] : text.getBytes(\"UTF-8\");\n}\n", "nl": "Returns the text in this <code>VirtualLocalFile</code> object in an <code>byte[]</code>."}
{"code": "private void interruptIdleWorkers(){\n  interruptIdleWorkers(false);\n}\n", "nl": "Common form of interruptIdleWorkers, to avoid having to remember what the boolean argument means."}
{"code": "protected Node copyInto(Node n){\n  super.copyInto(n);\n  AbstractElementNS ae=(AbstractElementNS)n;\n  ae.namespaceURI=namespaceURI;\n  return n;\n}\n", "nl": "Copy the fields of the current node into the given node."}
{"code": "private Future<ReplDBMSHeader> waitForCommittedEvent(WatchPredicate<ReplDBMSHeader> predicate,boolean cancel) throws InterruptedException {\n  return waitForEvent(predicate,cancel,commitWatches,true);\n}\n", "nl": "Set a watch on a committed event. This is an event that has been processed completely the task loop *and* committed. This must be synchronized to compute the minimum committed event."}
{"code": "public void go(){\n  dim.go();\n}\n", "nl": "Resumes execution of the script."}
{"code": "public void registerBugCollection(BugCollection bugCollection){\n}\n", "nl": "Register a BugCollection. This allows us to find the class and method hashes for BugInstances to be compared."}
{"code": "public Instances kNearestNeighbours(Instance target,int k) throws Exception {\n  MyHeap heap=new MyHeap(k);\n  if (m_Stats != null)   m_Stats.searchStart();\n  nearestNeighbours(heap,m_Root,target,k);\n  if (m_Stats != null)   m_Stats.searchFinish();\n  Instances neighbours=new Instances(m_Instances,heap.totalSize());\n  m_Distances=new double[heap.totalSize()];\n  int[] indices=new int[heap.totalSize()];\n  int i=1;\n  MyHeapElement h;\n  while (heap.noOfKthNearest() > 0) {\n    h=heap.getKthNearest();\n    indices[indices.length - i]=h.index;\n    m_Distances[indices.length - i]=h.distance;\n    i++;\n  }\n  while (heap.size() > 0) {\n    h=heap.get();\n    indices[indices.length - i]=h.index;\n    m_Distances[indices.length - i]=h.distance;\n    i++;\n  }\n  m_DistanceFunction.postProcessDistances(m_Distances);\n  for (i=0; i < indices.length; i++)   neighbours.add(m_Instances.instance(indices[i]));\n  return neighbours;\n}\n", "nl": "Returns k nearest instances in the current neighbourhood to the supplied instance. &gt;k instances can be returned if there is more than one instance  at the kth boundary (i.e. if there are more than 1 instance with the  same distance as the kth nearest neighbour)."}
{"code": "public SocketCommandServer(){\n  this(0,50,false);\n}\n", "nl": "Constructs a new instance using default configurations, i.e. an ephemeral port as the default port, a backlog valued <code>50</code>."}
{"code": "public static NbtInputStream fromDeflater(File in,NbtLimiter limiter) throws IOException {\n  return fromDeflater(new FileInputStream(in),limiter);\n}\n", "nl": "Construct new NbtInputStream for deflated data file and limiter."}
{"code": "public Builder user(final User user){\n  this.user=user;\n  return this;\n}\n", "nl": "Set user."}
{"code": "public static final String listToString(List<Object> l){\n  StringBuffer row=new StringBuffer();\n  for (  Object obj : l) {\n    row.append(obj.toString()).append(\" \");\n  }\n  return (row.toString());\n}\n", "nl": "returns a string with the elements of l separated by spaces"}
{"code": "public String pad(String value,int places,String padCharacter){\n  StringBuilder sb=new StringBuilder();\n  sb.append(value);\n  while (sb.length() < places) {\n    sb.append(padCharacter);\n  }\n  return sb.toString();\n}\n", "nl": "Pads spaces onto the end of the value to make it 'places' long"}
{"code": "public String toString(){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"java.util.Scanner\");\n  sb.append(\"[delimiters=\" + delimPattern + \"]\");\n  sb.append(\"[position=\" + position + \"]\");\n  sb.append(\"[match valid=\" + matchValid + \"]\");\n  sb.append(\"[need input=\" + needInput + \"]\");\n  sb.append(\"[source closed=\" + sourceClosed + \"]\");\n  sb.append(\"[skipped=\" + skipped + \"]\");\n  sb.append(\"[group separator=\" + groupSeparator + \"]\");\n  sb.append(\"[decimal separator=\" + decimalSeparator + \"]\");\n  sb.append(\"[positive prefix=\" + positivePrefix + \"]\");\n  sb.append(\"[negative prefix=\" + negativePrefix + \"]\");\n  sb.append(\"[positive suffix=\" + positiveSuffix + \"]\");\n  sb.append(\"[negative suffix=\" + negativeSuffix + \"]\");\n  sb.append(\"[NaN string=\" + nanString + \"]\");\n  sb.append(\"[infinity string=\" + infinityString + \"]\");\n  return sb.toString();\n}\n", "nl": "<p>Returns the string representation of this <code>Scanner</code>. The string representation of a <code>Scanner</code> contains information that may be useful for debugging. The exact format is unspecified."}
{"code": "private synchronized void block(boolean tf){\n  if (tf) {\n    try {\n      wait();\n    }\n catch (    InterruptedException ex) {\n    }\n  }\n else {\n    notifyAll();\n  }\n}\n", "nl": "Function used to stop code that calls acceptTrainingSet. This is needed as classifier construction is performed inside a separate thread of execution."}
{"code": "public boolean isPurge(){\n  return purge;\n}\n", "nl": "Returns true if all the offline messages of the user should be deleted."}
{"code": "public VolumeMonitor(SpeechController speechController,TalkBackService context){\n  if (speechController == null)   throw new IllegalStateException();\n  mContext=context;\n  mSpeechController=speechController;\n  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);\n  mTelephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);\n}\n", "nl": "Creates and initializes a new volume monitor."}
{"code": "public ResourceLineage(){\n  resourceMap=new LinkedMap<>();\n}\n", "nl": "Empty lineage for objects rooted in the URL."}
{"code": "public void normalise(){\n  this.dirty=true;\n  float mag=(float)Math.sqrt(points[3] * points[3] + points[0] * points[0] + points[1] * points[1] + points[2] * points[2]);\n  points[3]=points[3] / mag;\n  points[0]=points[0] / mag;\n  points[1]=points[1] / mag;\n  points[2]=points[2] / mag;\n}\n", "nl": "Normalise this Quaternion into a unity Quaternion."}
{"code": "protected void _addFields(){\n  final AnnotationIntrospector ai=_annotationIntrospector;\n  for (  AnnotatedField f : _classDef.fields()) {\n    String implName=f.getName();\n    String explName;\n    if (ai == null) {\n      explName=null;\n    }\n else     if (_forSerialization) {\n      explName=ai.findSerializablePropertyName(f);\n    }\n else {\n      explName=ai.findDeserializablePropertyName(f);\n    }\n    if (\"\".equals(explName)) {\n      explName=implName;\n    }\n    boolean visible=(explName != null);\n    if (!visible) {\n      visible=_visibilityChecker.isFieldVisible(f);\n    }\n    boolean ignored=(ai != null) && ai.hasIgnoreMarker(f);\n    _property(implName).addField(f,explName,visible,ignored);\n  }\n}\n", "nl": "Method for collecting basic information on all fields found"}
{"code": "public ParsedURL(String urlStr){\n  userAgent=getGlobalUserAgent();\n  data=parseURL(urlStr);\n}\n", "nl": "Construct a ParsedURL from the given url string."}
{"code": "public static void main(final String[] args){\n  DOMTestCase.doMain(attrgetownerelement04.class,args);\n}\n", "nl": "Runs this test from the command line."}
{"code": "private void _shutdownScheduledExecutorService(){\n  _logger.info(\"Shutting down scheduled disable warden alerts executor service\");\n  _scheduledExecutorService.shutdown();\n  try {\n    if (!_scheduledExecutorService.awaitTermination(5,TimeUnit.SECONDS)) {\n      _logger.warn(\"Shutdown of scheduled disable warden alerts executor service timed out after 5 seconds.\");\n      _scheduledExecutorService.shutdownNow();\n    }\n  }\n catch (  InterruptedException ex) {\n    _logger.warn(\"Shutdown of executor service was interrupted.\");\n    Thread.currentThread().interrupt();\n  }\n}\n", "nl": "Shuts down the scheduled executor service."}
{"code": "public final void removePoint(double x){\n  dataPoints--;\n  if (dataPoints <= 0) {\n    initialize();\n  }\n else {\n    sumX-=x;\n    sumXSq-=x * x;\n  }\n}\n", "nl": "Remove a X data point only."}
{"code": "public synchronized MetaStore storeTerm(long term){\n  LOGGER.debug(\"Store term {}\",term);\n  buffer.writeLong(0,term).flush();\n  return this;\n}\n", "nl": "Stores the current server term."}
{"code": "public EmailIntentBuilder bcc(@NonNull Collection<String> bcc){\n  checkNotNull(bcc);\n  for (  String email : bcc) {\n    checkEmail(email);\n  }\n  this.bcc.addAll(bcc);\n  return this;\n}\n", "nl": "Add an email address to be used in the \"bcc\" field."}
{"code": "public static java.lang.String valueOf(char c){\n  return null;\n}\n", "nl": "Returns the string representation of the char argument."}
{"code": "public static final boolean isASCII(Resources res,int resId) throws IOException, NotFoundException {\n  BufferedReader buffer=new BufferedReader(new InputStreamReader(res.openRawResource(resId)));\n  boolean isASCII=isASCII(buffer);\n  buffer.close();\n  return isASCII;\n}\n", "nl": "Determine if a given resource appears to be in ASCII format."}
{"code": "public synchronized void addTextListener(TextListener cl){\n  m_textListeners.addElement(cl);\n}\n", "nl": "Add a text listener"}
{"code": "private void tellClients(){\n  Player partner=SingletonRepository.getRuleProcessor().getPlayer(partnerName);\n  if (partner == null) {\n    player.addEvent(new TradeStateChangeEvent(-1,tradeState,TradeState.NO_ACTIVE_TRADE));\n  }\n else {\n    player.addEvent(new TradeStateChangeEvent(partner.getInt(\"id\"),tradeState,partner.getTradeState()));\n    partner.addEvent(new TradeStateChangeEvent(player.getInt(\"id\"),partner.getTradeState(),tradeState));\n    partner.notifyWorldAboutChanges();\n  }\n  player.notifyWorldAboutChanges();\n}\n", "nl": "inform both clients about the current state of trading."}
{"code": "private void distributeExtraSpace(int extraHeight){\n  int topSpacerHeight;\n  int middleSpacerHeight;\n  int bottomSpacerHeight;\n  if (extraHeight < mTotalSpacerHeight) {\n    topSpacerHeight=Math.round(extraHeight * (TOP_SPACER_HEIGHT_DP / TOTAL_SPACER_HEIGHT_DP));\n    extraHeight-=topSpacerHeight;\n    middleSpacerHeight=Math.round(extraHeight * (MIDDLE_SPACER_HEIGHT_DP / (MIDDLE_SPACER_HEIGHT_DP + BOTTOM_SPACER_HEIGHT_DP)));\n    extraHeight-=middleSpacerHeight;\n    bottomSpacerHeight=extraHeight;\n  }\n else {\n    topSpacerHeight=mTopSpacerHeight;\n    middleSpacerHeight=mMiddleSpacerHeight;\n    bottomSpacerHeight=mBottomSpacerHeight;\n    extraHeight-=mTotalSpacerHeight;\n    topSpacerHeight+=(extraHeight + 1) / 2;\n    bottomSpacerHeight+=extraHeight / 2;\n  }\n  int widthSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.EXACTLY);\n  mTopSpacer.measure(widthSpec,MeasureSpec.makeMeasureSpec(topSpacerHeight,MeasureSpec.EXACTLY));\n  mMiddleSpacer.measure(widthSpec,MeasureSpec.makeMeasureSpec(middleSpacerHeight,MeasureSpec.EXACTLY));\n  mBottomSpacer.measure(widthSpec,MeasureSpec.makeMeasureSpec(bottomSpacerHeight,MeasureSpec.EXACTLY));\n}\n", "nl": "Distribute extra vertical space between the three spacer views."}
{"code": "public static void updateVArrayRelations(Collection<StoragePort> ports,Collection<StoragePort> remPorts,DbClient dbClient,CoordinatorClient coordinator){\n  HashSet<URI> systemsToProcess=getStorageSytemsFromPorts(ports,remPorts);\n  for (  URI systemUri : systemsToProcess) {\n    updateSystemVarrays(systemUri,dbClient);\n  }\n}\n", "nl": "Given the changes made to a list of ports' varray associations, update the pools associations."}
{"code": "public XMLSignatureInput resolve(Attr uri,String baseURI,boolean secureValidation) throws ResourceResolverException {\n  ResourceResolverContext context=new ResourceResolverContext(uri,baseURI,secureValidation);\n  return resolverSpi.engineResolveURI(context);\n}\n", "nl": "Method resolve"}
{"code": "@Deprecated public static Uri addToGroup(ContentResolver resolver,long personId,long groupId){\n  ContentValues values=new ContentValues();\n  values.put(GroupMembership.PERSON_ID,personId);\n  values.put(GroupMembership.GROUP_ID,groupId);\n  return resolver.insert(GroupMembership.CONTENT_URI,values);\n}\n", "nl": "Adds a person to a group."}
{"code": "public static boolean putFloat(ContentResolver cr,String name,float value){\n  return putFloatForUser(cr,name,value,UserHandle.myUserId());\n}\n", "nl": "Convenience function for updating a single settings value as a floating point number. This will either create a new entry in the table if the given name does not exist, or modify the value of the existing row with that name.  Note that internally setting values are always stored as strings, so this function converts the given value to a string before storing it."}
{"code": "public CompactConcurrentHashSet2(int initialCapacity){\n  if (initialCapacity < 0)   throw new IllegalArgumentException();\n  int cap=((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n  this.sizeCtl=cap;\n}\n", "nl": "Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize."}
{"code": "protected void parseStartSound(InStream in) throws IOException {\n  int id=in.readUI16();\n  SoundInfo info=new SoundInfo(in);\n  tagtypes.tagStartSound(id,info);\n}\n", "nl": "Description of the Method"}
{"code": "public static void process(Process p,LineConsumer stdout) throws IOException {\n  try (BufferedReader inputReader=new BufferedReader(new InputStreamReader(p.getInputStream()))){\n    String line;\n    while ((line=inputReader.readLine()) != null) {\n      stdout.writeLine(line);\n    }\n  }\n }\n", "nl": "Writes stdout of the process to consumer.<br> Supposes that stderr of the process is redirected to stdout."}
{"code": "public UDView bringToFront(){\n  final View view=getView();\n  if (view != null) {\n    view.bringToFront();\n  }\n  return this;\n}\n", "nl": "bring a view to front"}
{"code": "public void runTest() throws Throwable {\n  String namespaceURI=\"http://www.ecommerce.org/schema\";\n  String qualifiedName=\"y:x\";\n  Document doc;\n  DocumentType docType=null;\n  DOMImplementation domImpl;\n  Document aNewDoc;\n  String nodeName;\n  String nodeValue;\n  doc=(Document)load(\"staffNS\",false);\n  domImpl=doc.getImplementation();\n  aNewDoc=domImpl.createDocument(namespaceURI,qualifiedName,docType);\n  nodeName=aNewDoc.getNodeName();\n  nodeValue=aNewDoc.getNodeValue();\n  assertEquals(\"nodeName\",\"#document\",nodeName);\n  assertNull(\"nodeValue\",nodeValue);\n}\n", "nl": "Runs the test case."}
{"code": "public boolean usesClass(String className){\n  return findClass(className) != NOT_FOUND;\n}\n", "nl": "Checks if the constant pool contains a reference to the provided class. NB: Most uses of a type do <em>NOT</em> show up as a class in the constant pool. For example, the parameter types and return type of any method you invoke or declare, are stored as signatures and not as type references, but the type to which any method you invoke belongs, is. Read the JVM Specification for more information."}
{"code": "boolean verifyDeveloperPayload(Purchase p){\n  String payload=p.getDeveloperPayload();\n  return true;\n}\n", "nl": "Verifies the developer payload of a purchase."}
{"code": "public static String printInferenceResult(InferenceResult ir){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"InferenceResult.isTrue=\" + ir.isTrue());\n  sb.append(\"\\n\");\n  sb.append(\"InferenceResult.isPossiblyFalse=\" + ir.isPossiblyFalse());\n  sb.append(\"\\n\");\n  sb.append(\"InferenceResult.isUnknownDueToTimeout=\" + ir.isUnknownDueToTimeout());\n  sb.append(\"\\n\");\n  sb.append(\"InferenceResult.isPartialResultDueToTimeout=\" + ir.isPartialResultDueToTimeout());\n  sb.append(\"\\n\");\n  sb.append(\"InferenceResult.#Proofs=\" + ir.getProofs().size());\n  sb.append(\"\\n\");\n  int proofNo=0;\n  for (  Proof p : ir.getProofs()) {\n    proofNo++;\n    sb.append(\"InferenceResult.Proof#\" + proofNo + \"=\\n\"+ ProofPrinter.printProof(p));\n  }\n  return sb.toString();\n}\n", "nl": "Utility method for outputting InferenceResults in a formatted textual representation."}
{"code": "private void validateUserNamespaceAuthorizationCreateRequest(UserNamespaceAuthorizationCreateRequest request){\n  Assert.notNull(request,\"A user namespace authorization create request must be specified.\");\n  validateUserNamespaceAuthorizationKey(request.getUserNamespaceAuthorizationKey());\n  validateNamespacePermissions(request.getNamespacePermissions());\n}\n", "nl": "Validates the user namespace authorization create request. This method also trims the request parameters."}
{"code": "final int dec(int i){\n  return ((i == 0) ? items.length : i) - 1;\n}\n", "nl": "Circularly decrement i."}
{"code": "public boolean isMarkSeen(){\n  return fieldMarkSeen;\n}\n", "nl": "Returns the markSeen."}
{"code": "public void addPlayer(final Player player){\n  this.onlinePlayers.add(player);\n}\n", "nl": "Adds a player object to the list of players."}
{"code": "public void checkLoadScript(String scriptType,ParsedURL scriptURL,ParsedURL docURL) throws SecurityException {\n  ScriptSecurity s=getScriptSecurity(scriptType,scriptURL,docURL);\n  if (s != null) {\n    s.checkLoadScript();\n  }\n}\n", "nl": "This method throws a SecurityException if the script of given type, found at url and referenced from docURL should not be loaded. This is a convenience method to call checkLoadScript on the ScriptSecurity strategy returned by  getScriptSecurity."}
{"code": "static public long longFactorial(int k) throws IllegalArgumentException {\n  if (k < 0)   throw new IllegalArgumentException(\"Negative k\");\n  if (k < longFactorials.length)   return longFactorials[k];\n  throw new IllegalArgumentException(\"Overflow\");\n}\n", "nl": "Instantly returns the factorial <tt>k!</tt>."}
{"code": "private void generatePaySelect(){\n  if (miniTable.getRowCount() == 0)   return;\n  miniTable.setSelectedIndices(new int[]{0});\n  calculateSelection();\n  if (m_noSelected == 0)   return;\n  String msg=generatePaySelect(miniTable,(ValueNamePair)fieldPaymentRule.getSelectedItem().getValue(),new Timestamp(fieldPayDate.getComponent().getValue().getTime()),(BankInfo)fieldBankAccount.getSelectedItem().getValue());\n  if (msg != null && msg.length() > 0) {\n    FDialog.error(m_WindowNo,form,\"SaveError\",msg);\n    return;\n  }\n  if (!FDialog.ask(m_WindowNo,form,\"VPaySelectGenerate?\",\"(\" + m_ps.getName() + \")\"))   return;\n  int AD_Proces_ID=155;\n  ProcessModalDialog dialog=new ProcessModalDialog(this,m_WindowNo,AD_Proces_ID,X_C_PaySelection.Table_ID,m_ps.getC_PaySelection_ID(),false);\n  if (dialog.isValid()) {\n    try {\n      dialog.setWidth(\"500px\");\n      dialog.setVisible(true);\n      dialog.setPage(form.getPage());\n      dialog.doModal();\n    }\n catch (    SuspendNotAllowedException e) {\n      log.log(Level.SEVERE,e.getLocalizedMessage(),e);\n    }\ncatch (    InterruptedException e) {\n      log.log(Level.SEVERE,e.getLocalizedMessage(),e);\n    }\n  }\n}\n", "nl": "Generate PaySelection"}
{"code": "public StatelessSection(int headerResourceId,int footerResourceId,int itemResourceId){\n  this(headerResourceId,itemResourceId);\n  this.footerResourceId=footerResourceId;\n  this.hasFooter=true;\n}\n", "nl": "Create a Section object with loading/failed states, a custom header and footer"}
{"code": "@Override public Object eGet(int featureID,boolean resolve,boolean coreType){\nswitch (featureID) {\ncase UmplePackage.ANONYMOUS_EVENT_DEFINITION_1__PARAMETER_LIST_1:\n    return getParameterList_1();\n}\nreturn super.eGet(featureID,resolve,coreType);\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public static void d(String tag,String msg,Throwable tr){\n  println(DEBUG,tag,msg,tr);\n}\n", "nl": "Prints a message at DEBUG priority."}
{"code": "public void evalMinAggregatedValue(final String field,final String fieldValue,final long value) throws RequiredInputMissingException {\n  if (StringUtils.isBlank(field))   throw new RequiredInputMissingException(\"Missing required input for parameter 'field'\");\n  if (StringUtils.isBlank(fieldValue))   throw new RequiredInputMissingException(\"Missing required input for parameter 'fieldValue'\");\n  String fieldKey=StringUtils.lowerCase(StringUtils.trim(field));\n  String fieldValueKey=StringUtils.lowerCase(StringUtils.trim(fieldValue));\n  Map<String,Long> fieldAggregationValues=this.aggregatedValues.get(fieldKey);\n  if (fieldAggregationValues == null)   fieldAggregationValues=new HashMap<>();\n  long aggregationValue=(fieldAggregationValues.containsKey(fieldValueKey) ? fieldAggregationValues.get(fieldValueKey) : Integer.MAX_VALUE);\n  if (value < aggregationValue) {\n    fieldAggregationValues.put(fieldValueKey,value);\n    this.aggregatedValues.put(fieldKey,fieldAggregationValues);\n  }\n}\n", "nl": "Evaluates the referenced aggregated value against the provided value and saves the smaller one"}
{"code": "public void receiveResendFileTransferInvitation(FileSharingSession session,ContactId remoteContact,String displayName){\n  if (sLogger.isActivated()) {\n    sLogger.info(\"Receive resend FT invitation from \" + remoteContact + \" displayName=\"+ displayName);\n  }\n  OneToOneFileTransferImpl oneToOneFileTransfer=getOrCreateOneToOneFileTransfer(session.getFileTransferId());\n  session.addListener(oneToOneFileTransfer);\n}\n", "nl": "Receive a new resend file transfer invitation"}
{"code": "public static ConjunctionOfClauses convert(Sentence s){\n  ConjunctionOfClauses result=null;\n  Sentence cnfSentence=ConvertToCNF.convert(s);\n  List<Clause> clauses=new ArrayList<Clause>();\n  clauses.addAll(ClauseCollector.getClausesFrom(cnfSentence));\n  result=new ConjunctionOfClauses(clauses);\n  return result;\n}\n", "nl": "Returns the specified sentence in its logically equivalent conjunction of clauses."}
{"code": "public void registerConverter(final SingleValueConverter converter){\n  registerConverter(converter,PRIORITY_NORMAL);\n}\n", "nl": "Register a single value converter with normal priority."}
{"code": "public SelfSignSslOkHttpStack(OkHttpClient okHttpClient,Map<String,SSLSocketFactory> factoryMap){\n  this.okHttpClient=okHttpClient;\n  this.socketFactoryMap=factoryMap;\n}\n", "nl": "Create a OkHttpStack with a custom OkHttpClient"}
{"code": "public AppletServer(int port,ClassPool src) throws IOException, NotFoundException, CannotCompileException {\n  this(new ClassPool(src),new StubGenerator(),port);\n}\n", "nl": "Constructs a web server."}
{"code": "public void taskClassName(String taskClsName){\n  this.taskClsName=taskClsName;\n}\n", "nl": "Sets name of the task class that triggered this event."}
{"code": "@Override public ServiceExceptionNotAuthorized rethrow(String msg){\n  return new ServiceExceptionNotAuthorized(msg,this);\n}\n", "nl": "Rethrows an exception to record the full stack trace, both caller and callee."}
{"code": "public List<Option> asSortedList(){\n  ArrayList<Option> options=new ArrayList<Option>();\n  if (if_match_list != null)   for (  byte[] value : if_match_list)   options.add(new Option(OptionNumberRegistry.IF_MATCH,value));\n  if (hasUriHost())   options.add(new Option(OptionNumberRegistry.URI_HOST,getUriHost()));\n  if (etag_list != null)   for (  byte[] value : etag_list)   options.add(new Option(OptionNumberRegistry.ETAG,value));\n  if (hasIfNoneMatch())   options.add(new Option(OptionNumberRegistry.IF_NONE_MATCH));\n  if (hasUriPort())   options.add(new Option(OptionNumberRegistry.URI_PORT,getUriPort()));\n  if (location_path_list != null)   for (  String str : location_path_list)   options.add(new Option(OptionNumberRegistry.LOCATION_PATH,str));\n  if (uri_path_list != null)   for (  String str : uri_path_list)   options.add(new Option(OptionNumberRegistry.URI_PATH,str));\n  if (hasContentFormat())   options.add(new Option(OptionNumberRegistry.CONTENT_FORMAT,getContentFormat()));\n  if (hasMaxAge())   options.add(new Option(OptionNumberRegistry.MAX_AGE,getMaxAge()));\n  if (uri_query_list != null)   for (  String str : uri_query_list)   options.add(new Option(OptionNumberRegistry.URI_QUERY,str));\n  if (hasAccept())   options.add(new Option(OptionNumberRegistry.ACCEPT,getAccept()));\n  if (location_query_list != null)   for (  String str : location_query_list)   options.add(new Option(OptionNumberRegistry.LOCATION_QUERY,str));\n  if (hasProxyUri())   options.add(new Option(OptionNumberRegistry.PROXY_URI,getProxyUri()));\n  if (hasProxyScheme())   options.add(new Option(OptionNumberRegistry.PROXY_SCHEME,getProxyScheme()));\n  if (hasObserve())   options.add(new Option(OptionNumberRegistry.OBSERVE,getObserve()));\n  if (hasBlock1())   options.add(new Option(OptionNumberRegistry.BLOCK1,getBlock1().getValue()));\n  if (hasBlock2())   options.add(new Option(OptionNumberRegistry.BLOCK2,getBlock2().getValue()));\n  if (hasSize1())   options.add(new Option(OptionNumberRegistry.SIZE1,getSize1()));\n  if (hasSize2())   options.add(new Option(OptionNumberRegistry.SIZE2,getSize2()));\n  if (others != null)   options.addAll(others);\n  Collections.sort(options);\n  return options;\n}\n", "nl": "Returns all options in a list sorted according to their option number. The list cannot be use to modify the OptionSet of the message, since it is a copy."}
{"code": "public SubscriptionMigrationException(){\n  super();\n}\n", "nl": "Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized."}
{"code": "public void clear(){\n  m.clear();\n}\n", "nl": "Removes all of the elements from this set. The set will be empty after this call returns."}
{"code": "public Node encode(Object obj){\n  Node node=null;\n  if (obj != null) {\n    String name=mxCodecRegistry.getName(obj);\n    mxObjectCodec enc=mxCodecRegistry.getCodec(name);\n    if (enc != null) {\n      node=enc.encode(this,obj);\n    }\n else {\n      if (obj instanceof Node) {\n        node=((Node)obj).cloneNode(true);\n      }\n else {\n        System.err.println(\"No codec for \" + name);\n      }\n    }\n  }\n  return node;\n}\n", "nl": "Encodes the specified object and returns the resulting XML node."}
{"code": "@Override public Adapter createAdapter(Notifier target){\n  return modelSwitch.doSwitch((EObject)target);\n}\n", "nl": "Creates an adapter for the <code>target</code>. <!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@Override public Automaton<LR1Item,LR1State> createAutomaton() throws GeneratorException {\n  return new LALR1AutomatonFactory().createAutomaton(this,grammarInfo);\n}\n", "nl": "Creates the DFA of the parser, consisting of states and edges (for shift and goto) connecting them."}
{"code": "public void close(){\n  AQUtility.close(close);\n  close=null;\n}\n", "nl": "Close any opened inputstream associated with the response. Call this method when finish parsing the response of a synchronous call."}
{"code": "public static void dropTable(SQLiteDatabase db,boolean ifExists){\n  String sql=\"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"'ADDRESS_BOOK'\";\n  db.execSQL(sql);\n}\n", "nl": "Drops the underlying database table."}
{"code": "public void progressbarReady(TextView downloadStatus,ProgressBar progressBar){\n  int status=Variable.getVariable().getDownloadStatus();\n  if (status == Constant.DOWNLOADING || status == Constant.PAUSE) {\n    try {\n      this.downloadStatusTV=downloadStatus;\n      initProgressBar(progressBar);\n      this.vh=(View)progressBar.getParent();\n      itemPosition=mapsRV.getChildAdapterPosition(vh);\n    }\n catch (    Exception e) {\n      e.getStackTrace();\n    }\n  }\n}\n", "nl": "Recycler view is ready to use"}
{"code": "public Object runSafely(Catbert.FastStack stack) throws Exception {\n  Widget cw=getWidget(stack);\n  Widget pw=getWidget(stack);\n  if (SageConstants.LITE)   return null;\n  if (cw != null && pw != null && pw.willContain(cw))   WidgetFidget.contain(pw,cw);\n  return null;\n}\n", "nl": "Creates a parent-child relationship between two Widgets. If the relationship already exists, this call has no effect. This new child will be the last child of the parent."}
{"code": "protected static String urlDecode(String str) throws UnsupportedEncodingException {\n  return URLDecoder.decode(str.replace(\"+\",\"%2B\"),\"UTF-8\");\n}\n", "nl": "Decode URL-encoded strings as UTF-8, and avoid converting \"+\" to space"}
{"code": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) public static LineByLineFileInputOperator restoreCheckPoint(LineByLineFileInputOperator checkPointOper,ByteArrayOutputStream bos) throws Exception {\n  Kryo kryo=new Kryo();\n  Input lInput=new Input(bos.toByteArray());\n  LineByLineFileInputOperator oper=kryo.readObject(lInput,checkPointOper.getClass());\n  lInput.close();\n  return oper;\n}\n", "nl": "Restores the checkpointed operator."}
{"code": "public Weight(String magnitude,WeightUnit unit){\n  this.magnitude=new BigDecimal(magnitude);\n  this.unit=unit;\n}\n", "nl": "Create a new <code>Weight</code>."}
{"code": "public SerialTurnout(String systemName,String userName){\n  super(systemName,userName);\n  tSystemName=systemName;\n  tBit=SerialAddress.getBitFromSystemName(systemName);\n}\n", "nl": "Create a Turnout object, with both system and user names. <P> 'systemName' was previously validated in SerialTurnoutManager"}
{"code": "public DistributedLogClientBuilder handshakeWithClientInfo(boolean enabled){\n  DistributedLogClientBuilder newBuilder=newBuilder(this);\n  newBuilder._clientConfig.setHandshakeWithClientInfo(enabled);\n  return newBuilder;\n}\n", "nl": "Whether to use the new handshake endpoint to exchange ownership cache. Enable this when the servers are updated to support handshaking with client info."}
{"code": "public void fireSynapseChanged(final Synapse changed){\n  for (  SynapseListener listener : synapseListeners) {\n    listener.synapseChanged(new NetworkEvent<Synapse>(this,changed));\n  }\n}\n", "nl": "Fire a synapse changed event to all registered model listeners."}
{"code": "public boolean checkValidity(){\n  Matcher matcher=sValidityPattern.matcher(getFieldName());\n  isValid=matcher.find();\n  return isValid;\n}\n", "nl": "Check validity of field name"}
{"code": "public void ensureCapacity(int additionalCapacity){\n  int sizeNeeded=size + additionalCapacity;\n  if (sizeNeeded >= threshold)   resize(MathUtils.nextPowerOfTwo((int)(sizeNeeded / loadFactor)));\n}\n", "nl": "Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many items to avoid multiple backing array resizes."}
{"code": "public synchronized void write(byte b[],int off,int len) throws IOException {\n  out.write(b,off,len);\n  incCount(len);\n}\n", "nl": "Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to the underlying output stream. If no exception is thrown, the counter <code>written</code> is incremented by <code>len</code>."}
{"code": "private Headers parseResponseHeaders(URI uri,int responseCode,Map<String,List<String>> responseHeaders){\n  try {\n    NoHttp.getCookieManager().put(uri,responseHeaders);\n  }\n catch (  IOException e) {\n    Logger.e(e,\"Save cookie filed: \" + uri.toString() + \".\");\n  }\n  Headers headers=new HttpHeaders();\n  headers.set(responseHeaders);\n  headers.set(Headers.HEAD_KEY_RESPONSE_CODE,Integer.toString(responseCode));\n  for (  String headKey : headers.keySet()) {\n    List<String> headValues=headers.getValues(headKey);\n    for (    String headValue : headValues) {\n      StringBuilder builder=new StringBuilder();\n      if (!TextUtils.isEmpty(headKey))       builder.append(headKey).append(\": \");\n      if (!TextUtils.isEmpty(headValue))       builder.append(headValue);\n      Logger.i(builder.toString());\n    }\n  }\n  return headers;\n}\n", "nl": "Parse server response headers, here will save cookies."}
{"code": "protected void illegalMessageReceived(OFMessage m){\n  String msg=getSwitchStateMessage(m,\"Switch should never send this message in the current state\");\n  throw new SwitchStateException(msg);\n}\n", "nl": "We have an OFMessage we didn't expect given the current state and we want to treat this as an error. We currently throw an exception that will terminate the connection However, we could be more forgiving"}
{"code": "public WordsToTokens(Parser p){\n  parser=p;\n}\n", "nl": "Creates the parser."}
{"code": "public static ArrayList<Coords> intervening(Coords src,Coords dest,boolean split){\n  IdealHex iSrc=IdealHex.get(src);\n  IdealHex iDest=IdealHex.get(dest);\n  int[] directions=new int[3];\n  int centerDirection=src.direction(dest);\n  if (split) {\n    centerDirection=(int)Math.round(src.radian(dest) + 0.0001 / HEXSIDE) % 6;\n  }\n  directions[2]=centerDirection;\n  directions[1]=(centerDirection + 5) % 6;\n  directions[0]=(centerDirection + 1) % 6;\n  ArrayList<Coords> hexes=new ArrayList<>();\n  Coords current=src;\n  hexes.add(current);\n  while (!dest.equals(current)) {\n    current=Coords.nextHex(current,iSrc,iDest,directions);\n    hexes.add(current);\n  }\n  return hexes;\n}\n", "nl": "Returns an array of the Coords of hexes that are crossed by a straight line from the center of src to the center of dest, including src & dest. The returned coordinates are in line order, and if the line passes directly between two hexes, it returns them both. Based on the degree of the angle, the next hex is going to be one of three hexes. We check those three hexes, sides first, add the first one that intersects and continue from there. Based off of some of the formulas at Amit's game programming site. (http://www-cs-students.stanford.edu/~amitp/gameprog.html) Note: this function can return Coordinates that are not on the board."}
{"code": "private GeofenceErrorMessages(){\n}\n", "nl": "Prevents instantiation."}
{"code": "public static <STATE,ACTION,PLAYER>IterativeDeepeningAlphaBetaSearch<STATE,ACTION,PLAYER> createFor(Game<STATE,ACTION,PLAYER> game,double utilMin,double utilMax,int time){\n  return new IterativeDeepeningAlphaBetaSearch<STATE,ACTION,PLAYER>(game,utilMin,utilMax,time);\n}\n", "nl": "Creates a new search object for a given game."}
{"code": "public Depend_ createDepend_(){\n  Depend_Impl depend_=new Depend_Impl();\n  return depend_;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "public DragControl(){\n}\n", "nl": "Creates a new drag control that issues repaint requests as an item is dragged."}
{"code": "public double eval(double params[]){\n  double p1=params[0];\n  double p2=params[1];\n  return (p1 != p2) ? p1 : p2;\n}\n", "nl": "Evaluate Ifne2 with the 2 parameters x,y such that If (x != y) then x else y."}
{"code": "public final GVector subSelf(GVector vector){\n  if (length != vector.length) {\n    throw new MatrixSizeException();\n  }\n  for (int i=0; i < length; i++) {\n    this.values[i]-=vector.values[i];\n  }\n  return this;\n}\n", "nl": "Sets the value of this vector to the vector difference of itself and vector (this = this - vector)."}
{"code": "public void add(Collection geometries){\n  for (Iterator i=geometries.iterator(); i.hasNext(); ) {\n    Geometry geometry=(Geometry)i.next();\n    add(geometry);\n  }\n}\n", "nl": "Adds a collection of Geometries to be processed. May be called multiple times. Any dimension of Geometry may be added; the constituent linework will be extracted."}
{"code": "public boolean hasOpenTradePosition(){\n  if (null == getOpenTradePosition()) {\n    return false;\n  }\n  return true;\n}\n", "nl": "Method hasOpenTradePosition."}
{"code": "@Override public synchronized void removeConfigurationListener(ConfigurationListener cl){\n}\n", "nl": "We don't have to keep track of configuration listeners (see the documentation for ConfigurationListener/ConfigurationEvent)."}
{"code": "protected void showPopup(Iterator<String> iter){\n  getPopupComponent();\n  boolean different=false;\n  Vector<String> v=new Vector<String>();\n  ListModel<String> model=entryList.getModel();\n  for (int i=0; iter.hasNext(); i++) {\n    String next=iter.next();\n    v.add(next);\n    if (!different && i < model.getSize())     different|=!next.equals(model.getElementAt(i));\n  }\n  different|=model.getSize() != v.size();\n  if (different) {\n    entryList.setListData(v);\n    entryList.clearSelection();\n  }\n  entryList.setCurrentText(getText());\n  showPopup();\n}\n", "nl": "Fills the popup with text & shows it."}
{"code": "public boolean isHighlightable(OMGraphic omg){\n  return false;\n}\n", "nl": "Don't need DTEDFrames highlighting themselves."}
{"code": "@ObjectiveCName(\"registerApplePushWithApnsId:withToken:\") public void registerApplePush(int apnsId,String token){\n  modules.getPushesModule().registerApplePush(apnsId,token);\n}\n", "nl": "Register apple push"}
{"code": "public StructImpl(StructTypeImpl type,Object[] values){\n  if (type == null) {\n    throw new IllegalArgumentException(LocalizedStrings.StructImpl_TYPE_MUST_NOT_BE_NULL.toLocalizedString());\n  }\n  this.type=type;\n  this.values=values;\n  if (this.values != null) {\n    for (    Object o : values) {\n      if (o instanceof PdxInstance || o instanceof PdxString) {\n        this.hasPdx=true;\n        break;\n      }\n    }\n  }\n}\n", "nl": "Creates a new instance of StructImpl"}
{"code": "public GOCDataBuilder withSeverity(final int smSeverityc){\n  this.smSeverityc=smSeverityc;\n  return this;\n}\n", "nl": "Specifies the severity."}
{"code": "@Override public Experiment read(File file){\n  Experiment result;\n  FileReader freader;\n  BufferedReader breader;\n  String line;\n  result=null;\n  freader=null;\n  breader=null;\n  try {\n    freader=new FileReader(file);\n    breader=new BufferedReader(freader);\n    line=breader.readLine();\n    result=OptionUtils.fromCommandLine(Experiment.class,line);\n  }\n catch (  Exception e) {\n    result=null;\n    handleException(\"Failed to read experiment from: \" + file,e);\n  }\n finally {\n    FileUtils.closeQuietly(breader);\n    FileUtils.closeQuietly(freader);\n  }\n  return result;\n}\n", "nl": "Reads an experiment from disk."}
{"code": "int encryptFinal(byte[] plain,int plainOffset,int plainLen,byte[] cipher,int cipherOffset){\n  int oddBytes=plainLen % numBytes;\n  int len=encrypt(plain,plainOffset,(plainLen - oddBytes),cipher,cipherOffset);\n  plainOffset+=len;\n  cipherOffset+=len;\n  if (oddBytes != 0) {\n    embeddedCipher.encryptBlock(register,0,k,0);\n    for (int i=0; i < oddBytes; i++) {\n      cipher[i + cipherOffset]=(byte)(k[i] ^ plain[i + plainOffset]);\n    }\n  }\n  return plainLen;\n}\n", "nl": "Performs the last encryption operation. <p>The input plain text <code>plain</code>, starting at <code>plainOffset</code> and ending at <code>(plainOffset + plainLen - 1)</code>, is encrypted. The result is stored in <code>cipher</code>, starting at <code>cipherOffset</code>."}
{"code": "public static <T>T deserializeFile(String path,Class<T> clazz){\n  try {\n    JAXBContext context=JAXBContext.newInstance(clazz);\n    Unmarshaller m=context.createUnmarshaller();\n    Object o=m.unmarshal(new FileInputStream(path));\n    return clazz.cast(o);\n  }\n catch (  JAXBException e) {\n    e.printStackTrace();\n  }\ncatch (  FileNotFoundException e) {\n    e.printStackTrace();\n  }\n  return null;\n}\n", "nl": "Reads a file and deserializes it to an object of given class."}
{"code": "private void addHyperlinkToken(int start,int end,int tokenType){\n  int so=start + offsetShift;\n  addToken(zzBuffer,start,end,tokenType,so,true);\n}\n", "nl": "Adds the token specified to the current linked list of tokens."}
{"code": "public boolean hasRemaining(){\n  boolean rem=_buf.hasRemaining();\n  return rem;\n}\n", "nl": "Returns true if this buffer has remaining bytes, false otherwise."}
{"code": "public static boolean exists(String path){\n  File f=new File(path);\n  return f.exists();\n}\n", "nl": "Checks if the path given exists. No distinction is made between a file or directory"}
{"code": "public boolean isEmpty(){\n  return count == 0;\n}\n", "nl": "<p> Tests if this hashtable maps no keys to values. </p>"}
{"code": "private void closeRepository(String name,RepositoryHolder holder) throws IOException {\n  logger.debug(\"closing repository [{}][{}]\",holder.type,name);\n  if (holder.repository != null) {\n    holder.repository.close();\n  }\n}\n", "nl": "Closes the repository"}
{"code": "public StrBuilder deleteAll(final StrMatcher matcher){\n  return replace(matcher,null,0,size,-1);\n}\n", "nl": "Deletes all parts of the builder that the matcher matches. <p> Matchers can be used to perform advanced deletion behaviour. For example you could write a matcher to delete all occurrences where the character 'a' is followed by a number."}
{"code": "public static boolean[] copyOfRange(boolean[] original,int start,int end){\n  if (start <= end) {\n    if (original.length >= start && 0 <= start) {\n      int length=end - start;\n      int copyLength=Math.min(length,original.length - start);\n      boolean[] copy=new boolean[length];\n      System.arraycopy(original,start,copy,0,copyLength);\n      return copy;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  throw new IllegalArgumentException();\n}\n", "nl": "Copies elements in original array to a new array, from index start(inclusive) to end(exclusive). The first element (if any) in the new array is original[from], and other elements in the new array are in the original order. The padding value whose index is bigger than or equal to original.length - start is false."}
{"code": "@Pure public final int hashCode(){\n  return super.hashCode();\n}\n", "nl": "Returns a hash code for this enum constant."}
{"code": "private boolean checkPlayServices(){\n  int resultCode=GooglePlayServicesUtil.isGooglePlayServicesAvailable(this);\n  if (resultCode != ConnectionResult.SUCCESS) {\n    if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n      GooglePlayServicesUtil.getErrorDialog(resultCode,this,PLAY_SERVICES_RESOLUTION_REQUEST).show();\n    }\n else {\n      Log.i(\"LOG\",\"This device is not supported.\");\n      finish();\n    }\n    return false;\n  }\n  return true;\n}\n", "nl": "Check the device to make sure it has the Google Play Services APK. If it doesn't, display a dialog that allows users to download the APK from the Google Play Store or enable it in the device's system settings."}
{"code": "public BooleanPropertyAttributeType createBooleanPropertyAttributeTypeFromString(EDataType eDataType,String initialValue){\n  BooleanPropertyAttributeType result=BooleanPropertyAttributeType.get(initialValue);\n  if (result == null)   throw new IllegalArgumentException(\"The value '\" + initialValue + \"' is not a valid enumerator of '\"+ eDataType.getName()+ \"'\");\n  return result;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "protected GraphicsNode instantiateGraphicsNode(){\n  return null;\n}\n", "nl": "Creates the GraphicsNode depending on the GraphicsNodeBridge implementation."}
{"code": "protected void uploadTestDataFilesToS3(String s3KeyPrefix,List<ManifestFile> manifestFiles) throws Exception {\n  uploadTestDataFilesToS3(s3KeyPrefix,manifestFiles,new ArrayList<String>());\n}\n", "nl": "Creates locally and uploads to S3 the specified list of test data files."}
{"code": "static public String name(){\n  String releaseName;\n  if (official) {\n    String addOn;\n    if (\"unknown\".equals(revisionId)) {\n      addOn=buildDate;\n    }\n else {\n      addOn=\"R\" + revisionId;\n    }\n    releaseName=major + \".\" + minor+ getModifier()+ \"-\"+ addOn;\n  }\n else {\n    String addOn;\n    if (\"unknown\".equals(revisionId)) {\n      addOn=buildDate + \"-\" + buildUser;\n    }\n else {\n      addOn=buildDate + \"-\" + buildUser+ \"-R\"+ revisionId;\n    }\n    releaseName=major + \".\" + minor+ getModifier()+ \"-\"+ addOn;\n  }\n  return releaseName;\n}\n", "nl": "Provide the current version string. <P> This string is built using various known build parameters, including the versionBundle.{major,minor,build} values, the Git revision ID (if known) and the official property"}
{"code": "@DSComment(\"OS Bundle data structure\") @DSSafe(DSCat.DATA_STRUCTURE) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:36.474 -0500\",hash_original_method=\"E7336EB9055C9F862A0B8D336BB5AE0F\",hash_generated_method=\"9B77596588C53FA62A7F6A9D3F01E4F8\") public void putString(String key,String value){\n  unparcel();\n  mMap.put(key,value);\n}\n", "nl": "Inserts a String value into the mapping of this Bundle, replacing any existing value for the given key.  Either key or value may be null."}
{"code": "@Deprecated public void compact(int[] map,int numValuesAllocated){\n  if (true) {\n    throw new UnsupportedOperationException();\n  }\n  ArrayList<ValueNumber> oldList=this.allocatedValueList;\n  ArrayList<ValueNumber> newList=new ArrayList<ValueNumber>(Collections.<ValueNumber>nCopies(numValuesAllocated,null));\n  for (  ValueNumber value : oldList) {\n    int newNumber=map[value.getNumber()];\n    if (newNumber >= 0) {\n      newList.set(newNumber,value);\n    }\n  }\n  this.allocatedValueList=newList;\n}\n", "nl": "Compact the value numbers produced by this factory."}
{"code": "public ImageResizer(Context context,int imageWidth,int imageHeight){\n  super(context);\n  setImageSize(imageWidth,imageHeight);\n}\n", "nl": "Initialize providing a single target image size (used for both width and height);"}
{"code": "@DSComment(\"Private Method\") @DSBan(DSCat.PRIVATE_METHOD) @DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2013-12-30 12:33:12.301 -0500\",hash_original_method=\"6C44E95231996B5164D16D96A5AF9CAD\",hash_generated_method=\"40B9E65FBFB1331A55BF5EE628C65CE7\") private void nativeLoadUrl(String url,Map<String,String> headers){\n  addTaint(url.getTaint());\n  addTaint(headers.getTaint());\n}\n", "nl": "Returns false if the url is bad."}
{"code": "public static DecomposableMatchBuilder1<Byte,Byte> caseByte(MatchesAny b){\n  List<Matcher<Object>> matchers=new ArrayList<>();\n  matchers.add(any());\n  return new DecomposableMatchBuilder1<>(matchers,0,new PrimitiveFieldExtractor<>(Byte.class));\n}\n", "nl": "Matches a byte. <p>If matched, the byte value is extracted."}
{"code": "@Override @SideEffectFree public Object clone(){\n  try {\n    Locale that=(Locale)super.clone();\n    return that;\n  }\n catch (  CloneNotSupportedException e) {\n    throw new InternalError(e);\n  }\n}\n", "nl": "Overrides Cloneable."}
{"code": "@Override public synchronized void acceptDataSet(ThresholdDataEvent e){\n  if (m_env == null) {\n    m_env=Environment.getSystemWide();\n  }\n  if (!GraphicsEnvironment.isHeadless()) {\n    if (m_visPanel == null) {\n      m_visPanel=new VisualizePanel();\n    }\n    if (m_masterPlot == null) {\n      m_masterPlot=e.getDataSet();\n    }\n    try {\n      if (!m_masterPlot.getPlotInstances().relationName().equals(e.getDataSet().getPlotInstances().relationName())) {\n        m_masterPlot=e.getDataSet();\n        m_visPanel.setMasterPlot(m_masterPlot);\n        m_visPanel.validate();\n        m_visPanel.repaint();\n      }\n else {\n        m_visPanel.addPlot(e.getDataSet());\n        m_visPanel.validate();\n        m_visPanel.repaint();\n      }\n      m_visPanel.setXIndex(4);\n      m_visPanel.setYIndex(5);\n    }\n catch (    Exception ex) {\n      System.err.println(\"Problem setting up visualization (ModelPerformanceChart)\");\n      ex.printStackTrace();\n    }\n  }\n else {\n    m_headlessEvents.add(e);\n  }\n  if (m_imageListeners.size() > 0 && !m_processingHeadlessEvents) {\n    setupOffscreenRenderer();\n    if (m_offscreenPlotData == null || !m_offscreenPlotData.get(0).relationName().equals(e.getDataSet().getPlotInstances().relationName())) {\n      m_offscreenPlotData=new ArrayList<Instances>();\n      m_thresholdSeriesTitles=new ArrayList<String>();\n    }\n    m_offscreenPlotData.add(e.getDataSet().getPlotInstances());\n    m_thresholdSeriesTitles.add(e.getDataSet().getPlotName());\n    List<String> options=new ArrayList<String>();\n    String additional=\"-color=/last\";\n    if (m_additionalOptions != null && m_additionalOptions.length() > 0) {\n      additional=m_additionalOptions;\n      try {\n        additional=m_env.substitute(additional);\n      }\n catch (      Exception ex) {\n      }\n    }\n    String[] optsParts=additional.split(\",\");\n    for (    String p : optsParts) {\n      options.add(p.trim());\n    }\n    String xAxis=\"False Positive Rate\";\n    if (m_xAxis != null && m_xAxis.length() > 0) {\n      xAxis=m_xAxis;\n      try {\n        xAxis=m_env.substitute(xAxis);\n      }\n catch (      Exception ex) {\n      }\n    }\n    String yAxis=\"True Positive Rate\";\n    if (m_yAxis != null && m_yAxis.length() > 0) {\n      yAxis=m_yAxis;\n      try {\n        yAxis=m_env.substitute(yAxis);\n      }\n catch (      Exception ex) {\n      }\n    }\n    String width=m_width;\n    String height=m_height;\n    int defWidth=500;\n    int defHeight=400;\n    try {\n      width=m_env.substitute(width);\n      height=m_env.substitute(height);\n      defWidth=Integer.parseInt(width);\n      defHeight=Integer.parseInt(height);\n    }\n catch (    Exception ex) {\n    }\n    try {\n      List<Instances> series=new ArrayList<Instances>();\n      for (int i=0; i < m_offscreenPlotData.size(); i++) {\n        Instances temp=new Instances(m_offscreenPlotData.get(i));\n        temp.setRelationName(m_thresholdSeriesTitles.get(i));\n        series.add(temp);\n      }\n      BufferedImage osi=m_offscreenRenderer.renderXYLineChart(defWidth,defHeight,series,xAxis,yAxis,options);\n      ImageEvent ie=new ImageEvent(this,osi);\n      notifyImageListeners(ie);\n    }\n catch (    Exception e1) {\n      e1.printStackTrace();\n    }\n  }\n}\n", "nl": "Display a threshold curve."}
{"code": "@Override protected EClass eStaticClass(){\n  return GamlPackage.Literals.EQUATION_DEFINITION;\n}\n", "nl": "<!-- begin-user-doc --> <!-- end-user-doc -->"}
{"code": "@SuppressWarnings(\"unchecked\") public static void matchBlockSystemPools(Object systemPools,Object dbClient,Object coordinator,Object systemId) throws Exception {\n  List<StoragePool> modifiedPools=new ArrayList<StoragePool>(((Map<URI,StoragePool>)systemPools).values());\n  StringBuffer errorMessage=new StringBuffer();\n  matchModifiedStoragePoolsWithAllVpool(modifiedPools,(DbClient)dbClient,(CoordinatorClient)coordinator,(URI)systemId,errorMessage);\n}\n", "nl": "Match block system pools with all VirtualPool. This method will be invoked only for block storage systems. This method is written as per the plugin design."}
{"code": "private void renewEntityCapsVersion(){\n  if (capsManager != null && capsManager.entityCapsEnabled())   capsManager.updateLocalEntityCaps();\n}\n", "nl": "Updates the Entity Capabilities Verification String if EntityCaps is enabled"}
{"code": "SavedState(Parcelable superState){\n  super(superState);\n}\n", "nl": "Called by onSaveInstanceState."}
{"code": "public void computeSquadronBombLoadout(){\n  for (  Mounted bomb : bombList) {\n    equipmentList.remove(bomb);\n  }\n  bombList.clear();\n  for (int btype=0; btype < BombType.B_NUM; btype++) {\n    int maxBombCount=0;\n    for (    Integer fId : fighters) {\n      int bombCount=0;\n      Aero fighter=(Aero)game.getEntity(fId);\n      ArrayList<Mounted> bombs=fighter.getBombs();\n      for (      Mounted m : bombs) {\n        if (((BombType)m.getType()).getBombType() == btype) {\n          bombCount++;\n        }\n      }\n      maxBombCount=Math.max(bombCount,maxBombCount);\n    }\n    bombChoices[btype]=maxBombCount;\n  }\n  int gameTL=TechConstants.getSimpleLevel(game.getOptions().stringOption(\"techlevel\"));\n  for (int type=0; type < BombType.B_NUM; type++) {\n    for (int i=0; i < bombChoices[type]; i++) {\n      if ((type == BombType.B_ALAMO) && !game.getOptions().booleanOption(\"at2_nukes\")) {\n        continue;\n      }\n      if ((type > BombType.B_TAG) && (gameTL < TechConstants.T_SIMPLE_ADVANCED)) {\n        continue;\n      }\n      if ((null != BombType.getBombWeaponName(type)) && (type != BombType.B_ARROW) && (type != BombType.B_HOMING)) {\n        try {\n          addBomb(EquipmentType.get(BombType.getBombWeaponName(type)),LOC_NOSE);\n        }\n catch (        LocationFullException ex) {\n        }\n      }\n      if ((type != BombType.B_TAG) && (null == BombType.getBombWeaponName(type))) {\n        try {\n          addEquipment(EquipmentType.get(BombType.getBombInternalName(type)),LOC_NOSE,false);\n        }\n catch (        LocationFullException ex) {\n        }\n      }\n    }\n    bombChoices[type]=0;\n  }\n  if (game.getOptions().booleanOption(\"stratops_space_bomb\") && game.getBoard().inSpace() && (getBombs(AmmoType.F_SPACE_BOMB).size() > 0)) {\n    try {\n      addEquipment(EquipmentType.get(SPACE_BOMB_ATTACK),LOC_NOSE,false);\n    }\n catch (    LocationFullException ex) {\n    }\n  }\n  if (!game.getBoard().inSpace() && (getBombs(AmmoType.F_GROUND_BOMB).size() > 0)) {\n    try {\n      addEquipment(EquipmentType.get(DIVE_BOMB_ATTACK),LOC_NOSE,false);\n    }\n catch (    LocationFullException ex) {\n    }\n    for (int i=0; i < Math.min(10,getBombs(AmmoType.F_GROUND_BOMB).size()); i++) {\n      try {\n        addEquipment(EquipmentType.get(ALT_BOMB_ATTACK),LOC_NOSE,false);\n      }\n catch (      LocationFullException ex) {\n      }\n    }\n  }\n  updateWeaponGroups();\n  loadAllWeapons();\n}\n", "nl": "This method looks at the bombs equipped on all the fighters in the squadron and determines what possible bombing attacks the squadrons can make. TODO: Make this into a generic \"clean up bomb loadout\" method"}
{"code": "public final double correct(){\n  return m_Correct;\n}\n", "nl": "Gets the number of instances correctly classified (that is, for which a correct prediction was made). (Actually the sum of the weights of these instances)"}
{"code": "public void run(InterpreterContextRunner runner){\n  sendEvent(new RemoteInterpreterEvent(RemoteInterpreterEventType.RUN_INTERPRETER_CONTEXT_RUNNER,gson.toJson(runner)));\n}\n", "nl": "Run paragraph"}
{"code": "public PagedQuery(final String query,final QueryLanguage language,final int requestLimit,final int requestOffset){\n  LOGGER.debug(\"Query Language: {}, requestLimit: \" + requestLimit + \", requestOffset: \"+ requestOffset,language);\n  LOGGER.debug(\"Query: {}\",query);\n  String rval=query;\n  hasLimitAndOffset=requestLimit > 0;\n  if (hasLimitAndOffset) {\n    int queryLimit=-1;\n    int queryOffset=-1;\n    final Matcher matcher=LIMIT_OR_OFFSET.matcher(query);\n    while (matcher.find()) {\n      final String clause=matcher.group().toLowerCase();\n      final int value=Integer.parseInt(SPLITTER.split(clause)[1]);\n      if (clause.startsWith(\"limit\")) {\n        if (query.indexOf('}',matcher.end()) < 0) {\n          queryLimit=value;\n        }\n      }\n else {\n        queryOffset=value;\n      }\n    }\n    final boolean queryLimitExists=(queryLimit >= 0);\n    final boolean queryOffsetExists=(queryOffset >= 0);\n    final int maxQueryCount=getMaxQueryResultCount(queryLimit,queryOffset,queryLimitExists,queryOffsetExists);\n    final int offset=(requestOffset < 0) ? 0 : requestOffset;\n    final int maxRequestCount=requestLimit + offset;\n    limitSubstitute=(maxRequestCount < maxQueryCount) ? requestLimit : queryLimit - offset;\n    offsetSubstitute=queryOffsetExists ? queryOffset + offset : offset;\n    rval=modifyLimit(language,rval,queryLimit,queryLimitExists,queryOffsetExists,limitSubstitute);\n    rval=modifyOffset(language,offset,rval,queryOffsetExists);\n    LOGGER.debug(\"Modified Query: {}\",rval);\n  }\n  this.modifiedQuery=rval;\n}\n", "nl": "<p> Creates an object that adds or modifies the limit and offset clauses of the query to be executed so that only those results to be displayed are requested from the query engine. </p> <p> Implementation note: The new object contains the user's query with appended or modified LIMIT and OFFSET clauses. </p>"}
{"code": "public RectHV(double xmin,double ymin,double xmax,double ymax){\n  if (Double.isNaN(xmin) || Double.isNaN(xmax))   throw new IllegalArgumentException(\"x-coordinate cannot be NaN\");\n  if (Double.isNaN(ymin) || Double.isNaN(ymax))   throw new IllegalArgumentException(\"y-coordinates cannot be NaN\");\n  if (xmax < xmin || ymax < ymin) {\n    throw new IllegalArgumentException(\"Invalid rectangle\");\n  }\n  this.xmin=xmin;\n  this.ymin=ymin;\n  this.xmax=xmax;\n  this.ymax=ymax;\n}\n", "nl": "Initializes a new rectangle [<em>xmin</em>, <em>xmax</em>] x [<em>ymin</em>, <em>ymax</em>]."}
{"code": "public static List<org.oscm.vo.VOCatalogEntry> convertToApiVOCatalogEntry(List<org.oscm.internal.vo.VOCatalogEntry> oldVO){\n  if (oldVO == null) {\n    return null;\n  }\n  List<org.oscm.vo.VOCatalogEntry> newVO=new ArrayList<org.oscm.vo.VOCatalogEntry>();\n  for (  org.oscm.internal.vo.VOCatalogEntry tmp : oldVO) {\n    newVO.add(convertToApi(tmp));\n  }\n  return newVO;\n}\n", "nl": "Convert list of LdapProperties."}
{"code": "public void startCheck(){\n  checker=new Thread(new CheckForUpdate());\n  checker.setPriority(Thread.MIN_PRIORITY);\n  checker.start();\n}\n", "nl": "Start key pair generation in a separate thread."}
{"code": "@Override public void onCreate(Bundle savedInstanceState){\n  super.onCreate(savedInstanceState);\n  if (!USE_EXO_PLAYER) {\n    videoSceneObjectPlayer=makeMediaPlayer();\n  }\n else {\n    videoSceneObjectPlayer=makeExoPlayer();\n  }\n  if (null != videoSceneObjectPlayer) {\n    final Minimal360Video main=new Minimal360Video(videoSceneObjectPlayer);\n    setMain(main,\"gvr.xml\");\n  }\n}\n", "nl": "Called when the activity is first created."}
{"code": "public void updateNameOnMigrationCommit(String updatedName){\n  String currentPath=getPath();\n  setPath(currentPath.replace(getName(),updatedName));\n  setName(updatedName);\n}\n", "nl": "Update the virtual volume name after path of the virtual volume when a migration associated with the virtual volume is committed."}
{"code": "public static void executeInBulk(@NotNull Document document,final boolean executeInBulk,@NotNull Runnable task){\n  if (!(document instanceof DocumentEx)) {\n    task.run();\n    return;\n  }\n  DocumentEx documentEx=(DocumentEx)document;\n  if (executeInBulk == documentEx.isInBulkUpdate()) {\n    task.run();\n    return;\n  }\n  documentEx.setInBulkUpdate(executeInBulk);\n  try {\n    task.run();\n  }\n  finally {\n    documentEx.setInBulkUpdate(!executeInBulk);\n  }\n}\n", "nl": "Ensures that given task is executed when given document is at the given 'in bulk' mode."}
{"code": "protected Date calcSleepTime(Integer SleepSecondsAfterNotice){\n  if (mapping.getCondition().getSleepSecAfterAction() != null) {\n    Calendar cal=Calendar.getInstance();\n    cal.setTime(new Date());\n    cal.add(Calendar.SECOND,SleepSecondsAfterNotice);\n    return cal.getTime();\n  }\n else {\n    return null;\n  }\n}\n", "nl": "Calculate sleep time point"}
{"code": "public void tagGenerator(byte[] data) throws IOException {\n  if (tags != null) {\n    tags.tagGenerator(data);\n  }\n}\n", "nl": "SWFTagTypes interface"}
{"code": "public mat4 copy(mat4 matA){\n  for (int i=0; i < 16; ++i) {\n    this.m[i]=matA.m[i];\n  }\n  return this;\n}\n", "nl": "\\fn copy \\brief Copies the elements of matA to current matrix"}
{"code": "@Override public void run(){\n  amIActive=true;\n  if (args.length < 2) {\n    showFeedback(\"Plugin parameters have not been set properly.\");\n    return;\n  }\n  String inputHeader=args[0];\n  String outputHeader=args[1];\n  if ((inputHeader == null) || (outputHeader == null)) {\n    showFeedback(\"One or more of the input parameters have not been set properly.\");\n    return;\n  }\n  try {\n    int row, col;\n    double z1;\n    int progress, oldProgress=-1;\n    double[] data1;\n    WhiteboxRaster inputFile1=new WhiteboxRaster(inputHeader,\"r\");\n    int rows=inputFile1.getNumberRows();\n    int cols=inputFile1.getNumberColumns();\n    double noData=inputFile1.getNoDataValue();\n    WhiteboxRaster outputFile=new WhiteboxRaster(outputHeader,\"rw\",inputHeader,WhiteboxRaster.DataType.FLOAT,noData);\n    outputFile.setPreferredPalette(inputFile1.getPreferredPalette());\n    for (row=0; row < rows; row++) {\n      data1=inputFile1.getRowValues(row);\n      for (col=0; col < cols; col++) {\n        z1=data1[col];\n        if (z1 != noData) {\n          outputFile.setValue(row,col,z1 * z1);\n        }\n else {\n          outputFile.setValue(row,col,noData);\n        }\n      }\n      progress=(int)(100f * row / (rows - 1));\n      if (progress != oldProgress) {\n        oldProgress=progress;\n        updateProgress((int)progress);\n        if (cancelOp) {\n          cancelOperation();\n          return;\n        }\n      }\n    }\n    outputFile.addMetadataEntry(\"Created by the \" + getDescriptiveName() + \" tool.\");\n    outputFile.addMetadataEntry(\"Created on \" + new Date());\n    inputFile1.close();\n    outputFile.close();\n    returnData(outputHeader);\n  }\n catch (  OutOfMemoryError oe) {\n    myHost.showFeedback(\"An out-of-memory error has occurred during operation.\");\n  }\ncatch (  Exception e) {\n    myHost.showFeedback(\"An error has occurred during operation. See log file for details.\");\n    myHost.logException(\"Error in \" + getDescriptiveName(),e);\n  }\n finally {\n    updateProgress(\"Progress: \",0);\n    amIActive=false;\n    myHost.pluginComplete();\n  }\n}\n", "nl": "Used to execute this plugin tool."}
{"code": "public boolean hasValue(){\n  return super.hasTextValue();\n}\n", "nl": "Returns whether it has the value."}
{"code": "private void internalRemoveConnection(String hostAndPort){\n  if ((hostAndPort == null) || (hostAndPort.length() == 0)) {\n    throw new ConnectionManagerException(\"Passed host/port is null or blank.\");\n  }\n  try {\n    if (!isConnected(hostAndPort)) {\n      throw new ConnectionManagerException(MessageFormatter.format(\"The connection manager is not managing a connection to host {}\",hostAndPort).getMessage());\n    }\n    _listener.pause();\n    CimConnection connection=_connections.get(hostAndPort);\n    if (connection != null) {\n      s_logger.info(\"Closing connection to the CIM provider on host/port {}\",hostAndPort);\n      connection.close();\n      _connections.remove(hostAndPort);\n      connectionLastTouch.remove(hostAndPort);\n      pinnedConnections.remove(hostAndPort);\n    }\n  }\n catch (  ConnectionManagerException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new ConnectionManagerException(MessageFormatter.format(\"Failed removing the connection to the provider on host/port {}\",hostAndPort).getMessage(),e);\n  }\n finally {\n    _listener.resume();\n  }\n}\n", "nl": "Looks up the 'hostAndPort' connection in the map. If it exists, the underlying connection will be closed, it will be removed from the map, and related data structures will be updated."}
{"code": "protected void verifyObb1Contents(String filePath){\n  String path=null;\n  path=doWaitForPath(filePath);\n  doValidateIntContents(path,\"OneToOneThousandInts.bin\",0,1000);\n  doValidateIntContents(path,\"SevenHundredInts.bin\",0,700);\n  doValidateZeroLongFile(path,\"FiveLongs.bin\",5,true);\n}\n", "nl": "Verifies the pre-defined contents of our first OBB (OBB_FILE_1) The OBB contains 4 files and no subdirectories"}
{"code": "public SplitAction(DrawingEditor editor){\n  super(editor,new SVGPathFigure(),false);\n  labels.configureAction(this,ID);\n}\n", "nl": "Creates a new instance."}
{"code": "public static RSAPrivateKey newKey(byte[] encoded) throws InvalidKeyException {\n  RSAPrivateCrtKeyImpl key=new RSAPrivateCrtKeyImpl(encoded);\n  if (key.getPublicExponent().signum() == 0) {\n    return new RSAPrivateKeyImpl(key.getModulus(),key.getPrivateExponent());\n  }\n else {\n    return key;\n  }\n}\n", "nl": "Generate a new key from its encoding. Returns a CRT key if possible and a non-CRT key otherwise. Used by RSAKeyFactory."}
{"code": "public String cacheName(){\n  return cacheName;\n}\n", "nl": "Gets cache name."}
{"code": "@Inject public AddRemoteRepositoryPresenter(AddRemoteRepositoryView view,GitServiceClient service,AppContext appContext){\n  this.view=view;\n  this.view.setDelegate(this);\n  this.service=service;\n  this.appContext=appContext;\n}\n", "nl": "Create presenter."}
{"code": "public double calculateLogLikelihood(){\n  return calculateLogLikelihood(intervals,demographicFunction);\n}\n", "nl": "Calculates the log likelihood of this set of coalescent intervals, given a demographic model."}
{"code": "public ScVolume createReplayView(String instanceId,String name) throws StorageCenterAPIException {\n  Parameters params=new Parameters();\n  params.add(\"Name\",name);\n  params.add(\"Notes\",instanceId);\n  RestResult rr=restClient.post(String.format(\"StorageCenter/ScReplay/%s/CreateView\",instanceId),params.toJson());\n  if (!checkResults(rr)) {\n    LOG.warn(\"Error creating view volume of replay {}: {}\",instanceId,rr.getErrorMsg());\n    throw new StorageCenterAPIException(rr.getErrorMsg());\n  }\n  return gson.fromJson(rr.getResult(),ScVolume.class);\n}\n", "nl": "Create a view volume of a replay."}
{"code": "private ComparableTimSort(Object[] a,Object[] work,int workBase,int workLen){\n  this.a=a;\n  int len=a.length;\n  int tlen=(len < 2 * INITIAL_TMP_STORAGE_LENGTH) ? len >>> 1 : INITIAL_TMP_STORAGE_LENGTH;\n  if (work == null || workLen < tlen || workBase + tlen > work.length) {\n    tmp=new Object[tlen];\n    tmpBase=0;\n    tmpLen=tlen;\n  }\n else {\n    tmp=work;\n    tmpBase=workBase;\n    tmpLen=workLen;\n  }\n  int stackLen=(len < 120 ? 5 : len < 1542 ? 10 : len < 119151 ? 24 : 49);\n  runBase=new int[stackLen];\n  runLen=new int[stackLen];\n}\n", "nl": "Creates a TimSort instance to maintain the state of an ongoing sort."}
{"code": "public void handleDiscontinuity(){\n  if (startMediaTimeState == START_IN_SYNC) {\n    startMediaTimeState=START_NEED_SYNC;\n  }\n}\n", "nl": "Signals to the audio track that the next buffer is discontinuous with the previous buffer."}
{"code": "public CLKernel createKernel(String name,Object... args) throws CLBuildException {\n}\n", "nl": "#documentCallsFunction(\"clCreateKernel\") Find a kernel by its functionName, and optionally bind some arguments to it."}
{"code": "public void addFooterView(View view){\n  if (null == view) {\n    throw new IllegalArgumentException(\"the view to add must not be null!\");\n  }\n else   if (mWrapAdapter == null) {\n    mTmpFooterView.add(view);\n  }\n else {\n    mWrapAdapter.addFooterView(view);\n  }\n}\n", "nl": "Adds a footer view"}
{"code": "public T caseS_Declaration(S_Declaration object){\n  return null;\n}\n", "nl": "Returns the result of interpreting the object as an instance of '<em>SDeclaration</em>'. <!-- begin-user-doc --> This implementation returns null; returning a non-null result will terminate the switch. <!-- end-user-doc -->"}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-09-03 15:01:14.718 -0400\",hash_original_method=\"29A8172D11EE1F6C2B41EDC469205BD4\",hash_generated_method=\"59F81D826E94B385983D565339AE7DB1\") private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {\n  try {\n    s.defaultReadObject();\n    this.queue=new Object[q.size()];\n    comparator=q.comparator();\n    addAll(q);\n  }\n  finally {\n    q=null;\n  }\n}\n", "nl": "Reconstitutes this queue from a stream (that is, deserializes it)."}
{"code": "public static OrganizationAuthorityException convertToApi(org.oscm.internal.types.exception.OrganizationAuthorityException oldEx){\n  return convertExceptionToApi(oldEx,OrganizationAuthorityException.class);\n}\n", "nl": "Convert source version Exception to target version Exception"}
{"code": "public static <T>void assertIterator(List<T> expected,Iterator<T> it){\n  assertIterator(expected,it,true);\n}\n", "nl": "Asserts the contents of an iterator."}
{"code": "public synchronized void remove(ComponentName componentName,UserHandleCompat user){\n  mCache.remove(new ComponentKey(componentName,user));\n}\n", "nl": "Remove any records for the supplied ComponentName."}
{"code": "@DSGenerator(tool_name=\"Doppelganger\",tool_version=\"2.0\",generated_on=\"2014-02-25 10:38:12.483 -0500\",hash_original_method=\"CEA0E6C41E8B0166BD3ED01845CB7616\",hash_generated_method=\"2A0DF62DC3D6BDA6FD332746248CC193\") public int receive(byte[] data,int length) throws IOException {\n  __receivePacket.setData(data);\n  __receivePacket.setLength(length);\n  _socket_.receive(__receivePacket);\n  return __receivePacket.getLength();\n}\n", "nl": "Receives echoed data and returns its length.  The data may be divided up among multiple datagrams, requiring multiple calls to receive. Also, the UDP packets will not necessarily arrive in the same order they were sent. <p>"}
{"code": "private void checkContains(Spanned text,String[] spans,String spanName,int start,int end) throws Exception {\n  for (  String i : spans) {\n    if (i.equals(spanName)) {\n      assertEquals(start,text.getSpanStart(i));\n      assertEquals(end,text.getSpanEnd(i));\n      return;\n    }\n  }\n  fail();\n}\n", "nl": "Fail unless text+spans contains a span 'spanName' with the given start and end."}
{"code": "public CSSClassCondition(String localName,String namespaceURI,String value){\n  super(localName,namespaceURI,true,value);\n}\n", "nl": "Creates a new CSSAttributeCondition object."}
{"code": "public final int length(){\n  return (m_lastChunk << m_chunkBits) + m_firstFree;\n}\n", "nl": "Get the length of the list. Synonym for size()."}
{"code": "@Override public float idf(long docFreq,long docCount){\n  return (float)(Math.log((docCount + 1) / (double)(docFreq + 1)) + 1.0);\n}\n", "nl": "Implemented as <code>log((docCount+1)/(docFreq+1)) + 1</code>."}
{"code": "public boolean isDrawCenterTextEnabled(){\n  return mDrawCenterText;\n}\n", "nl": "returns true if drawing the center text is enabled"}
{"code": "public _MelLexer(java.io.Reader in){\n  this.zzReader=in;\n}\n", "nl": "Creates a new scanner"}
{"code": "public static <T>List<T> createUnsafeList(Collection<? extends T> collection){\n  List<T> list=new UnsafeArrayList<>(collection.size());\n  list.addAll(collection);\n  return list;\n}\n", "nl": "Construct new unsafe array list. Unsafe array lists are like array lists but doesn't check for concurrent modifications. <br> NOTE: They are not created for concurrent usage! They are not thread safe!"}
{"code": "public void ensureCapacity(int minCapacity){\n  modCount++;\n  int oldCapacity=elementData.length;\n  if (minCapacity > oldCapacity) {\n    Object oldData[]=elementData;\n    int newCapacity=(oldCapacity * 3) / 2 + 1;\n    if (newCapacity < minCapacity)     newCapacity=minCapacity;\n    elementData=Arrays.copyOf(elementData,newCapacity);\n  }\n}\n", "nl": "Increases the capacity of this <tt>IdentityArrayList</tt> instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument."}
{"code": "public static int scale(float val,int max){\n  if (val == 1)   return max - 1;\n  return (int)(val * max);\n}\n", "nl": "Return the int in the range [0,max-1] represented by the given float which is in the range [0.0,1.0)."}
{"code": "protected void appendDetail(StringBuffer buffer,String fieldName,int[] array){\n  buffer.append(arrayStart);\n  for (int i=0; i < array.length; i++) {\n    if (i > 0) {\n      buffer.append(arraySeparator);\n    }\n    appendDetail(buffer,fieldName,array[i]);\n  }\n  buffer.append(arrayEnd);\n}\n", "nl": "<p>Append to the <code>toString</code> the detail of an <code>int</code> array.</p>"}
{"code": "protected float parseFraction() throws ParseException, IOException {\n  float value=0;\n  if (current < '0' || current > '9') {\n    reportUnexpectedCharacterError(current);\n  }\n  float weight=0.1f;\n  do {\n    value+=weight * (current - '0');\n    weight*=0.1f;\n    current=reader.read();\n  }\n while (current >= '0' && current <= '9');\n  return value;\n}\n", "nl": "Parses a '.' and a sequence of digits and returns the float."}
{"code": "public int readSignedExpGolombCodedInt(){\n  int codeNum=readExpGolombCodeNum();\n  return ((codeNum % 2) == 0 ? -1 : 1) * ((codeNum + 1) / 2);\n}\n", "nl": "Reads an signed Exp-Golomb-coded format integer."}